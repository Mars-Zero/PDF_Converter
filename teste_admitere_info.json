[{"page_number": 0, "page_char_count": 112, "page_word_count": 29, "page_sentence_count_raw": 1, "page_token_count": 28.0, "text": "Teste de INFORMATIC\u0102    pentru admiterea la   Universitatea Politehnica din Bucure\u0219ti            Bucure\u0219ti  2020", "sentences": ["Teste de INFORMATIC\u0102    pentru admiterea la   Universitatea Politehnica din Bucure\u0219ti            Bucure\u0219ti  2020"], "page_sentence_count_spacy": 1}, {"page_number": 1, "page_char_count": 2679, "page_word_count": 439, "page_sentence_count_raw": 13, "page_token_count": 669.75, "text": "1        CUV\u00c2NT \u00ceNAINTE      Ne bucur\u0103m c\u0103 \u00eencep\u00e2nd cu acest an, Universitatea Politehnica din Bucure\u0219ti (UPB) a ad\u0103ugat  informatica ca disciplin\u0103 de admitere pentru studiile de licen\u021b\u0103. Am considerat c\u0103 acest demers este  important, \u00een special, pentru facult\u0103\u021bile care au specializ\u0103ri legate de Tehnologiile Informa\u021biei \u0219i a  Comunica\u021biilor (TIC). Totu\u0219i, admiterea la informatic\u0103 a fost acceptat\u0103 ca prob\u0103 de admitere de  majoritatea facult\u0103\u021bilor din UPB, un num\u0103r de 11 facult\u0103\u021bi oferind posibilitatea elevilor s\u0103 aleag\u0103  informatica ca prob\u0103 de concurs \u00een anul 2020.   De\u0219i este o disciplin\u0103 mult mai t\u00e2n\u0103r\u0103 comparativ cu celelalte probe de concurs, informatica a ajuns  s\u0103 fie un element esen\u021bial \u00een educa\u021bia inginerilor, chiar \u0219i a celor cu specializ\u0103ri din afara  domeniului TIC. \u00cen lumea de ast\u0103zi, programarea calculatoarelor \u0219i g\u00e2ndirea algoritmic\u0103 sunt  aspecte de baz\u0103 pentru rezolvarea de probleme practice \u00eentr-o gam\u0103 variat\u0103 de domenii. Mai mult,  majoritatea domeniilor inginere\u0219ti necesit\u0103 m\u0103car minimal aplicarea unor concepte din  informatic\u0103, pornind de la programare \u00een diverse limbaje (precum C/C++, Java, Python, Matlab,  R, SPSS etc.), unele generale \u0219i altele specifice anumitor domenii, \u0219i merg\u00e2nd p\u00e2n\u0103 la \u00een\u021belegerea  \u0219i eventual proiectarea unor algoritmi particulari fiec\u0103rui domeniu de studiu.  A\u0219adar, sper\u0103m ca acest demers s\u0103 fie de bun augur pentru \u00eentreaga comunitate UPB, dar \u0219i un  exemplu pentru celalalte universit\u0103\u021bi tehnice din Rom\u00e2nia \u00een promovarea informaticii ca discipin\u0103  de admitere la facultate. \u00cen acest mileniu, informatica va fi esen\u021bial\u0103 pentru un num\u0103r din ce \u00een ce  mai mare de specialit\u0103\u021bi tehnice.   \u00cen acela\u0219i timp, organizarea admiterii la informatic\u0103 vine cu o responsabilitate suplimentar\u0103 at\u00e2t  pentru comunitatea de profesori din cadrul UPB, c\u00e2t \u0219i din ciclul preuniversitar. Astfel, profesorii  din UPB care predau programare \u0219i algoritmi, dar \u0219i alte materii mai avansate, au trebuit s\u0103 se  familiarizeze cu terminologia \u0219i curricula de informatic\u0103 din liceu. \u00cen acest context, ne-am bucurat  de sprijinul \u0219i colaborarea cu o comunitate larg\u0103 de profesori de informatic\u0103 din ciclul  preuniversitar. Aceasta a fost benefic\u0103 pentru ambele comunit\u0103\u021bi \u0219i ne dorim continuarea ei \u0219i \u00een  viitor, pentru a le oferi un instrument util elevilor de liceu pasiona\u021bi de informatic\u0103 \u0219i care \u00ee\u0219i doresc  s\u0103 ajung\u0103 studen\u021bi \u00een cadrul Universit\u0103\u021bii Politehnica din Bucure\u0219ti \u0219i, ulterior, ingineri. Un aspect  observat \u00een cadrul acestei colabor\u0103ri a fost c\u0103 de\u0219i \u00een liceu se folose\u0219te nota\u021bia \u201eO\u201d pentru analiza  de complexitate a algoritmilor, aceasta are de fapt sensul nota\u021biei \u201e\u03b8\u201d \u0219i este folosit\u0103 ca atare \u0219i \u00een  acest volum.", "sentences": ["1        CUV\u00c2NT \u00ceNAINTE      Ne bucur\u0103m c\u0103 \u00eencep\u00e2nd cu acest an, Universitatea Politehnica din Bucure\u0219ti (UPB) a ad\u0103ugat  informatica ca disciplin\u0103 de admitere pentru studiile de licen\u021b\u0103.", "Am considerat c\u0103 acest demers este  important, \u00een special, pentru facult\u0103\u021bile care au specializ\u0103ri legate de Tehnologiile Informa\u021biei \u0219i a  Comunica\u021biilor (TIC).", "Totu\u0219i, admiterea la informatic\u0103 a fost acceptat\u0103 ca prob\u0103 de admitere de  majoritatea facult\u0103\u021bilor din UPB, un num\u0103r de 11 facult\u0103\u021bi oferind posibilitatea elevilor s\u0103 aleag\u0103  informatica ca prob\u0103 de concurs \u00een anul 2020.", "  De\u0219i este o disciplin\u0103 mult mai t\u00e2n\u0103r\u0103 comparativ cu celelalte probe de concurs, informatica a ajuns  s\u0103 fie un element esen\u021bial \u00een educa\u021bia inginerilor, chiar \u0219i a celor cu specializ\u0103ri din afara  domeniului TIC.", "\u00cen lumea de ast\u0103zi, programarea calculatoarelor \u0219i g\u00e2ndirea algoritmic\u0103 sunt  aspecte de baz\u0103 pentru rezolvarea de probleme practice \u00eentr-o gam\u0103 variat\u0103 de domenii.", "Mai mult,  majoritatea domeniilor inginere\u0219ti necesit\u0103 m\u0103car minimal aplicarea unor concepte din  informatic\u0103, pornind de la programare \u00een diverse limbaje (precum C/C++, Java, Python, Matlab,  R, SPSS etc.), unele generale \u0219i altele specifice anumitor domenii, \u0219i merg\u00e2nd p\u00e2n\u0103 la \u00een\u021belegerea  \u0219i eventual proiectarea unor algoritmi particulari fiec\u0103rui domeniu de studiu.", " A\u0219adar, sper\u0103m ca acest demers s\u0103 fie de bun augur pentru \u00eentreaga comunitate UPB, dar \u0219i un  exemplu pentru celalalte universit\u0103\u021bi tehnice din Rom\u00e2nia \u00een promovarea informaticii ca discipin\u0103  de admitere la facultate.", "\u00cen acest mileniu, informatica va fi esen\u021bial\u0103 pentru un num\u0103r din ce \u00een ce  mai mare de specialit\u0103\u021bi tehnice.", "  \u00cen acela\u0219i timp, organizarea admiterii la informatic\u0103 vine cu o responsabilitate suplimentar\u0103 at\u00e2t  pentru comunitatea de profesori din cadrul UPB, c\u00e2t \u0219i din ciclul preuniversitar.", "Astfel, profesorii  din UPB care predau programare \u0219i algoritmi, dar \u0219i alte materii mai avansate, au trebuit s\u0103 se  familiarizeze cu terminologia \u0219i curricula de informatic\u0103 din liceu.", "\u00cen acest context, ne-am bucurat  de sprijinul \u0219i colaborarea cu o comunitate larg\u0103 de profesori de informatic\u0103 din ciclul  preuniversitar.", "Aceasta a fost benefic\u0103 pentru ambele comunit\u0103\u021bi \u0219i ne dorim continuarea ei \u0219i \u00een  viitor, pentru a le oferi un instrument util elevilor de liceu pasiona\u021bi de informatic\u0103 \u0219i care \u00ee\u0219i doresc  s\u0103 ajung\u0103 studen\u021bi \u00een cadrul Universit\u0103\u021bii Politehnica din Bucure\u0219ti \u0219i, ulterior, ingineri.", "Un aspect  observat \u00een cadrul acestei colabor\u0103ri a fost c\u0103 de\u0219i \u00een liceu se folose\u0219te nota\u021bia \u201eO\u201d pentru analiza  de complexitate a algoritmilor, aceasta are de fapt sensul nota\u021biei \u201e\u03b8\u201d \u0219i este folosit\u0103 ca atare \u0219i \u00een  acest volum."], "page_sentence_count_spacy": 13}, {"page_number": 2, "page_char_count": 2351, "page_word_count": 386, "page_sentence_count_raw": 13, "page_token_count": 587.75, "text": "2    La final, \u00een calitate de coordonator al comisiei de admitere la informatic\u0103 \u00een cadrul UPB, doresc s\u0103  mul\u021bumesc \u00eentregii echipe de colegi at\u00e2t din ciclul preuniversitar, c\u00e2t \u0219i din universitate, care au  participat la elaborarea acestor variante de subiecte propuse pentru preg\u0103tirea candida\u021bilor \u00eenainte  de concurs \u2013 lista complet\u0103 este disponibil\u0103 \u00een continuare. Mai mult, \u00eempreun\u0103 cu colegii din  universitate vom organiza sesiuni de preg\u0103tire a admiterii la informatic\u0103 \u00een lunile antemerg\u0103toare  admiterii. V\u0103 a\u0219tept\u0103m \u00een num\u0103r c\u00e2t mai mare la concursul de admitere la informatic\u0103, unde  \u00eempreun\u0103 cu colegii din UPB vom avea sarcina dificil\u0103, dar plin\u0103 de recompense, de a propune  setul de probleme pentru concurs. Pentru orice sugestii sau observa\u021bii legate de acest volum, pute\u021bi  s\u0103 ne scrie\u021bi la adresa admitere.informatica@upb.ro.      Succes la preg\u0103tirea pentru examen!     Traian Rebedea  Conferen\u021biar universitar  Facultatea de Automatic\u0103 \u0219i Calculatoare      Penea \u0218tefania  Colegiul Na\u021bional \u201eSf\u00e2ntul Sava\u201d  Florea Andrei   Colegiul Na\u021bional \u201eI.L.Caragiale\u201d  Rusu Oana  Liceul Greco-Catolic \u201eTimotei Cipariu\u201d  B\u0103la\u0219a Filonela  Colegiul Na\u021bional \u201eGrigore Moisil\u201d  Cr\u0103ciunescu Georgeta Antonia Rodica  Colegiul Na\u021bional \u201eElena Cuza\u201d  S\u0103cuiu Silviu - Eugen  Colegiul Na\u021bional \u201eMihai Viteazul\u201d  Sm\u00eent\u00een\u0103 Rodica  Colegiul Na\u021bional \u201eGh. \u0218incai\u201d  Balc\u0103 Mariana - Mihaela  Colegiul Na\u021bional \u201e\u0218coala Central\u0103\u201d  Anca Mihaela  Colegiul Na\u021bional \u201eI.L.Caragiale\u201d  Badea Corina Elena  Liceul Teoretic \u201eAl. I. Cuza\u201d  Berbece Georgiana - Ligia  Liceul Teoretic \u201eNichita St\u0103nescu\u201d  Bu\u0219e Constan\u021ba Elena  Colegiul Na\u021bional \u201eIon Neculce\u201d  Chiri\u021b\u0103 Valentina  Liceul Teoretic \u201eAl. I. Cuza\u201d  Ciocaru Lumini\u021ba  Liceul Teoretic \u201eDante Alighieri\u201d  Danciu Alina  Colegiul Na\u021bional \u201eIon Creang\u0103\u201d  Dru\u021b\u0103 Doina Lumini\u021ba  Liceul Teoretic \u201eDante Alighieri\u201d  Dumitrescu Vasilica Iuliana  Colegiul Na\u021bional \u201eI.L.Caragiale\u201d  Dumitru Silviu - Iulian  Colegiul Na\u021bional \u201eGh. Laz\u0103r\u201d  Geb\u0103il\u0103 Gilda - Gra\u021biela  Colegiul Na\u021bional \u201eMihai Viteazul\u201d  Manz Victor - Claudiu  Colegiul Na\u021bional de Informatic\u0103  \u201eTudor Vianu\u201d  Mitrache Adrian  Liceul Teoretic \u201eEugen Lovinescu\u201d  Mitrache Claudia Elena  Colegiul de Po\u0219t\u0103 \u0219i Telecomunica\u021bii  \u201eGh. Airinei\u201d  Petri\u0219or Valiana Felicia  Colegiul Na\u021bional Bilingv \u201eGeorge Co\u0219buc\u201d  Popa Simona Mihaela  Colegiul Na\u021bional \u201eGh. Laz\u0103r\u201d", "sentences": ["2    La final, \u00een calitate de coordonator al comisiei de admitere la informatic\u0103 \u00een cadrul UPB, doresc s\u0103  mul\u021bumesc \u00eentregii echipe de colegi at\u00e2t din ciclul preuniversitar, c\u00e2t \u0219i din universitate, care au  participat la elaborarea acestor variante de subiecte propuse pentru preg\u0103tirea candida\u021bilor \u00eenainte  de concurs \u2013 lista complet\u0103 este disponibil\u0103 \u00een continuare.", "Mai mult, \u00eempreun\u0103 cu colegii din  universitate vom organiza sesiuni de preg\u0103tire a admiterii la informatic\u0103 \u00een lunile antemerg\u0103toare  admiterii.", "V\u0103 a\u0219tept\u0103m \u00een num\u0103r c\u00e2t mai mare la concursul de admitere la informatic\u0103, unde  \u00eempreun\u0103 cu colegii din UPB vom avea sarcina dificil\u0103, dar plin\u0103 de recompense, de a propune  setul de probleme pentru concurs.", "Pentru orice sugestii sau observa\u021bii legate de acest volum, pute\u021bi  s\u0103 ne scrie\u021bi la adresa admitere.informatica@upb.ro.", "     Succes la preg\u0103tirea pentru examen!", "    Traian Rebedea  Conferen\u021biar universitar  Facultatea de Automatic\u0103 \u0219i Calculatoare      Penea \u0218tefania  Colegiul Na\u021bional \u201eSf\u00e2ntul Sava\u201d  Florea Andrei   Colegiul Na\u021bional \u201eI.L.Caragiale\u201d  Rusu Oana  Liceul Greco-Catolic \u201eTimotei Cipariu\u201d  B\u0103la\u0219a Filonela  Colegiul Na\u021bional \u201eGrigore Moisil\u201d  Cr\u0103ciunescu Georgeta Antonia Rodica  Colegiul Na\u021bional \u201eElena Cuza\u201d  S\u0103cuiu Silviu - Eugen  Colegiul Na\u021bional \u201eMihai Viteazul\u201d  Sm\u00eent\u00een\u0103 Rodica  Colegiul Na\u021bional \u201eGh. \u0218incai\u201d  Balc\u0103 Mariana - Mihaela  Colegiul Na\u021bional \u201e\u0218coala Central\u0103\u201d  Anca Mihaela  Colegiul Na\u021bional \u201eI.L.Caragiale\u201d  Badea Corina Elena  Liceul Teoretic \u201eAl. I. Cuza\u201d  Berbece Georgiana - Ligia  Liceul Teoretic \u201eNichita St\u0103nescu\u201d  Bu\u0219e Constan\u021ba Elena  Colegiul Na\u021bional \u201eIon Neculce\u201d  Chiri\u021b\u0103 Valentina  Liceul Teoretic \u201eAl. I. Cuza\u201d  Ciocaru Lumini\u021ba  Liceul Teoretic \u201eDante Alighieri\u201d  Danciu Alina  Colegiul Na\u021bional \u201eIon Creang\u0103\u201d  Dru\u021b\u0103 Doina Lumini\u021ba  Liceul Teoretic \u201eDante Alighieri\u201d  Dumitrescu Vasilica Iuliana  Colegiul Na\u021bional \u201eI.L.Caragiale\u201d  Dumitru Silviu - Iulian  Colegiul Na\u021bional \u201eGh. Laz\u0103r\u201d  Geb\u0103il\u0103 Gilda - Gra\u021biela  Colegiul Na\u021bional \u201eMihai Viteazul\u201d  Manz Victor - Claudiu  Colegiul Na\u021bional de Informatic\u0103  \u201eTudor Vianu\u201d  Mitrache Adrian  Liceul Teoretic \u201eEugen Lovinescu\u201d  Mitrache Claudia Elena  Colegiul de Po\u0219t\u0103 \u0219i Telecomunica\u021bii  \u201eGh. Airinei\u201d  Petri\u0219or Valiana Felicia  Colegiul Na\u021bional Bilingv \u201eGeorge Co\u0219buc\u201d  Popa Simona Mihaela  Colegiul Na\u021bional \u201eGh. Laz\u0103r\u201d"], "page_sentence_count_spacy": 6}, {"page_number": 3, "page_char_count": 857, "page_word_count": 129, "page_sentence_count_raw": 1, "page_token_count": 214.25, "text": "3    Preda Doina Lavinia  Liceul Teoretic \u201eDante Alighieri\u201d  Rusu Vicen\u021biu  Liceul Greco-Catolic \u201eTimotei Cipariu\u201d    Rebedea Traian  Universitatea Politehnica din Bucure\u0219ti  Ablachim Denis  Universitatea Politehnica din Bucure\u0219ti  Chiroiu Mihai  Universitatea Politehnica din Bucure\u0219ti  Gliga Lavinius Ioan   Universitatea Politehnica din Bucure\u0219ti  Mocanu Irina  Universitatea Politehnica din Bucure\u0219ti  Niculescu Drago\u0219   Universitatea Politehnica din Bucure\u0219ti  Olteanu Alexandru  Universitatea Politehnica din Bucure\u0219ti  Pop Florin  Universitatea Politehnica din Bucure\u0219ti  Posea Vlad  Universitatea Politehnica din Bucure\u0219ti  Ru\u0219e\u021bi \u0218tefan  Universitatea Politehnica din Bucure\u0219ti  Speril\u0103 Andrei  Universitatea Politehnica din Bucure\u0219ti  Tranc\u0103 Cristian  Universitatea Politehnica din Bucure\u0219ti  Udrea Andreea  Universitatea Politehnica din Bucure\u0219ti", "sentences": ["3    Preda Doina Lavinia  Liceul Teoretic \u201eDante Alighieri\u201d  Rusu Vicen\u021biu  Liceul Greco-Catolic \u201eTimotei Cipariu\u201d    Rebedea Traian  Universitatea Politehnica din Bucure\u0219ti  Ablachim Denis  Universitatea Politehnica din Bucure\u0219ti  Chiroiu Mihai  Universitatea Politehnica din Bucure\u0219ti  Gliga Lavinius Ioan   Universitatea Politehnica din Bucure\u0219ti  Mocanu Irina  Universitatea Politehnica din Bucure\u0219ti  Niculescu Drago\u0219   Universitatea Politehnica din Bucure\u0219ti  Olteanu Alexandru  Universitatea Politehnica din Bucure\u0219ti  Pop Florin  Universitatea Politehnica din Bucure\u0219ti  Posea Vlad  Universitatea Politehnica din Bucure\u0219ti  Ru\u0219e\u021bi \u0218tefan  Universitatea Politehnica din Bucure\u0219ti  Speril\u0103 Andrei  Universitatea Politehnica din Bucure\u0219ti  Tranc\u0103 Cristian  Universitatea Politehnica din Bucure\u0219ti  Udrea Andreea  Universitatea Politehnica din Bucure\u0219ti"], "page_sentence_count_spacy": 1}, {"page_number": 4, "page_char_count": 1479, "page_word_count": 250, "page_sentence_count_raw": 34, "page_token_count": 369.75, "text": "4      PROGRAMA DE EXAMEN PENTRU DISCIPLINA INFORMATIC\u0102    Programa de examen pentru disciplina informatic\u0103, \u00een cadrul admiterii la Facultatea de Automatic\u0103  \u0219i Calculatoare, valabil\u0103 pentru anul 2020, urmeaz\u0103 programa de la examenul de bacalaureat  stabilit\u0103 prin Anexa nr. 2 la OMECTS nr. 4800/31.VIII. 2010.    1. Algoritmi   1.1. No\u0163iunea de algoritm, caracteristici   1.2. Date, variabile, expresii, opera\u0163ii   1.3. Structuri de baz\u0103 (liniar\u0103, alternativ\u0103 \u015fi repetitiv\u0103)   1.4. Descrierea algoritmilor (programe pseudocod)     2. Elementele de baz\u0103 ale unui limbaj de programare (Pascal sau C, la alegere)   2.1. Vocabularul limbajului   2.2. Constante. Identificatori   2.3. No\u0163iunea de tip de dat\u0103. Operatori aritmetici, logici, rela\u0163ionali   2.4. Definirea tipurilor de date   2.5. Variabile. Declararea variabilelor   2.6. Definirea constantelor   2.7. Structura programelor. Comentarii   2.8. Expresii. Instruc\u0163iunea de atribuire   2.9. Citirea/scrierea datelor   2.10. Structuri de control (instruc\u0163iunea compus\u0103, structuri alternative \u015fi repetitive)     3. Subprograme predefinite   3.1. Subprograme. Mecanisme de transfer prin intermediul parametrilor   3.2. Proceduri \u015fi func\u0163ii predefinite     4. Tipuri structurate de date   4.1. Tipul tablou   4.2. Tipul \u015fir de caractere   \u2013 operatori, proceduri \u015fi func\u0163ii predefinite pentru: citire, afi\u015fare, concatenare, c\u0103utare,  extragere, inserare, eliminare \u015fi conversii (\u015fir \u27f7 valoare numeric\u0103)   4.3. Tipul \u00eenregistrare", "sentences": ["4      PROGRAMA DE EXAMEN PENTRU DISCIPLINA INFORMATIC\u0102    Programa de examen pentru disciplina informatic\u0103, \u00een cadrul admiterii la Facultatea de Automatic\u0103  \u0219i Calculatoare, valabil\u0103 pentru anul 2020, urmeaz\u0103 programa de la examenul de bacalaureat  stabilit\u0103 prin Anexa nr. 2 la OMECTS nr. 4800/31.VIII.", "2010.", "   1.", "Algoritmi   1.1.", "No\u0163iunea de algoritm, caracteristici   1.2.", "Date, variabile, expresii, opera\u0163ii   1.3.", "Structuri de baz\u0103 (liniar\u0103, alternativ\u0103 \u015fi repetitiv\u0103)   1.4.", "Descrierea algoritmilor (programe pseudocod)     2.", "Elementele de baz\u0103 ale unui limbaj de programare (Pascal sau C, la alegere)   2.1.", "Vocabularul limbajului   2.2.", "Constante.", "Identificatori   2.3.", "No\u0163iunea de tip de dat\u0103.", "Operatori aritmetici, logici, rela\u0163ionali   2.4.", "Definirea tipurilor de date   2.5.", "Variabile.", "Declararea variabilelor   2.6.", "Definirea constantelor   2.7.", "Structura programelor.", "Comentarii   2.8.", "Expresii.", "Instruc\u0163iunea de atribuire   2.9.", "Citirea/scrierea datelor   2.10.", "Structuri de control (instruc\u0163iunea compus\u0103, structuri alternative \u015fi repetitive)     3.", "Subprograme predefinite   3.1.", "Subprograme.", "Mecanisme de transfer prin intermediul parametrilor   3.2.", "Proceduri \u015fi func\u0163ii predefinite     4.", "Tipuri structurate de date   4.1.", "Tipul tablou   4.2.", "Tipul \u015fir de caractere   \u2013 operatori, proceduri \u015fi func\u0163ii predefinite pentru: citire, afi\u015fare, concatenare, c\u0103utare,  extragere, inserare, eliminare \u015fi conversii (\u015fir \u27f7 valoare numeric\u0103)   4.3.", "Tipul \u00eenregistrare"], "page_sentence_count_spacy": 32}, {"page_number": 5, "page_char_count": 1521, "page_word_count": 266, "page_sentence_count_raw": 32, "page_token_count": 380.25, "text": "5    5. Fi\u015fiere text   5.1. Fi\u015fiere text. Tipuri de acces   5.2. Proceduri \u015fi func\u0163ii predefinite pentru fi\u015fiere text     6. Algoritmi elementari   6.1. Probleme care opereaz\u0103 asupra cifrelor unui num\u0103r   6.2. Divizibilitate. Numere prime. Algoritmul lui Euclid   6.3. \u015eirul lui Fibonacci. Calculul unor sume cu termenul general dat   6.4. Determinare minim/maxim   6.5. Metode de ordonare (metoda bulelor, inser\u0163iei, selec\u0163iei, num\u0103r\u0103rii)   6.6. Interclasare   6.7. Metode de c\u0103utare (secven\u0163ial\u0103, binar\u0103)   6.8. Analiza complexit\u0103\u0163ii unui algoritm (consider\u00e2nd criteriile de eficien\u0163\u0103 durata de executare \u015fi  spa\u0163iu de memorie utilizat)     7. Subprograme definite de utilizator   7.1. Proceduri \u015fi func\u0163ii   \u2013 declarare \u015fi apel   \u2013 parametri formali \u015fi parametri efectivi   \u2013 parametri transmi\u015fi prin valoare, parametri transmi\u015fi prin referin\u0163\u0103   \u2013 variabile globale \u015fi variabile locale, domeniu de vizibilitate   7.2. Proiectarea modular\u0103 a rezolv\u0103rii unei probleme     8. Recursivitate   8.1. Prezentare general\u0103   8.2. Proceduri \u015fi func\u0163ii recursive     9. Metoda backtracking (iterativ\u0103 sau recursiv\u0103)   9.1. Prezentare general\u0103   9.2. Probleme de generare. Oportunitatea utiliz\u0103rii metodei backtracking     10. Generarea elementelor combinatoriale   10.1. Permut\u0103ri, aranjamente, combin\u0103ri   10.2. Produs cartezian, submul\u0163imi     11. Grafuri   11.1. Grafuri neorientate   \u2013 terminologie (nod/v\u00e2rf, muchie, adiacen\u0163\u0103, inciden\u0163\u0103, grad, lan\u0163, lan\u0163 elementar, ciclu,  ciclu elementar, lungime, subgraf, graf par\u0163ial)", "sentences": ["5    5.", "Fi\u015fiere text   5.1.", "Fi\u015fiere text.", "Tipuri de acces   5.2.", "Proceduri \u015fi func\u0163ii predefinite pentru fi\u015fiere text     6.", "Algoritmi elementari   6.1.", "Probleme care opereaz\u0103 asupra cifrelor unui num\u0103r   6.2.", "Divizibilitate.", "Numere prime.", "Algoritmul lui Euclid   6.3.", "\u015eirul lui Fibonacci.", "Calculul unor sume cu termenul general dat   6.4.", "Determinare minim/maxim   6.5.", "Metode de ordonare (metoda bulelor, inser\u0163iei, selec\u0163iei, num\u0103r\u0103rii)   6.6.", "Interclasare   6.7.", "Metode de c\u0103utare (secven\u0163ial\u0103, binar\u0103)   6.8.", "Analiza complexit\u0103\u0163ii unui algoritm (consider\u00e2nd criteriile de eficien\u0163\u0103 durata de executare \u015fi  spa\u0163iu de memorie utilizat)     7.", "Subprograme definite de utilizator   7.1.", "Proceduri \u015fi func\u0163ii   \u2013 declarare \u015fi apel   \u2013 parametri formali \u015fi parametri efectivi   \u2013 parametri transmi\u015fi prin valoare, parametri transmi\u015fi prin referin\u0163\u0103   \u2013 variabile globale \u015fi variabile locale, domeniu de vizibilitate   7.2.", "Proiectarea modular\u0103 a rezolv\u0103rii unei probleme     8.", "Recursivitate   8.1.", "Prezentare general\u0103   8.2.", "Proceduri \u015fi func\u0163ii recursive     9.", "Metoda backtracking (iterativ\u0103 sau recursiv\u0103)   9.1.", "Prezentare general\u0103   9.2.", "Probleme de generare.", "Oportunitatea utiliz\u0103rii metodei backtracking     10.", "Generarea elementelor combinatoriale   10.1.", "Permut\u0103ri, aranjamente, combin\u0103ri   10.2.", "Produs cartezian, submul\u0163imi     11.", "Grafuri   11.1.", "Grafuri neorientate   \u2013 terminologie (nod/v\u00e2rf, muchie, adiacen\u0163\u0103, inciden\u0163\u0103, grad, lan\u0163, lan\u0163 elementar, ciclu,  ciclu elementar, lungime, subgraf, graf par\u0163ial)"], "page_sentence_count_spacy": 32}, {"page_number": 6, "page_char_count": 729, "page_word_count": 114, "page_sentence_count_raw": 3, "page_token_count": 182.25, "text": "6    \u2013 propriet\u0103\u0163i (conex, component\u0103 conex\u0103, graf complet, hamiltonian, eulerian)   \u2013 metode de reprezentare (matrice de adiacen\u0163\u0103, liste de adiacen\u0163\u0103)   11.2. Grafuri orientate   \u2013 terminologie (nod/v\u00e2rf, arc, adiacen\u0163\u0103, inciden\u0163\u0103, grad intern \u015fi extern, drum, drum  elementar, circuit, circuit elementar, lungime, subgraf, graf par\u0163ial)   \u2013 propriet\u0103\u0163i (tare conexitate, component\u0103 tare conex\u0103)   \u2013 metode de reprezentare (matrice de adiacen\u0163\u0103, liste de adiacen\u0163\u0103)   11.3. Arbori   \u2013 terminologie (nod, muchie, r\u0103d\u0103cin\u0103, descendent, descendent direct/fiu, ascendent,  ascendent direct/p\u0103rinte, fra\u0163i, nod terminal, frunz\u0103)   \u2013 metode de reprezentare \u00een memorie (matrice de adiacen\u0163\u0103, liste \u201dde descenden\u0163i\u201d, vector  \u201dde ta\u0163i\u201d)", "sentences": ["6    \u2013 propriet\u0103\u0163i (conex, component\u0103 conex\u0103, graf complet, hamiltonian, eulerian)   \u2013 metode de reprezentare (matrice de adiacen\u0163\u0103, liste de adiacen\u0163\u0103)   11.2.", "Grafuri orientate   \u2013 terminologie (nod/v\u00e2rf, arc, adiacen\u0163\u0103, inciden\u0163\u0103, grad intern \u015fi extern, drum, drum  elementar, circuit, circuit elementar, lungime, subgraf, graf par\u0163ial)   \u2013 propriet\u0103\u0163i (tare conexitate, component\u0103 tare conex\u0103)   \u2013 metode de reprezentare (matrice de adiacen\u0163\u0103, liste de adiacen\u0163\u0103)   11.3.", "Arbori   \u2013 terminologie (nod, muchie, r\u0103d\u0103cin\u0103, descendent, descendent direct/fiu, ascendent,  ascendent direct/p\u0103rinte, fra\u0163i, nod terminal, frunz\u0103)   \u2013 metode de reprezentare \u00een memorie (matrice de adiacen\u0163\u0103, liste \u201dde descenden\u0163i\u201d, vector  \u201dde ta\u0163i\u201d)"], "page_sentence_count_spacy": 3}, {"page_number": 7, "page_char_count": 31, "page_word_count": 23, "page_sentence_count_raw": 1, "page_token_count": 7.75, "text": "7                      VARIANTE", "sentences": ["7                      VARIANTE"], "page_sentence_count_spacy": 1}, {"page_number": 8, "page_char_count": 1836, "page_word_count": 383, "page_sentence_count_raw": 12, "page_token_count": 459.0, "text": "8        Varianta 1    1.  Variabila a este de tip real. Pentru a verifica dac\u0103 valoarea variabilei a apar\u021bine mul\u021bimii   [-3,2] U{3, 5, 9} se va utiliza urm\u0103toarea expresie:  Limbajul C++/ Limbajul C  a)!((a<-3) || (a>2)) || (a==3) || (a==5) || (a==9)  b)(a>=-3)&&(a<=2)&&(a==3) || (a==5) || (a==9)  c)(a>-3) && (a<2) || (a==3) || (a==5) || (a==9)  d)(a<-3)||(a>2) && (a==3) && (a==5) && (a==9)  e)(a>=-3)||((a<=2)&&(a==3)) || (a==5) || (a==9)  f)(a>=-3) || !((a>2)) || (a==3)) || (a==5) || (a==9)    Limbajul Pascal  a)not ((a<-3) or (a>2)) or (a=3) or (a=5) or (a=9)  b)(a>=-3) and (a<=2) and (a=3) or (a=5) or (a=9)  c)(a>-3) and (a<2) or (a=3) or (a=5) or (a=9)  d)(a<-3) or (a>2) and (a=3) and (a=5) and (a=9)  e)(a>=-3) or ((a<=2) and (a=3)) or (a=5) or (a=9)  f)(a>=-3) or not((a>2)) or (a=3)) or (a=5) or (a=9)      2.  Preciza\u021bi cu ce expresie trebuie \u00eenlocuite punctele de suspensie, astfel \u00eenc\u00e2t \u00een urma  execut\u0103rii secven\u021bei al\u0103turate, s\u0103 se deplaseze elementele xp, xp+1, . . . , xk  ale unui tablou  unidimensional x, cu q-1 pozi\u021bii spre dreapta.    Limbajul C++/ Limbajul C  Limbajul Pascal  for (j=k; j>=p; j--)      x[\u2026]=x[j];  for j:= k downto p do       x[\u2026]:=x[j];    a)q-1-j  b) j-q+1  c) q-1+j  d) q-2+j  e) q-j+1  f) j+q-3    3.  Preciza\u021bi ce se va afi\u0219a dup\u0103 executarea secven\u021bei de program de mai jos.    Limbajul C++/ Limbajul C  Limbajul Pascal  char a[20]=\u201dinformatica\u201d, b[20]=\u201d\u201d;  strncat(b,a,strlen(strchr(a,\u2019t\u2019)));  cout<<b;  |  printf(\u201d% s\u201d, b);  var b : string[20];  begin  b:=\u2019informatica\u2019;  delete(b,pos(\u2019r\u2019,b),pos(\u2019a\u2019,b));  write(b);  end.    a) tica  b) form  c)  ica  d) inf  e) rmatica  f) info    4.  Preciza\u021bi care dintre urm\u0103toarele secven\u021be calculeaz\u0103 suma elementelor de pe linia p, ale  unui tablou bidimensional x, cu m linii \u0219i n coloane (numerotate de la 1 la m, respectiv de  la 1 la n)", "sentences": ["8        Varianta 1    1.", " Variabila a este de tip real.", "Pentru a verifica dac\u0103 valoarea variabilei a apar\u021bine mul\u021bimii   [-3,2] U{3, 5, 9} se va utiliza urm\u0103toarea expresie:  Limbajul C++/ Limbajul C  a)!((a<-3) || (a>2)) || (a==3) || (a==5) || (a==9)  b)(a>=-3)&&(a<=2)&&(a==3) || (a==5) || (a==9)  c)(a>-3) && (a<2) || (a==3) || (a==5) || (a==9)  d)(a<-3)||(a>2) && (a==3) && (a==5) && (a==9)  e)(a>=-3)||((a<=2)&&(a==3)) || (a==5) || (a==9)  f)(a>=-3) || !((", "a>2)) || (a==3)) || (a==5) || (a==9)    Limbajul Pascal  a)not ((a<-3) or (a>2)) or (a=3) or (a=5) or (a=9)  b)(a>=-3) and (a<=2) and (a=3) or (a=5) or (a=9)  c)(a>-3) and (a<2) or (a=3) or (a=5) or (a=9)  d)(a<-3) or (a>2) and (a=3) and (a=5) and (a=9)  e)(a>=-3) or ((a<=2) and (a=3)) or (a=5) or (a=9)  f)(a>=-3) or not((a>2)) or (a=3)) or (a=5) or (a=9)      2.", " Preciza\u021bi cu ce expresie trebuie \u00eenlocuite punctele de suspensie, astfel \u00eenc\u00e2t \u00een urma  execut\u0103rii secven\u021bei al\u0103turate, s\u0103 se deplaseze elementele xp, xp+1, . . . ,", "xk  ale unui tablou  unidimensional x, cu q-1 pozi\u021bii spre dreapta.", "   Limbajul C++/ Limbajul C  Limbajul Pascal  for (j=k; j>=p; j--)      x[\u2026]=x[j];  for j:= k downto p do       x[\u2026]:=x[j];    a)q-1-j  b) j-q+1  c) q-1+j  d) q-2+j  e) q-j+1  f) j+q-3    3.", " Preciza\u021bi ce se va afi\u0219a dup\u0103 executarea secven\u021bei de program de mai jos.", "   Limbajul C++/ Limbajul C  Limbajul Pascal  char a[20]=\u201dinformatica\u201d, b[20]=\u201d\u201d;  strncat(b,a,strlen(strchr(a,\u2019t\u2019)));  cout<<b;  |  printf(\u201d% s\u201d, b);  var b : string[20];  begin  b:=\u2019informatica\u2019;  delete(b,pos(\u2019r\u2019,b),pos(\u2019a\u2019,b));  write(b);  end.", "   a) tica  b) form  c)  ica  d) inf  e) rmatica  f) info    4.", " Preciza\u021bi care dintre urm\u0103toarele secven\u021be calculeaz\u0103 suma elementelor de pe linia p, ale  unui tablou bidimensional x, cu m linii \u0219i n coloane (numerotate de la 1 la m, respectiv de  la 1 la n)"], "page_sentence_count_spacy": 11}, {"page_number": 9, "page_char_count": 2084, "page_word_count": 819, "page_sentence_count_raw": 6, "page_token_count": 521.0, "text": "9    Limbajul C++/ Limbajul C  Limbajul Pascal  a) s=0;      for (i=m; i>=1; i--)       s=s+x[p][i];    b) s=0; i=1;      while(i<=m)      { s=s+x[i][p];         i++;}      c) s=0;      for(i=n; i>=1; i--)       s=s+x[i][p];    d) s=0; i=1;       while(i<=n)        {s=s+x[p][i];           i++;}    e)   s=0;      for (i=m; i>1; i--)       s=s+x[p][i];  f) s=0;      for(i=m; i>=1; i--)       s=s+x[i][p];      a) s:=0;      for i:=m downto 1 do       s:=s+x[p, i];    b) s:=0;  i:=1;      while i<=m do        begin          s:=s+x[i, p];          i:=i+1;        end;  c) s:=0;      for i:=n downto 1 do        s:=s+x[i, p];    d) s:=0; i:=1;       while i<=n do          begin           s:=s+x[p, i];           i:=i+1;          end;  e) s:=0;      for i:=m downto 2 do       s:=s+x[p,i];  f) s:=0;      for i:=m downto 1 do        s:=s+x[i, p];        5.  Fie graful orientat cu 5 noduri numerotate de la 1 la 5, \u0219i arcele (1,2), (2,3), (3,1), (3,4),  (4,5), (5,4). Preciza\u021bi care este matricea drumurilor asociat\u0103 acestui graf. Matricea  drumurilor este o matrice p\u0103tratic\u0103 de dimensiune nxn, definit\u0103 astfel:   Limbajul C++/ Limbajul C  Limbajul Pascal  -  a[i][j]=1 dac\u0103 exist\u0103 cel pu\u021bin  un drum de la nodul i la nodul  j  -  a[i][j]=0 dac\u0103 nu exist\u0103 niciun  drum de la nodul i la nodul j  -  a[i,j]=1 dac\u0103 exist\u0103 cel pu\u021bin  un drum de la nodul i la nodul  j  -  a[i,j]=0 dac\u0103 nu exist\u0103 niciun  drum de la nodul i la nodul j  a)  1 1 1 1 1      1 1 1 1 1      1 1 1 1 1       0 0 0 1 1      0 0 0 1 1    b)  0 1 1 1 1      1 0 1 1 1      1 1 0 1 1       0 0 0 0 1      0 0 0 1 0  c)  1 1 1 1 1      1 1 1 1 1      1 1 1 1 1       0 0 1 1 1      0 0 0 1 1     d)  0 1 0 0 0      0 0 1 0 0       1 0 0 1 0        0 0 0 0 1      0 0 0 1 0  e)  1 1 1 1 1      1 1 1 1 1      1 1 1 1 1       1 0 0 1 1      0 1 0 1 1  f)  1 1 0 0 0      0 0 1 0 0       1 0 0 1 1        0 1 0 0 1      1 0 0 1 0      6.  Utiliz\u00e2nd metoda backtracking se genereaz\u0103 elementele produsului cartezian a n mul\u021bimi:  A1, A2,\u2026, An. Utiliz\u00e2nd acest algoritm pentru a genera elementele produsului cartezian a 3", "sentences": ["9    Limbajul C++/ Limbajul C  Limbajul Pascal  a) s=0;      for (i=m; i>=1; i--)       s=s+x[p][i];    b) s=0; i=1;      while(i<=m)      { s=s+x[i][p];         i++;}      c) s=0;      for(i=n; i>=1; i--)       s=s+x[i][p];    d) s=0; i=1;       while(i<=n)        {s=s+x[p][i];           i++;}    e)   s=0;      for (i=m; i>1; i--)       s=s+x[p][i];  f) s=0;      for(i=m; i>=1; i--)       s=s+x[i][p];      a) s:=0;      for i:=m downto 1 do       s:=s+x[p, i];    b) s:=0;  i:=1;      while i<=m do        begin          s:=s+x[i, p];          i:=i+1;        end;  c) s:=0;      for i:=n downto 1 do        s:=s+x[i, p];    d) s:=0; i:=1;       while i<=n do          begin           s:=s+x[p, i];           i:=i+1;          end;  e) s:=0;      for i:=m downto 2 do       s:=s+x[p,i];  f) s:=0;      for i:=m downto 1 do        s:=s+x[i, p];        5.", " Fie graful orientat cu 5 noduri numerotate de la 1 la 5, \u0219i arcele (1,2), (2,3), (3,1), (3,4),  (4,5), (5,4).", "Preciza\u021bi care este matricea drumurilor asociat\u0103 acestui graf.", "Matricea  drumurilor este o matrice p\u0103tratic\u0103 de dimensiune nxn, definit\u0103 astfel:   Limbajul C++/ Limbajul C  Limbajul Pascal  -  a[i][j]=1 dac\u0103 exist\u0103 cel pu\u021bin  un drum de la nodul i la nodul  j  -  a[i][j]=0 dac\u0103 nu exist\u0103 niciun  drum de la nodul i la nodul j  -  a[i,j]=1 dac\u0103 exist\u0103 cel pu\u021bin  un drum de la nodul i la nodul  j  -  a[i,j]=0 dac\u0103 nu exist\u0103 niciun  drum de la nodul i la nodul j  a)  1 1 1 1 1      1 1 1 1 1      1 1 1 1 1       0 0 0 1 1      0 0 0 1 1    b)  0 1 1 1 1      1 0 1 1 1      1 1 0 1 1       0 0 0 0 1      0 0 0 1 0  c)  1 1 1 1 1      1 1 1 1 1      1 1 1 1 1       0 0 1 1 1      0 0 0 1 1     d)  0 1 0 0 0      0 0 1 0 0       1 0 0 1 0        0 0 0 0 1      0 0 0 1 0  e)  1 1 1 1 1      1 1 1 1 1      1 1 1 1 1       1 0 0 1 1      0 1 0 1 1  f)  1 1 0 0 0      0 0 1 0 0       1 0 0 1 1        0 1 0 0 1      1 0 0 1 0      6.", " Utiliz\u00e2nd metoda backtracking se genereaz\u0103 elementele produsului cartezian a n mul\u021bimi:  A1, A2,\u2026, An.", "Utiliz\u00e2nd acest algoritm pentru a genera elementele produsului cartezian a 3"], "page_sentence_count_spacy": 6}, {"page_number": 10, "page_char_count": 1861, "page_word_count": 457, "page_sentence_count_raw": 7, "page_token_count": 465.25, "text": "10    mul\u021bimi: A1={1, 2, 3}, A2={1, 2} \u0219i A3={1, 2, 3, 4} atunci, preciza\u021bi care din urm\u0103toarele  secven\u021be nu reprezint\u0103 o solu\u021bie a acestui algoritm, pentru produsul A3x A2x A1.  a) (4, 2, 3)  b) (3, 3, 3)  c) (3, 2, 1)    d) (1, 1, 1)  e) (4, 1, 2)  f) (3, 1, 3)      7.  Fie func\u021bia p definit\u0103 mai jos  Limbajul C++/ Limbajul C  Limbajul Pascal  int p (int a, int b)  {if (b==0)  return 0;    else      if (a%b==0) return p(a, b-1)+1;          else return p(a, b-1);}    function p (a, b: integer) : integer;  begin  if b=0 then p:=0  else   if a mod b=0 then p:=p(a, b-1)+1        else p:=p(a,b-1);  end;  preciza\u021bi care este apelul corect al func\u021biei p pentru a verifica dac\u0103 un num\u0103r x este prim.  Limbajul C++/ Limbajul C  a) if (p(x,x)==2) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);  b) if (p(2,x)==2) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);  c) if (p(x,2)==0) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);  d) if (p(x,x/2)==2) cout<<\u201dprim\u201d;  |  printf(\u201dprim\u201d);  e) if (p(x,2)==x) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);  f) if (p(2,x)==1) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);    Limbajul Pascal  a) if p(x, x)=2 then write(\u2019prim\u2019);  b) if p(2, x)=2 then write(\u2019prim\u2019);  c) if p(x, 2)=0 then write(\u2019prim\u2019);  d) if p(x, x div 2)=2 then write(\u2019prim\u2019);  e) if p(x, 2)=x then write(\u2019prim\u2019);  f) if p(2, x)=1 then write(\u2019prim\u2019);      8.  Un arbore are nodurile numerotate cu numere de la 1 la 5. Vectorul de ta\u021bi asociat arborelui  poate fi:  a) 5, 4, 2, 1, 3  b) 2, 1, 0, 3, 4  c) 5, 2, 4, 5, 0    d) 2, 4, 0, 3, 4  e) 0, 2, 4, 5, 0  f) 1, 4, 0, 3, 4      9.  Se consider\u0103 subprogramul t av\u00e2nd defini\u021bia urm\u0103toare:  Limbajul C++  void t(int &x, int y)    { x=x-1; y=x+1;    cout<<x<<y;     }  Limbajul C  Limbajul Pascal  void t(int *x, int y)  { *x=*x-1; y=*x+1;    printf( \u201c%d%d\u201d,*x,y);  }  procedure t( var x: integer; y: integer);  begin    x:=x-1;  y:=x+1;    write(x, y);  end;", "sentences": ["10    mul\u021bimi: A1={1, 2, 3}, A2={1, 2} \u0219i A3={1, 2, 3, 4} atunci, preciza\u021bi care din urm\u0103toarele  secven\u021be nu reprezint\u0103 o solu\u021bie a acestui algoritm, pentru produsul A3x A2x A1.", " a) (4, 2, 3)  b) (3, 3, 3)  c) (3, 2, 1)    d) (1, 1, 1)  e) (4, 1, 2)  f) (3, 1, 3)      7.", " Fie func\u021bia p definit\u0103 mai jos  Limbajul C++/ Limbajul C  Limbajul Pascal  int p (int a, int b)  {if (b==0)  return 0;    else      if (a%b==0) return p(a, b-1)+1;          else return p(a, b-1);}    function p (a, b: integer) : integer;  begin  if b=0 then p:=0  else   if a mod b=0 then p:=p(a, b-1)+1        else p:=p(a,b-1);  end;  preciza\u021bi care este apelul corect al func\u021biei p pentru a verifica dac\u0103 un num\u0103r x este prim.", " Limbajul C++/ Limbajul C  a) if (p(x,x)==2) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);  b) if (p(2,x)==2) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);  c) if (p(x,2)==0) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);  d) if (p(x,x/2)==2) cout<<\u201dprim\u201d;  |  printf(\u201dprim\u201d);  e) if (p(x,2)==x) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);  f) if (p(2,x)==1) cout<<\u201dprim\u201d;    |  printf(\u201dprim\u201d);    Limbajul Pascal  a) if p(x, x)=2 then write(\u2019prim\u2019);  b) if p(2, x)=2 then write(\u2019prim\u2019);  c) if p(x, 2)=0 then write(\u2019prim\u2019);  d) if p(x, x div 2)=2 then write(\u2019prim\u2019);  e) if p(x, 2)=x then write(\u2019prim\u2019);  f) if p(2, x)=1 then write(\u2019prim\u2019);      8.", " Un arbore are nodurile numerotate cu numere de la 1 la 5.", "Vectorul de ta\u021bi asociat arborelui  poate fi:  a) 5, 4, 2, 1, 3  b) 2, 1, 0, 3, 4  c) 5, 2, 4, 5, 0    d) 2, 4, 0, 3, 4  e) 0, 2, 4, 5, 0  f) 1, 4, 0, 3, 4      9.", " Se consider\u0103 subprogramul t av\u00e2nd defini\u021bia urm\u0103toare:  Limbajul C++  void t(int &x, int y)    { x=x-1; y=x+1;    cout<<x<<y;     }  Limbajul C  Limbajul Pascal  void t(int *x, int y)  { *x=*x-1; y=*x+1;    printf( \u201c%d%d\u201d,*x,y);  }  procedure t( var x: integer; y: integer);  begin    x:=x-1;  y:=x+1;    write(x, y);  end;"], "page_sentence_count_spacy": 7}, {"page_number": 11, "page_char_count": 2178, "page_word_count": 472, "page_sentence_count_raw": 41, "page_token_count": 544.5, "text": "11    Dac\u0103 ini\u021bial x=3 \u0219i y=7, preciza\u021bi ce se va afi\u0219a \u00een urma execut\u0103rii secven\u021bei de  instruc\u021biuni:  Limbajul C++  Limbajul C  Limbajul Pascal  t(y,y);   cout<<x<<y;     t(y,x);    t(&y,y);  printf( \u201c%d%d\u201d,x,y);  t(&y,x);  t(y,y);  write(x,y);  t(y,x);      a) 673556  b) 676767  c) 673767  d) 768978  e) 656376  f) 673656    10 .  Func\u021bia par cu parametrii de tip \u00eentreg a \u0219i b determin\u0103 num\u0103rul de valori pare din intervalul  [a, b], (a<b). Preciza\u021bi care din urm\u0103toarele expresii este adev\u0103rat\u0103, pentru orice numere a  \u0219i b care nu au aceea\u0219i paritate.  Limbajul C++/ Limbajul C  Limbajul Pascal  a) par(a, b) == b-a  b) par(a, b) == (b-a-1)/2  c) par(a, b) == (b-a+1)/2  d) par(a, b) == par(a, b +1)  e) par(a, b) == (b-a)/2  f) par(a, b) == par(a+1, b)  a) par(a, b) = b-a  b) par(a, b) = (b-a-1) DIV 2  c) par(a, b) = (b-a+1) DIV 2  d) par(a, b) = par(a, b +1)  e) par(a, b) = (b-a) DIV 2  f) par(a, b) = par(a+1, b)      11 .  Fie antetul func\u021biei mini:  Limbajul C++/ Limbajul C  Limbajul Pascal  int mini (int x, int y)  function  mini(x,y : integer): integer;  care returneaz\u0103 minimul dintre valorile variabilelor x \u0219i y. Preciza\u021bi instruc\u021biunea prin care  se \u00eenlocuiesc punctele de suspensie, astfel \u00eenc\u00e2t la finalul execut\u0103rii secven\u021bei de mai jos, s\u0103  se afi\u0219eze minimul dintre elementele tabloului unidimensional v, care are 30 de elemente  \u00eentregi aflate pe pozi\u021biile 1, 2,....,30.  Limbajul C++/ Limbajul C  c = mini(v[1], v[2]);  for(i=3; i<=30; i++)  . . . . . . . . . . . . . . . .  cout<<c;   |  printf( \u201d%d\u201d,c);    a) c =mini(v[i], v[i+1]);  b) c =mini(mini(v[i],v[1]),v[i+1]);  c) c =mini(c, v[i]);  d) c =mini(v[1], v[i]);  e) c =mini(v[i], v[i-1]);  f) c =mini(c, v[30]);  Limbajul Pascal  c :=mini(v[1],v[2]);  for i: =3 to 30 do  . . . . . . . . . . . . . . . .  writeln(c);    a) c:=mini(v[i], v[i+1]);  b) c:=mini(mini(v[i],v[1]),v[i+1]);  c) c:=mini(c, v[i]);  d) c:=mini(v[1], v[i]);  e) c:=mini(v[i], v[i-1]);  f) c:=mini(c, v[30]);    12 .  Preciza\u021bi ce va con\u021bine variabila s dup\u0103 executarea urm\u0103toarei secven\u021be de instruc\u021biuni.  Limbajul C++/ Limbajul C  Limbajul Pascal  char s[30]=\u201dAdmiTerE\u201d;  int i;  var s: string[29];        i: integer;", "sentences": ["11    Dac\u0103 ini\u021bial x=3 \u0219i y=7, preciza\u021bi ce se va afi\u0219a \u00een urma execut\u0103rii secven\u021bei de  instruc\u021biuni:  Limbajul C++  Limbajul C  Limbajul Pascal  t(y,y);   cout<<x<<y;     t(y,x);    t(&y,y);  printf( \u201c%d%d\u201d,x,y);  t(&y,x);  t(y,y);  write(x,y);  t(y,x);      a) 673556  b) 676767  c) 673767  d) 768978  e) 656376  f) 673656    10 .", " Func\u021bia par cu parametrii de tip \u00eentreg a \u0219i b determin\u0103 num\u0103rul de valori pare din intervalul  [a, b], (a<b).", "Preciza\u021bi care din urm\u0103toarele expresii este adev\u0103rat\u0103, pentru orice numere a  \u0219i b care nu au aceea\u0219i paritate.", " Limbajul C++/ Limbajul C  Limbajul Pascal  a) par(a, b) == b-a  b) par(a, b) == (b-a-1)/2  c) par(a, b) == (b-a+1)/2  d) par(a, b) == par(a, b +1)  e) par(a, b) == (b-a)/2  f) par(a, b) == par(a+1, b)  a) par(a, b) = b-a  b) par(a, b) = (b-a-1) DIV 2  c) par(a, b) = (b-a+1) DIV 2  d) par(a, b) = par(a, b +1)  e) par(a, b) = (b-a) DIV 2  f) par(a, b) = par(a+1, b)      11 .", " Fie antetul func\u021biei mini:  Limbajul C++/ Limbajul C  Limbajul Pascal  int mini (int x, int y)  function  mini(x,y : integer): integer;  care returneaz\u0103 minimul dintre valorile variabilelor x \u0219i y. Preciza\u021bi instruc\u021biunea prin care  se \u00eenlocuiesc punctele de suspensie, astfel \u00eenc\u00e2t la finalul execut\u0103rii secven\u021bei de mai jos, s\u0103  se afi\u0219eze minimul dintre elementele tabloului unidimensional v, care are 30 de elemente  \u00eentregi aflate pe pozi\u021biile 1, 2,....,30.", " Limbajul C++/ Limbajul C  c = mini(v[1], v[2]);  for(i=3; i<=30; i++)  . . . . . . . . . . . . . . . .", " cout<<c;   |  printf( \u201d%d\u201d,c);    a) c =mini(v[i], v[i+1]);  b) c =mini(mini(v[i],v[1]),v[i+1]);  c) c =mini(c, v[i]);  d) c =mini(v[1], v[i]);  e) c =mini(v[i], v[i-1]);  f) c =mini(c, v[30]);  Limbajul Pascal  c :=mini(v[1],v[2]);  for i: =3 to 30 do  . . . . . . . . . . . . . . . .", " writeln(c);    a) c:=mini(v[i], v[i+1]);  b) c:=mini(mini(v[i],v[1]),v[i+1]);  c) c:=mini(c, v[i]);  d) c:=mini(v[1], v[i]);  e) c:=mini(v[i], v[i-1]);  f) c:=mini(c, v[30]);    12 .", " Preciza\u021bi ce va con\u021bine variabila s dup\u0103 executarea urm\u0103toarei secven\u021be de instruc\u021biuni.", " Limbajul C++/ Limbajul C  Limbajul Pascal  char s[30]=\u201dAdmiTerE\u201d;  int i;  var s: string[29];        i: integer;"], "page_sentence_count_spacy": 10}, {"page_number": 12, "page_char_count": 1921, "page_word_count": 555, "page_sentence_count_raw": 13, "page_token_count": 480.25, "text": "12    for (i=0; i<strlen(s); i++)     if (s[i]>=\u2019A\u2019 && s[i]<=\u2019Z\u2019)           s[i]=s[i]+32;        else           strcpy(s+i, s+i+1);  cout<<s;   |  printf(\u201c%s\u201d, s);  .........................  s:=\u2019AdmiTerE\u2019;  for i:=1 to length(s) do      if s[i] in [\u2018A\u2019..\u2019Z\u2019] then            s[i] := chr(ord(s[i])+32)          else            delete(s,i,1);  write(s);      a) ate  b) amtre  c) amre  d) aTe  e) amTre  f)are    13 .  Pentru urm\u0103toarele declar\u0103ri:  Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct {        char nume[20];        int nr;        int nota[15];  } elev;  elev e[28], x;  type elev = record      nume : string[19];     nr : integer;     nota : array[1..14] of integer;  end;  var e: array[1..27] of elev;  x: elev;  preciza\u021bi care dintre urm\u0103toarele instruc\u021biuni este corect\u0103 din punct de vedere sintactic.  Limbajul C++/ Limbajul C  Limbajul Pascal  a) e[10] = x;  b) e[10] = x.nr;  c) e[10] = e.nota[10];  d) elev. nota[5] = 7;  e) x.nota = x.nota+1;  f) x.nr=x.nota;  a) e[10] := x;  b) e[10] := x.nr;  c) e[10] := e.nota[10];  d) elev. nota[5] := 7;  e) x. nota := x. nota +1;  f) x.nr := x.nota;      14 .  Preciza\u021bi c\u00e2te grafuri neorientate distincte, cu 6 noduri, numerotate de la 1 la 6, se pot  construi, astfel \u00eenc\u00e2t nodul 2 s\u0103 aib\u0103 gradul 1. Dou\u0103 grafuri sunt distincte dac\u0103 matricele lor  de adiacen\u021b\u0103      sunt diferite.  a) 46  b) 256  c) 6!  d) 1024  e) 2345  f) 5120    15 .  Pentru func\u021bia g definit\u0103 mai jos, preciza\u021bi valoarea care se returneaz\u0103 \u00een urma apelului   g(2,1).  Limbajul C++/ Limbajul C  Limbajul Pascal  int g(int x, int y)   { if (x > 0)     { if (y == 0) return g(x-1,1);       if (y > 0) return g(x-1, g(x,  y-1));                      }   return y+1;   }  function g(x,y: integer): integer;  begin  if x>0 then begin       if y=0 then g:=g(x-1,1);     if y>0 then g:=g(x-1,g(x,y-1));              end    else  g:=y+1;  end;      a) 3  b) 4  c) 5  d) 6  e) 7  f) 10", "sentences": ["12    for (i=0; i<strlen(s); i++)     if (s[i]>=\u2019A\u2019 && s[i]<=\u2019Z\u2019)           s[i]=s[i]+32;        else           strcpy(s+i, s+i+1);  cout<<s;   |  printf(\u201c%s\u201d, s);  .........................  s:=\u2019AdmiTerE\u2019;  for i:=1 to length(s) do      if s[i] in [\u2018A\u2019..\u2019Z\u2019] then            s[i] := chr(ord(s[i])+32)          else            delete(s,i,1);  write(s);      a) ate  b) amtre  c) amre  d) aTe  e) amTre  f)are    13 .", " Pentru urm\u0103toarele declar\u0103ri:  Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct {        char nume[20];        int nr;        int nota[15];  } elev;  elev e[28], x;  type elev = record      nume : string[19];     nr : integer;     nota : array[1..14] of integer;  end;  var e: array[1..27] of elev;  x: elev;  preciza\u021bi care dintre urm\u0103toarele instruc\u021biuni este corect\u0103 din punct de vedere sintactic.", " Limbajul C++/ Limbajul C  Limbajul Pascal  a) e[10] = x;  b) e[10] = x.nr;  c) e[10] = e.nota[10];  d) elev.", "nota[5] = 7;  e) x.nota = x.nota+1;  f) x.nr=x.nota;  a) e[10] := x;  b) e[10] := x.nr;  c) e[10] := e.nota[10];  d) elev.", "nota[5] := 7;  e) x. nota := x. nota +1;  f) x.nr := x.nota;      14 .", " Preciza\u021bi c\u00e2te grafuri neorientate distincte, cu 6 noduri, numerotate de la 1 la 6, se pot  construi, astfel \u00eenc\u00e2t nodul 2 s\u0103 aib\u0103 gradul 1.", "Dou\u0103 grafuri sunt distincte dac\u0103 matricele lor  de adiacen\u021b\u0103      sunt diferite.", " a) 46  b) 256  c) 6!", " d) 1024  e) 2345  f) 5120    15 .", " Pentru func\u021bia g definit\u0103 mai jos, preciza\u021bi valoarea care se returneaz\u0103 \u00een urma apelului   g(2,1).", " Limbajul C++/ Limbajul C  Limbajul Pascal  int g(int x, int y)   { if (x > 0)     { if (y == 0) return g(x-1,1);       if (y > 0) return g(x-1, g(x,  y-1));                      }   return y+1;   }  function g(x,y: integer): integer;  begin  if x>0 then begin       if y=0 then g:=g(x-1,1);     if y>0 then g:=g(x-1,g(x,y-1));              end    else  g:=y+1;  end;      a) 3  b) 4  c) 5  d) 6  e) 7  f) 10"], "page_sentence_count_spacy": 11}, {"page_number": 13, "page_char_count": 1841, "page_word_count": 450, "page_sentence_count_raw": 7, "page_token_count": 460.25, "text": "13        Varianta 2    1.  Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execut\u0103rii urm\u0103toarelor instruc\u021biuni.  Limbajul C++/ Limbajul C  Limbajul Pascal  for(i=1; i<=5; i++)   for(j=5; j>=i; j--)      if (i%2==0) cout<<i;          | printf(\u201c%d\u201d,i);           else cout<<j;         | printf(\u201c%d\u201d,j);  for i :=1 to 5 do    for j :=5 downto  i do      if i mod 2 = 0  then  write(i)                    else  write(j);      a) 12345  b) 111115432333545  c) 543212222543445      d)122333444455555  e) 12334445555  f) 23344455554443      2.  Se consider\u0103 expresia:  Limbajul C++/ Limbajul C  Limbajul Pascal  !((x<=y && x>=z) || x<=t)  not(((x<=y) and (x>=z))or(x<=t))  Preciza\u021bi care expresie este echivalent\u0103 cu expresia dat\u0103.  Limbajul C++/ Limbajul C  Limbajul Pascal  a) x<=y || x>=z && x<=t  b) x>y || x<z && x>t  c) x>y && x<z || x>t  d)(x>y || x<z) && x>t  e) x>y || x<z && x<=t  f) x>=y && x<=z || x>t  a) (x<=y) or (x>=z) and (x<=t)  b) (x>y) or (x<z) and (x>t)  c) (x>y) and (x<z) or (x>t)  d) ((x>y) or (x<z)) and (x>t)  e) (x>y) or (x<z) and (x<=t)  f) (x>=y) and (x<=z) or (x>t)      3.  Un tablou bidimensional a, cu n linii \u0219i n coloane numerotate de la 1 la n, este simetric fa\u021b\u0103  de diagonala secundar\u0103 dac\u0103 pentru orice pereche de indici (i, j) este adev\u0103rat\u0103 expresia:  Limbajul C++/ Limbajul C  Limbajul Pascal  a) a[i][j] == a[j][i]  b) a[i][i] == a[n+1-j][n+1+i]  c) a[i][j] == a[n+1-i][n+1-j]  d) a[i][j] == a[n-j][[n-i]  e) a[i][j] == a[n+1-j][n+1-i]  f) a[i][j] == a[n+j][[n-i]  a) a[i, j] = a[j, i]  b) a[i, i] = a[n+1-j, n+1+i]  c) a[i, j] = a[n+1-i, n+1-j]  d) a[i, j] = a[n-j, n-i]  e) a[i, j] = a[n+1-j, n+1-i]  f) a[i, j] = a[n+j, n-i]      4.  Preciza\u021bi ce valoare are variabila b de tip \u0219ir de caractere dup\u0103 executarea secven\u021bei:  Limbajul C++/ Limbajul C  Limbajul Pascal  char b[ ]=\u201dtoc2019\u201d;  var b: string[30];", "sentences": ["13        Varianta 2    1.", " Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execut\u0103rii urm\u0103toarelor instruc\u021biuni.", " Limbajul C++/ Limbajul C  Limbajul Pascal  for(i=1; i<=5; i++)   for(j=5; j>=i; j--)      if (i%2==0) cout<<i;          | printf(\u201c%d\u201d,i);           else cout<<j;         | printf(\u201c%d\u201d,j);  for i :=1 to 5 do    for j :=5 downto  i do      if i mod 2 = 0  then  write(i)                    else  write(j);      a) 12345  b) 111115432333545  c) 543212222543445      d)122333444455555  e) 12334445555  f) 23344455554443      2.", " Se consider\u0103 expresia:  Limbajul C++/ Limbajul C  Limbajul Pascal  !((", "x<=y && x>=z) || x<=t)  not(((x<=y) and (x>=z))or(x<=t))  Preciza\u021bi care expresie este echivalent\u0103 cu expresia dat\u0103.", " Limbajul C++/ Limbajul C  Limbajul Pascal  a) x<=y || x>=z && x<=t  b) x>y || x<z && x>t  c) x>y && x<z || x>t  d)(x>y || x<z) && x>t  e) x>y || x<z && x<=t  f) x>=y && x<=z || x>t  a) (x<=y) or (x>=z) and (x<=t)  b) (x>y) or (x<z) and (x>t)  c) (x>y) and (x<z) or (x>t)  d) ((x>y) or (x<z)) and (x>t)  e) (x>y) or (x<z) and (x<=t)  f) (x>=y) and (x<=z) or (x>t)      3.", " Un tablou bidimensional a, cu n linii \u0219i n coloane numerotate de la 1 la n, este simetric fa\u021b\u0103  de diagonala secundar\u0103 dac\u0103 pentru orice pereche de indici (i, j) este adev\u0103rat\u0103 expresia:  Limbajul C++/ Limbajul C  Limbajul Pascal  a) a[i][j] == a[j][i]  b) a[i][i] == a[n+1-j][n+1+i]  c) a[i][j] == a[n+1-i][n+1-j]  d) a[i][j] == a[n-j][[n-i]  e) a[i][j] == a[n+1-j][n+1-i]  f) a[i][j] == a[n+j][[n-i]  a) a[i, j] = a[j, i]  b) a[i, i] = a[n+1-j, n+1+i]  c) a[i, j] = a[n+1-i, n+1-j]  d) a[i, j] = a[n-j, n-i]  e) a[i, j] = a[n+1-j, n+1-i]  f) a[i, j] = a[n+j, n-i]      4.", " Preciza\u021bi ce valoare are variabila b de tip \u0219ir de caractere dup\u0103 executarea secven\u021bei:  Limbajul C++/ Limbajul C  Limbajul Pascal  char b[ ]=\u201dtoc2019\u201d;  var b: string[30];"], "page_sentence_count_spacy": 8}, {"page_number": 14, "page_char_count": 1898, "page_word_count": 522, "page_sentence_count_raw": 9, "page_token_count": 474.5, "text": "14    b[3]=b[3]-1;  strcpy(b+5,b+7);  strcpy(b,b+3);  b:= \u2018toc2019\u2019;  b[4]:= chr(ord(b[4])-1);  delete(b,6,2);  delete(b,1,3);  a)  b20  b) 19   c) 20  d) 10  e) toc  f)2019      5.  Se consider\u0103 tipul de date punct, ce memoreaz\u0103 abscisa \u0219i ordonata unui punct din plan \u0219i  tipul de date segment ce memoreaz\u0103 dou\u0103 puncte distincte reprezent\u00e2nd extremit\u0103\u021bile unui  segment din plan. Preciza\u021bi care dintre urm\u0103toarele expresii are ca valoare ordonata  mijlocului segmentului corespunz\u0103tor variabilei s de tip segment.    Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct    { float x, y;}punct;  typedef struct     {punct  A, B;}segment;  segment s;  type punct=record     x, y: real;          end;  type segment=record      A, B: punct;           end;  var s: segment;    a) (A.x+B.x)/2  b) (A.s.y+B.s.y)/2  c) (s.y+s.y)/2      d) (A.x+B.y)/2  e) (s.A.x+s.B.x)/2  f) (s.A.y+s.B.y)/2        6.  Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate tablourile bidimensionale p\u0103tratice de  ordin n ale c\u0103ror elemente apar\u021bin mul\u021bimii {0, 1}, cu proprietatea c\u0103 pe fiecare linie \u0219i pe  fiecare coloan\u0103 exist\u0103 o singur\u0103 valoare 1. Dac\u0103 n=3 tablourile bidimensionale sunt generate  \u00een ordinea urm\u0103toare:   100  010  001  100  001  010  010  100  001  010  001  100  001  100  010  001  010  100  Dac\u0103 n =4, preciza\u021bi care este tabloul bidimensional generat imediat dup\u0103 tabloul  bidimensional:  0010  1000  0001  0100.  a) 0010        1000        0100        0001  b) 0010        0100        1000        0001  c) 0001        1000        0010        0100  d) 0010        0001        1000        0100  e) 0001        0010        0100        1000  f) 1000        0010           0100           0001    7.  Pentru defini\u021bia de mai jos a subprogramului nr, stabili\u021bi ce valoare returneaz\u0103 apelul  nr(6,3).  Limbajul C++/ Limbajul C  Limbajul Pascal  int nr (int x, int y)  function nr(x,y:integer): integer;", "sentences": ["14    b[3]=b[3]-1;  strcpy(b+5,b+7);  strcpy(b,b+3);  b:= \u2018toc2019\u2019;  b[4]:= chr(ord(b[4])-1);  delete(b,6,2);  delete(b,1,3);  a)  b20  b) 19   c) 20  d) 10  e) toc  f)2019      5.", " Se consider\u0103 tipul de date punct, ce memoreaz\u0103 abscisa \u0219i ordonata unui punct din plan \u0219i  tipul de date segment ce memoreaz\u0103 dou\u0103 puncte distincte reprezent\u00e2nd extremit\u0103\u021bile unui  segment din plan.", "Preciza\u021bi care dintre urm\u0103toarele expresii are ca valoare ordonata  mijlocului segmentului corespunz\u0103tor variabilei s de tip segment.", "   Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct    { float x, y;}punct;  typedef struct     {punct  A, B;}segment;  segment s;  type punct=record     x, y: real;          end;  type segment=record      A, B: punct;           end;  var s: segment;    a) (A.x+B.x)/2  b) (A.s.y+B.s.y)/2  c) (s.y+s.y)/2      d) (A.x+B.y)/2  e) (s.A.x+s.", "B.x)/2  f) (s.A.y+s.", "B.y)/2        6.", " Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate tablourile bidimensionale p\u0103tratice de  ordin n ale c\u0103ror elemente apar\u021bin mul\u021bimii {0, 1}, cu proprietatea c\u0103 pe fiecare linie \u0219i pe  fiecare coloan\u0103 exist\u0103 o singur\u0103 valoare 1.", "Dac\u0103 n=3 tablourile bidimensionale sunt generate  \u00een ordinea urm\u0103toare:   100  010  001  100  001  010  010  100  001  010  001  100  001  100  010  001  010  100  Dac\u0103 n =4, preciza\u021bi care este tabloul bidimensional generat imediat dup\u0103 tabloul  bidimensional:  0010  1000  0001  0100.", " a) 0010        1000        0100        0001  b) 0010        0100        1000        0001  c) 0001        1000        0010        0100  d) 0010        0001        1000        0100  e) 0001        0010        0100        1000  f) 1000        0010           0100           0001    7.", " Pentru defini\u021bia de mai jos a subprogramului nr, stabili\u021bi ce valoare returneaz\u0103 apelul  nr(6,3).", " Limbajul C++/ Limbajul C  Limbajul Pascal  int nr (int x, int y)  function nr(x,y:integer): integer;"], "page_sentence_count_spacy": 11}, {"page_number": 15, "page_char_count": 2349, "page_word_count": 668, "page_sentence_count_raw": 11, "page_token_count": 587.25, "text": "15    { int a, t;     if (x==y || y==1) return 1;     if (x<y) return 0;     a=0;     for(t=1; t<=y; t++)        a=a+nr(x-y,t);     return a;  }  var a, t : integer;  begin  if (x=y) or (y=1) then nr := 1     else if x<y then  nr :=0              else  begin                    a :=0;                    for t :=1 to y do                      a :=a+nr(x-y,t);                    nr := a;                   end;  end;    a) 0  b) 1  c) 2  d) 3  e) 4  f) 6    8.  Se consider\u0103 un arbore cu 10 noduri, numerotate de la 1 la 10 av\u00e2nd vectorul de ta\u021bi urm\u0103tor  (0, 1, 1, 1, 3, 3, 3, 4, 7, 7). Descenden\u021bii nodului 3 sunt:  a) 5, 6, 7  b) 5, 6, 7, 9, 10  c) 4, 5, 6, 7, 8, 9, 10    d) 6, 7  e) 4, 5, 6  f) 4,7      9.  \u0218tiind c\u0103 ini\u021bial variabilele \u00eentregi x \u0219i y au valorile 1 \u0219i respectiv 2, stabili\u021bi care sunt valorile  lor dup\u0103 apelul F(x,y) (pentru variantele \u00een limbajele C++ sau Pascal)  respectiv F(&x,y)  (pentru varianta \u00een limbajul C):   Limbajul C++  Limbajul C  Limbajul Pascal  void F( int &x, int y)   {    x=2; y=3;  }  void F( int *x, int y)  {      *x=2; y=3;  }  procedure F(var x:  integer; y: integer);  begin    x:=2; y:=3;  end;    a) 3 2  b) 1 2   c) 1 1  d) 2 3  e) 2 2  f) 3 3    10 .  Se consider\u0103 un graf neorientat cu 8 noduri numerotate de la 1 la 8 \u0219i urm\u0103toarele muchii:  [1,7], [1,8], [3,4], [3,5], [3,6], [3,7], [4,7], [5,6], [5,8], [6,7], [6,8], [7,8]. Preciza\u021bi care este  num\u0103rul minim de culori cu care pot fi colorate nodurile grafului, astfel \u00eenc\u00e2t oricare dou\u0103  noduri adiacente s\u0103 aib\u0103 culori diferite.  a)  1  b)  2  c)  3  d)  4  e) 6  f) 8    11 .  Num\u0103rul maxim de muchii dintr-un graf neorientat cu 16 noduri \u0219i 7 componente conexe  este:  a) 15  b)  18  c)  23  d)  25  e) 36  f) 45    12 .  Se consider\u0103 un \u0219ir de caractere c de lungime maxim\u0103 20, ce con\u021bine cel pu\u021bin un caracter  \u2018d\u2019. Preciza\u021bi care dintre urm\u0103toarele secven\u021be afi\u0219eaz\u0103 pozi\u021bia primei apari\u021bii a lui \u2018d\u2019 \u00een  \u0219irul de catactere c.  Limbajul C++/ Limbajul C  a) cout<<strchr(c, \u2019d\u2019)-c;  | printf(\u201d%d\u201d, strchr(c, \u2019d\u2019)-c );  b) cout<<strrchr(c, \u2019d\u2019);  | printf(\u201d%d\u201d, strrchr(c, \u2019d\u2019));  c) cout<<strchr(c, \u2019d\u2019)-c-1; | printf(\u201d%d\u201d, strchr(c, \u2019d\u2019)-c-1 );  d) cout<<strchr(c, \u2019d\u2019);  | printf(\u201d%d\u201d, strchr(c, \u2019d\u2019));  e) cout<<strchr(c, \u2019d\u2019)-c+2; | printf(\u201d%d\u201d, strchr(c, \u2019d\u2019)-c+2 );  f) cout<<strchr(c, \u2019d-c\u2019);  | printf(\u201d%d\u201d, strchr(c, \u2019d-c\u2019));", "sentences": ["15    { int a, t;     if (x==y || y==1) return 1;     if (x<y) return 0;     a=0;     for(t=1; t<=y; t++)        a=a+nr(x-y,t);     return a;  }  var a, t : integer;  begin  if (x=y) or (y=1) then nr := 1     else if x<y then  nr :=0              else  begin                    a :=0;                    for t :=1 to y do                      a :=a+nr(x-y,t);                    nr := a;                   end;  end;    a) 0  b) 1  c) 2  d) 3  e) 4  f) 6    8.", " Se consider\u0103 un arbore cu 10 noduri, numerotate de la 1 la 10 av\u00e2nd vectorul de ta\u021bi urm\u0103tor  (0, 1, 1, 1, 3, 3, 3, 4, 7, 7).", "Descenden\u021bii nodului 3 sunt:  a) 5, 6, 7  b) 5, 6, 7, 9, 10  c) 4, 5, 6, 7, 8, 9, 10    d) 6, 7  e) 4, 5, 6  f) 4,7      9.", " \u0218tiind c\u0103 ini\u021bial variabilele \u00eentregi x \u0219i y au valorile 1 \u0219i respectiv 2, stabili\u021bi care sunt valorile  lor dup\u0103 apelul F(x,y) (pentru variantele \u00een limbajele C++ sau Pascal)  respectiv F(&x,y)  (pentru varianta \u00een limbajul C):   Limbajul C++  Limbajul C  Limbajul Pascal  void F( int &x, int y)   {    x=2; y=3;  }  void F( int *x, int y)  {      *x=2; y=3;  }  procedure F(var x:  integer; y: integer);  begin    x:=2; y:=3;  end;    a) 3 2  b) 1 2   c) 1 1  d) 2 3  e) 2 2  f) 3 3    10 .", " Se consider\u0103 un graf neorientat cu 8 noduri numerotate de la 1 la 8 \u0219i urm\u0103toarele muchii:  [1,7], [1,8], [3,4], [3,5], [3,6], [3,7], [4,7], [5,6], [5,8], [6,7], [6,8], [7,8].", "Preciza\u021bi care este  num\u0103rul minim de culori cu care pot fi colorate nodurile grafului, astfel \u00eenc\u00e2t oricare dou\u0103  noduri adiacente s\u0103 aib\u0103 culori diferite.", " a)  1  b)  2  c)  3  d)  4  e) 6  f) 8    11 .", " Num\u0103rul maxim de muchii dintr-un graf neorientat cu 16 noduri \u0219i 7 componente conexe  este:  a) 15  b)  18  c)  23  d)  25  e) 36  f) 45    12 .", " Se consider\u0103 un \u0219ir de caractere c de lungime maxim\u0103 20, ce con\u021bine cel pu\u021bin un caracter  \u2018d\u2019.", "Preciza\u021bi care dintre urm\u0103toarele secven\u021be afi\u0219eaz\u0103 pozi\u021bia primei apari\u021bii a lui \u2018d\u2019 \u00een  \u0219irul de catactere c.  Limbajul C++/ Limbajul C  a) cout<<strchr(c, \u2019d\u2019)-c;  | printf(\u201d%d\u201d, strchr(c, \u2019d\u2019)-c );  b) cout<<strrchr(c, \u2019d\u2019);  | printf(\u201d%d\u201d, strrchr(c, \u2019d\u2019));  c) cout<<strchr(c, \u2019d\u2019)-c-1; | printf(\u201d%d\u201d, strchr(c, \u2019d\u2019)-c-1 );  d) cout<<strchr(c, \u2019d\u2019);  | printf(\u201d%d\u201d, strchr(c, \u2019d\u2019));  e) cout<<strchr(c, \u2019d\u2019)-c+2; | printf(\u201d%d\u201d, strchr(c, \u2019d\u2019)-c+2 );  f) cout<<strchr(c, \u2019d-c\u2019);  | printf(\u201d%d\u201d, strchr(c, \u2019d-c\u2019));"], "page_sentence_count_spacy": 10}, {"page_number": 16, "page_char_count": 1589, "page_word_count": 402, "page_sentence_count_raw": 8, "page_token_count": 397.25, "text": "16      Limbajul Pascal  a) write(pos(\u2018d\u2019, c));  b) write(pos(c, \u2018d\u2019));  c) write(pos(c, \u2018d\u2019)-1);  d) write(substr(c,\u2018d\u2019));  e) write(pos(c, \u2018d\u2019)+2);  f) write(substr(c,\u2018d-c\u2019));        13 .  Preciza\u021bi ce valoare are variabilade tip \u00eentreg a dup\u0103 executarea urm\u0103toarei secven\u021be de  instruc\u021biuni.  Limbajul C++/ Limbajul C  Limbajul Pascal  a=2019;  for(x=1; x<=5; x++);  a=a+2;  a: = 2019;  for x:=1 to 5 do;  a: =a+2;      a) 2019  b) 2020  c) 2021  d) 2024  e)2027  f)2029    14 .  O clas\u0103 de 30 de elevi este la ora de informatic\u0103 \u0219i profesorul dore\u0219te s\u0103 formeze o echip\u0103 de  5 elevi. El \u00eei cere unui elev s\u0103-i genereze toate posibilit\u0103\u021bile de a forma o grup\u0103 de 5 elevi din  acea clas\u0103. Aceast\u0103 problem\u0103 este similar\u0103 cu generarea tuturor:  a) elementelor produsului cartezian A5, A fiind o mul\u021bime cu 30 de elemente  b) parti\u021biilor      unei mul\u021bimi  c) aranjamentelor de 30 de elemente luate c\u00e2te 5  d) permut\u0103rilor de 5 elemente  e) combin\u0103rilor de 30 de elemente luate c\u00e2te 5  f) submul\u021bimilor de 5 elemente din mul\u021bimea A, A fiind o mul\u021bime cu 30 de elemente    15 .  Se consider\u0103 urm\u0103toarea func\u021bie recursiv\u0103:  Limbajul C++/  Limbajul C  Limbajul Pascal  int s(int t)   { if (t == 1) return 0;        else     if (t == 2) return 1;     else       return s(t-2) + s(t\u20131); }    function s(t : integer) : integer;   begin     if t = 1 then s := 0       else        if t = 2 then s := 1             else       s:=s(t-2)+s(t-1);   end;   Dac\u0103 apelul ini\u021bial nu se ia \u00een considerare, preciza\u021bi c\u00e2te autoapeluri vor fi f\u0103cute pentru apelul  s(6).   a) 4  b) 6  c) 8  d) 10  e) 11  f) 14", "sentences": ["16      Limbajul Pascal  a) write(pos(\u2018d\u2019, c));  b) write(pos(c, \u2018d\u2019));  c) write(pos(c, \u2018d\u2019)-1);  d) write(substr(c,\u2018d\u2019));  e) write(pos(c, \u2018d\u2019)+2);  f) write(substr(c,\u2018d-c\u2019));        13 .", " Preciza\u021bi ce valoare are variabilade tip \u00eentreg a dup\u0103 executarea urm\u0103toarei secven\u021be de  instruc\u021biuni.", " Limbajul C++/ Limbajul C  Limbajul Pascal  a=2019;  for(x=1; x<=5; x++);  a=a+2;  a: = 2019;  for x:=1 to 5 do;  a: =a+2;      a) 2019  b) 2020  c) 2021  d) 2024  e)2027  f)2029    14 .", " O clas\u0103 de 30 de elevi este la ora de informatic\u0103 \u0219i profesorul dore\u0219te s\u0103 formeze o echip\u0103 de  5 elevi.", "El \u00eei cere unui elev s\u0103-i genereze toate posibilit\u0103\u021bile de a forma o grup\u0103 de 5 elevi din  acea clas\u0103.", "Aceast\u0103 problem\u0103 este similar\u0103 cu generarea tuturor:  a) elementelor produsului cartezian A5, A fiind o mul\u021bime cu 30 de elemente  b) parti\u021biilor      unei mul\u021bimi  c) aranjamentelor de 30 de elemente luate c\u00e2te 5  d) permut\u0103rilor de 5 elemente  e) combin\u0103rilor de 30 de elemente luate c\u00e2te 5  f) submul\u021bimilor de 5 elemente din mul\u021bimea A, A fiind o mul\u021bime cu 30 de elemente    15 .", " Se consider\u0103 urm\u0103toarea func\u021bie recursiv\u0103:  Limbajul C++/  Limbajul C  Limbajul Pascal  int s(int t)   { if (t == 1) return 0;        else     if (t == 2) return 1;     else       return s(t-2) + s(t\u20131); }    function s(t : integer) : integer;   begin     if t = 1 then s := 0       else        if t = 2 then s := 1             else       s:=s(t-2)+s(t-1);   end;   Dac\u0103 apelul ini\u021bial nu se ia \u00een considerare, preciza\u021bi c\u00e2te autoapeluri vor fi f\u0103cute pentru apelul  s(6).", "  a) 4  b) 6  c) 8  d) 10  e) 11  f) 14"], "page_sentence_count_spacy": 8}, {"page_number": 17, "page_char_count": 2115, "page_word_count": 651, "page_sentence_count_raw": 10, "page_token_count": 528.75, "text": "17    Varianta 3    1.  Preciza\u021bi pentru c\u00e2te valori naturale citite pentru variabila n programul urm\u0103tor afi\u0219eaz\u0103  valoarea 10.  Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int main()  {      int n,i=1,k=1;      cin>>n;       while(k*k<=n)k+=++i;      cout<<k;  }  #include<stdio.h>  void main( )  {      int n,i=1,k=1;      scanf(\"%d\", &n);      while(k*k<=n)  k+=++i;      printf(\"%d\", k);  }    var n,i,k:integer;  begin    i:=1; k:=1;    readln(n);    while k*k<=n do      begin        inc(i); k:=k+i;     end;    write(k)  end.  a) 0  b) 10  c) 54  d) 63  e)  64  f)  100    2.  Se consider\u0103 urm\u0103torul program:  Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int main()  {     int i, v[10];     for(i=1;i<10;i++)       cin>>v[i];     i=v[7];     do      {        cout<<i<<\" \";        i=v[i];      }while(i!=1);     cout<<i;  }  #include<stdio.h>  void main()  {     int i,v[10];     for(i=1;i<10;i++)       scanf(\"%d\",&v[i]);     i=v[7];     do      {          printf(\"%d \",i);          i=v[i];      }while(i!=1);     printf(\"%d \",i);  }  var i:integer;   v:array[0..9]of integer;  begin    for i:=1 to 9 do        read(v[i]);    i:=v[7];    repeat       write( i, ' ');       i:=v[i];    until i=1;    write(i)  end.  La executarea programului se introduc, \u00een ordine, valorile:  5 3 7 6 9 2 1 4 8.   Preciza\u021bi care sunt valorile afi\u0219ate.  a)  1 5 9 8 4 6 2 3 7 1  b)  1 2 3 4 5 6 7 8 9 1  c)  1 5 9 8 4 6 2 3 7   d)  1 5 3 7 6 9 2 4 8 1  e)     7 1 2 9 8 4 6 2 3 1  f)      7 3 5 4 2 8 1 9 6 1    3.  Preciza\u021bi ce valoare se afi\u0219eaz\u0103 \u00een urma execu\u021biei urm\u0103torului program dac\u0103 pentru n se  cite\u0219te valoarea 20.  Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int main()  {    int a[51][51];    int i,j,n, s=0;    cin>>n;    for(i=1;i<=n;i++)  #include<stdio.h>  void main()  {    int a[51][51];    int i,j,n, s=0;    scanf(\"%d\", &n);    for(i=1;i<=n;i++)     for(j=1;j<=n;j++)  var a:array[1..50,1..50]        of integer;      i,j,n,s: integer;   begin   s:=0;   readln(n);  for i:=1 to n do", "sentences": ["17    Varianta 3    1.", " Preciza\u021bi pentru c\u00e2te valori naturale citite pentru variabila n programul urm\u0103tor afi\u0219eaz\u0103  valoarea 10.", " Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int main()  {      int n,i=1,k=1;      cin>>n;       while(k*k<=n)k+=++i;      cout<<k;  }  #include<stdio.h>  void main( )  {      int n,i=1,k=1;      scanf(\"%d\", &n);      while(k*k<=n)  k+=++i;      printf(\"%d\", k);  }    var n,i,k:integer;  begin    i:=1; k:=1;    readln(n);    while k*k<=n do      begin        inc(i); k:=k+i;     end;    write(k)  end.", " a) 0  b) 10  c) 54  d) 63  e)  64  f)  100    2.", " Se consider\u0103 urm\u0103torul program:  Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int main()  {     int i, v[10];     for(i=1;i<10;i++)       cin>>v[i];     i=v[7];     do      {        cout<<i<<\" \";        i=v[i];      }while(i!=1);     cout<<i;  }  #include<stdio.h>  void main()  {     int i,v[10];     for(i=1;i<10;i++)       scanf(\"%d\",&v[i]);     i=v[7];     do      {          printf(\"%d \",i);          i=v[i];      }while(i!=1);     printf(\"%d \",i);  }  var i:integer;   v:array[0..9]of integer;  begin    for i:=1 to 9 do        read(v[i]);    i:=v[7];    repeat       write( i, ' ');       i:=v[i];    until i=1;    write(i)  end.", " La executarea programului se introduc, \u00een ordine, valorile:  5 3 7 6 9 2 1 4 8.", "  Preciza\u021bi care sunt valorile afi\u0219ate.", " a)  1 5 9 8 4 6 2 3 7 1  b)  1 2 3 4 5 6 7 8 9 1  c)  1 5 9 8 4 6 2 3 7   d)  1 5 3 7 6 9 2 4 8 1  e)     7 1 2 9 8 4 6 2 3 1  f)      7 3 5 4 2 8 1 9 6 1    3.", " Preciza\u021bi ce valoare se afi\u0219eaz\u0103 \u00een urma execu\u021biei urm\u0103torului program dac\u0103 pentru n se  cite\u0219te valoarea 20.", " Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int main()  {    int a[51][51];    int i,j,n, s=0;    cin>>n;    for(i=1;i<=n;i++)  #include<stdio.h>  void main()  {    int a[51][51];    int i,j,n, s=0;    scanf(\"%d\", &n);    for(i=1;i<=n;i++)     for(j=1;j<=n;j++)  var a:array[1..50,1..50]        of integer;      i,j,n,s: integer;   begin   s:=0;   readln(n);  for i:=1 to n do"], "page_sentence_count_spacy": 10}, {"page_number": 18, "page_char_count": 2325, "page_word_count": 588, "page_sentence_count_raw": 7, "page_token_count": 581.25, "text": "18       for(j=1;j<=n;j++)      a[i][j]=i-j;    for(i=1;i<=n;i++)     for(j=1;j<=n;j++)      if(i+1!=j)       s+=a[i][j];    cout<<s;  }      a[i][j]=i-j;    for(i=1;i<=n;i++)     for(j=1;j<=n;j++)      if(i+1!=j)        s+=a[i][j];    printf(\"%d \", s);  }    for j:=1 to n do  a[i,j]:=i-j;  for i:=1 to n do    for j:=1 to n do        if  i+1<> j then  s:=s+ a[i,j];  write(s)  end.  a)  -19  b)   0  c)   9  d)  19  e)  20  f)  190    4.  Urm\u0103toarea secven\u021b\u0103 de program folose\u0219te metoda c\u0103ut\u0103rii binare pentru a verifica dac\u0103  valoarea x se afl\u0103 printre cele 10 elemente ale tabloului unidimensional v (cu indicii de la  1 la 10), dar produce eroare de execu\u021bie pentru mai multe seturi de date.   Limbajul C++/ Limbajul C  Limbajul Pascal  i=1; j=10;  do {        k=(i+j)/2;        if(v[k]<x) i=k;         else j=k;      } while(v[k]!=x&&i<j);  if(v[k]==x)cout<<\"EXISTA\";              | printf(\"EXISTA\");  else cout<<\"NU EXISTA\";       | printf(\"NU EXISTA\");  i:=1; j:=10;  repeat    k:=(i+j)div 2;    if v[k]<x then i:=k    else j:=k  until (v[k]=x)or(i>=j);  if v[k]=x then write('EXISTA')  else write('NU EXISTA');  Preciza\u021bi pentru care dintre seturile de date de intrare (elementele tabloului unidimensional v  \u0219i valoarea lui x) secven\u021ba dat\u0103 nu produce eroare de execu\u021bie.   a)  v=(1,2,3,4,5,6,7,8,9,10)\u0219i x>10  b)  v=(2,4,6,8,10,12,14,16,18,20) \u0219i x>20  c)  v=(2,2,2,2,2,2,2,2,2,2) \u0219i x>2  d)  v=(2,4,6,8,10,12,14,16,18,20)\u0219i 2<x<20, x num\u0103r par  e)  v=(1,2,5,4,3,6,7,8,9,10)\u0219i x=4   f)  v=(2,4,6,8,10,12,14,16,18,20)\u0219i 2<x<20, x num\u0103r impar    5.  Preciza\u021bi c\u00e2te elemente divizibile cu 10, se vor afi\u0219a \u00een urma execut\u0103rii programului  urm\u0103tor.  Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int f(int &y, int x)    {     y=y/10+x;     return x+y;    }  int main( )  {    int x=101,y=10;    cout<<f(x,y)<<\" \";    cout<<x<<\" \"<<y<<\"  \";    cout<<f(x,y);  }  #include<stdio.h>  int f(int *y, int x)    {     *y=*y/10+x;     return x+*y;    }  void main( )  {    int x=101,y=10;    printf(\"%d \",  f(&x,y));    printf(\"%d %d \", x,  y);    printf(\"%d \",  f(&x,y));  }  var x,y:integer;  function f(var  y:integer;         x:integer):integer;   begin    y:=y div 10 + 10;    f:=x + y  end;  begin    x:=101; y:=10;    write(f(x,y),' ');    write(x,' ',y,' ');    write(f(x,y))  end.", "sentences": ["18       for(j=1;j<=n;j++)      a[i][j]=i-j;    for(i=1;i<=n;i++)     for(j=1;j<=n;j++)      if(i+1!=j)       s+=a[i][j];    cout<<s;  }      a[i][j]=i-j;    for(i=1;i<=n;i++)     for(j=1;j<=n;j++)      if(i+1!=j)        s+=a[i][j];    printf(\"%d \", s);  }    for j:=1 to n do  a[i,j]:=i-j;  for i:=1 to n do    for j:=1 to n do        if  i+1<> j then  s:=s+ a[i,j];  write(s)  end.", " a)  -19  b)   0  c)   9  d)  19  e)  20  f)  190    4.", " Urm\u0103toarea secven\u021b\u0103 de program folose\u0219te metoda c\u0103ut\u0103rii binare pentru a verifica dac\u0103  valoarea x se afl\u0103 printre cele 10 elemente ale tabloului unidimensional v (cu indicii de la  1 la 10), dar produce eroare de execu\u021bie pentru mai multe seturi de date.", "  Limbajul C++/ Limbajul C  Limbajul Pascal  i=1; j=10;  do {        k=(i+j)/2;        if(v[k]<x) i=k;         else j=k;      } while(v[k]!=x&&i<j);  if(v[k]==x)cout<<\"EXISTA\";              | printf(\"EXISTA\");  else cout<<\"NU EXISTA\";       | printf(\"NU EXISTA\");  i:=1; j:=10;  repeat    k:=(i+j)div 2;    if v[k]<x then i:=k    else j:=k  until (v[k]=x)or(i>=j);  if v[k]=x then write('EXISTA')  else write('NU EXISTA');  Preciza\u021bi pentru care dintre seturile de date de intrare (elementele tabloului unidimensional v  \u0219i valoarea lui x) secven\u021ba dat\u0103 nu produce eroare de execu\u021bie.", "  a)  v=(1,2,3,4,5,6,7,8,9,10)\u0219i x>10  b)  v=(2,4,6,8,10,12,14,16,18,20) \u0219i x>20  c)  v=(2,2,2,2,2,2,2,2,2,2) \u0219i x>2  d)  v=(2,4,6,8,10,12,14,16,18,20)\u0219i 2<x<20, x num\u0103r par  e)  v=(1,2,5,4,3,6,7,8,9,10)\u0219i x=4   f)  v=(2,4,6,8,10,12,14,16,18,20)\u0219i 2<x<20, x num\u0103r impar    5.", " Preciza\u021bi c\u00e2te elemente divizibile cu 10, se vor afi\u0219a \u00een urma execut\u0103rii programului  urm\u0103tor.", " Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int f(int &y, int x)    {     y=y/10+x;     return x+y;    }  int main( )  {    int x=101,y=10;    cout<<f(x,y)<<\" \";    cout<<x<<\" \"<<y<<\"  \";    cout<<f(x,y);  }  #include<stdio.h>  int f(int *y, int x)    {     *y=*y/10+x;     return x+*y;    }  void main( )  {    int x=101,y=10;    printf(\"%d \",  f(&x,y));    printf(\"%d %d \", x,  y);    printf(\"%d \",  f(&x,y));  }  var x,y:integer;  function f(var  y:integer;         x:integer):integer;   begin    y:=y div 10 + 10;    f:=x + y  end;  begin    x:=101; y:=10;    write(f(x,y),' ');    write(x,' ',y,' ');    write(f(x,y))  end."], "page_sentence_count_spacy": 7}, {"page_number": 19, "page_char_count": 1672, "page_word_count": 538, "page_sentence_count_raw": 3, "page_token_count": 418.0, "text": "19    a)  0  b)  1  c)  2   d)  3  e)  4  f)  5    6.  Se consider\u0103 func\u021bia:  Limbajul C++/ Limbajul C  Limbajul Pascal  unsigned f(unsigned x, unsigned  y)  {      if(x==1)return y;      if(x%2==0)return f(x/2,y*2);      return y+f(x/2,y*2);  }    function f(x, y:word):word;  begin   if x=1 then f:=y   else    if  x mod 2=0 then f:=f(x div 2,  y*2)      else f:=y + f(x div 2, y*2)  end;  Preciza\u021bi care dintre func\u021biile urm\u0103toare nu este echivalent\u0103 cu func\u021bia dat\u0103.  Limbajul C++/ Limbajul C  Limbajul Pascal  a) unsigned f(unsigned x, unsigned y)  {      if(x==0) return 0;      if(x%2==0) return 2*f(x/2,y);      return y+f(x-1,y);  }  a) function f(x,y:word):word;  begin    if x=0 then f:=0   else      if x mod 2 = 0 then            f:=2*f(x div 2, y)      else f:=y + f(x-1, y)  end;  b) unsigned f(unsigned x, unsigned y)  {      if(x==0) return y;      if(x%2==0) return f(x/2,y);      return y+f(x-1,y);  }  b) function f(x,y:word):word;    begin      if x=0 then f:=y      else       if x mod 2 = 0 then            f:=f(x div 2, y)       else f:=y + f(x-1, y)    end;  c) unsigned f(unsigned x, unsigned y)  {      return y*x;  }  c) function f(x,y:word):word;    begin        f:=y*x    end;  d) unsigned f(unsigned x, unsigned y)  {      if(x==0) return 0;      return y+f(x-1,y);  }  d) function f(x,y:word):word;    begin     if x=0 then f:=0     else f:=y+f(x-1, y)    end;  e) unsigned f(unsigned x, unsigned y)     {      unsigned s=0;      while(x>0)      {          s=s+y;          x--;      }      return s;  }  e) function f(x,y:word):word;   var s:word;   begin     s:=0;     while x>0 do      begin       s:=s+y; x:=x-1      end;     f:=s   end;", "sentences": ["19    a)  0  b)  1  c)  2   d)  3  e)  4  f)  5    6.", " Se consider\u0103 func\u021bia:  Limbajul C++/ Limbajul C  Limbajul Pascal  unsigned f(unsigned x, unsigned  y)  {      if(x==1)return y;      if(x%2==0)return f(x/2,y*2);      return y+f(x/2,y*2);  }    function f(x, y:word):word;  begin   if x=1 then f:=y   else    if  x mod 2=0 then f:=f(x div 2,  y*2)      else f:=y + f(x div 2, y*2)  end;  Preciza\u021bi care dintre func\u021biile urm\u0103toare nu este echivalent\u0103 cu func\u021bia dat\u0103.", " Limbajul C++/ Limbajul C  Limbajul Pascal  a) unsigned f(unsigned x, unsigned y)  {      if(x==0) return 0;      if(x%2==0) return 2*f(x/2,y);      return y+f(x-1,y);  }  a) function f(x,y:word):word;  begin    if x=0 then f:=0   else      if x mod 2 = 0 then            f:=2*f(x div 2, y)      else f:=y + f(x-1, y)  end;  b) unsigned f(unsigned x, unsigned y)  {      if(x==0) return y;      if(x%2==0) return f(x/2,y);      return y+f(x-1,y);  }  b) function f(x,y:word):word;    begin      if x=0 then f:=y      else       if x mod 2 = 0 then            f:=f(x div 2, y)       else f:=y + f(x-1, y)    end;  c) unsigned f(unsigned x, unsigned y)  {      return y*x;  }  c) function f(x,y:word):word;    begin        f:=y*x    end;  d) unsigned f(unsigned x, unsigned y)  {      if(x==0) return 0;      return y+f(x-1,y);  }  d) function f(x,y:word):word;    begin     if x=0 then f:=0     else f:=y+f(x-1, y)    end;  e) unsigned f(unsigned x, unsigned y)     {      unsigned s=0;      while(x>0)      {          s=s+y;          x--;      }      return s;  }  e) function f(x,y:word):word;   var s:word;   begin     s:=0;     while x>0 do      begin       s:=s+y; x:=x-1      end;     f:=s   end;"], "page_sentence_count_spacy": 3}, {"page_number": 20, "page_char_count": 2313, "page_word_count": 572, "page_sentence_count_raw": 9, "page_token_count": 578.25, "text": "20    f) unsigned f(unsigned x, unsigned y)    {      unsigned i,s=0;      for(i=1;i<=y;i++)s=s+x;      return s;  }  f) function f(x,y:word):word;    var i,s:word;    begin      s:=0;      for i:=1 to y do s:=s+x;      f:=s    end;    7.  Pentru implementarea unei stive se define\u0219te structura urm\u0103toare, \u00een care c\u00e2mpul v este un  tablou unidemensional \u00een care sunt memorate valorile din stiv\u0103, iar c\u00e2mpul k reprezint\u0103 v\u00e2rful  stivei:  Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct   {     int k ; int v[100];  }stiva;  type stiva=record     k: integer;     v: array[0..99] of integer;  end;  Variabila s este de tipul stiva, iar x este un num\u0103r intreg.  Preciza\u021bi care dintre urm\u0103toarele secven\u021be determin\u0103 ad\u0103ugarea corect\u0103 a valorii x \u00een stiv\u0103.  Limbajul C++/ Limbajul C  Limbajul Pascal  a)     if (s.k<99) s.v[++s.k]=x;    b)     k++;v[k]=x;    c)      if (s.k<99) s.v[s.k]=x;    d)      k++; s.v[s.k]=x;      e)      s.v[s.k+1]:=x;    f)      x:=s.v[s.k];  a)     if s.k<99 then         begin         s.v[s.k+1]:=x;         inc(s.k)       end;  b)     inc(k); v[k]:=x;  c)     if s.k<99 then s.v[s.k]:=x;  d)     with s do begin            k:=k+1; v[k]:=x         end;  e)     s.v[s.k+1]:=x;    f)     x:=s.v[s.k];    8.  Se consider\u0103 definit un subprogram care determin\u0103 \u0219tergerea tuturor apari\u021biilor unui caracter  c din \u0219irul de caractere s. Antetul subprogramului este:      (C++/C)   void del (char s[255], char c);   (Pascal)  procedure del (var s:string; c:character);  Preciza\u021bi ce secven\u021b\u0103 poate fi utilizat\u0103 pentru \u0219tergerea tuturor caracterelor ce reprezint\u0103 cifre  din \u0219irul s. (s este un \u0219ir de caractere de lungime maxim 255, iar i este o variabil\u0103 de tip  caracter)  Limbajul C++/ Limbajul C  Limbajul Pascal  a)  del(s,\"0123456789\");  b)  del (s,i);  c)  for(i='0';i<='9';i++)del(i,s);  d)  for(i=0;i<=9;i++)del(s,i);  e)  for(i='0';i<='10';i++)del(s,i);  f)  for(i='0';i<='9';i++)del(s,i);  a) del(s, '0123456789');  b) del(s,i);  c) for i:='0' to '9' do del(i,s);  d) for i:= 0 to 9 do del(s,i);  e) for i:='0' to '10' do del(s,i);  f) for i:='0' to '9' do del(s,i);    9.  Variabila n reprezint\u0103 un num\u0103r natural cu cel mult 3 cifre. Preciza\u021bi pentru c\u00e2te valori ale  variabilei n expresia:   (C++/C)    n/100+n%100/10+n%10  (Pascal)   n div 100 + n mod 100 div 10 + n mod 10", "sentences": ["20    f) unsigned f(unsigned x, unsigned y)    {      unsigned i,s=0;      for(i=1;i<=y;i++)s=s+x;      return s;  }  f) function f(x,y:word):word;    var i,s:word;    begin      s:=0;      for i:=1 to y do s:=s+x;      f:=s    end;    7.", " Pentru implementarea unei stive se define\u0219te structura urm\u0103toare, \u00een care c\u00e2mpul v este un  tablou unidemensional \u00een care sunt memorate valorile din stiv\u0103, iar c\u00e2mpul k reprezint\u0103 v\u00e2rful  stivei:  Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct   {     int k ; int v[100];  }stiva;  type stiva=record     k: integer;     v: array[0..99] of integer;  end;  Variabila s este de tipul stiva, iar x este un num\u0103r intreg.", " Preciza\u021bi care dintre urm\u0103toarele secven\u021be determin\u0103 ad\u0103ugarea corect\u0103 a valorii x \u00een stiv\u0103.", " Limbajul C++/ Limbajul C  Limbajul Pascal  a)     if (s.k<99) s.v[++s.k]=x;    b)     k++;v[k]=x;    c)      if (s.k<99) s.v[s.k]=x;    d)      k++; s.v[s.k]=x;      e)      s.v[s.k+1]:=x;    f)      x:=s.v[s.k];  a)     if s.k<99 then         begin         s.v[s.k+1]:=x;         inc(s.k)       end;  b)     inc(k); v[k]:=x;  c)     if s.k<99 then s.v[s.k]:=x;  d)     with s do begin            k:=k+1; v[k]:=x         end;  e)     s.v[s.k+1]:=x;    f)     x:=s.v[s.k];    8.", " Se consider\u0103 definit un subprogram care determin\u0103 \u0219tergerea tuturor apari\u021biilor unui caracter  c din \u0219irul de caractere s. Antetul subprogramului este:      (C++/C)   void del (char s[255], char c);   (Pascal)  procedure del (var s:string; c:character);  Preciza\u021bi ce secven\u021b\u0103 poate fi utilizat\u0103 pentru \u0219tergerea tuturor caracterelor ce reprezint\u0103 cifre  din \u0219irul s. (s este un \u0219ir de caractere de lungime maxim 255, iar i este o variabil\u0103 de tip  caracter)  Limbajul C++/ Limbajul C  Limbajul Pascal  a)  del(s,\"0123456789\");  b)  del (s,i);  c)  for(i='0';i<='9';i++)del(i,s);  d)  for(i=0;i<=9;i++)del(s,i);  e)  for(i='0';i<='10';i++)del(s,i);  f)  for(i='0';i<='9';i++)del(s,i);  a) del(s, '0123456789');  b) del(s,i);  c) for i:='0' to '9' do del(i,s);  d) for i:= 0 to 9 do del(s,i);  e) for i:='0' to '10' do del(s,i);  f) for i:='0' to '9' do del(s,i);    9.", " Variabila n reprezint\u0103 un num\u0103r natural cu cel mult 3 cifre.", "Preciza\u021bi pentru c\u00e2te valori ale  variabilei n expresia:   (C++/C)    n/100+n%100/10+n%10  (Pascal)   n div 100 + n mod 100 div 10 + n mod 10"], "page_sentence_count_spacy": 7}, {"page_number": 21, "page_char_count": 2083, "page_word_count": 433, "page_sentence_count_raw": 16, "page_token_count": 520.75, "text": "21    are valoarea 9.  a) 9  b) 10  c) 45  d) 54  e)  55  f) 100    10.   Unei expresii algebrice i se asociaz\u0103 un arbore \u00een care orice  nod care nu este frunz\u0103 are ca valoare un operator \u0219i are exact  doi fii, iar frunzele sunt operanzi. Cu c\u00e2t prioritatea unui  operator este mai mare, cu at\u00e2t nivelul pe care se afl\u0103 este mai  mare. Parantezele influen\u021beaz\u0103 prioritatea operatorilor, dar nu  apar \u00een arborele asociat.  Indica\u021bi expresia corespunz\u0103toare arborelui de mai jos.    Exemple:  a*(b+c)    a*b+c    a)   a+b*c+d*e  b)    a+b*(c+d*e)  c)  (a+b)*(c+d*e)  d)  (a+b)*c+d*e  e)    a+b*(c+d)*e  f)  (a+b)*c+d*e    11.  Se consider\u0103 un tablou bidimensional  A cu n linii \u0219i n coloane (n \u2013 num\u0103r natural, n>1).  Folosind rezolvarea optim\u0103 pentru fiecare caz, preciza\u021bi care dintre problemele urm\u0103toare se  poate rezolva printr-un algoritm de complexitate minim\u0103.  a)  Determinarea num\u0103rului de valori nule din A  b)  Determinarea sumei elementelor de pe diagonala principal\u0103  c)  Determinarea rangului matricei A  d) Ordonarea cresc\u0103toare a elementelor de pe prima linie a tabloului prin apelarea celei mai  eficiente metode de sortare   e) Determinarea num\u0103rului de valori aflate sub diagonala principal\u0103  f) Interschimbarea a dou\u0103 coloane ale tabloului      12.  Se consider\u0103 un graf orientat tare conex cu n noduri, numerotate 1, 2, 3, ..., n.  Pentru determinarea drumurilor de lungime minim\u0103 de la nodul 1 la celelalte noduri, s-a  construit vectorul t \u00een care t[i]=k dac\u0103 (k,i) este ultimul arc al drumului minim de la  nodul 1 la nodul i. Preciza\u021bi instruc\u021biunea care poate \u00eenlocui punctele de suspensie astfel  \u00eenc\u00e2t apelul drum(t,n) s\u0103 determine afi\u0219area drumului de lungime minim\u0103 de la nodul 1  la nodul n.  Limbajul C++/ Limbajul C  Limbajul Pascal  void drum(int t[ ], int i)   {    if (i!=1) .......    cout<<i<<\" \";  }  type vector=array[1..100] of integer;   procedure drum (t:vector; i:integer);  begin    if i<>1 then ......   write(i, '  ' )  end;  a)  drum(t,n);  b)  drum(t[i],i);  c)  drum(t,t[i]);  d)  drum(t,i);  e)  drum(t,1);  f)   drum(t[i],t);    13.", "sentences": ["21    are valoarea 9.", " a) 9  b) 10  c) 45  d) 54  e)  55  f) 100    10.", "  Unei expresii algebrice i se asociaz\u0103 un arbore \u00een care orice  nod care nu este frunz\u0103 are ca valoare un operator \u0219i are exact  doi fii, iar frunzele sunt operanzi.", "Cu c\u00e2t prioritatea unui  operator este mai mare, cu at\u00e2t nivelul pe care se afl\u0103 este mai  mare.", "Parantezele influen\u021beaz\u0103 prioritatea operatorilor, dar nu  apar \u00een arborele asociat.", " Indica\u021bi expresia corespunz\u0103toare arborelui de mai jos.", "   Exemple:  a*(b+c)    a*b+c    a)   a+b*c+d*e  b)    a+b*(c+d*e)  c)  (a+b)*(c+d*e)  d)  (a+b)*c+d*e  e)    a+b*(c+d)*e  f)  (a+b)*c+d*e    11.", " Se consider\u0103 un tablou bidimensional  A cu n linii \u0219i n coloane (n \u2013 num\u0103r natural, n>1).", " Folosind rezolvarea optim\u0103 pentru fiecare caz, preciza\u021bi care dintre problemele urm\u0103toare se  poate rezolva printr-un algoritm de complexitate minim\u0103.", " a)  Determinarea num\u0103rului de valori nule din A  b)  Determinarea sumei elementelor de pe diagonala principal\u0103  c)  Determinarea rangului matricei A  d) Ordonarea cresc\u0103toare a elementelor de pe prima linie a tabloului prin apelarea celei mai  eficiente metode de sortare   e) Determinarea num\u0103rului de valori aflate sub diagonala principal\u0103  f) Interschimbarea a dou\u0103 coloane ale tabloului      12.", " Se consider\u0103 un graf orientat tare conex cu n noduri, numerotate 1, 2, 3, ..., n.  Pentru determinarea drumurilor de lungime minim\u0103 de la nodul 1 la celelalte noduri, s-a  construit vectorul t \u00een care t[i]=k dac\u0103 (k,i) este ultimul arc al drumului minim de la  nodul 1 la nodul i. Preciza\u021bi instruc\u021biunea care poate \u00eenlocui punctele de suspensie astfel  \u00eenc\u00e2t apelul drum(t,n) s\u0103 determine afi\u0219area drumului de lungime minim\u0103 de la nodul 1  la nodul n.  Limbajul C++/ Limbajul C  Limbajul Pascal  void drum(int t[ ], int i)   {    if (i!=1) .......    cout<<i<<\" \";  }  type vector=array[1..100] of integer;   procedure drum (t:vector; i:integer);  begin    if i<>1 then ......   write(i, '  ' )  end;  a)  drum(t,n);  b)  drum(t[i],i);  c)  drum(t,t[i]);  d)  drum(t,i);  e)  drum(t,1);  f)   drum(t[i],t);    13."], "page_sentence_count_spacy": 11}, {"page_number": 22, "page_char_count": 1056, "page_word_count": 250, "page_sentence_count_raw": 16, "page_token_count": 264.0, "text": "22    V\u00e2rful  1  2  3  4  Grad exterior  2  0  2  x  Grad interior  0  2  y  1  Preciza\u021bi care din urm\u0103toarele arce apar\u0163ine grafului orientat cu 4 v\u00e2rfuri, av\u00e2nd gradele din  tabelul al\u0103turat (x,y\u2208N).  a)  (1,2)  b)  (2,1)  c)  (2,3)  d)  (2,4)  e)  (3,1)  f)  (4,1)    14.  Preciza\u021bi care este num\u0103rul ciclurilor hamiltoniene disticte \u00eentr-un graf complet cu 5 noduri.  (Dou\u0103 cicluri sunt distincte dac\u0103 difer\u0103 prin cel pu\u021bin o muchie.)  a)   5  b)   4!/2  c)   4!  d)   4*4!  e)  5!  f)  54    15.  Preciza\u021bi c\u00e2te dintre afirma\u021biile urm\u0103toare referitoare la grafuri neorientate sunt adev\u0103rate.  1. Dac\u0103 gradul oric\u0103rui nod este un num\u0103r impar, atunci graful trebuie s\u0103 aib\u0103 num\u0103r par  de noduri.  2. Un ciclu elementar este un caz particular de  lan\u0163 elementar.  3. Num\u0103rul muchiilor grafului nu poate fi mai mic dec\u00e2t num\u0103rul nodurilor.  4. Lungimea unui lan\u0163 poate fi mai mare dec\u00e2t num\u0103rul de noduri al grafului.  5. Num\u0103rul valorilor 1 din matricea de adiacen\u021b\u0103 asociat\u0103 este egal cu dublul num\u0103rului  de muchii.  a) 0  b) 1  c) 2  d)  3  e) 4  f) 5", "sentences": ["22    V\u00e2rful  1  2  3  4  Grad exterior  2  0  2  x  Grad interior  0  2  y  1  Preciza\u021bi care din urm\u0103toarele arce apar\u0163ine grafului orientat cu 4 v\u00e2rfuri, av\u00e2nd gradele din  tabelul al\u0103turat (x,y\u2208N).", " a)  (1,2)  b)  (2,1)  c)  (2,3)  d)  (2,4)  e)  (3,1)  f)  (4,1)    14.", " Preciza\u021bi care este num\u0103rul ciclurilor hamiltoniene disticte \u00eentr-un graf complet cu 5 noduri.", " (Dou\u0103 cicluri sunt distincte dac\u0103 difer\u0103 prin cel pu\u021bin o muchie.)", " a)   5  b)   4!/2  c)   4!", " d)   4*4!", " e)  5!", " f)  54    15.", " Preciza\u021bi c\u00e2te dintre afirma\u021biile urm\u0103toare referitoare la grafuri neorientate sunt adev\u0103rate.", " 1.", "Dac\u0103 gradul oric\u0103rui nod este un num\u0103r impar, atunci graful trebuie s\u0103 aib\u0103 num\u0103r par  de noduri.", " 2.", "Un ciclu elementar este un caz particular de  lan\u0163 elementar.", " 3.", "Num\u0103rul muchiilor grafului nu poate fi mai mic dec\u00e2t num\u0103rul nodurilor.", " 4.", "Lungimea unui lan\u0163 poate fi mai mare dec\u00e2t num\u0103rul de noduri al grafului.", " 5.", "Num\u0103rul valorilor 1 din matricea de adiacen\u021b\u0103 asociat\u0103 este egal cu dublul num\u0103rului  de muchii.", " a) 0  b) 1  c) 2  d)  3  e) 4  f) 5"], "page_sentence_count_spacy": 20}, {"page_number": 23, "page_char_count": 2299, "page_word_count": 581, "page_sentence_count_raw": 21, "page_token_count": 574.75, "text": "23    Varianta 4    1.  Variabila n reprezint\u0103 un num\u0103r natural cu exact dou\u0103 cifre. Preciza\u021bi c\u00e2te dintre expresiile  urm\u0103toare au valoarea 1/true dac\u0103 \u0219i numai dac\u0103 cifrele lui n au aceea\u0219i paritate.  Limbajul C++/ Limbajul C  Limbajul Pascal  1.  (n/10\u2013n%10)%2==0  2.  n/10%2==n%2  3.  n/10==n%10  4.  (n/10+n%10*10)%2==n%2  5.  n/2==n%2  1.  (n div 10 \u2013 n mod 10) mod 2 = 0  2.  n div 10 mod 2 = n mod 2  3.  n div 10 = n mod 10  4.  (n div 10 + n mod 10 *10) mod 2 = n mod 2  5.  n div 2 = n mod 2  a)   0  b)   1  c)   2  d)   3  e)   4  f)   5    2 .  Pentru implementarea ecua\u021biei unei drepte de forma ax+by+c=0 (unde a,b,c\u2208R), se  define\u0219te structura:  Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct       {float a, b, c;}dreapta;  type dreapta=record            a, b, c : real;          end;  Dac\u0103 d1 \u0219i d2 sunt dou\u0103 variabile de tipul dreapta, preciza\u021bi care dintre urm\u0103toarele expresii  verific\u0103 dac\u0103 d1 \u0219i d2 sunt paralele.  Limbajul C++/ Limbajul C  Limbajul Pascal  a)  d1 || d2  b)  d1.a==d2.a && d1.b==d2.b  c)  a.d1/a.d2==b.d1/b.d2  d)  d1.a/d2.a==d1.b/d2.b  e)  d1.a==0 && d2.a==0  f)  d1.a*d2.b-d1.b*d2.a==0  a)  d1 = d2  b)  (d1.a=d2.a)and(d1.b = d2.b)  c)  a.d1/a.d2 = b.d1/b.d2  d)  d1.a/d2.a=d1.b/d2.b  e)  (d1.a=0) and (d2.a=0)  f)  d1.a*d2.b-d1.b*d2.a=0    3 .  Func\u0163ia f prime\u015fte ca parametri dou\u0103 valori reale \u015fi returneaz\u0103 cea mai mare dintre cele dou\u0103  valori. Antetul func\u021biei este:    (Limbajul C++/C)    float f(float x, float y);   (Limbajul Pascal)         function f( x, y: real):real;  Preciza\u021bi care dintre urm\u0103toarele expresii reprezint\u0103 suma celor mai mici dou\u0103 valori dintre  numerele reale a, b \u015fi c.  a)  a+b+c-f(a,b)  b)  a+b+c-f(a,b)-f(b,c)  c)  a+2*b+c-f(a,b)-f(b,c)  d)  a+b+c-f(a,b,c)  e)  a+b+c-f(a,f(c,b))  f)  a+b+c-f(f(a,b),f(b,a))    4 .  Preciza\u021bi care sunt valorile afi\u0219ate \u00een urma execu\u021biei urm\u0103torului program.  Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int a,b;  void f(int a, int &b)  {     if(a>0)      {        a++; b--; f(b,a);      }  #include<stdio.h>  int a,b;  void f(int a, int *b)  {   if(a>0)    {      a++; (*b)--;      f(*b,&a);    }  var a,b:integer;  procedure f(a:integer;    var b:integer);  begin    if a>0 then      begin        a:=a+1; b:=b-1;        f(b,a)      end;", "sentences": ["23    Varianta 4    1.", " Variabila n reprezint\u0103 un num\u0103r natural cu exact dou\u0103 cifre.", "Preciza\u021bi c\u00e2te dintre expresiile  urm\u0103toare au valoarea 1/true dac\u0103 \u0219i numai dac\u0103 cifrele lui n au aceea\u0219i paritate.", " Limbajul C++/ Limbajul C  Limbajul Pascal  1.", " (n/10\u2013n%10)%2==0  2.", " n/10%2==n%2  3.", " n/10==n%10  4.", " (n/10+n%10*10)%2==n%2  5.", " n/2==n%2  1.", " (n div 10 \u2013 n mod 10) mod 2 = 0  2.", " n div 10 mod 2 = n mod 2  3.", " n div 10 = n mod 10  4.", " (n div 10 + n mod 10 *10) mod 2 = n mod 2  5.", " n div 2 = n mod 2  a)   0  b)   1  c)   2  d)   3  e)   4  f)   5    2 .", " Pentru implementarea ecua\u021biei unei drepte de forma ax+by+c=0 (unde a,b,c\u2208R), se  define\u0219te structura:  Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct       {float a, b, c;}dreapta;  type dreapta=record            a, b, c : real;          end;  Dac\u0103 d1 \u0219i d2 sunt dou\u0103 variabile de tipul dreapta, preciza\u021bi care dintre urm\u0103toarele expresii  verific\u0103 dac\u0103 d1 \u0219i d2 sunt paralele.", " Limbajul C++/ Limbajul C  Limbajul Pascal  a)  d1 || d2  b)  d1.a==d2.a && d1.b==d2.b  c)  a.d1/a.d2==b.d1/b.d2  d)  d1.a/d2.a==d1.b/d2.b  e)  d1.a==0 && d2.a==0  f)  d1.a*d2.b-d1.b*d2.a==0  a)  d1 = d2  b)  (d1.a=d2.a)and(d1.b = d2.b)  c)  a.d1/a.d2 = b.d1/b.d2  d)  d1.a/d2.a=d1.b/d2.b  e)  (d1.a=0) and (d2.a=0)  f)  d1.a*d2.b-d1.b*d2.a=0    3 .", " Func\u0163ia f prime\u015fte ca parametri dou\u0103 valori reale \u015fi returneaz\u0103 cea mai mare dintre cele dou\u0103  valori.", "Antetul func\u021biei este:    (Limbajul C++/C)    float f(float x, float y);   (Limbajul Pascal)         function f( x, y: real):real;  Preciza\u021bi care dintre urm\u0103toarele expresii reprezint\u0103 suma celor mai mici dou\u0103 valori dintre  numerele reale a, b \u015fi c.  a)  a+b+c-f(a,b)  b)  a+b+c-f(a,b)-f(b,c)  c)  a+2*b+c-f(a,b)-f(b,c)  d)  a+b+c-f(a,b,c)  e)  a+b+c-f(a,f(c,b))  f)  a+b+c-f(f(a,b),f(b,a))    4 .", " Preciza\u021bi care sunt valorile afi\u0219ate \u00een urma execu\u021biei urm\u0103torului program.", " Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int a,b;  void f(int a, int &b)  {     if(a>0)      {        a++; b--; f(b,a);      }  #include<stdio.h>  int a,b;  void f(int a, int *b)  {   if(a>0)    {      a++; (*b)--;      f(*b,&a);    }  var a,b:integer;  procedure f(a:integer;    var b:integer);  begin    if a>0 then      begin        a:=a+1; b:=b-1;        f(b,a)      end;"], "page_sentence_count_spacy": 20}, {"page_number": 24, "page_char_count": 1863, "page_word_count": 573, "page_sentence_count_raw": 7, "page_token_count": 465.75, "text": "24       cout<<a<<\" \"<<b<<\" \";  }  int main()  {   a=0; b=1;      f(b,a);      cout<<a<<\" \"<<b;  }   printf(\"%d %d  \",a,*b);  }  void main ( )  {     a=0; b=1;     f(b,&a);     printf(\"%d  %d\",a,b);  }    write(a,' ',b,' ')  end;  begin     a:=0; b:=1;     f(b,a);     write(a,' ',b,' ')  end.  a)  -1 2 2 -1 -1 1  b)  0 1 0 1  c)  Ciclare infinit\u0103  d)  -1 2 2 -1 0 1  e)  0 2 0 -1 0 1  f)  -1 0 1 -1 1 1    5 .  \u00cen secven\u021ba urm\u0103toare variabilele n \u0219i m au ca valori numere naturale.  Limbajul C++/ Limbajul C  Limbajul Pascal  n=42015; m=0;  while(n>0)   {      m=m*100+n/10%10*10+n%10;      n/=100;    }  n:=42015; m:=0;   while n>0 do    begin     m:=m*100+n div 10 mod 10*10+n mod 10;     n:=n div 100;    end;   Dup\u0103 rularea secven\u021bei, valoarea variabilei m este:   a)  15024  b)  15204  c)  24051  d)  51024  e) 152004 f)  152400    6 .  Se consider\u0103 urm\u0103torul program:  Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int main( )  {   int n, cn, x=0,p=1;   cin>>n;   cn=n;   while(n)   {    if (n%10>x)x=n%10;    n/=10;   }   x++;   while(cn)    {     n=n+cn%10*p;     p*=x;     cn/=10;    }   cout<<n;  }  #include<stdio.h>  void main ( )  {   int n, cn, x=0,p=1;   scanf(\"%d\", &n);   cn=n;   while(n)    {     if (n%10>x)x=n%10;     n/=10;    }   x++;   while(cn)    {     n=n+cn%10*p;     p*=x;     cn/=10;    }   printf(\"%d\", n);  }  var n,cn,x,p : longint;  begin    readln(n);  cn:=n;  x:=0;  p:=1;  while n>0 do  begin   if n mod 10>x then      x:=n mod 10;   n:=n div 10  end;  x:=x+1;  while cn>0 do   begin     n:=n+cn mod 10*p;     p:=p*x;     cn:=cn div 10   end;  write(n)  end.  Preciza\u021bi care este cel mai mic num\u0103r natural format din 5 cifre distincte care poate fi citit ca  dat\u0103 de intrare astfel \u00eenc\u00e2t valoarea afi\u0219at\u0103 s\u0103 fie aceea\u0219i.  a)   10000  b)  10192  c)  10234  d)  10239  e) 10923  f)  12345", "sentences": ["24       cout<<a<<\" \"<<b<<\" \";  }  int main()  {   a=0; b=1;      f(b,a);      cout<<a<<\" \"<<b;  }   printf(\"%d %d  \",a,*b);  }  void main ( )  {     a=0; b=1;     f(b,&a);     printf(\"%d  %d\",a,b);  }    write(a,' ',b,' ')  end;  begin     a:=0; b:=1;     f(b,a);     write(a,' ',b,' ')  end.", " a)  -1 2 2 -1 -1 1  b)  0 1 0 1  c)  Ciclare infinit\u0103  d)  -1 2 2 -1 0 1  e)  0 2 0 -1 0 1  f)  -1 0 1 -1 1 1    5 .", " \u00cen secven\u021ba urm\u0103toare variabilele n \u0219i m au ca valori numere naturale.", " Limbajul C++/ Limbajul C  Limbajul Pascal  n=42015; m=0;  while(n>0)   {      m=m*100+n/10%10*10+n%10;      n/=100;    }  n:=42015; m:=0;   while n>0 do    begin     m:=m*100+n div 10 mod 10*10+n mod 10;     n:=n div 100;    end;   Dup\u0103 rularea secven\u021bei, valoarea variabilei m este:   a)  15024  b)  15204  c)  24051  d)  51024  e) 152004 f)  152400    6 .", " Se consider\u0103 urm\u0103torul program:  Limbajul C++  Limbajul C  Limbajul Pascal  #include<iostream>  using namespace std;  int main( )  {   int n, cn, x=0,p=1;   cin>>n;   cn=n;   while(n)   {    if (n%10>x)x=n%10;    n/=10;   }   x++;   while(cn)    {     n=n+cn%10*p;     p*=x;     cn/=10;    }   cout<<n;  }  #include<stdio.h>  void main ( )  {   int n, cn, x=0,p=1;   scanf(\"%d\", &n);   cn=n;   while(n)    {     if (n%10>x)x=n%10;     n/=10;    }   x++;   while(cn)    {     n=n+cn%10*p;     p*=x;     cn/=10;    }   printf(\"%d\", n);  }  var n,cn,x,p : longint;  begin    readln(n);  cn:=n;  x:=0;  p:=1;  while n>0 do  begin   if n mod 10>x then      x:=n mod 10;   n:=n div 10  end;  x:=x+1;  while cn>0 do   begin     n:=n+cn mod 10*p;     p:=p*x;     cn:=cn div 10   end;  write(n)  end.", " Preciza\u021bi care este cel mai mic num\u0103r natural format din 5 cifre distincte care poate fi citit ca  dat\u0103 de intrare astfel \u00eenc\u00e2t valoarea afi\u0219at\u0103 s\u0103 fie aceea\u0219i.", " a)   10000  b)  10192  c)  10234  d)  10239  e) 10923  f)  12345"], "page_sentence_count_spacy": 7}, {"page_number": 25, "page_char_count": 2433, "page_word_count": 585, "page_sentence_count_raw": 11, "page_token_count": 608.25, "text": "25    7 .  Tabloul bidimensional b (cu liniile \u0219i coloanele numerotate de la 1 la n)  se ob\u021bine din  tabloul bidimensional a prin rotire cu 90o spre dreapta.   De exemplu, dac\u0103 a este:  (1 2 3 4 5 6 7 8 9 )  se ob\u021bine tabloul bidimensional b:  (7 4 1 8 5 2 9 6 3 )   Pentru ob\u021binerea unei transform\u0103ri corecte, secven\u021ba:  Limbajul C++/ Limbajul C  Limbajul Pascal  for(i=1; i<=n; i++)     for(j=1; j<=n; j++) ......;  for i:=1 to n do      for j:=1 to n do ......;  trebuie completat\u0103 cu atribuirea:    Limbajul C++/ Limbajul C  Limbajul Pascal  a)   b[i][j]=a[j][i]  b)   b[i][j]=a[j][n-i+1]  c)   b[i][j]=a[n-j+1][n-i+1]  d)   b[i][j]=a[n-i+1][n-j+1]  e)   b[i][j]=a[n-j+1][i]  f)   b[i][j]=a[n-i+1][j]  a)   b[i][j]:=a[j][i]  b)   b[i,j]:=a[j,n-i+1]  c)   b[i,j]:=a[n-j+1,n-i+1]  d)   b[i,j]:=a[n-i+1,n-j+1]  e)   b[i,j]:=a[n-j+1,i]  f)   b[i,j]:=a[n-i+1,j]    8 .  Variabila x este de tip \u00eentreg \u0219i reprezint\u0103 o cifr\u0103 nenul\u0103. Preciza\u021bi care dintre expresiile  urm\u0103toare este echivalent\u0103 cu expresia:        (Limbajul C++/C)         x == 7 || x == 5          (Limbajul Pascal)         (x=7) or (x=5)   Limbajul C++/ Limbajul C  Limbajul Pascal  a)  35%x==0  b)  x!=7&&x!=5  c)  x>4&&!(x%2==0||x%3==0)  d)  x%2!=0&&x%3!=0  e)  !(x!=7||x!=5)  f)  x>4&&!(x%2==0&&x%3==0)  a)   35 mod x = 0  b)  (x<>7)and(x<>5)  c)  (x>4)and not((x mod 2=0)or(x mod 3=0))  d)  (x mod 2<>0) and (x mod 3<>0)  e)   not((x<>7)or(x<>5))  f)  (x>4)and not((x mod 2=0)and(x mod 3=0)    9 .  Tabloul unidimensional a con\u021bine n numere naturale, ordonate cresc\u0103tor. Se cere afi\u0219area  mesajului DA dac\u0103 \u00een a exist\u0103 dou\u0103 elemente a c\u0103ror diferen\u021b\u0103 este egal\u0103 cu s (num\u0103r natural)  sau a mesajului NU, \u00een caz contrar. Preciza\u021bi condi\u021bia ce trebuie utilizat\u0103 \u00een locul punctelor de  suspensie astfel \u00eenc\u00e2t secven\u021ba urm\u0103toare s\u0103 rezolve corect problema dat\u0103.      Limbajul C++/C  Limbajul Pascal  i = 1; j = 2;  while ( ....... )      {          if (a[j]-a[i]<s) j++;          else i++;      }  if (j <= n) cout<<\"DA\"; |  printf(\"DA\");  else cout<<\"NU\";  | printf(\"DA\");    i:= 1; j:= 2;  while  ....... do   begin          if a[j]-a[i]<s then inc(j)      else inc(i);   end;  if j <=n then write('DA')  else write('NU');  a)   j<n  b)   j<=n&&a[j]-a[i]!=s   c)   j<=n&&a[j]-a[i]==s  d)   a[j]-a[i]!=s  e)   i<=j  f)   i<=n&&a[j]-a[i]==s  a)   j<n  b)   (j<=n)and(a[j]-a[i]<>s)  c)   (j<=n)and(a[j]-a[i]=s)  d)   a[j]-a[i]<>s  e)   i<=j  f)   (i<=n)and(a[j]-a[i]=s)", "sentences": ["25    7 .", " Tabloul bidimensional b (cu liniile \u0219i coloanele numerotate de la 1 la n)  se ob\u021bine din  tabloul bidimensional a prin rotire cu 90o spre dreapta.", "  De exemplu, dac\u0103 a este:  (1 2 3 4 5 6 7 8 9 )  se ob\u021bine tabloul bidimensional b:  (7 4 1 8 5 2 9 6 3 )   Pentru ob\u021binerea unei transform\u0103ri corecte, secven\u021ba:  Limbajul C++/ Limbajul C  Limbajul Pascal  for(i=1; i<=n; i++)     for(j=1; j<=n; j++) ......;  for i:=1 to n do      for j:=1 to n do ......;  trebuie completat\u0103 cu atribuirea:    Limbajul C++/ Limbajul C  Limbajul Pascal  a)   b[i][j]=a[j][i]  b)   b[i][j]=a[j][n-i+1]  c)   b[i][j]=a[n-j+1][n-i+1]  d)   b[i][j]=a[n-i+1][n-j+1]  e)   b[i][j]=a[n-j+1][i]  f)   b[i][j]=a[n-i+1][j]  a)   b[i][j]:=a[j][i]  b)   b[i,j]:=a[j,n-i+1]  c)   b[i,j]:=a[n-j+1,n-i+1]  d)   b[i,j]:=a[n-i+1,n-j+1]  e)   b[i,j]:=a[n-j+1,i]  f)   b[i,j]:=a[n-i+1,j]    8 .", " Variabila x este de tip \u00eentreg \u0219i reprezint\u0103 o cifr\u0103 nenul\u0103.", "Preciza\u021bi care dintre expresiile  urm\u0103toare este echivalent\u0103 cu expresia:        (Limbajul C++/C)         x == 7 || x == 5          (Limbajul Pascal)         (x=7) or (x=5)   Limbajul C++/ Limbajul C  Limbajul Pascal  a)  35%x==0  b)  x!=7&&x!=5  c)  x>4&&!(x%2==0||x%3==0)  d)  x%2!=0&&x%3!=0  e)  !(", "x!=7||x!=5)  f)  x>4&&!(x%2==0&&x%3==0)  a)   35 mod x = 0  b)  (x<>7)and(x<>5)  c)  (x>4)and not((x mod 2=0)or(x mod 3=0))  d)  (x mod 2<>0) and (x mod 3<>0)  e)   not((x<>7)or(x<>5))  f)  (x>4)and not((x mod 2=0)and(x mod 3=0)    9 .", " Tabloul unidimensional a con\u021bine n numere naturale, ordonate cresc\u0103tor.", "Se cere afi\u0219area  mesajului DA dac\u0103 \u00een a exist\u0103 dou\u0103 elemente a c\u0103ror diferen\u021b\u0103 este egal\u0103 cu s (num\u0103r natural)  sau a mesajului NU, \u00een caz contrar.", "Preciza\u021bi condi\u021bia ce trebuie utilizat\u0103 \u00een locul punctelor de  suspensie astfel \u00eenc\u00e2t secven\u021ba urm\u0103toare s\u0103 rezolve corect problema dat\u0103.", "     Limbajul C++/C  Limbajul Pascal  i = 1; j = 2;  while ( ....... )      {          if (a[j]-a[i]<s) j++;          else i++;      }  if (j <= n) cout<<\"DA\"; |  printf(\"DA\");  else cout<<\"NU\";  | printf(\"DA\");    i:= 1; j:= 2;  while  ....... do   begin          if a[j]-a[i]<s then inc(j)      else inc(i);   end;  if j <=n then write('DA')  else write('NU');  a)   j<n  b)   j<=n&&a[j]-a[i]!=s   c)   j<=n&&a[j]-a[i]==s  d)   a[j]-a[i]!=s  e)   i<=j  f)   i<=n&&a[j]-a[i]==s  a)   j<n  b)   (j<=n)and(a[j]-a[i]<>s)  c)   (j<=n)and(a[j]-a[i]=s)  d)   a[j]-a[i]<>s  e)   i<=j  f)   (i<=n)and(a[j]-a[i]=s)"], "page_sentence_count_spacy": 10}, {"page_number": 26, "page_char_count": 2352, "page_word_count": 556, "page_sentence_count_raw": 17, "page_token_count": 588.0, "text": "26      10. Preciza\u021bi care este rolul urm\u0103torului subprogram.  Limbajul C++/ Limbajul C  Limbajul Pascal  void f(char s[],char t[],int k)  {     char aux[255];     strcpy(aux,s+k);     s[k]=0;     strcat(s,t);     strcat(s,aux);  }  procedure f(var s:string;t:string;  k:byte);  var aux:string;  begin      aux:=copy(s,k,255);      delete(s,k,255);      s:=concat(s,t);      s:=concat (s,aux);  end;  a)   \u0218terge ultimele k caractere ale lui s \u0219i concateneaz\u0103 rezultatul cu \u0219irul t  b)   Concateneaz\u0103 \u0219irul s cu rezultatul concaten\u0103rii \u0219irurilor s \u0219i t  c)   Insereaz\u0103 \u0219irul s \u00een \u0219irul t, \u00eencep\u00e2nd cu pozi\u021bia k  d)   Concateneaz\u0103 \u0219irurile s \u0219i t, ob\u021bin\u00e2nd un \u0219ir de lungime k  e)   \u00cenlocuie\u0219te primele k caractere din s cu primele k caractere din t  f)   Insereaz\u0103 \u0219irul t \u00een \u0219irul s, \u00eencep\u00e2nd cu pozi\u021bia k      11. Se consider\u0103 un graf orientat cu 6 noduri, numerotate 1,2,..,6. Arcele grafului sunt de  forma (x,2*x) pentru orice x\u2208{1,2,3} \u0219i de forma (x,x-1) pentru orice  x\u2208{2,3,4,5,6}. Care este num\u0103rul minim de arce ce trebuie ad\u0103ugate astfel \u00eenc\u00e2t graful  s\u0103 fie tare conex?  a)   0  b)   1  c)   2   d)   3  e)  4  f)  5    12. Preciza\u021bi care dintre tablourile urm\u0103toare poate reprezenta vectorul gradelor unui graf  neorientat  conex.  a)   (3,2,1,5,1,1)  b)   (5,1,6,4,5,3)  c)   (1,1,1,1,2,2)  d)   (1,1,1,1,1,6)  e)   (2,1,3,1,0,1)  f)    (1,3,5,2,1,2)     13. Dac\u0103 un graf neorientat conex are n v\u00e2rfuri \u0219i 3n+2 muchii, preciza\u021bi care este valoarea  minim\u0103 pentru n.  a)   16  b)   8  c)   4  d)   2  e)  1  f)  0    14. Pentru un num\u0103r natural nenul n, se construie\u0219te un arbore cu r\u0103d\u0103cin\u0103 astfel: r\u0103d\u0103cina este  numerotat\u0103 n \u0219i orice nod care este numerotat cu o valoare x>1 are ca fii nodurile numerotate  cu divizorii s\u0103i, mai pu\u021bin num\u0103rul \u00eensu\u0219i. Toate frunzele arborelui sunt numerotate cu 1.  Preciza\u021bi c\u00e2te dintre numerele naturale din intervalul [10,20] pot fi alese ca r\u0103d\u0103cin\u0103,  astfel \u00eenc\u00e2t arborele asociat s\u0103 aib\u0103 un num\u0103r maxim de frunze.  a)   1  b)   2  c)   3  d)   4  e)   5  f)   6    15. Un pulover norvegian este frumos dac\u0103 pentru a-l tricota se folosesc cel pu\u021bin 2 \u0219i cel mult 4  culori de l\u00e2n\u0103. Preciza\u021bi c\u00e2te modalit\u0103\u021bi de combinare a culorilor exist\u0103 pentru a tricota un  pulover norvegian frumos, av\u00e2nd la dispozi\u021bie 5 ghemuri de l\u00e2n\u0103 de culori diferite.  a)  5   b)   12  c)   24  d)   25  e)   48  f)  125", "sentences": ["26      10.", "Preciza\u021bi care este rolul urm\u0103torului subprogram.", " Limbajul C++/ Limbajul C  Limbajul Pascal  void f(char s[],char t[],int k)  {     char aux[255];     strcpy(aux,s+k);     s[k]=0;     strcat(s,t);     strcat(s,aux);  }  procedure f(var s:string;t:string;  k:byte);  var aux:string;  begin      aux:=copy(s,k,255);      delete(s,k,255);      s:=concat(s,t);      s:=concat (s,aux);  end;  a)   \u0218terge ultimele k caractere ale lui s \u0219i concateneaz\u0103 rezultatul cu \u0219irul t  b)   Concateneaz\u0103 \u0219irul s cu rezultatul concaten\u0103rii \u0219irurilor s \u0219i t  c)   Insereaz\u0103 \u0219irul s \u00een \u0219irul t, \u00eencep\u00e2nd cu pozi\u021bia k  d)   Concateneaz\u0103 \u0219irurile s \u0219i t, ob\u021bin\u00e2nd un \u0219ir de lungime k  e)   \u00cenlocuie\u0219te primele k caractere din s cu primele k caractere din t  f)   Insereaz\u0103 \u0219irul t \u00een \u0219irul s, \u00eencep\u00e2nd cu pozi\u021bia k      11.", "Se consider\u0103 un graf orientat cu 6 noduri, numerotate 1,2,..,6.", "Arcele grafului sunt de  forma (x,2*x) pentru orice x\u2208{1,2,3} \u0219i de forma (x,x-1) pentru orice  x\u2208{2,3,4,5,6}.", "Care este num\u0103rul minim de arce ce trebuie ad\u0103ugate astfel \u00eenc\u00e2t graful  s\u0103 fie tare conex?", " a)   0  b)   1  c)   2   d)   3  e)  4  f)  5    12.", "Preciza\u021bi care dintre tablourile urm\u0103toare poate reprezenta vectorul gradelor unui graf  neorientat  conex.", " a)   (3,2,1,5,1,1)  b)   (5,1,6,4,5,3)  c)   (1,1,1,1,2,2)  d)   (1,1,1,1,1,6)  e)   (2,1,3,1,0,1)  f)    (1,3,5,2,1,2)     13.", "Dac\u0103 un graf neorientat conex are n v\u00e2rfuri \u0219i 3n+2 muchii, preciza\u021bi care este valoarea  minim\u0103 pentru n.  a)   16  b)   8  c)   4  d)   2  e)  1  f)  0    14.", "Pentru un num\u0103r natural nenul n, se construie\u0219te un arbore cu r\u0103d\u0103cin\u0103 astfel: r\u0103d\u0103cina este  numerotat\u0103 n \u0219i orice nod care este numerotat cu o valoare x>1 are ca fii nodurile numerotate  cu divizorii s\u0103i, mai pu\u021bin num\u0103rul \u00eensu\u0219i.", "Toate frunzele arborelui sunt numerotate cu 1.", " Preciza\u021bi c\u00e2te dintre numerele naturale din intervalul [10,20] pot fi alese ca r\u0103d\u0103cin\u0103,  astfel \u00eenc\u00e2t arborele asociat s\u0103 aib\u0103 un num\u0103r maxim de frunze.", " a)   1  b)   2  c)   3  d)   4  e)   5  f)   6    15.", "Un pulover norvegian este frumos dac\u0103 pentru a-l tricota se folosesc cel pu\u021bin 2 \u0219i cel mult 4  culori de l\u00e2n\u0103.", "Preciza\u021bi c\u00e2te modalit\u0103\u021bi de combinare a culorilor exist\u0103 pentru a tricota un  pulover norvegian frumos, av\u00e2nd la dispozi\u021bie 5 ghemuri de l\u00e2n\u0103 de culori diferite.", " a)  5   b)   12  c)   24  d)   25  e)   48  f)  125"], "page_sentence_count_spacy": 17}, {"page_number": 27, "page_char_count": 1703, "page_word_count": 433, "page_sentence_count_raw": 8, "page_token_count": 425.75, "text": "27        Varianta 5    1. Preciza\u021bi care dintre urm\u0103toarele expresii  are valoarea 1/true dac\u0103 \u015fi numai dac\u0103 num\u0103rul  natural nenul memorat \u00een variabila x nu este divizibil cu 6.  Limbajul C++/ Limbajul C  Limbajul Pascal  a)  x/6==0  b)  x==6  c)  x%6 == 0  d)  x/6>0  e)  x%2+x%3>0  f)  x>6  a)  x div 6 = 0  b)  x=6  c)  x mod 6 = 0  d)  x/6>0  e)  x mod 2+x mod 3>0  f)  x>6    2. Preciza\u021bi care dintre urm\u0103toarele instruc\u021biuni este corect\u0103 dac\u0103 variabilele x, y \u0219i z au  declar\u0103rile de mai jos:  Limbajul C++/ Limbajul C  Limbajul Pascal  float x;  int y,z;  x : real;  y,z:integer;  a)  x = x*y%z;  b)  x = z%y*x;  c)  x = x%y*z;  d)  x = x*z%x;  e)  x = x%z;  f)  y = z%x;  a)  x:= x*y mod z;  b)  x:= z mod y*x;  c)  x:= x mod y*z;  d)  x:= x*z mod x;  e)  x:=x mod z;  f)  y:=z mod x;    3. Preciza\u021bi ce valoare se va afi\u015fa pe ecran \u00een urma execut\u0103rii secven\u0163ei de program urm\u0103toare,  \u015ftiind c\u0103 s este o variabil\u0103 care memoreaz\u0103 un \u015fir de caractere, iar i este o variabil\u0103 de tip  \u00eentreg.  Limbajul C++/ Limbajul C  Limbajul Pascal  strcpy(s,\"admitere\");  for(i=0;i<strlen(s);i++)    if(strchr(\"politehnica\",s[i]))           strcpy(s+i,s+i+1);  cout<<s;  | printf(\"%s\",s);  s:='admitere';  for i:=1 to length(s) do   if pos(s[i],'politehnica')>0 then         delete(s,i,1);  write(s);    a)  dmt  b)  dm  c)  dmtr  d)  dmr  e)   mt  f)  mrt    4. Preciza\u021bi care dintre urm\u0103toarele afirma\u021bii este adev\u0103rat\u0103 pentru orice graf neorientat G  format din 100 de noduri \u0219i 100 de muchii.    a) Graful G nu este conex  b) Graful G este conex    c) Graful G este complet  d) Graful G con\u021bine cel pu\u021bin un ciclu     e) Graful G nu are noduri izolate  f) Graful G con\u021bine un lan\u021b elementar de lungime 100", "sentences": ["27        Varianta 5    1.", "Preciza\u021bi care dintre urm\u0103toarele expresii  are valoarea 1/true dac\u0103 \u015fi numai dac\u0103 num\u0103rul  natural nenul memorat \u00een variabila x nu este divizibil cu 6.", " Limbajul C++/ Limbajul C  Limbajul Pascal  a)  x/6==0  b)  x==6  c)  x%6 == 0  d)  x/6>0  e)  x%2+x%3>0  f)  x>6  a)  x div 6 = 0  b)  x=6  c)  x mod 6 = 0  d)  x/6>0  e)  x mod 2+x mod 3>0  f)  x>6    2.", "Preciza\u021bi care dintre urm\u0103toarele instruc\u021biuni este corect\u0103 dac\u0103 variabilele x, y \u0219i z au  declar\u0103rile de mai jos:  Limbajul C++/ Limbajul C  Limbajul Pascal  float x;  int y,z;  x : real;  y,z:integer;  a)  x = x*y%z;  b)  x = z%y*x;  c)  x = x%y*z;  d)  x = x*z%x;  e)  x = x%z;  f)  y = z%x;  a)  x:= x*y mod z;  b)  x:= z mod y*x;  c)  x:= x mod y*z;  d)  x:= x*z mod x;  e)  x:=x mod z;  f)  y:=z mod x;    3.", "Preciza\u021bi ce valoare se va afi\u015fa pe ecran \u00een urma execut\u0103rii secven\u0163ei de program urm\u0103toare,  \u015ftiind c\u0103 s este o variabil\u0103 care memoreaz\u0103 un \u015fir de caractere, iar i este o variabil\u0103 de tip  \u00eentreg.", " Limbajul C++/ Limbajul C  Limbajul Pascal  strcpy(s,\"admitere\");  for(i=0;i<strlen(s);i++)    if(strchr(\"politehnica\",s[i]))           strcpy(s+i,s+i+1);  cout<<s;  | printf(\"%s\",s);  s:='admitere';  for i:=1 to length(s) do   if pos(s[i],'politehnica')>0 then         delete(s,i,1);  write(s);    a)  dmt  b)  dm  c)  dmtr  d)  dmr  e)   mt  f)  mrt    4.", "Preciza\u021bi care dintre urm\u0103toarele afirma\u021bii este adev\u0103rat\u0103 pentru orice graf neorientat G  format din 100 de noduri \u0219i 100 de muchii.", "   a) Graful G nu este conex  b) Graful G este conex    c) Graful G este complet  d) Graful G con\u021bine cel pu\u021bin un ciclu     e) Graful G nu are noduri izolate  f) Graful G con\u021bine un lan\u021b elementar de lungime 100"], "page_sentence_count_spacy": 8}, {"page_number": 28, "page_char_count": 2324, "page_word_count": 942, "page_sentence_count_raw": 9, "page_token_count": 581.0, "text": "28      5. Pentru reprezentarea unui graf orientat G se utilizeaz\u0103 matricea de adiacen\u021b\u0103. Preciza\u021bi care  este suma elementelor din aceast\u0103 matrice dac\u0103 graful are 20 de noduri \u0219i 30 de arce.  a) 60  b) 50  c) 40  d) 30  e) 20  f) 10    6. Preciza\u021bi care este lungimea maxim\u0103 a unui lan\u021b simplu (lan\u021b \u00een care fiecare muchie apare o  singur\u0103 dat\u0103) \u00eentr-un arbore cu 10 noduri \u00een care fiecare nod are gradul un num\u0103r impar.  a)  9  b)  8  c)  7  d)  6  e)  5  f)  4    7. Tabloul unidimensional v con\u021bine n numere \u00eentregi numerotate de la 1 la n. Preciza\u021bi care  dintre urm\u0103toarele secven\u021be determin\u0103 \u00eenlocuirea primului element din tabloul  unidimensional v cu cea mai mic\u0103 valoare care apare \u00een acesta.  Limbajul C++/ Limbajul C  Limbajul Pascal      a) for(i=1; i<n; i++)          if(v[i]>v[i+1])          {              a=v[i];              v[i]=v[i+1];              v[i+1]=a;          }  b) for(i=n-1; i>=1; i--)          if(v[i]>v[i+1])          {              a=v[i];              v[i]=v[i+1];              v[i+1]=a;          }  c) for(i=n-1; i>=1; i--)          if(v[i]<v[i+1])          {              a=v[i];              v[i]=v[i+1];              v[i+1]=a;          }  d) for(i=1; i<=n-1; i++)          if(v[i]<v[i+1])          {              a=v[i];              v[i]=v[i+1];              v[i+1]=a;          }  e) for(i=n-1; i>=1; i--)          if(v[i]<v[i+1])          {              a=v[i+1];              v[i]=v[i+1];              v[i+1]=a;          }  f) for(i=1; i<=n-1; i++)          if(v[i]<v[i+1])          {              a=v[i+1];  a) for i:=1 to n-1 do      if v[i]>v[i+1] then         begin       a:=v[i];          v[i]:=v[i+1];          v[i+1]:=a;           end;   b) for i:=n-1 downto 1 do      if v[i]>v[i+1] then        begin             a:=v[i];           v[i]:=v[i+1];           v[i+1]:=a;     end;  c) for i:=n-1 downto 1 do      if v[i]<v[i+1] then         begin        a:=v[i];           v[i]:=v[i+1];           v[i+1]:=a;         end;  d) for i:=1 to n-1 do      if v[i]<v[i+1] then         begin       a:=v[i];           v[i]:=v[i+1];           v[i+1]:=a;         end;  e) for i:=n-1 downto 1 do      if v[i]<v[i+1] then         begin          a:=v[i+1];          v[i]:=v[i+1];          v[i+1]:=a;         end;  f) for i:=1 to n-1 do      if v[i]<v[i+1] then         begin           a:=v[i+1];", "sentences": ["28      5.", "Pentru reprezentarea unui graf orientat G se utilizeaz\u0103 matricea de adiacen\u021b\u0103.", "Preciza\u021bi care  este suma elementelor din aceast\u0103 matrice dac\u0103 graful are 20 de noduri \u0219i 30 de arce.", " a) 60  b) 50  c) 40  d) 30  e) 20  f) 10    6.", "Preciza\u021bi care este lungimea maxim\u0103 a unui lan\u021b simplu (lan\u021b \u00een care fiecare muchie apare o  singur\u0103 dat\u0103) \u00eentr-un arbore cu 10 noduri \u00een care fiecare nod are gradul un num\u0103r impar.", " a)  9  b)  8  c)  7  d)  6  e)  5  f)  4    7.", "Tabloul unidimensional v con\u021bine n numere \u00eentregi numerotate de la 1 la n. Preciza\u021bi care  dintre urm\u0103toarele secven\u021be determin\u0103 \u00eenlocuirea primului element din tabloul  unidimensional v cu cea mai mic\u0103 valoare care apare \u00een acesta.", " Limbajul C++/ Limbajul C  Limbajul Pascal      a) for(i=1; i<n; i++)          if(v[i]>v[i+1])          {              a=v[i];              v[i]=v[i+1];              v[i+1]=a;          }  b) for(i=n-1; i>=1; i--)          if(v[i]>v[i+1])          {              a=v[i];              v[i]=v[i+1];              v[i+1]=a;          }  c) for(i=n-1; i>=1; i--)          if(v[i]<v[i+1])          {              a=v[i];              v[i]=v[i+1];              v[i+1]=a;          }  d) for(i=1; i<=n-1; i++)          if(v[i]<v[i+1])          {              a=v[i];              v[i]=v[i+1];              v[i+1]=a;          }  e) for(i=n-1; i>=1; i--)          if(v[i]<v[i+1])          {              a=v[i+1];              v[i]=v[i+1];              v[i+1]=a;          }  f) for(i=1; i<=n-1; i++)          if(v[i]<v[i+1])          {              a=v[i+1];  a) for i:=1 to n-1 do      if v[i]>v[i+1] then         begin       a:=v[i];          v[i]:=v[i+1];          v[i+1]:=a;           end;   b) for i:=n-1 downto 1 do      if v[i]>v[i+1] then        begin             a:=v[i];           v[i]:=v[i+1];           v[i+1]:=a;     end;  c) for i:=n-1 downto 1 do      if v[i]<v[i+1] then         begin        a:=v[i];           v[i]:=v[i+1];           v[i+1]:=a;         end;  d) for i:=1 to n-1 do      if v[i]<v[i+1] then         begin       a:=v[i];           v[i]:=v[i+1];           v[i+1]:=a;         end;  e) for i:=n-1 downto 1 do      if v[i]<v[i+1] then         begin          a:=v[i+1];          v[i]:=v[i+1];          v[i+1]:=a;         end;  f) for i:=1 to n-1 do      if v[i]<v[i+1] then         begin           a:=v[i+1];"], "page_sentence_count_spacy": 8}, {"page_number": 29, "page_char_count": 2177, "page_word_count": 538, "page_sentence_count_raw": 15, "page_token_count": 544.25, "text": "29                v[i]=v[i+1];              v[i+1]=a;          }          v[i]:=v[i+1];          v[i+1]:=a;         end;    8. Preciza\u021bi pentru care dintre urm\u0103toarele tablouri unidimensionale se poate aplica algoritmul  c\u0103ut\u0103rii binare cu scopul de a g\u0103si \u00een mod eficient, dac\u0103 exist\u0103, numere care au cifra unit\u0103\u021bilor  egal\u0103 cu o valoare x, dat\u0103.  a) (1, 21, 13, 23, 33, 17, 27)  b) (1, 13, 17, 21, 23, 27, 33)   c) (1, 13, 33, 17, 21, 23, 27)  d) (33, 27, 23, 21, 17, 13, 1)  e) (1, 13, 33, 21, 23, 27, 17)  f) (33, 27, 23, 21, 13, 1, 17)    9. \u00cen secven\u0163a de mai jos, variabila a memoreaz\u0103 un tablou bidimensional cu 4 linii \u015fi 4  coloane, numerotate de la 1 la 4, cu elementele \u00eentregi. Variabila s este \u00eentreag\u0103, iar i este  de tip \u00eentreg. Preciza\u021bi care dintre instruc\u0163iunile de mai jos poate \u00eenlocui punctele de  suspensie, astfel \u00eenc\u00e2t secven\u0163a s\u0103 determine memorarea \u00een variabila s, a valorii sumei  elementelor aflate pe prima \u0219i ultima coloan\u0103 ale matricei.  Limbajul C++/ Limbajul C  Limbajul Pascal   s=0;   for(i=1;i<=4;i++)....  s:=0;  for i:=1 to 4 do .....  a)  s=s+a[4][i]+a[i][4];   b)  s=s+a[4-i][4]+a[i][1];   c)  s=s+a[i][1]+a[i][4];   d)  s=s+a[i][i]+a[1][i];  e)  s=s+a[1][i]+a[4][i];   f)  s=s+a[i][i]+a[5-i][i];  a)  s:=s+a[4,i]+a[i,4];   b)  s:=s+a[4-i,4]+a[i,1];   c)  s:=s+a[i,1]+a[i,4];   d)  s:=s+a[i,i]+a[1,i];  e)  s:=s+a[1,i]+a[4,i];   f)  s:=s+a[i,i]+a[5-i,i];    10. Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate anagramele cuv\u00e2ntului avion. Preciza\u021bi  c\u00e2te anagrame \u00eencep \u0219i se termin\u0103 cu c\u00e2te o consoan\u0103.  a) 6  b) 12  c) 20  d) 36  e) 38  f) 40    11. Subprogramul f are defini\u0163ia urm\u0103toare. Dac\u0103 variabilele a \u0219i b sunt de tip \u00eentreg \u0219i  memoreaz\u0103 valorile 3 respectiv 5, preciza\u021bi care vor fi valorile pe care le memoreaz\u0103  variabilele a \u0219i b dup\u0103 apelul:         f(a,b);       (Limbajul Pascal/C++)         f(a,&b);     (Limbajul C).  Limbajul C++  Limbajul C   void f(int x,int &y)     {int aux;      aux=x; x=y;      y=aux;      }  void f(int x,int *y)     {int aux;      aux=x; x=*y;       *y=aux;     }  Limbajul Pascal     procedure f(x:integer;var y:integer);       var aux:integer;     begin    aux:=x; x:=y; y:=aux;     end;", "sentences": ["29                v[i]=v[i+1];              v[i+1]=a;          }          v[i]:=v[i+1];          v[i+1]:=a;         end;    8.", "Preciza\u021bi pentru care dintre urm\u0103toarele tablouri unidimensionale se poate aplica algoritmul  c\u0103ut\u0103rii binare cu scopul de a g\u0103si \u00een mod eficient, dac\u0103 exist\u0103, numere care au cifra unit\u0103\u021bilor  egal\u0103 cu o valoare x, dat\u0103.", " a) (1, 21, 13, 23, 33, 17, 27)  b) (1, 13, 17, 21, 23, 27, 33)   c) (1, 13, 33, 17, 21, 23, 27)  d) (33, 27, 23, 21, 17, 13, 1)  e) (1, 13, 33, 21, 23, 27, 17)  f) (33, 27, 23, 21, 13, 1, 17)    9.", "\u00cen secven\u0163a de mai jos, variabila a memoreaz\u0103 un tablou bidimensional cu 4 linii \u015fi 4  coloane, numerotate de la 1 la 4, cu elementele \u00eentregi.", "Variabila s este \u00eentreag\u0103, iar i este  de tip \u00eentreg.", "Preciza\u021bi care dintre instruc\u0163iunile de mai jos poate \u00eenlocui punctele de  suspensie, astfel \u00eenc\u00e2t secven\u0163a s\u0103 determine memorarea \u00een variabila s, a valorii sumei  elementelor aflate pe prima \u0219i ultima coloan\u0103 ale matricei.", " Limbajul C++/ Limbajul C  Limbajul Pascal   s=0;   for(i=1;i<=4;i++)....  s:=0;  for i:=1 to 4 do .....  a)  s=s+a[4][i]+a[i][4];   b)  s=s+a[4-i][4]+a[i][1];   c)  s=s+a[i][1]+a[i][4];   d)  s=s+a[i][i]+a[1][i];  e)  s=s+a[1][i]+a[4][i];   f)  s=s+a[i][i]+a[5-i][i];  a)  s:=s+a[4,i]+a[i,4];   b)  s:=s+a[4-i,4]+a[i,1];   c)  s:=s+a[i,1]+a[i,4];   d)  s:=s+a[i,i]+a[1,i];  e)  s:=s+a[1,i]+a[4,i];   f)  s:=s+a[i,i]+a[5-i,i];    10.", "Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate anagramele cuv\u00e2ntului avion.", "Preciza\u021bi  c\u00e2te anagrame \u00eencep \u0219i se termin\u0103 cu c\u00e2te o consoan\u0103.", " a) 6  b) 12  c) 20  d) 36  e) 38  f) 40    11.", "Subprogramul f are defini\u0163ia urm\u0103toare.", "Dac\u0103 variabilele a \u0219i b sunt de tip \u00eentreg \u0219i  memoreaz\u0103 valorile 3 respectiv 5, preciza\u021bi care vor fi valorile pe care le memoreaz\u0103  variabilele a \u0219i b dup\u0103 apelul:         f(a,b);       (Limbajul Pascal/C++)         f(a,&b);     (Limbajul C).", " Limbajul C++  Limbajul C   void f(int x,int &y)     {int aux;      aux=x; x=y;      y=aux;      }  void f(int x,int *y)     {int aux;      aux=x; x=*y;       *y=aux;     }  Limbajul Pascal     procedure f(x:integer;var y:integer);       var aux:integer;     begin    aux:=x; x:=y; y:=aux;     end;"], "page_sentence_count_spacy": 13}, {"page_number": 30, "page_char_count": 1745, "page_word_count": 410, "page_sentence_count_raw": 11, "page_token_count": 436.25, "text": "30    a)  3 \u0219i 3  b)  4 \u0219i 3  c)  5 \u0219i 5  d)  3 \u0219i 5  e)  3 \u0219i 4  f)  5 \u0219i 3    12. Consider\u0103m declararea urm\u0103toare, folosit\u0103 pentru a memora num\u0103r\u0103torul \u0219i numitorul unei  frac\u021bii. Preciza\u021bi care dintre instruc\u021biunile de mai jos este corect\u0103.  Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct    { int a, b; }fractie;  fractie  m,n;     type fractie=record       a,b:integer;     end;  var m,n:fractie;  a) m=n;  b) if(m>n) m++;  c) if(m==n) m--;  d) if(m<=n) m=n;  e) if(m!=n) m--;  f) if(m>n) m=n;  a) m:=n;  b) if (m>n) then m:=m+1;  c) if (m=n) then m:=m-1;  d) if (m<=n) then m:=n;  e) if (m<>n) then m:=m-1;  f) if (m>n) then m:=n;    13. Preciza\u021bi care este num\u0103rul de grafuri orientate distincte formate din  3 noduri \u0219i 4 arce. Dou\u0103  grafuri sunt distincte dac\u0103 au matricea de adiacen\u021b\u0103 diferit\u0103.  a)  32  b)  30  c)  20  d)  16  e)  15  f)  9    14. Preciza\u021bi care este instruc\u0163iunea prin care variabilei y i se atribuie num\u0103rul ob\u0163inut prin  inversarea ordinii cifrelor num\u0103rului natural format din exact 2 cifre, memorat \u00een variabila  \u00eentreag\u0103 x.  Limbajul C++/ Limbajul C  Limbajul Pascal  a)  y=x/10*10+x%100;  b)  y=x%10+x/10;  c)  y=x/10*10+x%10;  d)  y=x%100/10;  e)  y=x*10%100+x/10;  f)  y=x%10/10;  a)  y:=x div 10*10+x mod 100;  b)  y:=x mod 10 +x div 10;  c)  y:=x div 10*10+x mod 10;  d)  y:=x mod 100 div 10;  e)  y:=x*10 mod 100+x div 10;  f)  y:=x mod 10 div 10;    15. Fie G un graf neorientat complet cu 100 de noduri. Preciza\u021bi care dintre urm\u0103toarele afirma\u021bii  este adevarat\u0103:  a) \u00cen graful G exist\u0103 un lan\u021b elementar de lungime 100  b) Graful G este un graf hamiltonian  c) Graful G este un graf eulerian   d) Graful G nu este conex  e) Graful G are 900 de muchii  f) Graful G are dou\u0103 componente conexe", "sentences": ["30    a)  3 \u0219i 3  b)  4 \u0219i 3  c)  5 \u0219i 5  d)  3 \u0219i 5  e)  3 \u0219i 4  f)  5 \u0219i 3    12.", "Consider\u0103m declararea urm\u0103toare, folosit\u0103 pentru a memora num\u0103r\u0103torul \u0219i numitorul unei  frac\u021bii.", "Preciza\u021bi care dintre instruc\u021biunile de mai jos este corect\u0103.", " Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct    { int a, b; }fractie;  fractie  m,n;     type fractie=record       a,b:integer;     end;  var m,n:fractie;  a) m=n;  b) if(m>n) m++;  c) if(m==n) m--;  d) if(m<=n) m=n;  e) if(m!=n) m--;  f) if(m>n) m=n;  a) m:=n;  b) if (m>n) then m:=m+1;  c) if (m=n) then m:=m-1;  d) if (m<=n) then m:=n;  e) if (m<>n) then m:=m-1;  f) if (m>n) then m:=n;    13.", "Preciza\u021bi care este num\u0103rul de grafuri orientate distincte formate din  3 noduri \u0219i 4 arce.", "Dou\u0103  grafuri sunt distincte dac\u0103 au matricea de adiacen\u021b\u0103 diferit\u0103.", " a)  32  b)  30  c)  20  d)  16  e)  15  f)  9    14.", "Preciza\u021bi care este instruc\u0163iunea prin care variabilei y i se atribuie num\u0103rul ob\u0163inut prin  inversarea ordinii cifrelor num\u0103rului natural format din exact 2 cifre, memorat \u00een variabila  \u00eentreag\u0103 x.  Limbajul C++/ Limbajul C  Limbajul Pascal  a)  y=x/10*10+x%100;  b)  y=x%10+x/10;  c)  y=x/10*10+x%10;  d)  y=x%100/10;  e)  y=x*10%100+x/10;  f)  y=x%10/10;  a)  y:=x div 10*10+x mod 100;  b)  y:=x mod 10 +x div 10;  c)  y:=x div 10*10+x mod 10;  d)  y:=x mod 100 div 10;  e)  y:=x*10 mod 100+x div 10;  f)  y:=x mod 10 div 10;    15.", "Fie G un graf neorientat complet cu 100 de noduri.", "Preciza\u021bi care dintre urm\u0103toarele afirma\u021bii  este adevarat\u0103:  a) \u00cen graful G exist\u0103 un lan\u021b elementar de lungime 100  b) Graful G este un graf hamiltonian  c) Graful G este un graf eulerian   d) Graful G nu este conex  e) Graful G are 900 de muchii  f) Graful G are dou\u0103 componente conexe"], "page_sentence_count_spacy": 10}, {"page_number": 31, "page_char_count": 1782, "page_word_count": 390, "page_sentence_count_raw": 14, "page_token_count": 445.5, "text": "31        Varianta 6    1.  Preciza\u021bi care este valoarea maxim\u0103 pe care o poate avea expresia de mai jos \u00een care x este  o variabil\u0103 de tip \u00eentreg.  Limbajul C++/ Limbajul C  Limbajul Pascal  2*x%10*2%10  2*x mod 10 * 2 mod 10  a) 9  b) 8  c) 7  d) 0  e) 10  f) 20    2. Variabilele \u00eentregi a \u015fi b memoreaz\u0103 c\u00e2te un num\u0103r natural nenul. Preciza\u021bi care dintre  urm\u0103toarele expresii are valoarea true/1 dac\u0103 \u0219i numai dac\u0103 valorile memorate de a \u0219i b au  aceea\u0219i paritate.  Limbajul C++/ Limbajul C  Limbajul Pascal  a) a==b   b) a%2==0 && b%2==0   c) (a+b)%2==0  d) a*b%2==0  e) a%b==2  f) a/b==2  a) a=b   b) (a mod 2=0) and (b mod 2=0)   c) (a+b) mod 2 = 0  d) a*b mod 2=0  e) a mod b=2  f) a div b = 2    3. Preciza\u021bi ce se afi\u015feaz\u0103 \u00een urma execut\u0103rii secven\u0163ei de program de mai jos, dac\u0103 variabilele  a \u015fi b pot memora c\u00e2te un \u015fir de cel mult 100 de caractere.  Limbajul C++/ Limbajul C  Limbajul Pascal  strcpy(a,\u201dmatematica\u201d);  strcpy(b,strstr(a,\u201dema\u201d)+2);  strcat(b,strchr(a,a[3])+1);  cout<<b;     | printf(\u201c%s\u201d,b);  a:='matematica';  b:=copy(a,pos('ema',a)+2,length(a ));  b:=b+copy(a,pos(a[4],a)+1,length( a));  write(b);      a) aticamatica  b) maticamatica  c) maticaatica    d) matica  e) matematica  f) atica     4. Fie un graf neorientat complet cu 10 noduri. Preciza\u021bi care este num\u0103rul minim de muchii  care trebuie eliminate astfel \u00eenc\u00e2t graful par\u021bial ob\u021binut s\u0103 nu fie conex.  a) 10  b) 9  c) 8  d) 7  e) 6  f) 5    5. Preciza\u021bi care dintre urm\u0103toarele \u0219iruri de grade corespund unui graf neorientat cu 6 noduri.   a) (1,2,3,4,5,6)  b) (0,1,2,3,4,5)  c) (0,1,0,1,0,1)  d) (1,2,2,1,2,2)  e) (1,1,1,1,1,2)  f) (1,2,2,1,1,2)    6. Preciza\u021bi care este num\u0103rul maxim de frunze ce apar \u00eentr-un arbore cu 17 de noduri, dac\u0103  fiecare nod are gradul mai mic sau egal cu 4.", "sentences": ["31        Varianta 6    1.", " Preciza\u021bi care este valoarea maxim\u0103 pe care o poate avea expresia de mai jos \u00een care x este  o variabil\u0103 de tip \u00eentreg.", " Limbajul C++/ Limbajul C  Limbajul Pascal  2*x%10*2%10  2*x mod 10 * 2 mod 10  a) 9  b) 8  c) 7  d) 0  e) 10  f) 20    2.", "Variabilele \u00eentregi a \u015fi b memoreaz\u0103 c\u00e2te un num\u0103r natural nenul.", "Preciza\u021bi care dintre  urm\u0103toarele expresii are valoarea true/1 dac\u0103 \u0219i numai dac\u0103 valorile memorate de a \u0219i b au  aceea\u0219i paritate.", " Limbajul C++/ Limbajul C  Limbajul Pascal  a) a==b   b) a%2==0 && b%2==0   c) (a+b)%2==0  d) a*b%2==0  e) a%b==2  f) a/b==2  a) a=b   b) (a mod 2=0) and (b mod 2=0)   c) (a+b) mod 2 = 0  d) a*b mod 2=0  e) a mod b=2  f) a div b = 2    3.", "Preciza\u021bi ce se afi\u015feaz\u0103 \u00een urma execut\u0103rii secven\u0163ei de program de mai jos, dac\u0103 variabilele  a \u015fi b pot memora c\u00e2te un \u015fir de cel mult 100 de caractere.", " Limbajul C++/ Limbajul C  Limbajul Pascal  strcpy(a,\u201dmatematica\u201d);  strcpy(b,strstr(a,\u201dema\u201d)+2);  strcat(b,strchr(a,a[3])+1);  cout<<b;     | printf(\u201c%s\u201d,b);  a:='matematica';  b:=copy(a,pos('ema',a)+2,length(a ));  b:=b+copy(a,pos(a[4],a)+1,length( a));  write(b);      a) aticamatica  b) maticamatica  c) maticaatica    d) matica  e) matematica  f) atica     4.", "Fie un graf neorientat complet cu 10 noduri.", "Preciza\u021bi care este num\u0103rul minim de muchii  care trebuie eliminate astfel \u00eenc\u00e2t graful par\u021bial ob\u021binut s\u0103 nu fie conex.", " a) 10  b) 9  c) 8  d) 7  e) 6  f) 5    5.", "Preciza\u021bi care dintre urm\u0103toarele \u0219iruri de grade corespund unui graf neorientat cu 6 noduri.", "  a) (1,2,3,4,5,6)  b) (0,1,2,3,4,5)  c) (0,1,0,1,0,1)  d) (1,2,2,1,2,2)  e) (1,1,1,1,1,2)  f) (1,2,2,1,1,2)    6.", "Preciza\u021bi care este num\u0103rul maxim de frunze ce apar \u00eentr-un arbore cu 17 de noduri, dac\u0103  fiecare nod are gradul mai mic sau egal cu 4."], "page_sentence_count_spacy": 14}, {"page_number": 32, "page_char_count": 2184, "page_word_count": 466, "page_sentence_count_raw": 13, "page_token_count": 546.0, "text": "32    a) 11  b) 12  c) 13  d) 14  e) 15  f) 16    7. Graful orientat G are 10 noduri \u0219i 12 arce. Preciza\u021bi care este cel mai mare grad exterior al  unui nod din acest graf, dac\u0103 G este tare conex.  a) 12  b) 3  c) 10  d) 4  e) 5  f) 6    8. Se consider\u0103 un tablou bidimensional a cu n linii \u015fi n coloane, numerotate de la 1 la n, cu  elemente numere \u00eentregi. Preciza\u021bi ce reprezint\u0103 valoarea variabilei \u00eentregi x, dup\u0103 executarea  secven\u0163ei de program de mai jos.  Limbajul C++/ Limbajul C  Limbajul Pascal  x=0;   for(i=1;i<=n;i++) x=x+a[i][n-i+1];  x:=0;  for i:=1 to n do x:=x+a[i,n-i+1];    a) suma elementelor de pe diagonala principal\u0103 a tabloului a    b) suma elementelor de pe diagonala secundar\u0103 a tabloului a  c) suma elementelor tabloului a  d) suma elementelor situate pe ultima coloan\u0103 a tabloului a  e) suma elementelor situate pe prima coloan\u0103 a tabloului a  f) suma elementelor situate pe ultima linie a tabloului a    9. Se consider\u0103 secven\u0163a al\u0103turat\u0103 \u00een care A este un tablou bidimensional cu cinci linii \u015fi cinci  coloane, numerotate de la 1 la 5, iar x \u0219i i sunt variabile de tip \u00eentreg. \u015etiind c\u0103 orice element  al tabloului este ini\u0163ial egal cu num\u0103rul de ordine al liniei pe care se afl\u0103, preciza\u0163i care este  valoarea variabilei x dup\u0103 executarea secven\u021bei de mai jos?  Limbajul C++/ Limbajul C  Limbajul Pascal  x=0;  for(i=1;i<=5;i++)   if(i%2==0) x=x+A[i-1][i];    x:=0;  for i:=1 to 5 do       if ( i mod 2 = 0) then x:=x+A[i-1,i];  a) 25  b) 4  c) 15  d) 5  e) 30  f) 3    10 .  Problema gener\u0103rii tuturor numerelor formate din exact trei cifre nenule, cu toate cifrele  distincte dou\u0103 c\u00e2te dou\u0103, este similar\u0103 cu generarea:  a) aranjamentelor   b) permut\u0103rilor  c) elementelor produsului cartezian  d) tuturor submultimilor unei mul\u021bimi  e) combin\u0103rilor  f) parti\u021biilor unei mul\u021bimi    11 .  O delega\u021bie format\u0103 din patru elevi ai unei grupe trebuie s\u0103 participe la o conferin\u021b\u0103. \u0218tiind  c\u0103 \u00een grup\u0103 sunt 9 elevi, dintre care cinci sunt fete, preciza\u021bi care este num\u0103rul posibilit\u0103\u021bilor  de a forma delega\u021bia care va participa la conferin\u021b\u0103, dac\u0103 aceasta trebuie s\u0103 fie alc\u0103tuit\u0103 din  doi b\u0103ie\u021bi \u0219i dou\u0103 fete.  a) 20  b) 45  c) 180  d) 60  e) 90  f) 120", "sentences": ["32    a) 11  b) 12  c) 13  d) 14  e) 15  f) 16    7.", "Graful orientat G are 10 noduri \u0219i 12 arce.", "Preciza\u021bi care este cel mai mare grad exterior al  unui nod din acest graf, dac\u0103 G este tare conex.", " a) 12  b) 3  c) 10  d) 4  e) 5  f) 6    8.", "Se consider\u0103 un tablou bidimensional a cu n linii \u015fi n coloane, numerotate de la 1 la n, cu  elemente numere \u00eentregi.", "Preciza\u021bi ce reprezint\u0103 valoarea variabilei \u00eentregi x, dup\u0103 executarea  secven\u0163ei de program de mai jos.", " Limbajul C++/ Limbajul C  Limbajul Pascal  x=0;   for(i=1;i<=n;i++) x=x+a[i][n-i+1];  x:=0;  for i:=1 to n do x:=x+a[i,n-i+1];    a) suma elementelor de pe diagonala principal\u0103 a tabloului a    b) suma elementelor de pe diagonala secundar\u0103 a tabloului a  c) suma elementelor tabloului a  d) suma elementelor situate pe ultima coloan\u0103 a tabloului a  e) suma elementelor situate pe prima coloan\u0103 a tabloului a  f) suma elementelor situate pe ultima linie a tabloului a    9.", "Se consider\u0103 secven\u0163a al\u0103turat\u0103 \u00een care A este un tablou bidimensional cu cinci linii \u015fi cinci  coloane, numerotate de la 1 la 5, iar x \u0219i i sunt variabile de tip \u00eentreg.", "\u015etiind c\u0103 orice element  al tabloului este ini\u0163ial egal cu num\u0103rul de ordine al liniei pe care se afl\u0103, preciza\u0163i care este  valoarea variabilei x dup\u0103 executarea secven\u021bei de mai jos?", " Limbajul C++/ Limbajul C  Limbajul Pascal  x=0;  for(i=1;i<=5;i++)   if(i%2==0) x=x+A[i-1][i];    x:=0;  for i:=1 to 5 do       if ( i mod 2 = 0) then x:=x+A[i-1,i];  a) 25  b) 4  c) 15  d) 5  e) 30  f) 3    10 .", " Problema gener\u0103rii tuturor numerelor formate din exact trei cifre nenule, cu toate cifrele  distincte dou\u0103 c\u00e2te dou\u0103, este similar\u0103 cu generarea:  a) aranjamentelor   b) permut\u0103rilor  c) elementelor produsului cartezian  d) tuturor submultimilor unei mul\u021bimi  e) combin\u0103rilor  f) parti\u021biilor unei mul\u021bimi    11 .", " O delega\u021bie format\u0103 din patru elevi ai unei grupe trebuie s\u0103 participe la o conferin\u021b\u0103.", "\u0218tiind  c\u0103 \u00een grup\u0103 sunt 9 elevi, dintre care cinci sunt fete, preciza\u021bi care este num\u0103rul posibilit\u0103\u021bilor  de a forma delega\u021bia care va participa la conferin\u021b\u0103, dac\u0103 aceasta trebuie s\u0103 fie alc\u0103tuit\u0103 din  doi b\u0103ie\u021bi \u0219i dou\u0103 fete.", " a) 20  b) 45  c) 180  d) 60  e) 90  f) 120"], "page_sentence_count_spacy": 14}, {"page_number": 33, "page_char_count": 1763, "page_word_count": 397, "page_sentence_count_raw": 12, "page_token_count": 440.75, "text": "33    12 .  Fie un \u0219ir format din 10000 de numere naturale, fiecare av\u00e2nd cel mult 9 cifre. Preciza\u021bi care  dintre urm\u0103torii algoritmi efectueaz\u0103 un num\u0103r minim de pa\u0219i.  a) ordonarea cresc\u0103toare a elementelor din \u0219ir  b) num\u0103rarea elementelor prime din \u0219ir  c) determinarea elementului maxim din \u0219ir  d) verificarea unicit\u0103\u021bii tuturor elementelor din \u0219ir  e) generarea tuturor permut\u0103rilor elementelor din \u0219ir  f) suma elementelor care apar de exact dou\u0103 ori \u00een \u0219ir    13 .  \u00cen declararea al\u0103turat\u0103, c\u00e2mpurile x \u015fi y ale \u00eenregistr\u0103rii pot memora coordonatele carteziene  ale unui punct din planul xOy. Preciza\u021bi care dintre urm\u0103toarele expresii are valoarea true/1  dac\u0103 \u015fi numai dac\u0103 punctul P este situat \u00een cadranul I sau III, dar nu \u0219i pe axe.    Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct     {       float x,y;     } punct;  punct p;  type punct=record       x,y:real;       end;  var p:punct;  a) p.x*p.y>0  b) p.x>p.y  c) p.x*p.y>=0  d) x.p*y.p>0  e) x.p*y.p>0  f) p.x+p.y>=0    14 .  Preciza\u021bi care este suma maxim\u0103 a elementelor care apar \u00eentr-un tablou unidimensional cu  leg\u0103turi \u201ede tip tat\u0103\u201d, asociat unui arbore cu r\u0103d\u0103cin\u0103 format din 10 noduri, etichetate cu  numere de la 1 la 10.  a) 100  b) 90  c) 81  d) 45  e) 80  f) 60    15 .  Subprogramul f are defini\u0163ia de mai jos. Dac\u0103 variabila a este de tip \u00eentreg \u0219i memoreaz\u0103  valorarea 3, preciza\u021bi care va fi valorea pe care o memoreaz\u0103 aceea\u0219i variabil\u0103 a, dup\u0103 apelul  f(a,a); (limbajul Pascal/C++), respectiv f(&a,&a); (\u00een limbajul C).  Limbajul C++  Limbajul C    void f(int &x,int &y)  {    x=1;    x=x+y;  }  void f(int *x, int *y)  {     *x=1;     *x=*x+*y;  }  Limbajul Pascal  procedure f(var x,y: integer);  begin  x:=1;  x:=x+y;  end;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6", "sentences": ["33    12 .", " Fie un \u0219ir format din 10000 de numere naturale, fiecare av\u00e2nd cel mult 9 cifre.", "Preciza\u021bi care  dintre urm\u0103torii algoritmi efectueaz\u0103 un num\u0103r minim de pa\u0219i.", " a) ordonarea cresc\u0103toare a elementelor din \u0219ir  b) num\u0103rarea elementelor prime din \u0219ir  c) determinarea elementului maxim din \u0219ir  d) verificarea unicit\u0103\u021bii tuturor elementelor din \u0219ir  e) generarea tuturor permut\u0103rilor elementelor din \u0219ir  f) suma elementelor care apar de exact dou\u0103 ori \u00een \u0219ir    13 .", " \u00cen declararea al\u0103turat\u0103, c\u00e2mpurile x \u015fi y ale \u00eenregistr\u0103rii pot memora coordonatele carteziene  ale unui punct din planul xOy.", "Preciza\u021bi care dintre urm\u0103toarele expresii are valoarea true/1  dac\u0103 \u015fi numai dac\u0103 punctul P este situat \u00een cadranul I sau III, dar nu \u0219i pe axe.", "   Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct     {       float x,y;     } punct;  punct p;  type punct=record       x,y:real;       end;  var p:punct;  a) p.x*p.y>0  b) p.x>p.y  c) p.x*p.y>=0  d) x.p*y.p>0  e) x.p*y.p>0  f) p.x+p.y>=0    14 .", " Preciza\u021bi care este suma maxim\u0103 a elementelor care apar \u00eentr-un tablou unidimensional cu  leg\u0103turi \u201ede tip tat\u0103\u201d, asociat unui arbore cu r\u0103d\u0103cin\u0103 format din 10 noduri, etichetate cu  numere de la 1 la 10.", " a) 100  b) 90  c) 81  d) 45  e) 80  f) 60    15 .", " Subprogramul f are defini\u0163ia de mai jos.", "Dac\u0103 variabila a este de tip \u00eentreg \u0219i memoreaz\u0103  valorarea 3, preciza\u021bi care va fi valorea pe care o memoreaz\u0103 aceea\u0219i variabil\u0103 a, dup\u0103 apelul  f(a,a); (limbajul Pascal/C++), respectiv f(&a,&a); (\u00een limbajul C).", " Limbajul C++  Limbajul C    void f(int &x,int &y)  {    x=1;    x=x+y;  }  void f(int *x, int *y)  {     *x=1;     *x=*x+*y;  }  Limbajul Pascal  procedure f(var x,y: integer);  begin  x:=1;  x:=x+y;  end;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6"], "page_sentence_count_spacy": 12}, {"page_number": 34, "page_char_count": 2138, "page_word_count": 431, "page_sentence_count_raw": 9, "page_token_count": 534.5, "text": "34    Varianta 7    1.  Indica\u0163i care dintre expresiile C++/C/Pascal de mai jos are valoarea true/1 dac\u0103 \u0219i numai  dac\u0103 num\u0103rul memorat \u00een variabila \u00eentreag\u0103 x apar\u0163ine reuniunii de intervale:   [-4, -1]\u222a[1, 4] \u222a[10, \u221e).    Limbajul C++/ Limbajul C  a)x>= -4 && x<= -1 && x>=1 && x<=4 && x>=10  b) !(x<-4 || x>-1) || !(x<1 || x>4) || !(x<10)  c) x>= -4 || x<=-1 || x>=1 || x<=4 || x>=10  d)!(x<-4 && x>4 && x>-1 || x<1 && x>=10)  e) !(x<-4 || x>-1) && !(x<1 || x>4) || !(x<10)  f) !(x<-4 || x>-1) && !(x<1 || x>4) && !(x<10)   Limbajul Pascal  a) (x>= -4) and (x<= -1) and ( x>=1) and (x<=4) and (x>=10)  b) not((x<-4) or ( x>-1)) or not((x<1)or (x>4)) or not(x<10)  c) (x>= -4) or (x<=-1) or (x>=1) or (x<=4) or (x>=10)  d) not((x<-4) and (x>4) and (x>-1) or (x<1) and (x>=10))  e) not((x<-4) or ( x>-1)) and not((x<1)or (x>4)) or not(x<10)  f) not((x<-4) or ( x>-1)) and not((x<1)or (x>4)) and not(x<10)      2.  Indica\u021bi expresia C++/C/Pascal care are valoarea true /1:   Limbajul C++/ Limbajul C  Limbajul Pascal    a) floor(5)+1 == ceil(5)   b) floor(5.49) == ceil(5.49)  c) floor(5.19) == floor(5.91)   d) floor(5.91) == ceil(5.19)  e) floor(sqrt(8))==ceil(sqrt(8))  f) sqrt(4) == pow(4,2)  a) trunc(5)+1 = round(5)   b) trunc(5.19) = round(5.91)  c) trunc(5.19) = trunc(5.91)    d) round(5.91) = round(5.19)  e) round(sqrt(8))=trunc(sqrt(8))  f) sqrt(4) = sqr(4)     3.  Se consider\u0103 dou\u0103 tablouri unidimensionale A \u015fi B. \u0218tiind c\u0103 A=(7,10,12,18,20), iar \u00een  urma interclas\u0103rii tablourilor A \u015fi B, \u00een ordine descresc\u0103toare, se ob\u0163ine tabloul cu elementele  (46,20,18,17,12,10,10,7,4,3). Atunci tabloul B poate fi:   a) (3,4,17,46)  b) (3,4,10,46)  c) (3,4,10,17)  d) (3,4,10,17,46)   e) (46,17,4,3)  f) (46,10,4,3)    4.  Pentru  a  verifica  dac\u0103  \u00eentr-un  tablou  unidimensional  av\u00e2nd  elementele  (3,4,7,10,12,17,18,20,46) exist\u0103 elementul cu valoarea x=17, se aplic\u0103 metoda  c\u0103ut\u0103rii binare. \u015etiind c\u0103 numerotarea elementelor, \u00een tablou, se realizeaz\u0103 \u00eencep\u00e2nd cu pozi\u0163ia  0, care este num\u0103rul minim de elemente ale tabloului care trebuie verificate pentru a g\u0103si  elementul c\u0103utat?   a)  6  b) 2    c)  9    d)5   e) 3   f) 1", "sentences": ["34    Varianta 7    1.", " Indica\u0163i care dintre expresiile C++/C/Pascal de mai jos are valoarea true/1 dac\u0103 \u0219i numai  dac\u0103 num\u0103rul memorat \u00een variabila \u00eentreag\u0103 x apar\u0163ine reuniunii de intervale:   [-4, -1]\u222a[1, 4] \u222a[10, \u221e).", "   Limbajul C++/ Limbajul C  a)x>= -4 && x<= -1 && x>=1 && x<=4 && x>=10  b) !(", "x<-4 || x>-1) || !(", "x<1 || x>4) || !(", "x<10)  c) x>= -4 || x<=-1 || x>=1 || x<=4 || x>=10  d)!(x<-4 && x>4 && x>-1 || x<1 && x>=10)  e) !(", "x<-4 || x>-1) && !(", "x<1 || x>4) || !(", "x<10)  f) !(", "x<-4 || x>-1) && !(", "x<1 || x>4) && !(", "x<10)   Limbajul Pascal  a) (x>= -4) and (x<= -1) and ( x>=1) and (x<=4) and (x>=10)  b) not((x<-4) or ( x>-1)) or not((x<1)or (x>4)) or not(x<10)  c) (x>= -4) or (x<=-1) or (x>=1) or (x<=4) or (x>=10)  d) not((x<-4) and (x>4) and (x>-1) or (x<1) and (x>=10))  e) not((x<-4) or ( x>-1)) and not((x<1)or (x>4)) or not(x<10)  f) not((x<-4) or ( x>-1)) and not((x<1)or (x>4)) and not(x<10)      2.", " Indica\u021bi expresia C++/C/Pascal care are valoarea true /1:   Limbajul C++/ Limbajul C  Limbajul Pascal    a) floor(5)+1 == ceil(5)   b) floor(5.49) == ceil(5.49)  c) floor(5.19) == floor(5.91)   d) floor(5.91) == ceil(5.19)  e) floor(sqrt(8))==ceil(sqrt(8))  f) sqrt(4) == pow(4,2)  a) trunc(5)+1 = round(5)   b) trunc(5.19) = round(5.91)  c) trunc(5.19) = trunc(5.91)    d) round(5.91) = round(5.19)  e) round(sqrt(8))=trunc(sqrt(8))  f) sqrt(4) = sqr(4)     3.", " Se consider\u0103 dou\u0103 tablouri unidimensionale A \u015fi B. \u0218tiind c\u0103 A=(7,10,12,18,20), iar \u00een  urma interclas\u0103rii tablourilor A \u015fi B, \u00een ordine descresc\u0103toare, se ob\u0163ine tabloul cu elementele  (46,20,18,17,12,10,10,7,4,3).", "Atunci tabloul B poate fi:   a) (3,4,17,46)  b) (3,4,10,46)  c) (3,4,10,17)  d) (3,4,10,17,46)   e) (46,17,4,3)  f) (46,10,4,3)    4.", " Pentru  a  verifica  dac\u0103  \u00eentr-un  tablou  unidimensional  av\u00e2nd  elementele  (3,4,7,10,12,17,18,20,46) exist\u0103 elementul cu valoarea x=17, se aplic\u0103 metoda  c\u0103ut\u0103rii binare.", "\u015etiind c\u0103 numerotarea elementelor, \u00een tablou, se realizeaz\u0103 \u00eencep\u00e2nd cu pozi\u0163ia  0, care este num\u0103rul minim de elemente ale tabloului care trebuie verificate pentru a g\u0103si  elementul c\u0103utat?", "  a)  6  b) 2    c)  9    d)5   e) 3   f) 1"], "page_sentence_count_spacy": 18}, {"page_number": 35, "page_char_count": 1924, "page_word_count": 455, "page_sentence_count_raw": 8, "page_token_count": 481.0, "text": "35      5.  Variabila x este de tip real \u0219i poate memora un num\u0103r real din intervalul [32,48]. Num\u0103rul  valorilor distincte pe care le poate  avea expresia urm\u0103toare este:   Limbajul C++/C  Limbajul Pascal  floor(sqrt(x+1))    trunc(sqrt(x+1))    a) 17   b) 1  c) 0   d)2  e) 4   f) 3    6.  Un grup format din \u015fase prieteni (Andrei, Bogdan, Claudiu, Daniel, Emil,  Florin) dore\u015fte s\u0103 participe la o competi\u0163ie de baschet pentru echipe formate din c\u00e2te trei  juc\u0103tori. \u015etiind c\u0103 echipa Andrei, Bogdan, Claudiu este identic\u0103 cu echipa Bogdan,  Claudiu, Andrei, preciza\u021bi care este num\u0103rul de echipe care se pot forma cu cei \u015fase  prieteni.  a) 2  b)720  c) 120  d) 20  e) 6  f) 3    7.  Fie subprogramul recursiv urm\u0103tor:  Limbajul C++  Limbajul C  Limbajul Pascal  void ex(char c)  { if (c>'a')             ex(c-1);     cout<< c;     if (c>'a')             ex(c-1);  }  void ex(char c)  { if (c>'a')             ex(c-1);     printf(\"%c\", c);    if (c>'a')             ex(c-1);  }  procedure ex(c:char);  begin   if (c>'a') then                ex(pred(c));    write(c);    if (c>'a') then    ex(pred(c));  end;  Indica\u021bi num\u0103rul de autoapeluri ale subprogramului dac\u0103 se apeleaz\u0103 ex(\u2019c\u2019):  a) 0  b) 1  c) 7  d)3  e) 6  f)5     8.  \u020antr-un program C++/C/Pascal  \u00een care a este o variabil\u0103 de tip \u00eentreg, se citesc datele din  fi\u015fierul \u201cadmitere.dat\u201d utiliz\u00e2nd urm\u0103toarea instruc\u0163iune:  Limbajul C++  Limbajul C  Limbajul Pascal  f>>a;     fscanf(f, \"%d\", &a);  readln ( f, a);  Preciza\u0163i care este forma corect\u0103 a instruc\u0163iunii ce are ca efect \u00eenchiderea fi\u015fierului utilizat:  Limbajul C++  Limbajul C  Limbajul Pascal  a) close(f);  b)close(admitere);  c)admitere.close();  d) close.admitere;  e) close.f;  f) f.close();  a)fclose(admitere);  b)close(admitere);  c)close(f);  d)admitere(close);  e)close.f  f)fclose(f);  a) f.close();  b) admitere.close();  c) close(admitere);  d) admitere(close);  e) close.f;  f) close(f);", "sentences": ["35      5.", " Variabila x este de tip real \u0219i poate memora un num\u0103r real din intervalul [32,48].", "Num\u0103rul  valorilor distincte pe care le poate  avea expresia urm\u0103toare este:   Limbajul C++/C  Limbajul Pascal  floor(sqrt(x+1))    trunc(sqrt(x+1))    a) 17   b) 1  c) 0   d)2  e) 4   f) 3    6.", " Un grup format din \u015fase prieteni (Andrei, Bogdan, Claudiu, Daniel, Emil,  Florin) dore\u015fte s\u0103 participe la o competi\u0163ie de baschet pentru echipe formate din c\u00e2te trei  juc\u0103tori.", "\u015etiind c\u0103 echipa Andrei, Bogdan, Claudiu este identic\u0103 cu echipa Bogdan,  Claudiu, Andrei, preciza\u021bi care este num\u0103rul de echipe care se pot forma cu cei \u015fase  prieteni.", " a) 2  b)720  c) 120  d) 20  e) 6  f) 3    7.", " Fie subprogramul recursiv urm\u0103tor:  Limbajul C++  Limbajul C  Limbajul Pascal  void ex(char c)  { if (c>'a')             ex(c-1);     cout<< c;     if (c>'a')             ex(c-1);  }  void ex(char c)  { if (c>'a')             ex(c-1);     printf(\"%c\", c);    if (c>'a')             ex(c-1);  }  procedure ex(c:char);  begin   if (c>'a') then                ex(pred(c));    write(c);    if (c>'a') then    ex(pred(c));  end;  Indica\u021bi num\u0103rul de autoapeluri ale subprogramului dac\u0103 se apeleaz\u0103 ex(\u2019c\u2019):  a) 0  b) 1  c) 7  d)3  e) 6  f)5     8.", " \u020antr-un program C++/C/Pascal  \u00een care a este o variabil\u0103 de tip \u00eentreg, se citesc datele din  fi\u015fierul \u201cadmitere.dat\u201d utiliz\u00e2nd urm\u0103toarea instruc\u0163iune:  Limbajul C++  Limbajul C  Limbajul Pascal  f>>a;     fscanf(f, \"%d\", &a);  readln ( f, a);  Preciza\u0163i care este forma corect\u0103 a instruc\u0163iunii ce are ca efect \u00eenchiderea fi\u015fierului utilizat:  Limbajul C++  Limbajul C  Limbajul Pascal  a) close(f);  b)close(admitere);  c)admitere.close();  d) close.admitere;  e) close.f;  f) f.close();  a)fclose(admitere);  b)close(admitere);  c)close(f);  d)admitere(close);  e)close.f  f)fclose(f);  a) f.close();  b) admitere.close();  c) close(admitere);  d) admitere(close);  e) close.f;  f) close(f);"], "page_sentence_count_spacy": 8}, {"page_number": 36, "page_char_count": 1814, "page_word_count": 410, "page_sentence_count_raw": 6, "page_token_count": 453.5, "text": "36    9.  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de instruc\u0163iuni:  Limbajul C++   Limbajul C  Limbajul Pascal  char cif; int cifra;  cin>>cif;     cifra = cif \u2013 '0';  cout<< cifra;     char cif; int cifra;   scanf(\"%c\", &cif);   cifra = cif-'0';  printf (\"%d\", cifra);  var cif: char;       cifra: integer;  begin   read(cif);  cifra:=ord(cif)-ord('0');   write (cifra);  end.  Preciza\u021bi ce se afi\u015feaz\u0103 dup\u0103 executarea acestei secven\u0163e dac\u0103, \u00een urma opera\u0163iei de citire,  variabila cif con\u0163ine caracterul \u20199\u2019.  a) instruc\u0163iunea de atribuire    cifra:=ord(cif)-ord('0');  {Pascal}   cifra = cif \u2013 '0'; //C++/C    este incorect\u0103  b) '9'  c) 9  d) 0  e) '0' f) 57    10 .  Variabila c definit\u0103 mai jos, memoreaz\u0103 codul, cele dou\u0103 note ob\u0163inute la probele matematic\u0103  \u015fi informatic\u0103 din cadrul concursului de admitere la Facultatea de Automatic\u0103 \u015fi Calculatoare,  precum \u015fi media ob\u0163inut\u0103 la examenul de bacalaureat pentru un candidat.  Limbajul C++  Limbajul C  Limbajul Pascal  typedef struct      {     unsigned  cod;    float p1, p2;     float medbac;  }candidat ;  candidat c;  typedef struct {     unsigned  cod;    float p1, p2;     float medbac;  }candidat;  candidat c;  type candidat=record              cod: word;           p1, p2: real;           medbac: real;                   end;  var c: candidat;  Preciza\u0163i care este expresia corect\u0103 ce poate fi utilizat\u0103 pentru a verifica dac\u0103 un candidat  \u00eendepline\u015fte baremul minim de admitere (media de admitere este minimum 5):    a) (p1+p2)/2*0.8 + medbac*0.2 >= 5.0  b) (candidat.p1 + candidat.p2)*0.8 + candidat.medbac*0.2 >= 5.0  c) (candidat.c.p1 + candidat.c.p2)*0.8 + candidat.c.medbac*0.2 >= 5.0  d) (c.p1 + c.p2)/2*0.8 + c.medbac*0.2 >= 5.0  e) ((candidat.p1 + candidat.p2)*0.8 + candidat.medbac*0.2) >= 5.0  f) 80/100*(c.p1 + c.p2)/2+ 20/100*c.medbac >= 5.0", "sentences": ["36    9.", " Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de instruc\u0163iuni:  Limbajul C++   Limbajul C  Limbajul Pascal  char cif; int cifra;  cin>>cif;     cifra = cif \u2013 '0';  cout<< cifra;     char cif; int cifra;   scanf(\"%c\", &cif);   cifra = cif-'0';  printf (\"%d\", cifra);  var cif: char;       cifra: integer;  begin   read(cif);  cifra:=ord(cif)-ord('0');   write (cifra);  end.", " Preciza\u021bi ce se afi\u015feaz\u0103 dup\u0103 executarea acestei secven\u0163e dac\u0103, \u00een urma opera\u0163iei de citire,  variabila cif con\u0163ine caracterul \u20199\u2019.", " a) instruc\u0163iunea de atribuire    cifra:=ord(cif)-ord('0');  {Pascal}   cifra = cif \u2013 '0'; //C++/C    este incorect\u0103  b) '9'  c) 9  d) 0  e) '0' f) 57    10 .", " Variabila c definit\u0103 mai jos, memoreaz\u0103 codul, cele dou\u0103 note ob\u0163inute la probele matematic\u0103  \u015fi informatic\u0103 din cadrul concursului de admitere la Facultatea de Automatic\u0103 \u015fi Calculatoare,  precum \u015fi media ob\u0163inut\u0103 la examenul de bacalaureat pentru un candidat.", " Limbajul C++  Limbajul C  Limbajul Pascal  typedef struct      {     unsigned  cod;    float p1, p2;     float medbac;  }candidat ;  candidat c;  typedef struct {     unsigned  cod;    float p1, p2;     float medbac;  }candidat;  candidat c;  type candidat=record              cod: word;           p1, p2: real;           medbac: real;                   end;  var c: candidat;  Preciza\u0163i care este expresia corect\u0103 ce poate fi utilizat\u0103 pentru a verifica dac\u0103 un candidat  \u00eendepline\u015fte baremul minim de admitere (media de admitere este minimum 5):    a) (p1+p2)/2*0.8 + medbac*0.2 >= 5.0  b) (candidat.p1 + candidat.p2)*0.8 + candidat.medbac*0.2 >= 5.0  c) (candidat.c.p1 + candidat.c.p2)*0.8 + candidat.c.medbac*0.2 >= 5.0  d) (c.p1 + c.p2)/2*0.8 + c.medbac*0.2 >= 5.0  e) ((candidat.p1 + candidat.p2)*0.8 + candidat.medbac*0.2) >= 5.0  f) 80/100*(c.p1 + c.p2)/2+ 20/100*c.medbac >= 5.0"], "page_sentence_count_spacy": 6}, {"page_number": 37, "page_char_count": 2001, "page_word_count": 435, "page_sentence_count_raw": 13, "page_token_count": 500.25, "text": "37    11. Preciza\u0163i care este antetul corect al unui subprogram (definit de utilizator) care returneaz\u0103  prima \u015fi ultima cifr\u0103 a unui num\u0103r natural n, f\u0103r\u0103 a permite modificarea parametrului n.  Limbajul C++  a) unsigned cifre (unsigned n)  b) unsigned cifre (unsigned n, unsigned prim, unsigned ult)  c) void cifre (unsigned n, unsigned prim, unsigned ult)  d) void cifre (unsigned n, unsigned &prim, unsigned &ult)  e) void cifre (unsigned &n, unsigned &prim, unsigned &ult)  f) void cifre (unsigned &n)  Limbajul C  a) unsigned cifre (unsigned n)  b) unsigned cifre (unsigned n, unsigned prim, unsigned ult)  c) void cifre (unsigned n, unsigned prim, unsigned ult)  d) void cifre (unsigned n, unsigned *prim, unsigned *ult)  e) void cifre (unsigned *n, unsigned *prim, unsigned *ult)  f) void cifre (unsigned *n)  Limbajul  Pascal  a) function cifre (n: longint): byte;  b) function cifre (n: longint; prim,ult: byte): byte;  c) procedure cifre (n: longint; prim,ult: byte);  d) procedure cifre (n: longint; var prim,ult: byte);  e) procedure cifre (var n: longint; var prim,ult: byte);  f) procedure cifre (var n: longint);      12.  PrecizPreciza\u021bi care sunt num\u0103rul maxim, respectiv num\u0103rul minim de componente conexe pentru un  graf neorientat cu 16 noduri \u015fi 16 muchii?  a) 1 \u015fi 1      b) 11 \u015fi 2       c) 2 \u015fi 1  d) 16 \u015fi 1  e) 11 \u015fi 1  f) 10 \u015fi 1    13. Preciza\u021bi care sunt num\u0103rul minim \u0219i num\u0103rul maxim de arce ale unui graf orientat tare conex  cu 15 v\u00e2rfuri.    a) 14 \u0219i 105    b) 15 \u0219i 105  c) 15 \u0219i 210  d) 14 \u0219i 210   e) 15 \u015fi 15  f) 14 \u0219i 15      14. Dac\u0103 G este un graf neorientat eulerian cu 10 noduri \u015fi 16 muchii, iar lista de adiacen\u0163\u0103 a  fiec\u0103rui nod din G este format\u0103 din cel pu\u021bin un element, preciza\u021bi care dintre afirma\u021biile de  mai jos sunt \u00eentotdeauna adev\u0103rate.   1. G este conex   2. G are cel pu\u021bin un nod de grad egal cu 2   3. G este hamiltonian   4. G nu poate con\u021bine cicluri elementare de lungime 3.     a) toate  b)niciuna  c) 1, 2, 3  d) 2, 3  e) 3, 4  f) 1, 2", "sentences": ["37    11.", "Preciza\u0163i care este antetul corect al unui subprogram (definit de utilizator) care returneaz\u0103  prima \u015fi ultima cifr\u0103 a unui num\u0103r natural n, f\u0103r\u0103 a permite modificarea parametrului n.  Limbajul C++  a) unsigned cifre (unsigned n)  b) unsigned cifre (unsigned n, unsigned prim, unsigned ult)  c) void cifre (unsigned n, unsigned prim, unsigned ult)  d) void cifre (unsigned n, unsigned &prim, unsigned &ult)  e) void cifre (unsigned &n, unsigned &prim, unsigned &ult)  f) void cifre (unsigned &n)  Limbajul C  a) unsigned cifre (unsigned n)  b) unsigned cifre (unsigned n, unsigned prim, unsigned ult)  c) void cifre (unsigned n, unsigned prim, unsigned ult)  d) void cifre (unsigned n, unsigned *prim, unsigned *ult)  e) void cifre (unsigned *n, unsigned *prim, unsigned *ult)  f) void cifre (unsigned *n)  Limbajul  Pascal  a) function cifre (n: longint): byte;  b) function cifre (n: longint; prim,ult: byte): byte;  c) procedure cifre (n: longint; prim,ult: byte);  d) procedure cifre (n: longint; var prim,ult: byte);  e) procedure cifre (var n: longint; var prim,ult: byte);  f) procedure cifre (var n: longint);      12.", " PrecizPreciza\u021bi care sunt num\u0103rul maxim, respectiv num\u0103rul minim de componente conexe pentru un  graf neorientat cu 16 noduri \u015fi 16 muchii?", " a) 1 \u015fi 1      b) 11 \u015fi 2       c) 2 \u015fi 1  d) 16 \u015fi 1  e) 11 \u015fi 1  f) 10 \u015fi 1    13.", "Preciza\u021bi care sunt num\u0103rul minim \u0219i num\u0103rul maxim de arce ale unui graf orientat tare conex  cu 15 v\u00e2rfuri.", "   a) 14 \u0219i 105    b) 15 \u0219i 105  c) 15 \u0219i 210  d) 14 \u0219i 210   e) 15 \u015fi 15  f) 14 \u0219i 15      14.", "Dac\u0103 G este un graf neorientat eulerian cu 10 noduri \u015fi 16 muchii, iar lista de adiacen\u0163\u0103 a  fiec\u0103rui nod din G este format\u0103 din cel pu\u021bin un element, preciza\u021bi care dintre afirma\u021biile de  mai jos sunt \u00eentotdeauna adev\u0103rate.", "  1.", "G este conex   2.", "G are cel pu\u021bin un nod de grad egal cu 2   3.", "G este hamiltonian   4.", "G nu poate con\u021bine cicluri elementare de lungime 3.", "    a) toate  b)niciuna  c) 1, 2, 3  d) 2, 3  e) 3, 4  f) 1, 2"], "page_sentence_count_spacy": 13}, {"page_number": 38, "page_char_count": 378, "page_word_count": 94, "page_sentence_count_raw": 4, "page_token_count": 94.5, "text": "38    15. Un arbore binar este un arbore cu r\u0103d\u0103cin\u0103 \u00een care orice nod are cel mult doi fii. \u020an\u0103l\u021bimea  unui arbore binar este dat\u0103 de lungimea celui mai lung lan\u0163 elementar care are una dintre  extremit\u0103\u0163i \u00een r\u0103d\u0103cin\u0103 \u015fi cealalt\u0103 \u00een oricare dintre frunze. Num\u0103rul maxim de noduri dintr-un  arbore binar de \u00een\u0103l\u021bime 5 este:  a) 31     b) 15     c) 32      d) 63  e) 64      f) 6", "sentences": ["38    15.", "Un arbore binar este un arbore cu r\u0103d\u0103cin\u0103 \u00een care orice nod are cel mult doi fii.", "\u020an\u0103l\u021bimea  unui arbore binar este dat\u0103 de lungimea celui mai lung lan\u0163 elementar care are una dintre  extremit\u0103\u0163i \u00een r\u0103d\u0103cin\u0103 \u015fi cealalt\u0103 \u00een oricare dintre frunze.", "Num\u0103rul maxim de noduri dintr-un  arbore binar de \u00een\u0103l\u021bime 5 este:  a) 31     b) 15     c) 32      d) 63  e) 64      f) 6"], "page_sentence_count_spacy": 4}, {"page_number": 39, "page_char_count": 2316, "page_word_count": 421, "page_sentence_count_raw": 9, "page_token_count": 579.0, "text": "39      Varianta 8    1.  Indica\u0163i care dintre expresiile C++/C/Pascal de mai jos are valoarea true/1, dac\u0103 \u0219i  numai  dac\u0103 num\u0103rul memorat \u00een variabila \u00eentreag\u0103 x nu apar\u0163ine reuniunii de intervale:   [-4,-1]\u222a[1,4] \u222a[10,\u221e).    Limbajul C++/ Limbajul C  a) !((x>=-4 && x<=-1)&&(x>=1 && x<=4)&&(x>=10))  b) (x<-4 || x>-1) || (x<1 || x>4) || (x<10)  c) (x<-4 && x>-1) || (x<1 && x>4) || (x<10)  d) !(x<-4 && x>4 && x>-1 || x<1 && x>=10)  e) !((x>=-4 && x<=-1)||(x>=1 && x<=4)||(x>=10))  f) !(x>=-4 && x<=-1)||!(x>=1 && x<=4)||!(x>=10)    Limbajul Pascal  a) not((x>=-4 and x<=-1)and(x>=1 and x<=4)and(x>=10))  b) (x<-4 or x>-1) or (x<1 or x>4) or (x<10)  c) (x<-4 and x>-1) or (x<1 and x>4) or (x<10)  d) not(x<-4 and x>4 and x>-1 or x<1 and x>=10)  e) not((x>=-4 and x<=-1)or(x>=1 and x<=4)or(x>=10))  f) not(x>=-4 and x<=-1)or not(x>=1 and x<=4)or not(x>=10)    2.  O expresie C++/C/Pascal care are valoarea true /1 este:   Limbajul C++/ Limbajul C  Limbajul Pascal    a) floor(5)+1 == ceil(5)   b) floor(5.49) == ceil(5.49)  c) floor(5.19) == floor(5.91)   d) floor(5.91) == ceil(5.91)  e) floor(sqrt(8))==ceil(sqrt(8))  f) sqrt(4) == pow(4,2)  a) trunc(5)+1=round(5)   b) trunc(5.19)=round(5.91)  c) trunc(5.19)=trunc(5.91)    d) trunc(5.91)=round(5.91)  e) round(sqrt(8))=trunc(sqrt(8))  f) sqrt(4) = sqr(4)      3.  Pentru a verifica dac\u0103 \u00eentr-un tablou unidimensional exist\u0103 elementul cu valoarea x=17, se  aplic\u0103 metoda c\u0103ut\u0103rii binare, iar succesiunea de elemente ale tabloului a c\u0103ror valoare se  compar\u0103 cu valoarea lui x, pe parcursul aplic\u0103rii metodei indicate, este: 12,18,17.  Numerotarea elementelor, \u00een tablou, se realizeaz\u0103 \u00eencep\u00e2nd cu pozi\u0163ia 0. Elementele tabloului  pot fi (\u00een ordinea \u00een care apar \u00een tablou):   a) (3,4,7,12,15,17,18,20)     b) (3,7,8,10,12,17,18,20,46)  c) (4,7,12,17,18,20,46)  d) (3,4,7,10,12,18,17,20)     e) (3,7,8,10,12,17,18,20)  f) (3,4,7,10,12,17,18,20,46)    4.  Se consider\u0103 dou\u0103 tablouri unidimensionale A \u015fi B. \u0218tiind c\u0103 \u00een urma interclas\u0103rii  tablourilor  A  \u015fi  B  \u00een  ordine  descresc\u0103toare  se  ob\u0163ine  tabloul  cu  elementele:  (46,20,18,17,12,10,10,7,4,3),  o variant\u0103 corect\u0103 pentru valorile celor dou\u0103  tablouri este:    a)(3,4,17,46) \u015fi (7,10,12,18,20)     b)(7,10,12,18) \u015fi (46,17,4,3)    c)(3,4,10,46) \u015fi (7,10,12,18,20)    d)(7,10,12,18,20) \u015fi (46,17,4,3)", "sentences": ["39      Varianta 8    1.", " Indica\u0163i care dintre expresiile C++/C/Pascal de mai jos are valoarea true/1, dac\u0103 \u0219i  numai  dac\u0103 num\u0103rul memorat \u00een variabila \u00eentreag\u0103 x nu apar\u0163ine reuniunii de intervale:   [-4,-1]\u222a[1,4] \u222a[10,\u221e).", "   Limbajul C++/ Limbajul C  a) !((", "x>=-4 && x<=-1)&&(x>=1 && x<=4)&&(x>=10))  b) (x<-4 || x>-1) || (x<1 || x>4) || (x<10)  c) (x<-4 && x>-1) || (x<1 && x>4) || (x<10)  d) !(", "x<-4 && x>4 && x>-1 || x<1 && x>=10)  e) !((", "x>=-4 && x<=-1)||(x>=1 && x<=4)||(x>=10))  f) !(", "x>=-4 && x<=-1)||!(x>=1 && x<=4)||!(x>=10)    Limbajul Pascal  a) not((x>=-4 and x<=-1)and(x>=1 and x<=4)and(x>=10))  b) (x<-4 or x>-1) or (x<1 or x>4) or (x<10)  c) (x<-4 and x>-1) or (x<1 and x>4) or (x<10)  d) not(x<-4 and x>4 and x>-1 or x<1 and x>=10)  e) not((x>=-4 and x<=-1)or(x>=1 and x<=4)or(x>=10))  f) not(x>=-4 and x<=-1)or not(x>=1 and x<=4)or not(x>=10)    2.", " O expresie C++/C/Pascal care are valoarea true /1 este:   Limbajul C++/ Limbajul C  Limbajul Pascal    a) floor(5)+1 == ceil(5)   b) floor(5.49) == ceil(5.49)  c) floor(5.19) == floor(5.91)   d) floor(5.91) == ceil(5.91)  e) floor(sqrt(8))==ceil(sqrt(8))  f) sqrt(4) == pow(4,2)  a) trunc(5)+1=round(5)   b) trunc(5.19)=round(5.91)  c) trunc(5.19)=trunc(5.91)    d) trunc(5.91)=round(5.91)  e) round(sqrt(8))=trunc(sqrt(8))  f) sqrt(4) = sqr(4)      3.", " Pentru a verifica dac\u0103 \u00eentr-un tablou unidimensional exist\u0103 elementul cu valoarea x=17, se  aplic\u0103 metoda c\u0103ut\u0103rii binare, iar succesiunea de elemente ale tabloului a c\u0103ror valoare se  compar\u0103 cu valoarea lui x, pe parcursul aplic\u0103rii metodei indicate, este: 12,18,17.", " Numerotarea elementelor, \u00een tablou, se realizeaz\u0103 \u00eencep\u00e2nd cu pozi\u0163ia 0.", "Elementele tabloului  pot fi (\u00een ordinea \u00een care apar \u00een tablou):   a) (3,4,7,12,15,17,18,20)     b) (3,7,8,10,12,17,18,20,46)  c) (4,7,12,17,18,20,46)  d) (3,4,7,10,12,18,17,20)     e) (3,7,8,10,12,17,18,20)  f) (3,4,7,10,12,17,18,20,46)    4.", " Se consider\u0103 dou\u0103 tablouri unidimensionale A \u015fi B. \u0218tiind c\u0103 \u00een urma interclas\u0103rii  tablourilor  A  \u015fi  B  \u00een  ordine  descresc\u0103toare  se  ob\u0163ine  tabloul  cu  elementele:  (46,20,18,17,12,10,10,7,4,3),  o variant\u0103 corect\u0103 pentru valorile celor dou\u0103  tablouri este:    a)(3,4,17,46) \u015fi (7,10,12,18,20)     b)(7,10,12,18) \u015fi (46,17,4,3)    c)(3,4,10,46) \u015fi (7,10,12,18,20)    d)(7,10,12,18,20) \u015fi (46,17,4,3)"], "page_sentence_count_spacy": 12}, {"page_number": 40, "page_char_count": 2056, "page_word_count": 532, "page_sentence_count_raw": 10, "page_token_count": 514.0, "text": "40    e)(3,4,10,17,46) \u015fi (7,10,12,18,20)  f)(3,4,17,46) \u015fi (7,10,12,20)          5.  Variabila x este de tip \u00eentreg \u0219i poate memora un num\u0103r natural format din exact dou\u0103 cifre.  Indica\u0163i cea mai mare valoare pe care o poate avea expresia :   Limbajul C++/ Limbajul C   Limbajul Pascal  abs(x/10-x%10)  abs(x div 10- x mod 10)  este:  a) 1  b) 10  c) 9  d) 8  e)5  f)0    6.  O echip\u0103 profesionist\u0103 de ciclism este alc\u0103tuit\u0103 din  8 sportivi. La fiecare mare tur  particip\u0103 doar cu un lot format din 4 cicli\u015fti. Preciza\u021bi care este num\u0103rul de variante  pentru formarea lotului de cicli\u0219ti ce pot concura la Turul Fran\u0163ei \u00een anul 2020.  a) 40320  b)0  c) 1680  d) 70  e)8  f) 4    7.  Fie subprogramul recursiv urm\u0103tor \u00een care n este un num\u0103r natural nenul:  Limbajul C++/ Limbajul C  Limbajul Pascal  unsigned ex(unsigned n)  { unsigned a;     if (n == 0) return 9;       else        { a= ex(n / 10);          if ( n % 10 < a )             return n%10;          return a;       }  }  function ex(n:longint): byte;  var a: byte;  begin     if n=0 then ex:=9         else begin           a:= ex(n div 10);           if n mod 10 < a then                 ex:= n mod 10              else ex:=a;             end;  end;  Preciza\u021bi pentru care dintre valorile urm\u0103toare se va returna un num\u0103r impar la apelul  func\u0163iei ex(n).  a) 90  b) 98  c) 709  d) 340  e) 512  f) 256    8.  \u020antr-un program C++/C/Pascal, variabila a este de tip \u00eentreg, iar datele din fi\u015fierul  \u201ccandidati.dat\u201d se citesc utiliz\u00e2nd urm\u0103toarea instruc\u0163iune:  Limbajul C++  Limbajul C  Limbajul Pascal  f>>a;  fscanf(f, \"%d\", &a);  readln ( f, a);  Preciza\u0163i care este forma corect\u0103 a instruc\u0163iunii ce are ca efect \u00eenchiderea fi\u015fierului utilizat:  Limbajul C++  Limbajul C  Limbajul Pascal  a) close(f);  b) close(candidati);  c) candidati.close();  d) f.close();  e) close.f;  f) f(close);  a) fclose(candidati);  b) close(candidati);  c) close(f);  d) fclose(f);  e) close.f;  f) f(close);  a) f.close();  b)candidati.close();  c)close(candidati);  d)close(f);  e)f(close);  f)close(candidati);", "sentences": ["40    e)(3,4,10,17,46) \u015fi (7,10,12,18,20)  f)(3,4,17,46) \u015fi (7,10,12,20)          5.", " Variabila x este de tip \u00eentreg \u0219i poate memora un num\u0103r natural format din exact dou\u0103 cifre.", " Indica\u0163i cea mai mare valoare pe care o poate avea expresia :   Limbajul C++/ Limbajul C   Limbajul Pascal  abs(x/10-x%10)  abs(x div 10- x mod 10)  este:  a) 1  b) 10  c) 9  d) 8  e)5  f)0    6.", " O echip\u0103 profesionist\u0103 de ciclism este alc\u0103tuit\u0103 din  8 sportivi.", "La fiecare mare tur  particip\u0103 doar cu un lot format din 4 cicli\u015fti.", "Preciza\u021bi care este num\u0103rul de variante  pentru formarea lotului de cicli\u0219ti ce pot concura la Turul Fran\u0163ei \u00een anul 2020.", " a) 40320  b)0  c) 1680  d) 70  e)8  f) 4    7.", " Fie subprogramul recursiv urm\u0103tor \u00een care n este un num\u0103r natural nenul:  Limbajul C++/ Limbajul C  Limbajul Pascal  unsigned ex(unsigned n)  { unsigned a;     if (n == 0) return 9;       else        { a= ex(n / 10);          if ( n % 10 < a )             return n%10;          return a;       }  }  function ex(n:longint): byte;  var a: byte;  begin     if n=0 then ex:=9         else begin           a:= ex(n div 10);           if n mod 10 < a then                 ex:= n mod 10              else ex:=a;             end;  end;  Preciza\u021bi pentru care dintre valorile urm\u0103toare se va returna un num\u0103r impar la apelul  func\u0163iei ex(n).", " a) 90  b) 98  c) 709  d) 340  e) 512  f) 256    8.", " \u020antr-un program C++/C/Pascal, variabila a este de tip \u00eentreg, iar datele din fi\u015fierul  \u201ccandidati.dat\u201d se citesc utiliz\u00e2nd urm\u0103toarea instruc\u0163iune:  Limbajul C++  Limbajul C  Limbajul Pascal  f>>a;  fscanf(f, \"%d\", &a);  readln ( f, a);  Preciza\u0163i care este forma corect\u0103 a instruc\u0163iunii ce are ca efect \u00eenchiderea fi\u015fierului utilizat:  Limbajul C++  Limbajul C  Limbajul Pascal  a) close(f);  b) close(candidati);  c) candidati.close();  d) f.close();  e) close.f;  f) f(close);  a) fclose(candidati);  b) close(candidati);  c) close(f);  d) fclose(f);  e) close.f;  f) f(close);  a) f.close();  b)candidati.close();  c)close(candidati);  d)close(f);  e)f(close);  f)close(candidati);"], "page_sentence_count_spacy": 10}, {"page_number": 41, "page_char_count": 1964, "page_word_count": 398, "page_sentence_count_raw": 5, "page_token_count": 491.0, "text": "41      9.  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de instruc\u0163iuni:  Limbajul C++  Limbajul C  Limbajul Pascal  char cif; int cifra;  cin>>cifra;  cif = cifra + '0';  cout<<cif;     char cif; int cifra;  scanf(\"%d\", &cifra);  cif = cifra + '0';  printf (\"%c\", cif);  var cif: char;      cifra: integer;  begin    read(cifra);  cif:=chr(cifra+ord('0'));    write (cif);  end.  Preciza\u021bi care este valoarea memorat\u0103 \u00een variabila cif la finalul secven\u021bei dac\u0103, dup\u0103  citire, variabila cifra con\u0163ine valoarea 9.  a) instruc\u0163iunea de atribuire   cif:=chr(cifra+ ord('0'));{Pascal}   cif = cifra + '0'; //C++/C  este  incorect\u0103  b) '9'  c) 9  d) '0'  e) 0  f) 57    10.  Consider\u00e2nd declar\u0103rile de mai jos,   Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct{       unsigned z, l;}datan;  typedef struct{         char nume[30];         char sex;         datan dn;  }elev;  elev e;  type datan=record        z, l: byte; end;  elev=record     nume: string[30];     sex: char;     dn: datan;    end;  var e: elev;  Preciza\u021bi care este expresia corect\u0103 pentru a verifica dac\u0103 elevul este fat\u0103 \u015fi este n\u0103scut\u0103 \u00een  primele zece zile ale lunii iulie:  Limbajul C++/ Limbajul C  a) e.sex=='F' && e.sex=='f' && e.datan.l==7 && e.datan.z<=10  b) (elev.sex=='F' || elev.sex=='f') && (elev.dn.l==7 &&  elev.dn.z<=10)  c) (e.sex=='F' || e.sex=='f') && (e.dn.l==7 && e.dn.z<10)  d) (e.sex=='F' && e.sex=='f') && (e.dn.l==7 && e.dn.z<=10)  e)  e.sex=='F' || e.sex=='f' || e.dn.l==7 && e.dn.z<=10  f) (e.sex=='F' || e.sex=='f') && (e.dn.l==7 && e.dn.z<=10)  Limbajul Pascal  a) (e.sex='F') and (e.sex='f') and (e.datan.l=7) and  (e.datan.z<=10)  b) ((elev.sex='F') or (elev.sex='f')) and (elev.dn.l=7) and  (elev.dn.z<=10)  c) ((e.sex='F') or (e.sex='f')) and ((e.dn.l=7) and (e.dn.z<10))  d) ((e.sex='F') and (e.sex='f')) and (e.dn.l=7) and (e.dn.z<=10)  e) ((e.sex='F') or (e.sex='f')) or (e.dn.l=7) and (e.dn.z<=10)   f) ((e.sex='F') or (e.sex='f')) and (e.dn.l=7) and (e.dn.z<=10)", "sentences": ["41      9.", " Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de instruc\u0163iuni:  Limbajul C++  Limbajul C  Limbajul Pascal  char cif; int cifra;  cin>>cifra;  cif = cifra + '0';  cout<<cif;     char cif; int cifra;  scanf(\"%d\", &cifra);  cif = cifra + '0';  printf (\"%c\", cif);  var cif: char;      cifra: integer;  begin    read(cifra);  cif:=chr(cifra+ord('0'));    write (cif);  end.", " Preciza\u021bi care este valoarea memorat\u0103 \u00een variabila cif la finalul secven\u021bei dac\u0103, dup\u0103  citire, variabila cifra con\u0163ine valoarea 9.", " a) instruc\u0163iunea de atribuire   cif:=chr(cifra+ ord('0'));{Pascal}   cif = cifra + '0'; //C++/C  este  incorect\u0103  b) '9'  c) 9  d) '0'  e) 0  f) 57    10.", " Consider\u00e2nd declar\u0103rile de mai jos,   Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct{       unsigned z, l;}datan;  typedef struct{         char nume[30];         char sex;         datan dn;  }elev;  elev e;  type datan=record        z, l: byte; end;  elev=record     nume: string[30];     sex: char;     dn: datan;    end;  var e: elev;  Preciza\u021bi care este expresia corect\u0103 pentru a verifica dac\u0103 elevul este fat\u0103 \u015fi este n\u0103scut\u0103 \u00een  primele zece zile ale lunii iulie:  Limbajul C++/ Limbajul C  a) e.sex=='F' && e.sex=='f' && e.datan.l==7 && e.datan.z<=10  b) (elev.sex=='F' || elev.sex=='f') && (elev.dn.l==7 &&  elev.dn.z<=10)  c) (e.sex=='F' || e.sex=='f') && (e.dn.l==7 && e.dn.z<10)  d) (e.sex=='F' && e.sex=='f') && (e.dn.l==7 && e.dn.z<=10)  e)  e.sex=='F' || e.sex=='f' || e.dn.l==7 && e.dn.z<=10  f) (e.sex=='F' || e.sex=='f') && (e.dn.l==7 && e.dn.z<=10)  Limbajul Pascal  a) (e.sex='F') and (e.sex='f') and (e.datan.l=7) and  (e.datan.z<=10)  b) ((elev.sex='F') or (elev.sex='f')) and (elev.dn.l=7) and  (elev.dn.z<=10)  c) ((e.sex='F') or (e.sex='f')) and ((e.dn.l=7) and (e.dn.z<10))  d) ((e.sex='F') and (e.sex='f')) and (e.dn.l=7) and (e.dn.z<=10)  e) ((e.sex='F') or (e.sex='f')) or (e.dn.l=7) and (e.dn.z<=10)   f) ((e.sex='F') or (e.sex='f')) and (e.dn.l=7) and (e.dn.z<=10)"], "page_sentence_count_spacy": 5}, {"page_number": 42, "page_char_count": 1782, "page_word_count": 448, "page_sentence_count_raw": 8, "page_token_count": 445.5, "text": "42    11.  Pentru subprogramul urm\u0103tor:  Limbajul C++/ Limbajul C   Limbajul Pascal  unsigned suma( unsigned n)  { unsigned s=0;     while(n)       { s+=n%10;          n/=10;        }     return s;  }  function suma(n:longint): byte;  var s: byte;  begin       s:=0;       while n<>0 do begin            s:= s+ n mod 10;            n:= n div 10;             end;  suma:=s;  end;  Preciza\u021bi care dintre variante nu reprezint\u0103 o variant\u0103 corect\u0103 de apel.    Limbajul C++  a) if (suma(n) % 2) cout<<\u201dNU\u201d;              else cout<<\u201dDA\u201d;     b)cout<<suma(10945);  c)cout<<suma(12,12);  d)cout<<suma(suma(n)+suma(10945));  e)cout<<suma(n);  f)sn= suma(n); // sn este o variabil\u0103 declarat\u0103 de tip unsigned    Limbajul C  a)if (suma(n) % 2)  printf(\u201cNU\u201d);        else  printf(\u201cDA\u201d);  b) printf(\"%d\",suma(10945));  c) printf(\"%d\", suma(12,12));  d) printf(\"%d\",suma(suma(n)+suma(10945)));   e) printf(\"%d\",suma(n));  f) sn= suma(n); // sn este o variabil\u0103 declarat\u0103 de tip unsigned                      Limbajul Pascal  a)if suma(n) mod 2 = 0 then write (\u2018DA\u2019)         else write(\u2018NU\u2019);  b)write(suma(10945));  c)write(suma(12,12));  d)write(suma(suma(n)+suma(10945)));  e)write(suma(n));  f)sn:=suma(n); {sn este o variabil\u0103 declarat\u0103 de tip byte }      12.  Preciza\u021bi care este num\u0103rul minim de muchii ale unui graf neorientat cu 16 noduri care are  exact dou\u0103 componente conexe, fiecare dintre aceste dou\u0103 componente fiind graf complet.  a) 15    b)14  c) 105  d) 55      e) 28  f)56    13.  Se cunosc urm\u0103toarele informa\u0163ii despre matricea de adiacen\u0163\u0103 a unui graf neorientat conex:   are 10 linii \u015fi 24 de valori nenule. Preciza\u021bi care este valoarea maxim\u0103 pe care o poate avea  gradul unui nod \u00eentr-un astfel de graf.  a)nu exist\u0103 astfel de graf     b)12  c) 1    d) 10      e) 9    f)8", "sentences": ["42    11.", " Pentru subprogramul urm\u0103tor:  Limbajul C++/ Limbajul C   Limbajul Pascal  unsigned suma( unsigned n)  { unsigned s=0;     while(n)       { s+=n%10;          n/=10;        }     return s;  }  function suma(n:longint): byte;  var s: byte;  begin       s:=0;       while n<>0 do begin            s:= s+ n mod 10;            n:= n div 10;             end;  suma:=s;  end;  Preciza\u021bi care dintre variante nu reprezint\u0103 o variant\u0103 corect\u0103 de apel.", "   Limbajul C++  a) if (suma(n) % 2) cout<<\u201dNU\u201d;              else cout<<\u201dDA\u201d;     b)cout<<suma(10945);  c)cout<<suma(12,12);  d)cout<<suma(suma(n)+suma(10945));  e)cout<<suma(n);  f)sn= suma(n); // sn este o variabil\u0103 declarat\u0103 de tip unsigned    Limbajul C  a)if (suma(n) % 2)  printf(\u201cNU\u201d);        else  printf(\u201cDA\u201d);  b) printf(\"%d\",suma(10945));  c) printf(\"%d\", suma(12,12));  d) printf(\"%d\",suma(suma(n)+suma(10945)));   e) printf(\"%d\",suma(n));  f) sn= suma(n); // sn este o variabil\u0103 declarat\u0103 de tip unsigned                      Limbajul Pascal  a)if suma(n) mod 2 = 0 then write (\u2018DA\u2019)         else write(\u2018NU\u2019);  b)write(suma(10945));  c)write(suma(12,12));  d)write(suma(suma(n)+suma(10945)));  e)write(suma(n));  f)sn:=suma(n); {sn este o variabil\u0103 declarat\u0103 de tip byte }      12.", " Preciza\u021bi care este num\u0103rul minim de muchii ale unui graf neorientat cu 16 noduri care are  exact dou\u0103 componente conexe, fiecare dintre aceste dou\u0103 componente fiind graf complet.", " a) 15    b)14  c) 105  d) 55      e) 28  f)56    13.", " Se cunosc urm\u0103toarele informa\u0163ii despre matricea de adiacen\u0163\u0103 a unui graf neorientat conex:   are 10 linii \u015fi 24 de valori nenule.", "Preciza\u021bi care este valoarea maxim\u0103 pe care o poate avea  gradul unui nod \u00eentr-un astfel de graf.", " a)nu exist\u0103 astfel de graf     b)12  c) 1    d) 10      e) 9    f)8"], "page_sentence_count_spacy": 8}, {"page_number": 43, "page_char_count": 723, "page_word_count": 152, "page_sentence_count_raw": 8, "page_token_count": 180.75, "text": "43      14.  Fie graful orientat G, definit prin perechea ordonat\u0103 de mul\u0163imi X={1,2,3,4,5} \u015fi  U={(1,2),(2,1),(2,3),(3,4),(4,3),(4,1),(4,5),(5,1),(1,5)}.   Preciza\u021bi care dintre afirma\u0163iile urm\u0103toare nu este adev\u0103rat\u0103 pentru acest graf.    a) Graful este conex   b) Graful este tare conex   c) Graful are dou\u0103 componente conexe   d) Graful con\u0163ine cel pu\u0163in un drum elementar de lungime 4.  e) Graful nu con\u0163ine v\u00e2rfuri izolate(v\u00e2rf izolat = v\u00e2rf care nu este  adiacent cu alt v\u00e2rf)  f) Graful con\u0163ine cel pu\u0163in un circuit elementar.        15.  Preciza\u021bi care este num\u0103rul maxim de frunze ale unui arbore binar (arbore \u00een care fiecare nod  are cel mult doi fii) cu 66 de noduri.  a) 65   b) 35  c) 1  d) 33  e) 32  f)  66", "sentences": ["43      14.", " Fie graful orientat G, definit prin perechea ordonat\u0103 de mul\u0163imi X={1,2,3,4,5} \u015fi  U={(1,2),(2,1),(2,3),(3,4),(4,3),(4,1),(4,5),(5,1),(1,5)}.", "  Preciza\u021bi care dintre afirma\u0163iile urm\u0103toare nu este adev\u0103rat\u0103 pentru acest graf.", "   a) Graful este conex   b) Graful este tare conex   c) Graful are dou\u0103 componente conexe   d) Graful con\u0163ine cel pu\u0163in un drum elementar de lungime 4.", " e) Graful nu con\u0163ine v\u00e2rfuri izolate(v\u00e2rf izolat = v\u00e2rf care nu este  adiacent cu alt v\u00e2rf)  f) Graful con\u0163ine cel pu\u0163in un circuit elementar.", "       15.", " Preciza\u021bi care este num\u0103rul maxim de frunze ale unui arbore binar (arbore \u00een care fiecare nod  are cel mult doi fii) cu 66 de noduri.", " a) 65   b) 35  c) 1  d) 33  e) 32  f)  66"], "page_sentence_count_spacy": 8}, {"page_number": 44, "page_char_count": 1885, "page_word_count": 440, "page_sentence_count_raw": 18, "page_token_count": 471.25, "text": "44    Varianta 9  1.  Fie n un num\u0103r natural cu cel pu\u0163in 4 cifre. Preciza\u021bi care dintre urm\u0103toarele instruc\u021biuni  determin\u0103 interschimbarea cifrei sutelor cu cifra zecilor.  Limbajul C++/ Limbajul C  1. n=n%10+n/1000*1000+n%1000/100*10+n%100/10*100;  2. n=n/1000*1000+n%1000/100*100+n%100/10*10+n%10;  3. n=n%1000/100*10+n%100/10*100+n%10+n/1000*1000;  4. n=n%1000/100*10+n%100/10*100+n/10;    Limbajul Pascal  1. n:=n mod 10+n div 1000*1000+n mod 1000 div 100*10+n mod 100 div 10*100;  2. n:=n div 1000*1000+n mod 1000 div 100*100+n mod 100 div 10*10+n mod 10;  3. n:=n mod 1000 div 100*10+n mod 100 div 10*100+n mod 10+n div 1000*1000;  4. n:=n mod 1000 div 100*10+n mod 100 div 10*100+n div 10;  a) 1 \u0219i 2  b) 1 \u0219i 3  c) 1, 3 \u0219i 4  d) 1 \u0219i 4  e) 2 \u0219i 3  f) 2 \u0219i 4    2.  Dac\u0103 expresia:   Limbajul C++/ Limbajul C   Limbajul Pascal  !(x>2)||(x<=5)&&(x>-5)  not(x>2)or(x<=5)and(x>-5)  este adev\u0103rat\u0103, atunci:  a)  x\u2208(-5,2)\u222a[5,\u221e)  b) x\u2208(-\u221e,2]\u2229[5,\u221e)  c) x\u2208(-\u221e,2]\u222a[5,\u221e)  d)  x\u2208(-\u221e,5)  e) x\u2208(-5,2)\u2229[5,\u221e)  f) x\u2208(-\u221e,5]    3.  \u00cen urma execut\u0103rii secven\u0163ei de program de mai jos, \u00een care variabila s memoreaz\u0103 un \u015fir cu  cel mult 100 caractere, iar i este de tip \u00eentreg, se afi\u0219eaz\u0103 \u0219irul acbb. Preciza\u021bi care este  con\u021binutul \u0219irului s \u00eenainte de aceast\u0103 secven\u021b\u0103.  Limbajul C++/C   Limbajul Pascal  for(i=0;i<strlen(s);i++)      {          strcpy(s+i,s+i+1);          if(!strchr(\"aeiou\",s[i]))              s[i]--;          else s[i]++;      }      cout<<s;  |   printf(\"%s\",s);  for i:=1 to length(s) do   begin   delete(s,i,1);   if pos(s[i],'aeiou')=0 then          s[i]:=chr(ord(s[i])-1)       else s[i]:=chr(ord(s[i])+1);   end;   write(s);    a) abaa  b) abcbdcba  c) abcd  d) abcddcba  e) acbb  f) bdcc     4.  Preciza\u021bi care dintre urm\u0103toarele matrice, este  matricea de adiacen\u0163\u0103 a unui arbore cu 4  noduri.  a)   0 1 0 1    0 0 1 0  b)  0 0 1 0    0 0 0 1  c)  0 1 1 1    1 0 1 0", "sentences": ["44    Varianta 9  1.", " Fie n un num\u0103r natural cu cel pu\u0163in 4 cifre.", "Preciza\u021bi care dintre urm\u0103toarele instruc\u021biuni  determin\u0103 interschimbarea cifrei sutelor cu cifra zecilor.", " Limbajul C++/ Limbajul C  1.", "n=n%10+n/1000*1000+n%1000/100*10+n%100/10*100;  2.", "n=n/1000*1000+n%1000/100*100+n%100/10*10+n%10;  3.", "n=n%1000/100*10+n%100/10*100+n%10+n/1000*1000;  4.", "n=n%1000/100*10+n%100/10*100+n/10;    Limbajul Pascal  1.", "n:=n mod 10+n div 1000*1000+n mod 1000 div 100*10+n mod 100 div 10*100;  2.", "n:=n div 1000*1000+n mod 1000 div 100*100+n mod 100 div 10*10+n mod 10;  3.", "n:=n mod 1000 div 100*10+n mod 100 div 10*100+n mod 10+n div 1000*1000;  4.", "n:=n mod 1000 div 100*10+n mod 100 div 10*100+n div 10;  a) 1 \u0219i 2  b) 1 \u0219i 3  c) 1, 3 \u0219i 4  d) 1 \u0219i 4  e) 2 \u0219i 3  f) 2 \u0219i 4    2.", " Dac\u0103 expresia:   Limbajul C++/ Limbajul C   Limbajul Pascal  !(", "x>2)||(x<=5)&&(x>-5)  not(x>2)or(x<=5)and(x>-5)  este adev\u0103rat\u0103, atunci:  a)  x\u2208(-5,2)\u222a[5,\u221e)  b) x\u2208(-\u221e,2]\u2229[5,\u221e)  c) x\u2208(-\u221e,2]\u222a[5,\u221e)  d)  x\u2208(-\u221e,5)  e) x\u2208(-5,2)\u2229[5,\u221e)  f) x\u2208(-\u221e,5]    3.", " \u00cen urma execut\u0103rii secven\u0163ei de program de mai jos, \u00een care variabila s memoreaz\u0103 un \u015fir cu  cel mult 100 caractere, iar i este de tip \u00eentreg, se afi\u0219eaz\u0103 \u0219irul acbb.", "Preciza\u021bi care este  con\u021binutul \u0219irului s \u00eenainte de aceast\u0103 secven\u021b\u0103.", " Limbajul C++/C   Limbajul Pascal  for(i=0;i<strlen(s);i++)      {          strcpy(s+i,s+i+1);          if(!strchr(\"aeiou\",s[i]))              s[i]--;          else s[i]++;      }      cout<<s;  |   printf(\"%s\",s);  for i:=1 to length(s) do   begin   delete(s,i,1);   if pos(s[i],'aeiou')=0 then          s[i]:=chr(ord(s[i])-1)       else s[i]:=chr(ord(s[i])+1);   end;   write(s);    a) abaa  b) abcbdcba  c) abcd  d) abcddcba  e) acbb  f) bdcc     4.", " Preciza\u021bi care dintre urm\u0103toarele matrice, este  matricea de adiacen\u0163\u0103 a unui arbore cu 4  noduri.", " a)   0 1 0 1    0 0 1 0  b)  0 0 1 0    0 0 0 1  c)  0 1 1 1    1 0 1 0"], "page_sentence_count_spacy": 19}, {"page_number": 45, "page_char_count": 2244, "page_word_count": 595, "page_sentence_count_raw": 17, "page_token_count": 561.0, "text": "45      1 0 0 0    1 0 1 0    1 0 0 0    0 1 0 0    1 1 0 0    1 0 0 0  d)  0 0 1 0    0 0 0 1    1 0 0 1    0 1 1 0  e)   0 0 1 0    0 1 0 1    1 0 0 1    0 1 1 0  f)   0 0 1 0    0 0 0 1    1 0 0 1    0 1 1 1  5.  \u00cen secven\u0163a de mai jos, variabilele i \u015fi j sunt de tip \u00eentreg, iar variabila a memoreaz\u0103 un tablou  bidimensional \u00een care prima linie \u015fi prima coloan\u0103 sunt numerotate \u00eencep\u00e2nd cu 1. Toate  elementele tabloului primesc valori \u00een urma execut\u0103rii secven\u0163ei.  Limbajul C++/ Limbajul C  Limbajul Pascal  for(j=1;j<=4;j++)     for(i=3;i>=1;i--)       if(j==1||i==3)a[i][j]=i+j-1;        else     a[i][j]=a[i][j-1]+a[i+1][j];  for j:=1 to 4 do    for i:=3 downto 1 do     if (j=1)or(i=3) then    a[i][j]:=i+j-1       else        a[i][j]:=a[i][j-1]+a[i+1][j];  Preciza\u021bi c\u00e2te numere prime sunt memorate \u00een tabloul a dup\u0103 executarea secven\u021bei de  program.  a) 3  b) 4  c) 5  d) 6  e) 7  f) 8    6.  Se genereaz\u0103 prin metoda backtracking mul\u0163imi distincte cu elemente numere naturale nenule  \u015fi cu proprietatea c\u0103 suma elementelor fiec\u0103rei mul\u0163imi este egal\u0103 cu 6 astfel: {1, 2, 3},  {1, 5}, {2, 4}, {6}. Folosind aceea\u015fi metod\u0103 pentru a genera mul\u0163imi distincte cu  elemente numere naturale nenule \u015fi cu proprietatea c\u0103 suma elementelor fiec\u0103rei mul\u0163imi este  egal\u0103 cu 10, stabili\u0163i \u00een ce ordine sunt generate urm\u0103toarele mul\u0163imi:   1) {2, 3, 5};       2) {3, 7};            3) {2, 8};       4) {1, 9}.  a) 4 1 2 3  b) 4 1 3 2  c) 4 2 1 3  d) 4 2 3 1  e) 4 3 1 2  f) 4 3 2 1    7.  Se consider\u0103 graful neorientat G=(X,U) unde X={1,2,3,4,5,6} \u015fi U={[1,2], [1,3],  [5,1], [3,4], [4,5], [3,2], [3,5]}. Preciza\u021bi c\u00e2te cicluri elementare distincte exist\u0103  \u00een graful G. (Dou\u0103 cicluri elementare sunt distincte dac\u0103 difer\u0103 prin cel pu\u0163in o muchie).  a) 2  b) 3  c) 4  d) 5  e) 6  f) 7    8.  Se consider\u0103 graful orientat G=(V, E) unde V={1,2,3,4,5,6,7} \u015fi E={(1,2), (6,1),  (2,5), (2,3), (4,5), (3,4), (3,6)}. Preciza\u021bi c\u00e2te componente tare conexe are graful  dat.  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    9.  Un arbore cu nodurile numerotate de la 1 la 12, este memorat cu ajutorul vectorului de ta\u0163i   tata= (2,5,5,3,0,2,3,7,6,6,7,4). Num\u0103rul de lan\u021buri elementare de lungime maxim\u0103  care leag\u0103 dou\u0103 noduri ale arborelui este:  a) 2  b) 3  c) 4", "sentences": ["45      1 0 0 0    1 0 1 0    1 0 0 0    0 1 0 0    1 1 0 0    1 0 0 0  d)  0 0 1 0    0 0 0 1    1 0 0 1    0 1 1 0  e)   0 0 1 0    0 1 0 1    1 0 0 1    0 1 1 0  f)   0 0 1 0    0 0 0 1    1 0 0 1    0 1 1 1  5.", " \u00cen secven\u0163a de mai jos, variabilele i \u015fi j sunt de tip \u00eentreg, iar variabila a memoreaz\u0103 un tablou  bidimensional \u00een care prima linie \u015fi prima coloan\u0103 sunt numerotate \u00eencep\u00e2nd cu 1.", "Toate  elementele tabloului primesc valori \u00een urma execut\u0103rii secven\u0163ei.", " Limbajul C++/ Limbajul C  Limbajul Pascal  for(j=1;j<=4;j++)     for(i=3;i>=1;i--)       if(j==1||i==3)a[i][j]=i+j-1;        else     a[i][j]=a[i][j-1]+a[i+1][j];  for j:=1 to 4 do    for i:=3 downto 1 do     if (j=1)or(i=3) then    a[i][j]:=i+j-1       else        a[i][j]:=a[i][j-1]+a[i+1][j];  Preciza\u021bi c\u00e2te numere prime sunt memorate \u00een tabloul a dup\u0103 executarea secven\u021bei de  program.", " a) 3  b) 4  c) 5  d) 6  e) 7  f) 8    6.", " Se genereaz\u0103 prin metoda backtracking mul\u0163imi distincte cu elemente numere naturale nenule  \u015fi cu proprietatea c\u0103 suma elementelor fiec\u0103rei mul\u0163imi este egal\u0103 cu 6 astfel: {1, 2, 3},  {1, 5}, {2, 4}, {6}.", "Folosind aceea\u015fi metod\u0103 pentru a genera mul\u0163imi distincte cu  elemente numere naturale nenule \u015fi cu proprietatea c\u0103 suma elementelor fiec\u0103rei mul\u0163imi este  egal\u0103 cu 10, stabili\u0163i \u00een ce ordine sunt generate urm\u0103toarele mul\u0163imi:   1) {2, 3, 5};       2) {3, 7};            3) {2, 8};       4) {1, 9}.", " a) 4 1 2 3  b) 4 1 3 2  c) 4 2 1 3  d) 4 2 3 1  e) 4 3 1 2  f) 4 3 2 1    7.", " Se consider\u0103 graful neorientat G=(X,U) unde X={1,2,3,4,5,6} \u015fi U={[1,2], [1,3],  [5,1], [3,4], [4,5], [3,2], [3,5]}.", "Preciza\u021bi c\u00e2te cicluri elementare distincte exist\u0103  \u00een graful G. (Dou\u0103 cicluri elementare sunt distincte dac\u0103 difer\u0103 prin cel pu\u0163in o muchie).", " a) 2  b) 3  c) 4  d) 5  e) 6  f) 7    8.", " Se consider\u0103 graful orientat G=(V, E) unde V={1,2,3,4,5,6,7} \u015fi E={(1,2), (6,1),  (2,5), (2,3), (4,5), (3,4), (3,6)}.", "Preciza\u021bi c\u00e2te componente tare conexe are graful  dat.", " a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    9.", " Un arbore cu nodurile numerotate de la 1 la 12, este memorat cu ajutorul vectorului de ta\u0163i   tata= (2,5,5,3,0,2,3,7,6,6,7,4).", "Num\u0103rul de lan\u021buri elementare de lungime maxim\u0103  care leag\u0103 dou\u0103 noduri ale arborelui este:  a) 2  b) 3  c) 4"], "page_sentence_count_spacy": 16}, {"page_number": 46, "page_char_count": 1939, "page_word_count": 469, "page_sentence_count_raw": 12, "page_token_count": 484.75, "text": "46    d) 5  e) 6  f) 7    10. Se consider\u0103 declar\u0103rile urm\u0103toare, \u00een care variabila x memoreaz\u0103 coordonatele, \u00een planul  xOy, ale centrului unui cerc, precum \u015fi lungimea razei acestuia.   Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct {      float x, y;    } punct;  typedef struct {         punct c;        float r;    } cerc;  cerc x;  type punct=record            x,y:real;            end;          cerc=record            c:punct;            r:real;            end;  var x:cerc;  Expresia care verific\u0103 dac\u0103 originea sistemului de coordonate, este \u00een interiorul cercului,  este:  a) c.x*c.x+c.y*c.y<c.r*c.r;  b) x.c.x+x.c.y<x.r  c) c.x*c.x+c.y*c.y<x.r*x.r  d) x.x*x.x+x.y*x.y<x.r*x.r  e) x.c.x*x.c.x+x.c.y*x.c.y<x.r*x.r  f) x.r*x.r< x.c.x*x.c.x+x.c.y*x.c.y    11. Se consider\u0103 tabloul unidimensional x=(1,2,4,3). Preciza\u021bi care dintre urm\u0103toarele variante  reprezint\u0103 tabloul unidimensional y, \u0219tiind c\u0103 pentru orice 0\u2264i<4, exist\u0103 rela\u0163ia  x[y[i]]=y[x[i]].  a) y=(1,2,3,4)  b) y=(1,3,4,2)  c) y=(2,3,1,4)  d) y=(3,2,1,4)  e) y=(3,4,1,2)  f) y=(4,2,1,3)    12. Subprogramul f este definit mai jos. Preciza\u021bi ce valori se  vor afi\u0219a \u00een urma apelului  f('m',0).  Limbajul C++/ Limbajul C  Limbajul Pascal  void f(char c, int x)  {      if(!strchr(\"aeiou\",c)){          f(c-1,x+1)          cout<<c;|printf(\"%c\",c);      }else          cout<<x;|printf(\"%d\",x);  }  procedure f(c:char; x: word);  begin  if (pos(c,'aeiou')=0) then         begin           f(pred(c),x+1);      write(c); end    else   write(x);  end;    a) 4jklm  b) 4jmkl  c) 4mlkj  d) jklm4  e) jmkl4  f) mlkj4    13. Se consider\u0103 subprogramele de mai jos. Dac\u0103 \u00eenaintea apelului g(x), variabilele globale de  tip \u00eentreg x \u0219i y aveau valorile 1, respectiv -3, preciza\u021bi care vor fi valorile memorate \u00een  variabilele globale x \u0219i y dup\u0103 executarea apelului g(x).  Limbajul C++/ Limbajul C  Limbajul Pascal   void f(int x)  {  x=x+1;  procedure f(x: longint);  begin", "sentences": ["46    d) 5  e) 6  f) 7    10.", "Se consider\u0103 declar\u0103rile urm\u0103toare, \u00een care variabila x memoreaz\u0103 coordonatele, \u00een planul  xOy, ale centrului unui cerc, precum \u015fi lungimea razei acestuia.", "  Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct {      float x, y;    } punct;  typedef struct {         punct c;        float r;    } cerc;  cerc x;  type punct=record            x,y:real;            end;          cerc=record            c:punct;            r:real;            end;  var x:cerc;  Expresia care verific\u0103 dac\u0103 originea sistemului de coordonate, este \u00een interiorul cercului,  este:  a) c.x*c.x+c.y*c.y<c.r*c.r;  b) x.c.x+x.c.y<x.r  c) c.x*c.x+c.y*c.y<x.r*x.r  d) x.x*x.x+x.y*x.y<x.r*x.r  e) x.c.x*x.c.x+x.c.y*x.c.y<x.r*x.r  f) x.r*x.r< x.c.x*x.c.x+x.c.y*x.c.y    11.", "Se consider\u0103 tabloul unidimensional x=(1,2,4,3).", "Preciza\u021bi care dintre urm\u0103toarele variante  reprezint\u0103 tabloul unidimensional y, \u0219tiind c\u0103 pentru orice 0\u2264i<4, exist\u0103 rela\u0163ia  x[y[i]]=y[x[i]].", " a) y=(1,2,3,4)  b) y=(1,3,4,2)  c) y=(2,3,1,4)  d) y=(3,2,1,4)  e) y=(3,4,1,2)  f) y=(4,2,1,3)    12.", "Subprogramul f este definit mai jos.", "Preciza\u021bi ce valori se  vor afi\u0219a \u00een urma apelului  f('m',0).", " Limbajul C++/ Limbajul C  Limbajul Pascal  void f(char c, int x)  {      if(!strchr(\"aeiou\",c)){          f(c-1,x+1)          cout<<c;|printf(\"%c\",c);      }else          cout<<x;|printf(\"%d\",x);  }  procedure f(c:char; x: word);  begin  if (pos(c,'aeiou')=0) then         begin           f(pred(c),x+1);      write(c); end    else   write(x);  end;    a) 4jklm  b) 4jmkl  c) 4mlkj  d) jklm4  e) jmkl4  f) mlkj4    13.", "Se consider\u0103 subprogramele de mai jos.", "Dac\u0103 \u00eenaintea apelului g(x), variabilele globale de  tip \u00eentreg x \u0219i y aveau valorile 1, respectiv -3, preciza\u021bi care vor fi valorile memorate \u00een  variabilele globale x \u0219i y dup\u0103 executarea apelului g(x).", " Limbajul C++/ Limbajul C  Limbajul Pascal   void f(int x)  {  x=x+1;  procedure f(x: longint);  begin"], "page_sentence_count_spacy": 12}, {"page_number": 47, "page_char_count": 1634, "page_word_count": 647, "page_sentence_count_raw": 6, "page_token_count": 408.5, "text": "47       y=2*x+3; }  void g(int x)  {      int a,b;      a=x+y;   b=x-y;      f(a);   f(b);      y=y+b;  }  x:=x+1;  y:=2*x+3;end;  procedure g(x: longint);  var a,b:longint;  begin      a:=x+y;    b:=x-y;       f(a);  f(b);      y:=y+b;end;    a) 1 \u0219i 13  b) 1 \u0219i 17  c) 1 \u0219i 18  d) 2 \u0219i 13  e) 2 \u0219i 17  f) 2 \u0219i 18    14. \u00cen secven\u0163a de program de mai jos, toate variabilele sunt de tip \u00eentreg. Preciza\u021bi care este  valoarea afi\u0219at\u0103 la finalul execut\u0103rii secven\u0163ei urm\u0103toare.  Limbajul C++/Limbajul C  Limbajul Pascal          k=0;          for(     i=1;i<=9999;i++)          {              d=2;p=1;n=i;              while(d*d<=n)              {                  e=0;                  while(n%d==0)                  {                      e++;                      n=n/d;                  }              p=p*(e+1);              d++;              }          if(n>1)p=p*2;          if(p%2==0) k++;          }          cout<<k; | printf(\"%d\",k);  k:=0;  for i:=1 to 9999 do    begin    d:=2;p:=1;n:=i;    while d*d<=n do      begin      e:=0;      while n mod d=0 do        begin        inc(e);        n:=n div d;        end;      p:=p*(e+1);      inc(d);      end;    if n>1 then p:=p*2;    if p mod 2=0 then inc(k);    end;  write(k);    a) 99  b) 8901  c) 8990  d) 9900  e) 9901  f) 9990        15. Func\u021bia f este definit\u0103 mai jos.  Limbajul C++/ Limbajul C  int a[100];  int f(int x[100], int st, int dr)  {  if(st==dr) return 1;  else     if(f(x,st,(st+dr)/2)>0&&f(x,(st+dr)/2+1,dr)>0)      if (x[(st+dr)/2+1]>x[(st+dr)/2]) return 1;      else return 0;    else return 0;  }    Limbajul Pascal  type vector=array[0..99] of integer;", "sentences": ["47       y=2*x+3; }  void g(int x)  {      int a,b;      a=x+y;   b=x-y;      f(a);   f(b);      y=y+b;  }  x:=x+1;  y:=2*x+3;end;  procedure g(x: longint);  var a,b:longint;  begin      a:=x+y;    b:=x-y;       f(a);  f(b);      y:=y+b;end;    a) 1 \u0219i 13  b) 1 \u0219i 17  c) 1 \u0219i 18  d) 2 \u0219i 13  e) 2 \u0219i 17  f) 2 \u0219i 18    14.", "\u00cen secven\u0163a de program de mai jos, toate variabilele sunt de tip \u00eentreg.", "Preciza\u021bi care este  valoarea afi\u0219at\u0103 la finalul execut\u0103rii secven\u0163ei urm\u0103toare.", " Limbajul C++/Limbajul C  Limbajul Pascal          k=0;          for(     i=1;i<=9999;i++)          {              d=2;p=1;n=i;              while(d*d<=n)              {                  e=0;                  while(n%d==0)                  {                      e++;                      n=n/d;                  }              p=p*(e+1);              d++;              }          if(n>1)p=p*2;          if(p%2==0) k++;          }          cout<<k; | printf(\"%d\",k);  k:=0;  for i:=1 to 9999 do    begin    d:=2;p:=1;n:=i;    while d*d<=n do      begin      e:=0;      while n mod d=0 do        begin        inc(e);        n:=n div d;        end;      p:=p*(e+1);      inc(d);      end;    if n>1 then p:=p*2;    if p mod 2=0 then inc(k);    end;  write(k);    a) 99  b) 8901  c) 8990  d) 9900  e) 9901  f) 9990        15.", "Func\u021bia f este definit\u0103 mai jos.", " Limbajul C++/ Limbajul C  int a[100];  int f(int x[100], int st, int dr)  {  if(st==dr) return 1;  else     if(f(x,st,(st+dr)/2)>0&&f(x,(st+dr)/2+1,dr)>0)      if (x[(st+dr)/2+1]>x[(st+dr)/2]) return 1;      else return 0;    else return 0;  }    Limbajul Pascal  type vector=array[0..99] of integer;"], "page_sentence_count_spacy": 6}, {"page_number": 48, "page_char_count": 637, "page_word_count": 147, "page_sentence_count_raw": 6, "page_token_count": 159.25, "text": "48     var a:vector;  function f(x:vector;st,dr:integer):byte;  begin  if st=dr then f:=1  else        if (f(x,st,(st+dr)div 2)>0) and (f(x,(st+dr)div 2+1,dr)>0) then            if x[(st+dr)div 2+1]>x[(st+dr)div 2] then f:=1            else f:=0        else f:=0;  end;    Preciza\u021bi care dintre urm\u0103toarele \u0219iruri de valori pot fi memorate \u00een tabloul unidimensional a  (cu indicii \u00eencep\u00e2nd de la 0), astfel \u00eenc\u00e2t apelul f(a,2,5) s\u0103 returneze valoarea 1.  1. a=(0,1,1,3,4,4,5)  2. a=(0,5,3,4,2,0)  3. a=(0,2,2,3,4,5,5)  4. a=(0,4,3,3,2,2,1)  a) niciunul   b) \u0219irurile 1 \u0219i 3  c) doar \u0219irul 2  d) \u0219irurile 2 \u0219i 4  e) doar \u0219irul 3  f) toate", "sentences": ["48     var a:vector;  function f(x:vector;st,dr:integer):byte;  begin  if st=dr then f:=1  else        if (f(x,st,(st+dr)div 2)>0) and (f(x,(st+dr)div 2+1,dr)>0) then            if x[(st+dr)div 2+1]>x[(st+dr)div 2] then f:=1            else f:=0        else f:=0;  end;    Preciza\u021bi care dintre urm\u0103toarele \u0219iruri de valori pot fi memorate \u00een tabloul unidimensional a  (cu indicii \u00eencep\u00e2nd de la 0), astfel \u00eenc\u00e2t apelul f(a,2,5) s\u0103 returneze valoarea 1.", " 1.", "a=(0,1,1,3,4,4,5)  2.", "a=(0,5,3,4,2,0)  3.", "a=(0,2,2,3,4,5,5)  4.", "a=(0,4,3,3,2,2,1)  a) niciunul   b) \u0219irurile 1 \u0219i 3  c) doar \u0219irul 2  d) \u0219irurile 2 \u0219i 4  e) doar \u0219irul 3  f) toate"], "page_sentence_count_spacy": 6}, {"page_number": 49, "page_char_count": 1651, "page_word_count": 464, "page_sentence_count_raw": 17, "page_token_count": 412.75, "text": "49    Varianta 10    1.  Preciza\u021bi ce valoare va avea variabila real\u0103 x, dup\u0103 executarea urm\u0103toarei instruc\u021biuni.  Limbajul C++/ Limbajul C  Limbajul Pascal  x=7.51+35/4*67%8-2.83;  x:=7.51+35 div 4*67 mod 8-2.83;    a) instruc\u021biunea este  incorect\u0103   b) 4  c) 4.68  d) 5  e) 28  f) 28.68    2.  Preciza\u021bi care dintre urm\u0103toarele variante de instrunc\u021biuni insereaz\u0103 cifra 2 \u00een fa\u0163a ultimei  cifre a unui num\u0103r natural n.  Limbajul C++/ Limbajul C  1. n=(n%10*10+2)*10+n/10;  2. n=(n/10*10+2)*10+n%10;  3. n=n/10+2*10+n%10;  4. n=(n/10+2)*10+n%10;    Limbajul Pascal  1. n:=(n mod 10*10+2)*10+n div 10;  2. n:=(n div 10*10+2)*10+n mod 10;  3. n:=n div 10+2*10+n mod 10;  4. n:=(n div 10+2)*10+n mod 10;    a) niciuna   b) 1   c) 1 \u0219i 2  d) 2  e) 3  f) 4    3.  \u00cen secven\u021ba de program de mai jos, variabilele x, y \u0219i  z sunt de tip \u00eentreg.  Limbajul C++/ Limbajul C  Limbajul Pascal      z=1;      while(y>0)      {          if(y%2)                 z=x%10*z;          x=x*x%10;          y=y/2;      }      cout<<z; | printf(\"%d\",z);      z:=1;      while y>0 do      begin          if y mod %2=1 then         z:=x mod 10*z;          x:=x*x mod 10;          y:=y div 2;      end;      write(z);  Dac\u0103 \u00eenaintea secven\u021bei, x are valoarea 137, preciza\u021bi c\u00e2te valori cu exact dou\u0103 cifre poate  avea y astfel \u00eenc\u00e2t valoarea lui z (afi\u0219at\u0103 la finalul secven\u021bei) s\u0103 fie 1.  a) 21  b) 22  c) 23  d) 24  e) 25  f) 26    4.  Se consider\u0103 declar\u0103rile:   Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct     {        float st,dr;    } interval;  interval v[20], m;  type interval=record      st,dr:real;    end;  var v:array[0..19] of interval;  m:interval;", "sentences": ["49    Varianta 10    1.", " Preciza\u021bi ce valoare va avea variabila real\u0103 x, dup\u0103 executarea urm\u0103toarei instruc\u021biuni.", " Limbajul C++/ Limbajul C  Limbajul Pascal  x=7.51+35/4*67%8-2.83;  x:=7.51+35 div 4*67 mod 8-2.83;    a) instruc\u021biunea este  incorect\u0103   b) 4  c) 4.68  d) 5  e) 28  f) 28.68    2.", " Preciza\u021bi care dintre urm\u0103toarele variante de instrunc\u021biuni insereaz\u0103 cifra 2 \u00een fa\u0163a ultimei  cifre a unui num\u0103r natural n.  Limbajul C++/ Limbajul C  1.", "n=(n%10*10+2)*10+n/10;  2.", "n=(n/10*10+2)*10+n%10;  3.", "n=n/10+2*10+n%10;  4.", "n=(n/10+2)*10+n%10;    Limbajul Pascal  1.", "n:=(n mod 10*10+2)*10+n div 10;  2.", "n:=(n div 10*10+2)*10+n mod 10;  3.", "n:=n div 10+2*10+n mod 10;  4.", "n:=(n div 10+2)*10+n mod 10;    a) niciuna   b) 1   c) 1 \u0219i 2  d) 2  e) 3  f) 4    3.", " \u00cen secven\u021ba de program de mai jos, variabilele x, y \u0219i  z sunt de tip \u00eentreg.", " Limbajul C++/ Limbajul C  Limbajul Pascal      z=1;      while(y>0)      {          if(y%2)                 z=x%10*z;          x=x*x%10;          y=y/2;      }      cout<<z; | printf(\"%d\",z);      z:=1;      while y>0 do      begin          if y mod %2=1 then         z:=x mod 10*z;          x:=x*x mod 10;          y:=y div 2;      end;      write(z);  Dac\u0103 \u00eenaintea secven\u021bei, x are valoarea 137, preciza\u021bi c\u00e2te valori cu exact dou\u0103 cifre poate  avea y astfel \u00eenc\u00e2t valoarea lui z (afi\u0219at\u0103 la finalul secven\u021bei) s\u0103 fie 1.", " a) 21  b) 22  c) 23  d) 24  e) 25  f) 26    4.", " Se consider\u0103 declar\u0103rile:   Limbajul C++/ Limbajul C  Limbajul Pascal  typedef struct     {        float st,dr;    } interval;  interval v[20], m;  type interval=record      st,dr:real;    end;  var v:array[0..19] of interval;  m:interval;"], "page_sentence_count_spacy": 16}, {"page_number": 50, "page_char_count": 2118, "page_word_count": 453, "page_sentence_count_raw": 27, "page_token_count": 529.5, "text": "50    int i,j;  i,j:word;  Preciza\u021bi care dintre urm\u0103toarele instruc\u021biuni sunt corecte din punct de vedere sintactic.  Limbajul C++/ Limbajul C  Limbajul Pascal  1. v[i]=v[v[j]];  2. m=(v[2]+v[3])/2;  3. v[10]=m;  4. m.st=v[5].st%2;  1. v[i]:=v[v[j]];  2. m:=(v[2]+v[3])/2;  3. v[10]:=m;  4. m.st:=v[5].st mod 2;    a) niciuna   b) 1 , 2 \u0219i 3   c) 1 \u0219i 4  d) 3  e) 3 \u0219i 4  f) toate    5.  Subprogramul f cu antetul int f(int x) (\u00een limbajul C++ \u0219i limbajul C), respectiv   function f(x:integer):integer; (\u00een limbajul Pascal), returneaz\u0103 cea mai mic\u0103 cifr\u0103 a  num\u0103rului x, care apare de cel pu\u0163in dou\u0103 ori \u00een scrierea lui x, sau valoarea -1, dac\u0103 num\u0103rul  x este format din cifre distincte.   Stabili\u0163i valoarea expresiei   f(f(775125) + f(97917)).  a) -1  b) 0    c) 1     d) 12   e) 14  f) 16    6.  Se genereaz\u0103 prin metoda backtracking, submul\u0163imile nevide ale mul\u0163imii {1, 2, 3} astfel:  {1}, {1, 2}, {1, 2, 3}, {1, 3}, {2}, {2, 3}, {3}. Folosind aceea\u015fi metod\u0103 pentru a genera  submul\u0163imile nevide ale mul\u0163imii {1, 2, 3, 4, 5, 6, 7}, stabili\u0163i care este a 10-a, respectiv a  11-a solu\u021bie generat\u0103.  a) {1,2,3,4,7},  {1,2,3,4,6,7}   b) {1,2,3,4,7}, {1,2,3,5}  c) {1,2,3,4,6,7}, {1,2,3,6,7}  d) {1,2,3,4,6},  {1,2,3,4,6,7}  e) {1,2,3,4,6}, {1,2,3,5}  f) {1,2,3,4,6,7},{1,2,3,4,7}    7.  Se  consider\u0103  graful  neorientat  G=(X,U)  unde  X={1,2,3,4,5}  \u015fi  U={[1,2],[1,3],[5,1],[3,4],[4,5],[3,2]}. Preciza\u021bi num\u0103rul minim de muchii care  trebuie ad\u0103ugate pentru ca graful s\u0103 devin\u0103 eulerian.  a) 0  b) 1  c) 2  d) 3    e) 4  f) 5    8.  Un graf neorientat are 30 noduri \u015fi 16 muchii. Preciza\u021bi num\u0103rul componentelor conexe pe  care le poate avea acest graf.  a) exact 14    b) cel pu\u0163in 14 \u015fi cel mult 24     c) cel pu\u0163in 14 \u015fi cel mult 26  d) cel pu\u0163in 16 \u015fi cel mult 24  e) cel pu\u0163in 16 \u015fi cel mult 26  f) exact 24      9.  Fie G=(V,E) un graf orientat \u00een care mul\u0163imea nodurilor este V={1,2,\u2026,10}, iar   mul\u0163imea arcelor este E={(i,j) VxV| i este divizor propriu al lui j}. Stabili\u0163i care dintre  urm\u0103toarele afirma\u0163ii este adev\u0103rat\u0103.  1. Graful G are 3 componente tare conexe  2. Graful G are 3 componente conexe", "sentences": ["50    int i,j;  i,j:word;  Preciza\u021bi care dintre urm\u0103toarele instruc\u021biuni sunt corecte din punct de vedere sintactic.", " Limbajul C++/ Limbajul C  Limbajul Pascal  1.", "v[i]=v[v[j]];  2.", "m=(v[2]+v[3])/2;  3.", "v[10]=m;  4.", "m.st=v[5].st%2;  1.", "v[i]:=v[v[j]];  2.", "m:=(v[2]+v[3])/2;  3.", "v[10]:=m;  4.", "m.st:=v[5].st mod 2;    a) niciuna   b) 1 , 2 \u0219i 3   c) 1 \u0219i 4  d) 3  e) 3 \u0219i 4  f) toate    5.", " Subprogramul f cu antetul int f(int x) (\u00een limbajul C++ \u0219i limbajul C), respectiv   function f(x:integer):integer; (\u00een limbajul Pascal), returneaz\u0103 cea mai mic\u0103 cifr\u0103 a  num\u0103rului x, care apare de cel pu\u0163in dou\u0103 ori \u00een scrierea lui x, sau valoarea -1, dac\u0103 num\u0103rul  x este format din cifre distincte.", "  Stabili\u0163i valoarea expresiei   f(f(775125) + f(97917)).", " a) -1  b) 0    c) 1     d) 12   e) 14  f) 16    6.", " Se genereaz\u0103 prin metoda backtracking, submul\u0163imile nevide ale mul\u0163imii {1, 2, 3} astfel:  {1}, {1, 2}, {1, 2, 3}, {1, 3}, {2}, {2, 3}, {3}.", "Folosind aceea\u015fi metod\u0103 pentru a genera  submul\u0163imile nevide ale mul\u0163imii {1, 2, 3, 4, 5, 6, 7}, stabili\u0163i care este a 10-a, respectiv a  11-a solu\u021bie generat\u0103.", " a) {1,2,3,4,7},  {1,2,3,4,6,7}   b) {1,2,3,4,7}, {1,2,3,5}  c) {1,2,3,4,6,7}, {1,2,3,6,7}  d) {1,2,3,4,6},  {1,2,3,4,6,7}  e) {1,2,3,4,6}, {1,2,3,5}  f) {1,2,3,4,6,7},{1,2,3,4,7}    7.", " Se  consider\u0103  graful  neorientat  G=(X,U)  unde  X={1,2,3,4,5}  \u015fi  U={[1,2],[1,3],[5,1],[3,4],[4,5],[3,2]}.", "Preciza\u021bi num\u0103rul minim de muchii care  trebuie ad\u0103ugate pentru ca graful s\u0103 devin\u0103 eulerian.", " a) 0  b) 1  c) 2  d) 3    e) 4  f) 5    8.", " Un graf neorientat are 30 noduri \u015fi 16 muchii.", "Preciza\u021bi num\u0103rul componentelor conexe pe  care le poate avea acest graf.", " a) exact 14    b) cel pu\u0163in 14 \u015fi cel mult 24     c) cel pu\u0163in 14 \u015fi cel mult 26  d) cel pu\u0163in 16 \u015fi cel mult 24  e) cel pu\u0163in 16 \u015fi cel mult 26  f) exact 24      9.", " Fie G=(V,E) un graf orientat \u00een care mul\u0163imea nodurilor este V={1,2,\u2026,10}, iar   mul\u0163imea arcelor este E={(i,j) VxV| i este divizor propriu al lui j}.", "Stabili\u0163i care dintre  urm\u0103toarele afirma\u0163ii este adev\u0103rat\u0103.", " 1.", "Graful G are 3 componente tare conexe  2.", "Graful G are 3 componente conexe"], "page_sentence_count_spacy": 27}, {"page_number": 51, "page_char_count": 1848, "page_word_count": 472, "page_sentence_count_raw": 12, "page_token_count": 462.0, "text": "51    3. G nu are v\u00e2rfuri izolate   4. Graful G con\u0163ine cel pu\u021bin un circuit    a) 1  b) 1 \u0219i 2  c) 2  d) 3  e) 4  f) toate    10.  Prin \u00een\u0103l\u0163imea unui arbore cu r\u0103d\u0103cin\u0103 \u00een\u0163elegem num\u0103rul de muchii ale celui mai lung lan\u0163  elementar care are una dintre extremit\u0103\u0163i \u00een r\u0103d\u0103cina arborelui. Dac\u0103 arborele este  reprezentat prin urm\u0103torul vector de ta\u0163i: tata=( 4,5,1,0,4,5,6,1,4), atunci \u00een\u0103l\u0163imea  sa este:  a) 2  b) 3  c) 4  d) 5  e) 6  f) 7      11.  Subprogramul g este definit mai jos. Preciza\u021bi ce valori se vor afi\u0219a \u00een urma apelul g(4).  Limbajul C++/ Limbajul C  Limbajul Pascal  void g(int n)  {int i;   if(n>0)   for(i=n;i>1;i--)      {          cout<<i; | printf(\"%d\",i);          g(n-2);      }  }  procedure g(n:word);  var i:word;  begin  if n>0 then          for i:=n downto 2 do          begin                  write(i);                  g(n-2);          end;  end;    a) 42132  b) 42322  c) 423222  d) 432322  e) 432132121  f) 4213212211        12.  \u00cen secven\u0163a de program al\u0103turat\u0103, variabilele i \u0219i k sunt de tip \u00eentreg, iar variabila A  memoreaz\u0103 o matrice cu 8 linii \u0219i 8 coloane (numerotate de la 1 la 8) cu elemente numere  \u00eentregi. \u00cenainte de executarea secven\u021bei, toate elementele vectorului sunt nule. Preciza\u021bi care  este a 9-a valoare afi\u0219at\u0103 \u0219i care este num\u0103rul de valori afi\u0219ate pe parcursul execut\u0103rii  secven\u0163ei date.  Limbajul C++/ Limbajul C  n=8;k=3;  for (i=n;i>=1;i--)      for(j=n;j>=1;j--)          A[i][j]=n*(j-1)+i;  for(i=k;i<=n-k+1;i++)     cout<<A[i][k]<<' ';    | printf(\"%d \", A[i][k]);   for(i=k+1;i<=n-k+1;i++)     cout<<A[n-k+1][i]<<' ';  | printf(\"%d \",A[n-k+1][i]);  for(i=n-k;i>=k;i--)     cout<<A[i][n-k+1]<<' ';  | printf(\"%d \", A[i][n-k+1]);  for(i=n-k;i>k;i--)     cout<<A[k][i]<<' ';    | printf(\"%d \", A[k][i]);    Limbajul Pascal  n:=8;k:=3;  for i:=n downto 1 do      for j:=n downto 1 do", "sentences": ["51    3.", "G nu are v\u00e2rfuri izolate   4.", "Graful G con\u0163ine cel pu\u021bin un circuit    a) 1  b) 1 \u0219i 2  c) 2  d) 3  e) 4  f) toate    10.", " Prin \u00een\u0103l\u0163imea unui arbore cu r\u0103d\u0103cin\u0103 \u00een\u0163elegem num\u0103rul de muchii ale celui mai lung lan\u0163  elementar care are una dintre extremit\u0103\u0163i \u00een r\u0103d\u0103cina arborelui.", "Dac\u0103 arborele este  reprezentat prin urm\u0103torul vector de ta\u0163i: tata=( 4,5,1,0,4,5,6,1,4), atunci \u00een\u0103l\u0163imea  sa este:  a) 2  b) 3  c) 4  d) 5  e) 6  f) 7      11.", " Subprogramul g este definit mai jos.", "Preciza\u021bi ce valori se vor afi\u0219a \u00een urma apelul g(4).", " Limbajul C++/ Limbajul C  Limbajul Pascal  void g(int n)  {int i;   if(n>0)   for(i=n;i>1;i--)      {          cout<<i; | printf(\"%d\",i);          g(n-2);      }  }  procedure g(n:word);  var i:word;  begin  if n>0 then          for i:=n downto 2 do          begin                  write(i);                  g(n-2);          end;  end;    a) 42132  b) 42322  c) 423222  d) 432322  e) 432132121  f) 4213212211        12.", " \u00cen secven\u0163a de program al\u0103turat\u0103, variabilele i \u0219i k sunt de tip \u00eentreg, iar variabila A  memoreaz\u0103 o matrice cu 8 linii \u0219i 8 coloane (numerotate de la 1 la 8) cu elemente numere  \u00eentregi.", "\u00cenainte de executarea secven\u021bei, toate elementele vectorului sunt nule.", "Preciza\u021bi care  este a 9-a valoare afi\u0219at\u0103 \u0219i care este num\u0103rul de valori afi\u0219ate pe parcursul execut\u0103rii  secven\u0163ei date.", " Limbajul C++/ Limbajul C  n=8;k=3;  for (i=n;i>=1;i--)      for(j=n;j>=1;j--)          A[i][j]=n*(j-1)+i;  for(i=k;i<=n-k+1;i++)     cout<<A[i][k]<<' ';    | printf(\"%d \", A[i][k]);   for(i=k+1;i<=n-k+1;i++)     cout<<A[n-k+1][i]<<' ';  | printf(\"%d \",A[n-k+1][i]);  for(i=n-k;i>=k;i--)     cout<<A[i][n-k+1]<<' ';  | printf(\"%d \", A[i][n-k+1]);  for(i=n-k;i>k;i--)     cout<<A[k][i]<<' ';    | printf(\"%d \", A[k][i]);    Limbajul Pascal  n:=8;k:=3;  for i:=n downto 1 do      for j:=n downto 1 do"], "page_sentence_count_spacy": 12}, {"page_number": 52, "page_char_count": 1870, "page_word_count": 455, "page_sentence_count_raw": 7, "page_token_count": 467.5, "text": "52            A[i,j]:=n*(j-1)+i;  for i:=k to n-k+1 do     write(A[i,k],' ');  for i:=k+1 to n-k+1 do       write(A[n-k+1,i],' ');  for i:=n-k downto k do       write(A[i,n-k+1],' ');  for i:=n-k downto k+1 do     write(A[k,i],' ');    a) 43 \u0219i 10    b) 43 \u0219i 12  c) 44 \u0219i 10    d) 44 \u0219i 12    e) 45 \u0219i 10  f) 45 \u0219i 12    13.  Se consider\u0103 declar\u0103rile:  Limbajul C++/ Limbajul C  Limbajul Pascal  char s[30]=\"bacaacbc\";  char t[3][3]={\"ab\",\"ac\",\"bc\"};    var i:word;  s:string[30];  t:array[0..2]of string[3];  Preciza\u021bi ce se va afi\u0219a dup\u0103 executarea secven\u021bei de program de mai jos.  Limbajul C++/ Limbajul C  for(int i=0;i<3;i++)      if (!strstr(s,t[i]))          strcat(s,t[2-i]);      else cout<<t[i];   | printf(\"%s\",t[i]);  cout<<strlen(s);    | printf(\"%d\",strlen(s));  cout<<s;       | printf(\"%s\",s);    Limbajul Pascal  s:='bacaacbc';t[0]:='ab';t[1]:='ac';t[2]:='bc';  for i:=0 to 2 do          if pos(t[i],s)=0 then s:=s+t[2-i]          else write(t[i]);  write(length(s));  write(s);    a) secven\u021ba este incorect\u0103  sintactic  b) acbc8bacaacbc  c) acbc10bacaacbc  d) bcac10bacaacbcbc  e) acb10bacaacbcbc  f) acbc10bacaacbcbc     14.  Subprogramul p este definit mai jos. Variabila a memoreaz\u0103 un vector cu 100 de elemente  numere \u00eentregi, aflate pe pozi\u021bii numerotate de la 0 la 99. Preciza\u021bi c\u00e2te elemente divizibile  cu 3 con\u021bine tabloul unidimensional a dup\u0103 executarea apelului p(6,a).  Limbajul C++/Limbajul C  Limbajul Pascal  void p(int k, int v[100])  { int w[100];    v[0]=w[0]=1;    for(int i=1;i<=k;i++)    {     for(int j=0;j<=i;j++)     {       if(j==0) v[j]=1;       else        if(i==j) v[j]=1;  type vector=array[0..99]of integer;  var a:vector;   procedure p(k:integer; var v:vector);  var w:vector; i,j:integer;  begin      v[0]:=1; w[0]:=1;      for i:=1 to k do begin        for j:=0 to i do           if j=0 then v[j]:=1            else", "sentences": ["52            A[i,j]:=n*(j-1)+i;  for i:=k to n-k+1 do     write(A[i,k],' ');  for i:=k+1 to n-k+1 do       write(A[n-k+1,i],' ');  for i:=n-k downto k do       write(A[i,n-k+1],' ');  for i:=n-k downto k+1 do     write(A[k,i],' ');    a) 43 \u0219i 10    b) 43 \u0219i 12  c) 44 \u0219i 10    d) 44 \u0219i 12    e) 45 \u0219i 10  f) 45 \u0219i 12    13.", " Se consider\u0103 declar\u0103rile:  Limbajul C++/ Limbajul C  Limbajul Pascal  char s[30]=\"bacaacbc\";  char t[3][3]={\"ab\",\"ac\",\"bc\"};    var i:word;  s:string[30];  t:array[0..2]of string[3];  Preciza\u021bi ce se va afi\u0219a dup\u0103 executarea secven\u021bei de program de mai jos.", " Limbajul C++/ Limbajul C  for(int i=0;i<3;i++)      if (!", "strstr(s,t[i]))          strcat(s,t[2-i]);      else cout<<t[i];   | printf(\"%s\",t[i]);  cout<<strlen(s);    | printf(\"%d\",strlen(s));  cout<<s;       | printf(\"%s\",s);    Limbajul Pascal  s:='bacaacbc';t[0]:='ab';t[1]:='ac';t[2]:='bc';  for i:=0 to 2 do          if pos(t[i],s)=0 then s:=s+t[2-i]          else write(t[i]);  write(length(s));  write(s);    a) secven\u021ba este incorect\u0103  sintactic  b) acbc8bacaacbc  c) acbc10bacaacbc  d) bcac10bacaacbcbc  e) acb10bacaacbcbc  f) acbc10bacaacbcbc     14.", " Subprogramul p este definit mai jos.", "Variabila a memoreaz\u0103 un vector cu 100 de elemente  numere \u00eentregi, aflate pe pozi\u021bii numerotate de la 0 la 99.", "Preciza\u021bi c\u00e2te elemente divizibile  cu 3 con\u021bine tabloul unidimensional a dup\u0103 executarea apelului p(6,a).", " Limbajul C++/Limbajul C  Limbajul Pascal  void p(int k, int v[100])  { int w[100];    v[0]=w[0]=1;    for(int i=1;i<=k;i++)    {     for(int j=0;j<=i;j++)     {       if(j==0) v[j]=1;       else        if(i==j) v[j]=1;  type vector=array[0..99]of integer;  var a:vector;   procedure p(k:integer; var v:vector);  var w:vector; i,j:integer;  begin      v[0]:=1; w[0]:=1;      for i:=1 to k do begin        for j:=0 to i do           if j=0 then v[j]:=1            else"], "page_sentence_count_spacy": 8}, {"page_number": 53, "page_char_count": 834, "page_word_count": 280, "page_sentence_count_raw": 3, "page_token_count": 208.5, "text": "53          else v[j]=w[j-1]+w[j];     }     for(int j=0;j<=i;j++)       w[j]=v[j];    }  }              if i=j then v[j]:=1               else v[j]:=w[j-1]+w[j];      for j:=0 to i do w[j]:=v[j];      end;  end;    a)1   b)2  c)3  d)4  e) 5  f) 6    15.  Variabilele x,n,i,b,c memoreaz\u0103 numere naturale. Dac\u0103 ini\u021bial variabila b memoreaz\u0103  valoarea 3 \u0219i variabila x memoreaz\u0103 ini\u021bial valoarea 0, indica\u021bi valoarea afi\u0219at\u0103 de secven\u021ba  de program urm\u0103toare:  Limbajul C++/ Limbajul C  Limbajul Pascal  for(i=0;i<=99;i++)  {     c=0,n=i;     while(n>0)     {         c=c+n%b;         n=n/b;     }     if(c>x) x=c;  }  cout<<x; | printf(\"%d\",x);  for i:=0 to 99 do     begin       c:=0;n:=i;       while n>0 do    begin    c:=c+n mod b;    n:=n div b;    end;    if c>x then x:=c;  end;  write(x);    a) 4  b) 5  c) 6  d) 7   e) 8  f) 9", "sentences": ["53          else v[j]=w[j-1]+w[j];     }     for(int j=0;j<=i;j++)       w[j]=v[j];    }  }              if i=j then v[j]:=1               else v[j]:=w[j-1]+w[j];      for j:=0 to i do w[j]:=v[j];      end;  end;    a)1   b)2  c)3  d)4  e) 5  f) 6    15.", " Variabilele x,n,i,b,c memoreaz\u0103 numere naturale.", "Dac\u0103 ini\u021bial variabila b memoreaz\u0103  valoarea 3 \u0219i variabila x memoreaz\u0103 ini\u021bial valoarea 0, indica\u021bi valoarea afi\u0219at\u0103 de secven\u021ba  de program urm\u0103toare:  Limbajul C++/ Limbajul C  Limbajul Pascal  for(i=0;i<=99;i++)  {     c=0,n=i;     while(n>0)     {         c=c+n%b;         n=n/b;     }     if(c>x) x=c;  }  cout<<x; | printf(\"%d\",x);  for i:=0 to 99 do     begin       c:=0;n:=i;       while n>0 do    begin    c:=c+n mod b;    n:=n div b;    end;    if c>x then x:=c;  end;  write(x);    a) 4  b) 5  c) 6  d) 7   e) 8  f) 9"], "page_sentence_count_spacy": 3}, {"page_number": 54, "page_char_count": 1777, "page_word_count": 363, "page_sentence_count_raw": 8, "page_token_count": 444.25, "text": "54         Varianta 11    1. Preciza\u0163i care este num\u0103rul elementelor egale cu 1 (pentru limbajul C/C++)/true (pentru  limbajul Pascal) aflate pe diagonala principal\u0103 \u00een urma execut\u0103rii secven\u021bei de mai jos, \u00een  care a este un tablou bidimensional cu n linii \u0219i n coloane, iar i,j sunt variabile de tip  \u00eentreg.  Limbajul C++  for(i=n;i>=1;i--)  for(j=n;j>=1;j--)   a[i][j]=(i==j);    Limbajul  C  for(i=n;i>=1;i--)  for(j=n;j>=1;j--)   a[i][j]=(i==j);  Limbajul  Pascal  for i:=n downto 1 do  for j:=n downto 1 do   a[i,j]:=(i=j);  a) nu poate fi  calculat  b) n2  c) n-1  d) n2 -1  e) n  f) (n+1)*n/2    2. Preciza\u0163i care este complexitatea algoritmului de interclasare a dou\u0103 \u0219iruri, cu m \u0219i respectiv  n numere naturale (n\u2264m).  a) O(max(m,n))  b) O(min(m,n))  c) O(m+n)  d) O(m*n)  e) O(mlog2(n))  f) O(nlog2(m))    3. Indica\u0163i care dintre urm\u0103toarele secven\u021be de program calculeaz\u0103 \u00een variabila nr, \u00een mod  corect \u0219i eficient ca timp de executare, num\u0103rul cuburilor naturale perfecte mai mici sau  egale dec\u00e2t n (num\u0103r natural cunoscut).  a)  Limbajul  C++  int n,nr=0,i;  cin>>n;  for(i=1;i<=n;i++)  if(i*i*i<=n)  nr++;  cout<<nr;  Limbajul C  int n,nr=0,i;  scanf(\"%d\",&n);  for(i=1;i<=n;i++)  if(i*i*i<=n)  nr++;  printf(\"%d\",nr);  Limbajul  Pascal  var n,i,nr:integer;   BEGIN   readln(n);  nr:=0;   for i:=1 to n do  if i*i*i<=n then  nr:=nr+1;  writeln(nr);   END.  b)  Limbajul  C++  int n,nr=0,i,j;  cin>>n;  for(i=1;i<=n;i++)  for(j=1;j<=i;j++)  if(j*j*j==i)  nr++;  cout<<nr;          Limbajul C  int n, nr=0, j, i;  scanf(\"%d\",&n);  for(i=1;i<=n;i++)  for(j=1;j<=i;j++)  if(j*j*j==i)  nr++;  printf(\"%d\",nr);  Limbajul  Pascal  var  n,nr,i,j:integer;   BEGIN   readln(n);nr:=0;  for i:=1 to n do  for j:=1 to i do  if j*j*j=i then  nr:=nr+1;  writeln(nr);   END.", "sentences": ["54         Varianta 11    1.", "Preciza\u0163i care este num\u0103rul elementelor egale cu 1 (pentru limbajul C/C++)/true (pentru  limbajul Pascal) aflate pe diagonala principal\u0103 \u00een urma execut\u0103rii secven\u021bei de mai jos, \u00een  care a este un tablou bidimensional cu n linii \u0219i n coloane, iar i,j sunt variabile de tip  \u00eentreg.", " Limbajul C++  for(i=n;i>=1;i--)  for(j=n;j>=1;j--)   a[i][j]=(i==j);    Limbajul  C  for(i=n;i>=1;i--)  for(j=n;j>=1;j--)   a[i][j]=(i==j);  Limbajul  Pascal  for i:=n downto 1 do  for j:=n downto 1 do   a[i,j]:=(i=j);  a) nu poate fi  calculat  b) n2  c) n-1  d) n2 -1  e) n  f) (n+1)*n/2    2.", "Preciza\u0163i care este complexitatea algoritmului de interclasare a dou\u0103 \u0219iruri, cu m \u0219i respectiv  n numere naturale (n\u2264m).", " a) O(max(m,n))  b) O(min(m,n))  c) O(m+n)  d) O(m*n)  e) O(mlog2(n))  f) O(nlog2(m))    3.", "Indica\u0163i care dintre urm\u0103toarele secven\u021be de program calculeaz\u0103 \u00een variabila nr, \u00een mod  corect \u0219i eficient ca timp de executare, num\u0103rul cuburilor naturale perfecte mai mici sau  egale dec\u00e2t n (num\u0103r natural cunoscut).", " a)  Limbajul  C++  int n,nr=0,i;  cin>>n;  for(i=1;i<=n;i++)  if(i*i*i<=n)  nr++;  cout<<nr;  Limbajul C  int n,nr=0,i;  scanf(\"%d\",&n);  for(i=1;i<=n;i++)  if(i*i*i<=n)  nr++;  printf(\"%d\",nr);  Limbajul  Pascal  var n,i,nr:integer;   BEGIN   readln(n);  nr:=0;   for i:=1 to n do  if i*i*i<=n then  nr:=nr+1;  writeln(nr);   END.", " b)  Limbajul  C++  int n,nr=0,i,j;  cin>>n;  for(i=1;i<=n;i++)  for(j=1;j<=i;j++)  if(j*j*j==i)  nr++;  cout<<nr;          Limbajul C  int n, nr=0, j, i;  scanf(\"%d\",&n);  for(i=1;i<=n;i++)  for(j=1;j<=i;j++)  if(j*j*j==i)  nr++;  printf(\"%d\",nr);  Limbajul  Pascal  var  n,nr,i,j:integer;   BEGIN   readln(n);nr:=0;  for i:=1 to n do  for j:=1 to i do  if j*j*j=i then  nr:=nr+1;  writeln(nr);   END."], "page_sentence_count_spacy": 8}, {"page_number": 55, "page_char_count": 1731, "page_word_count": 349, "page_sentence_count_raw": 6, "page_token_count": 432.75, "text": "55    c)    Limbajul  C++  int n,nr;  cin>>n;  nr=(int)exp(1/2.0*  log(n));  cout<<nr;  Limbajul C  int n,nr;  scanf(\"%d\",&n);  nr=(int)exp(1/2.0*  log(n));  printf(\"%d\",nr);  Limbajul  Pascal  var n,nr:integer;   BEGIN   readln(n);   nr:=trunc(exp(1/2*  ln(n)));   writeln(nr);   END.  d)  Limbajul  C++  int n, nr;  cin>>n;  nr=n*n*(n+1)*(n+1)/4;  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=n*n*(n+1)*(n+1)/4;  printf(\"%d\",nr);  Limbajul  Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=n*n*(n+1)*(n+1)div 4;   writeln(nr);   END.  e)  Limbajul  C++  int n, nr;  cin>>n;  nr=n*n*(n+1)*(n+1)/6;  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=n*n*(n+1)*(n+1)/6;  printf(\"%d\",nr);  Limbajul  Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=n*n*(n+1)*(n+1)div 6;   writeln(nr);   END.  f)  Limbajul  C++  int n, nr;  cin>>n;  nr=(int)exp(1/3.0*  log(n));  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=(int)exp(1/3.0*  log(n));  printf(\"%d\",nr);  Limbajul  Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=trunc(exp(1/3*  ln(n)));   writeln(nr);   END.  4.    Se define\u0219te  func\u021bia:  \ud835\udc40\ud835\udc5b \ud835\udc58= {\ud835\udc40\ud835\udc5b\u22121 \ud835\udc58 + \ud835\udc58\u2217\ud835\udc40\ud835\udc5b\u22121 \ud835\udc58\u22121 \ud835\udc5d\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc62 \ud835\udc58> 0 1  \ud835\udc5d\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc62     \ud835\udc58= 0    Dac\u0103 se citesc numerele naturale n,k(n>=k) \u0219i se apeleaz\u0103 func\u021bia recursiv\u0103 scris\u0103 \u00eentr-un  limbaj de programare cunoscut (C++/C sau Pascal) care evalueaz\u0103 func\u021bia definit\u0103 mai sus,  valoarea calculat\u0103 reprezint\u0103:  a) produsul cartezian  b) num\u0103rul submul\u021bimilor  unei mul\u021bimi cu n elemente  c) afi\u0219area tuturor  aranjamentelor mul\u021bimii  {1,2,...n} luate c\u00e2te k  d) num\u0103rul submul\u021bimilor cu  k elemente ale unei mul\u021bimi  cu n elemente  e) afi\u0219area tuturor  combin\u0103rilor mul\u021bimii  {1,2,..,n}  luate c\u00e2te k  f) nici una dintre aceste  variante", "sentences": ["55    c)    Limbajul  C++  int n,nr;  cin>>n;  nr=(int)exp(1/2.0*  log(n));  cout<<nr;  Limbajul C  int n,nr;  scanf(\"%d\",&n);  nr=(int)exp(1/2.0*  log(n));  printf(\"%d\",nr);  Limbajul  Pascal  var n,nr:integer;   BEGIN   readln(n);   nr:=trunc(exp(1/2*  ln(n)));   writeln(nr);   END.", " d)  Limbajul  C++  int n, nr;  cin>>n;  nr=n*n*(n+1)*(n+1)/4;  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=n*n*(n+1)*(n+1)/4;  printf(\"%d\",nr);  Limbajul  Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=n*n*(n+1)*(n+1)div 4;   writeln(nr);   END.", " e)  Limbajul  C++  int n, nr;  cin>>n;  nr=n*n*(n+1)*(n+1)/6;  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=n*n*(n+1)*(n+1)/6;  printf(\"%d\",nr);  Limbajul  Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=n*n*(n+1)*(n+1)div 6;   writeln(nr);   END.", " f)  Limbajul  C++  int n, nr;  cin>>n;  nr=(int)exp(1/3.0*  log(n));  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=(int)exp(1/3.0*  log(n));  printf(\"%d\",nr);  Limbajul  Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=trunc(exp(1/3*  ln(n)));   writeln(nr);   END.", " 4.", "   Se define\u0219te  func\u021bia:  \ud835\udc40\ud835\udc5b \ud835\udc58= {\ud835\udc40\ud835\udc5b\u22121 \ud835\udc58 + \ud835\udc58\u2217\ud835\udc40\ud835\udc5b\u22121 \ud835\udc58\u22121 \ud835\udc5d\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc62 \ud835\udc58> 0 1  \ud835\udc5d\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc62     \ud835\udc58= 0    Dac\u0103 se citesc numerele naturale n,k(n>=k) \u0219i se apeleaz\u0103 func\u021bia recursiv\u0103 scris\u0103 \u00eentr-un  limbaj de programare cunoscut (C++/C sau Pascal) care evalueaz\u0103 func\u021bia definit\u0103 mai sus,  valoarea calculat\u0103 reprezint\u0103:  a) produsul cartezian  b) num\u0103rul submul\u021bimilor  unei mul\u021bimi cu n elemente  c) afi\u0219area tuturor  aranjamentelor mul\u021bimii  {1,2,...n} luate c\u00e2te k  d) num\u0103rul submul\u021bimilor cu  k elemente ale unei mul\u021bimi  cu n elemente  e) afi\u0219area tuturor  combin\u0103rilor mul\u021bimii  {1,2,..,n}  luate c\u00e2te k  f) nici una dintre aceste  variante"], "page_sentence_count_spacy": 6}, {"page_number": 56, "page_char_count": 1872, "page_word_count": 436, "page_sentence_count_raw": 11, "page_token_count": 468.0, "text": "56    5. Indica\u0163i care este efectul prelucr\u0103rii secven\u021bei de program de mai jos, pentru x, y numere  naturale cu x\u2264y:  Limbajul C++  int f(int x,int  y){  if(x==y) return x;  else if(x>y)  return x-1;  else   return   f(++x,--y);}  int main()  {int x, y;  cin>>x>>y;   cout<<f(x,y);  return 0;}  Limbajul C  int f(int x,int  y){  if(x==y) return x;  else if(x>y)  return x-1;  else   return   f(++x,--y);}  int main()  {int x, y;  scanf(\"%d%d\",&x,&y);  printf(\"%d\",f(x,y));  return 0;}  Limbajul Pascal  var x,y:integer;  function  f(x,y:integer):integ er;  begin  if x=y then f:=x  else  if x>y then f:=x-1  else  f:=f(succ(x),pred(y))  end;  begin  readln(x,y);  writeln(f(x,y));  end.  S-a notat cu [a] partea \u00eentreag\u0103 a num\u0103rului a \u0219i cu |a-b|, modulul diferen\u021bei a-b.  a) x+y  b) [y-x]  c) |y-x|  d) xy  e)[(x+y)/2]  f) yx    6. Indica\u0163i care este valoarea ini\u021bial\u0103 a variabilei a dac\u0103, \u00een urma execut\u0103rii secven\u021bei urm\u0103toare  de program, s-a afi\u0219at valoarea 6.  Limbajul  C++  int a=... ,n;  n=16327;  while(n!=0)  {  switch(n%10){   case 0: case 2: case  4:case 6: case 8:  a=a+n%2;break;  case 1: case 3: case  5:case 7: case 9:   a=a-n%2; break;}  n=n/10;  }  cout<<a<<endl;   Limbajul C   int a=... ,n;  n=16327;  while(n!=0)  {  switch(n%10){   case 0: case 2:  case 4:case 6:  case 8:  a=a+n%2;break;  case 1: case 3:  case 5:case 7:  case 9: a=a-n%2;  break;}  n=n/10;  }  printf(\"%d\",a);  Limbajul  Pascal  var n,a:integer;  BEGIN  a:=...;  n:=16327;  while n>0 do  begin  case  n mod 10 of  0,2,4,6,8:   a:=a+n mod 2;  1,3,5,7,9:   a:=a-n mod 2;   end;  n:=n div 10;  end;  writeln(a);  END.  a) 8  b)  nici una dintre   variante  c) 9  d) 13  e)10  f) 5    7.  Fie un graf neorientat conex cu 40 de noduri \u0219i 70 de muchii. Preciza\u021bi num\u0103rul maxim de  muchii care pot fi eliminate astfel \u00eenc\u00e2t graful s\u0103 r\u0103m\u00e2n\u0103 conex:  a) 31  b) 30  c) 1  d) 0  e) 39  f) 35", "sentences": ["56    5.", "Indica\u0163i care este efectul prelucr\u0103rii secven\u021bei de program de mai jos, pentru x, y numere  naturale cu x\u2264y:  Limbajul C++  int f(int x,int  y){  if(x==y) return x;  else if(x>y)  return x-1;  else   return   f(++x,--y);}  int main()  {int x, y;  cin>>x>>y;   cout<<f(x,y);  return 0;}  Limbajul C  int f(int x,int  y){  if(x==y) return x;  else if(x>y)  return x-1;  else   return   f(++x,--y);}  int main()  {int x, y;  scanf(\"%d%d\",&x,&y);  printf(\"%d\",f(x,y));  return 0;}  Limbajul Pascal  var x,y:integer;  function  f(x,y:integer):integ er;  begin  if x=y then f:=x  else  if x>y then f:=x-1  else  f:=f(succ(x),pred(y))  end;  begin  readln(x,y);  writeln(f(x,y));  end.", " S-a notat cu [a] partea \u00eentreag\u0103 a num\u0103rului a \u0219i cu |a-b|, modulul diferen\u021bei a-b.  a) x+y  b) [y-x]  c) |y-x|  d) xy  e)[(x+y)/2]  f) yx    6.", "Indica\u0163i care este valoarea ini\u021bial\u0103 a variabilei a dac\u0103, \u00een urma execut\u0103rii secven\u021bei urm\u0103toare  de program, s-a afi\u0219at valoarea 6.", " Limbajul  C++  int a=... ,n;  n=16327;  while(n!=0)  {  switch(n%10){   case 0: case 2: case  4:case 6: case 8:  a=a+n%2;break;  case 1: case 3: case  5:case 7: case 9:   a=a-n%2; break;}  n=n/10;  }  cout<<a<<endl;   Limbajul C   int a=... ,n;  n=16327;  while(n!=0)  {  switch(n%10){   case 0: case 2:  case 4:case 6:  case 8:  a=a+n%2;break;  case 1: case 3:  case 5:case 7:  case 9: a=a-n%2;  break;}  n=n/10;  }  printf(\"%d\",a);  Limbajul  Pascal  var n,a:integer;  BEGIN  a:=...;  n:=16327;  while n>0 do  begin  case  n mod 10 of  0,2,4,6,8:   a:=a+n mod 2;  1,3,5,7,9:   a:=a-n mod 2;   end;  n:=n div 10;  end;  writeln(a);  END.", " a) 8  b)  nici una dintre   variante  c) 9  d) 13  e)10  f) 5    7.", " Fie un graf neorientat conex cu 40 de noduri \u0219i 70 de muchii.", "Preciza\u021bi num\u0103rul maxim de  muchii care pot fi eliminate astfel \u00eenc\u00e2t graful s\u0103 r\u0103m\u00e2n\u0103 conex:  a) 31  b) 30  c) 1  d) 0  e) 39  f) 35"], "page_sentence_count_spacy": 8}, {"page_number": 57, "page_char_count": 1552, "page_word_count": 388, "page_sentence_count_raw": 6, "page_token_count": 388.0, "text": "57       8. Preciza\u021bi num\u0103rul grafurilor orientate complete cu n noduri care pot fi construite:  a) 4n*(n-1)/2  b) 4n*(n+1)/2  c) 3n*(n+1)/2  d)  4n/2  e)2n*(n-1)/2  f)  3n*(n-1)/2    9. Preciza\u021bi care din urm\u0103toarele \u0219iruri de numere nu poate reprezenta gradele v\u00e2rfurilor unui  arbore.  a) 2 2 1 1  b) 4 1 1 2 1 1  c) 1 2 1  d) 1 1 1 2 1 5  e) 1 1 1 2 1 4  f) 1 2 1 2 1 3    10. Preciza\u021bi care este valoarea produs\u0103 de subprogramului f definit mai jos, \u00een urma apelului  f(s),  atunci c\u00e2nd parametrul s prime\u0219te \u0219irul de caractere: 123abc4567  Limbajul C++  int f( char s[100])  {int i, nr=0, n=strlen(s);  for(i=0;s[i]>='0'&&s[i]<='9';i++)      nr=nr*10+s[n-i-1]-'0';  return nr;}  Limbajul C  int f( char s[100])  {int nr=0,i,n;  n=strlen(s);  for(i=0;s[i]>='0'&&s[i]<='9';i++)      nr=nr*10+s[n-i-1]-'0';   return nr;}    Limbajul Pascal  function f(s:String):longint;  var n,nr,i:longint ;  begin  n:=Length(s);nr:=0;i:=1;  while (s[i]>='0') and (s[i]<='9') do  begin  nr:=10*nr+ord(s[n-i+1])-ord('0');  i:=i+1;  end;f:=nr;    end;  a) 1234567  b) 123  c) 456  d) 321  e) 765  f)7654    11. Preciza\u021bi care este suma calculat\u0103 \u00een urma apelului f(1,n) al subprogramului f definit  mai jos, unde n este un num\u0103r natural cunoscut:  Limbajul C++  int f(int i, int n)  {     if(i<=3*n)       if(i%3!=0)           return f(i+1,n);      else         return i+f(i+1,n);      else return 0;   }    Limbajul C  int f(int i, int n)  {      if(i<=3*n)        if(i%3!=0)          return f(i+1,n);        else          return i+f(i+1,n);      else return 0;   }", "sentences": ["57       8.", "Preciza\u021bi num\u0103rul grafurilor orientate complete cu n noduri care pot fi construite:  a) 4n*(n-1)/2  b) 4n*(n+1)/2  c) 3n*(n+1)/2  d)  4n/2  e)2n*(n-1)/2  f)  3n*(n-1)/2    9.", "Preciza\u021bi care din urm\u0103toarele \u0219iruri de numere nu poate reprezenta gradele v\u00e2rfurilor unui  arbore.", " a) 2 2 1 1  b) 4 1 1 2 1 1  c) 1 2 1  d) 1 1 1 2 1 5  e) 1 1 1 2 1 4  f) 1 2 1 2 1 3    10.", "Preciza\u021bi care este valoarea produs\u0103 de subprogramului f definit mai jos, \u00een urma apelului  f(s),  atunci c\u00e2nd parametrul s prime\u0219te \u0219irul de caractere: 123abc4567  Limbajul C++  int f( char s[100])  {int i, nr=0, n=strlen(s);  for(i=0;s[i]>='0'&&s[i]<='9';i++)      nr=nr*10+s[n-i-1]-'0';  return nr;}  Limbajul C  int f( char s[100])  {int nr=0,i,n;  n=strlen(s);  for(i=0;s[i]>='0'&&s[i]<='9';i++)      nr=nr*10+s[n-i-1]-'0';   return nr;}    Limbajul Pascal  function f(s:String):longint;  var n,nr,i:longint ;  begin  n:=Length(s);nr:=0;i:=1;  while (s[i]>='0') and (s[i]<='9') do  begin  nr:=10*nr+ord(s[n-i+1])-ord('0');  i:=i+1;  end;f:=nr;    end;  a) 1234567  b) 123  c) 456  d) 321  e) 765  f)7654    11.", "Preciza\u021bi care este suma calculat\u0103 \u00een urma apelului f(1,n) al subprogramului f definit  mai jos, unde n este un num\u0103r natural cunoscut:  Limbajul C++  int f(int i, int n)  {     if(i<=3*n)       if(i%3!=0)           return f(i+1,n);      else         return i+f(i+1,n);      else return 0;   }    Limbajul C  int f(int i, int n)  {      if(i<=3*n)        if(i%3!=0)          return f(i+1,n);        else          return i+f(i+1,n);      else return 0;   }"], "page_sentence_count_spacy": 6}, {"page_number": 58, "page_char_count": 1712, "page_word_count": 400, "page_sentence_count_raw": 9, "page_token_count": 428.0, "text": "58    Limbajul Pascal  function f(i,n:integer):integer;  begin  if i<=3*n then    if i mod 3 =0 then       f:=f(i+1,n)+i    else f:=f(i+1,n)  else f:=0  end;  a)\u2211 \ud835\udc8a \ud835\udfd1\ud835\udc8f \ud835\udc8a=\ud835\udfcf  b)\u2211 3 \u2217\ud835\udc56 \ud835\udc5b \ud835\udc56=1   c) \u2211 \ud835\udc8a \ud835\udc8f \ud835\udc8a=\ud835\udfcf  d) \u2211 (\ud835\udc8a+ \ud835\udfd1) \ud835\udc8f \ud835\udc8a=\ud835\udfcf   e)\u2211 \ud835\udc8a\ud835\udfd1 \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf   f)\u2211 \ud835\udc8a \ud835\udc8f\ud835\udfd1 \u2044 \ud835\udc8a=\ud835\udfcf    12. Utiliz\u00e2nd metoda backtracking, se genereaz\u0103 toate posibilit\u0103\u021bile de a forma \u0219iruri din trei  cuvinte distincte din mul\u021bimea {examen, reu\u0219it, promovat, nota, felicit\u0103ri}. Primele trei  solu\u021bii sunt: examen reu\u0219it promovat; examen reu\u0219it nota; examen reu\u0219it felicit\u0103ri.  Indica\u021bi care este solu\u021bia generat\u0103 \u00eenainte de felicit\u0103ri examen reu\u0219it.  a) nota examen felicit\u0103ri  b) nota felicit\u0103ri promovat   c) felicit\u0103ri examen promovat  d) examen promovat  felicit\u0103ri  e) felicit\u0103ri nota examen  f) promovat examen  felicit\u0103ri    13. Dac\u0103 pentru variabila a se cite\u0219te valoarea 11, preciza\u021bi c\u00e2te valori pot fi citite pentru  variabila b astfel \u00eenc\u00e2t \u00een urma apelului f(a,b), subprogramul f de finit mai jos s\u0103  produc\u0103 valoarea 10.  Limbajul C++  int f(int a,int b)  {  if(a==b)            return a%2;     else   return  f(a,(a+b)/2)+f((a+b)/2+1,b); }    Limbajul C  int f(int a,int b)  {   if(a==b)            return a%2;     else  return  f(a,(a+b)/2)+f((a+b)/2+1,b);}  Limbajul Pascal  function f(a,b:integer):integer;  begin  if a=b then f:=a mod 2  else  f:=f(a,(a+b) div 2) +f((a+b) div 2+1,b);  end;  a) 2  b) 1  c) 0  d)3  e) 4  f)  7    14. Indica\u021bi pentru ce valori ale lui n \u0219i p, valoarea variabilei \u00eentregi x este 164, \u00een urma apelului   f(1) al subprogramului f definit mai jos.  Limbajul C++  int s[100],n,p,x;  void f(int k)  {    int i;      if(k==p+1) x++;  Limbajul C  int s[100],n,p,x;  void f(int k)  {    int i;      if(k==p+1) x++;", "sentences": ["58    Limbajul Pascal  function f(i,n:integer):integer;  begin  if i<=3*n then    if i mod 3 =0 then       f:=f(i+1,n)+i    else f:=f(i+1,n)  else f:=0  end;  a)\u2211 \ud835\udc8a \ud835\udfd1\ud835\udc8f \ud835\udc8a=\ud835\udfcf  b)\u2211 3 \u2217\ud835\udc56 \ud835\udc5b \ud835\udc56=1   c) \u2211 \ud835\udc8a \ud835\udc8f \ud835\udc8a=\ud835\udfcf  d) \u2211 (\ud835\udc8a+ \ud835\udfd1) \ud835\udc8f \ud835\udc8a=\ud835\udfcf   e)\u2211 \ud835\udc8a\ud835\udfd1 \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf   f)\u2211 \ud835\udc8a \ud835\udc8f\ud835\udfd1 \u2044 \ud835\udc8a=\ud835\udfcf    12.", "Utiliz\u00e2nd metoda backtracking, se genereaz\u0103 toate posibilit\u0103\u021bile de a forma \u0219iruri din trei  cuvinte distincte din mul\u021bimea {examen, reu\u0219it, promovat, nota, felicit\u0103ri}.", "Primele trei  solu\u021bii sunt: examen reu\u0219it promovat; examen reu\u0219it nota; examen reu\u0219it felicit\u0103ri.", " Indica\u021bi care este solu\u021bia generat\u0103 \u00eenainte de felicit\u0103ri examen reu\u0219it.", " a) nota examen felicit\u0103ri  b) nota felicit\u0103ri promovat   c) felicit\u0103ri examen promovat  d) examen promovat  felicit\u0103ri  e) felicit\u0103ri nota examen  f) promovat examen  felicit\u0103ri    13.", "Dac\u0103 pentru variabila a se cite\u0219te valoarea 11, preciza\u021bi c\u00e2te valori pot fi citite pentru  variabila b astfel \u00eenc\u00e2t \u00een urma apelului f(a,b), subprogramul f de finit mai jos s\u0103  produc\u0103 valoarea 10.", " Limbajul C++  int f(int a,int b)  {  if(a==b)            return a%2;     else   return  f(a,(a+b)/2)+f((a+b)/2+1,b); }    Limbajul C  int f(int a,int b)  {   if(a==b)            return a%2;     else  return  f(a,(a+b)/2)+f((a+b)/2+1,b);}  Limbajul Pascal  function f(a,b:integer):integer;  begin  if a=b then f:=a mod 2  else  f:=f(a,(a+b) div 2) +f((a+b) div 2+1,b);  end;  a) 2  b) 1  c) 0  d)3  e) 4  f)  7    14.", "Indica\u021bi pentru ce valori ale lui n \u0219i p, valoarea variabilei \u00eentregi x este 164, \u00een urma apelului   f(1) al subprogramului f definit mai jos.", " Limbajul C++  int s[100],n,p,x;  void f(int k)  {    int i;      if(k==p+1) x++;  Limbajul C  int s[100],n,p,x;  void f(int k)  {    int i;      if(k==p+1) x++;"], "page_sentence_count_spacy": 9}, {"page_number": 59, "page_char_count": 1086, "page_word_count": 255, "page_sentence_count_raw": 3, "page_token_count": 271.5, "text": "59    else  if(k==1)  for(i=1;i<=n;i++) f(k+1);      else  for(i=1+s[k-1];i<=n;i++)      {  s[k]=i;f(k+1); }}  else  if(k==1)  for(i=1;i<=n;i++) f(k+1);      else   for(i=1+s[k-1];i<=n;i++)      {  s[k]=i;f(k+1); }}    Limbajul Pascal  type vector=array[1..100] of integer;  var n,p,x:integer;  s: vector;  procedure f(k:integer);  var i,i1:integer;  begin  if k=p+1 then x:=x+1  else  if  k=1 then  for i1:=1 to n do  begin  s[k]:=i1; f(k+1);  end  else  for i:=1+s[k-1] to n do  begin  s[k]:=i; f(k+1);  end; end;  a) 82 \u0219i 2  b) 164 \u0219i 1  c) 328 \u0219i 4  d) 41 \u0219i  123  e) 41 \u0219i 1  f) 81 \u0219i 2    15. Preciza\u021bi care este valoarea produs\u0103 de subprogramul f, definit mai jos, \u00een urma apelului  f(1999,7).   Limbajul C++  int f(int x, int n)  {if(n)  if(n%2==0)   return (f(x,n/2)*f(x,n/2))%10;  else   return (x*f(x,n-1))%10;   else   return 1;}    Limbajul C  int f(int x, int n)  {if(n)   if(n%2==0)   return  (f(x,n/2)*f(x,n/2))%10;   else   return (x*f(x,n-1))%10;   else   return 1;}  Limbajul Pascal  function f(x,n:integer):integer;  begin  if n=0 then f:=1  else  if n mod 2=0 then", "sentences": ["59    else  if(k==1)  for(i=1;i<=n;i++) f(k+1);      else  for(i=1+s[k-1];i<=n;i++)      {  s[k]=i;f(k+1); }}  else  if(k==1)  for(i=1;i<=n;i++) f(k+1);      else   for(i=1+s[k-1];i<=n;i++)      {  s[k]=i;f(k+1); }}    Limbajul Pascal  type vector=array[1..100] of integer;  var n,p,x:integer;  s: vector;  procedure f(k:integer);  var i,i1:integer;  begin  if k=p+1 then x:=x+1  else  if  k=1 then  for i1:=1 to n do  begin  s[k]:=i1; f(k+1);  end  else  for i:=1+s[k-1] to n do  begin  s[k]:=i; f(k+1);  end; end;  a) 82 \u0219i 2  b) 164 \u0219i 1  c) 328 \u0219i 4  d) 41 \u0219i  123  e) 41 \u0219i 1  f) 81 \u0219i 2    15.", "Preciza\u021bi care este valoarea produs\u0103 de subprogramul f, definit mai jos, \u00een urma apelului  f(1999,7).", "  Limbajul C++  int f(int x, int n)  {if(n)  if(n%2==0)   return (f(x,n/2)*f(x,n/2))%10;  else   return (x*f(x,n-1))%10;   else   return 1;}    Limbajul C  int f(int x, int n)  {if(n)   if(n%2==0)   return  (f(x,n/2)*f(x,n/2))%10;   else   return (x*f(x,n-1))%10;   else   return 1;}  Limbajul Pascal  function f(x,n:integer):integer;  begin  if n=0 then f:=1  else  if n mod 2=0 then"], "page_sentence_count_spacy": 3}, {"page_number": 60, "page_char_count": 159, "page_word_count": 43, "page_sentence_count_raw": 1, "page_token_count": 39.75, "text": "60    f:=(f(x,n div 2)*f(x,n div 2)) mod 10  else   f:=(x*f(x,n-1)) mod 10;  end;  a) 798800599919  b) 9  c) nu poate fi  calculat\u0103 valoarea  d) 1  e) 0  f) 28", "sentences": ["60    f:=(f(x,n div 2)*f(x,n div 2)) mod 10  else   f:=(x*f(x,n-1)) mod 10;  end;  a) 798800599919  b) 9  c) nu poate fi  calculat\u0103 valoarea  d) 1  e) 0  f) 28"], "page_sentence_count_spacy": 1}, {"page_number": 61, "page_char_count": 1905, "page_word_count": 403, "page_sentence_count_raw": 9, "page_token_count": 476.25, "text": "61    Varianta 12    1. Preciza\u021bi care este num\u0103rul  muchiilor care trebuie ad\u0103ugate, \u00eentr-un graf neorientat conex  care are n noduri \u0219i n-1 muchii (n num\u0103r natural cunoscut),  pentru a deveni complet:   a) n*(n-1)/2  b) (n-1)*(n-2)/2  c) n  d) (n+1)*n/2  e) 0  f) n-1    2. \u00cen secven\u0163a urm\u0103toare i,j \u015fi n sunt variabile \u00eentregi, iar a este un tablou bidimensional  format din n linii \u015fi n coloane numerotate de la 1 la n. Indica\u021bi care este suma elementelor  de pe diagonala secundar\u0103 a tabloului a, \u00een urma execut\u0103rii acestei secven\u0163e.  Limbajul C++  for(i=1; i<=n; i++)  for(j=1; j<=n; j++)  a[i][j] = (i+j)% n;  Limbajul C  for(i=1; i<=n; i++)  for(j=1; j<=n; j++)  a[i][j] = (i+j)% n;  Limbajul Pascal  for i:=1 to n do  for j:=1 to n do  a[i,j]:=(i+j) mod n;  a)  n  b) n-1  c)  nu se poate calcula  d)  (n+1)*n/2  e) n2  f) n*n    3. Indica\u021bi care dintre urm\u0103toarele secven\u021be de program calculeaz\u0103 \u00een variabila nr, \u00een mod  corect \u0219i eficient ca timp de executare, suma primelor n cuburi naturale perfecte nenule (n  num\u0103r natural cunoscut).   a)  Limbajul C++  int n, nr=0, i;  cin>>n;  for(i=1;i<=n;i++)  if(i*i*i<=n)  nr+=i*i*i;  cout<<nr;  Limbajul C  int n, nr=0, i;  scanf(\"%d\",&n);  for(i=1;i<=n;i++)  if(i*i*i<=n)  nr+=i*i*i;   printf(\"%d\",nr);  Limbajul Pascal  var n,  nr,i:integer;   BEGIN   readln(n);  nr:=0;   for i:=1 to n do  if i*i*i<=n then  nr:=nr+i*i*i;  writeln(nr);   END.  b)   Limbajul C++  int n, nr=0, i, j;  cin>>n;  for(i=1;i<=n;i++)  for(j=1;j<=i;j++)  if(j*j*j==i)  nr+=i*i*i;  cout<<nr;  Limbajul C  int n, nr=0, i, j;  scanf(\"%d\",&n);  for(i=1;i<=n;i++)  for(j=1;j<=i;j++)  if(j*j*j==i)  nr+=i*i*i;  printf(\"%d\",nr);  Limbajul Pascal  var n, i, j  nr:integer;   BEGIN   readln(n);nr:=0;  for i:=1 to n do  for j:=1 to i do  if j*j*j=i then  nr:=nr+i*i*i;  writeln(nr);   END.  c)  Limbajul C++  int n, nr;  Limbajul C  int n, nr;  Limbajul Pascal  var n, nr:integer;", "sentences": ["61    Varianta 12    1.", "Preciza\u021bi care este num\u0103rul  muchiilor care trebuie ad\u0103ugate, \u00eentr-un graf neorientat conex  care are n noduri \u0219i n-1 muchii (n num\u0103r natural cunoscut),  pentru a deveni complet:   a) n*(n-1)/2  b) (n-1)*(n-2)/2  c) n  d) (n+1)*n/2  e) 0  f) n-1    2.", "\u00cen secven\u0163a urm\u0103toare i,j \u015fi n sunt variabile \u00eentregi, iar a este un tablou bidimensional  format din n linii \u015fi n coloane numerotate de la 1 la n. Indica\u021bi care este suma elementelor  de pe diagonala secundar\u0103 a tabloului a, \u00een urma execut\u0103rii acestei secven\u0163e.", " Limbajul C++  for(i=1; i<=n; i++)  for(j=1; j<=n; j++)  a[i][j] = (i+j)% n;  Limbajul C  for(i=1; i<=n; i++)  for(j=1; j<=n; j++)  a[i][j] = (i+j)% n;  Limbajul Pascal  for i:=1 to n do  for j:=1 to n do  a[i,j]:=(i+j) mod n;  a)  n  b) n-1  c)  nu se poate calcula  d)  (n+1)*n/2  e) n2  f) n*n    3.", "Indica\u021bi care dintre urm\u0103toarele secven\u021be de program calculeaz\u0103 \u00een variabila nr, \u00een mod  corect \u0219i eficient ca timp de executare, suma primelor n cuburi naturale perfecte nenule (n  num\u0103r natural cunoscut).", "  a)  Limbajul C++  int n, nr=0, i;  cin>>n;  for(i=1;i<=n;i++)  if(i*i*i<=n)  nr+=i*i*i;  cout<<nr;  Limbajul C  int n, nr=0, i;  scanf(\"%d\",&n);  for(i=1;i<=n;i++)  if(i*i*i<=n)  nr+=i*i*i;   printf(\"%d\",nr);  Limbajul Pascal  var n,  nr,i:integer;   BEGIN   readln(n);  nr:=0;   for i:=1 to n do  if i*i*i<=n then  nr:=nr+i*i*i;  writeln(nr);   END.", " b)   Limbajul C++  int n, nr=0, i, j;  cin>>n;  for(i=1;i<=n;i++)  for(j=1;j<=i;j++)  if(j*j*j==i)  nr+=i*i*i;  cout<<nr;  Limbajul C  int n, nr=0, i, j;  scanf(\"%d\",&n);  for(i=1;i<=n;i++)  for(j=1;j<=i;j++)  if(j*j*j==i)  nr+=i*i*i;  printf(\"%d\",nr);  Limbajul Pascal  var n, i, j  nr:integer;   BEGIN   readln(n);nr:=0;  for i:=1 to n do  for j:=1 to i do  if j*j*j=i then  nr:=nr+i*i*i;  writeln(nr);   END.", " c)  Limbajul C++  int n, nr;  Limbajul C  int n, nr;  Limbajul Pascal  var n, nr:integer;"], "page_sentence_count_spacy": 8}, {"page_number": 62, "page_char_count": 1673, "page_word_count": 345, "page_sentence_count_raw": 8, "page_token_count": 418.25, "text": "62    cin>>n;  nr=(int)exp(1/3.0*  log(n));  cout<<nr;  scanf(\"%d\",&n);  nr=(int)exp(1/3.0*  log(n)));  printf(\"%d\",nr);  BEGIN   readln(n);   nr:=trunc(exp(1/3*  ln(n)));   writeln(nr);   END.  d)  Limbajul C++  int n, nr;  cin>>n;  nr=n*n*(n+1)*(n+1)/4;  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=n*n*(n+1)*(n+1)/4;  printf(\"%d\",nr);  Limbajul Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=n*n*(n+1)*(n+1)  div 4;   writeln(nr);   END.  e)  Limbajul C++  int n, nr;  cin>>n;  nr=(int)exp(1/2.0*  log(n));  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=(int)exp(1/2.0*  log(n)));  printf(\"%d\",nr);  Limbajul Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=trunc(exp(1/2*  ln(n)));   writeln(nr);  END.  f)  Limbajul C++  int n, nr;  cin>>n;  nr=n*n*(n+1)*(n+1)/6;  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=n*n*(n+1)*(n+1)/6;  printf(\"%d\",nr);  Limbajul Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=n*n*(n+1)*(n+1)  div 6;   writeln(nr);   END.      4. Se define\u0219te recursiv o func\u021bie care calculeaz\u0103 num\u0103rul combin\u0103rilor de n luate c\u00e2te k  astfel:    \ud835\udc36\ud835\udc5b \ud835\udc58= { \ud835\udc5b\u2212\ud835\udc58+1 \ud835\udc58 \u2217\ud835\udc36\ud835\udc5b \ud835\udc58\u22121 \ud835\udc5d\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc62 \ud835\udc58> 0 1 \ud835\udc5d\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc62  \ud835\udc58= 0    Dac\u0103 se citesc numerele naturale n,k(n>=k) \u0219i se apeleaz\u0103 func\u021bia recursiv\u0103 scris\u0103 \u00eentr- un limbaj de programare cunoscut (C++/C/Pascal) care evalueaz\u0103 func\u021bia definit\u0103 mai sus,  preciza\u021bi care este num\u0103rul apelurilor necesare pentru a calcula \ud835\udc6a\ud835\udc8f \ud835\udc8c :  a) n  b) k  c) k-1  d) n+1  e) n+k  f) k+1    5. Preciza\u021bi num\u0103rul circuitelor care trec prin toate nodurile unui graf orientat tare conex cu  n noduri (n num\u0103r natural cunoscut).  a) cel pu\u021bin 1  b) exact 1 c) 0  d)  cel mult 1  e) exact n-2  f) exact n+1", "sentences": ["62    cin>>n;  nr=(int)exp(1/3.0*  log(n));  cout<<nr;  scanf(\"%d\",&n);  nr=(int)exp(1/3.0*  log(n)));  printf(\"%d\",nr);  BEGIN   readln(n);   nr:=trunc(exp(1/3*  ln(n)));   writeln(nr);   END.", " d)  Limbajul C++  int n, nr;  cin>>n;  nr=n*n*(n+1)*(n+1)/4;  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=n*n*(n+1)*(n+1)/4;  printf(\"%d\",nr);  Limbajul Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=n*n*(n+1)*(n+1)  div 4;   writeln(nr);   END.", " e)  Limbajul C++  int n, nr;  cin>>n;  nr=(int)exp(1/2.0*  log(n));  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=(int)exp(1/2.0*  log(n)));  printf(\"%d\",nr);  Limbajul Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=trunc(exp(1/2*  ln(n)));   writeln(nr);  END.", " f)  Limbajul C++  int n, nr;  cin>>n;  nr=n*n*(n+1)*(n+1)/6;  cout<<nr;  Limbajul C  int n, nr;  scanf(\"%d\",&n);  nr=n*n*(n+1)*(n+1)/6;  printf(\"%d\",nr);  Limbajul Pascal  var n, nr:integer;   BEGIN   readln(n);   nr:=n*n*(n+1)*(n+1)  div 6;   writeln(nr);   END.", "     4.", "Se define\u0219te recursiv o func\u021bie care calculeaz\u0103 num\u0103rul combin\u0103rilor de n luate c\u00e2te k  astfel:    \ud835\udc36\ud835\udc5b \ud835\udc58= { \ud835\udc5b\u2212\ud835\udc58+1 \ud835\udc58 \u2217\ud835\udc36\ud835\udc5b \ud835\udc58\u22121 \ud835\udc5d\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc62 \ud835\udc58> 0 1 \ud835\udc5d\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc62  \ud835\udc58= 0    Dac\u0103 se citesc numerele naturale n,k(n>=k) \u0219i se apeleaz\u0103 func\u021bia recursiv\u0103 scris\u0103 \u00eentr- un limbaj de programare cunoscut (C++/C/Pascal) care evalueaz\u0103 func\u021bia definit\u0103 mai sus,  preciza\u021bi care este num\u0103rul apelurilor necesare pentru a calcula \ud835\udc6a\ud835\udc8f \ud835\udc8c :  a) n  b) k  c) k-1  d) n+1  e) n+k  f) k+1    5.", "Preciza\u021bi num\u0103rul circuitelor care trec prin toate nodurile unui graf orientat tare conex cu  n noduri (n num\u0103r natural cunoscut).", " a) cel pu\u021bin 1  b) exact 1 c) 0  d)  cel mult 1  e) exact n-2  f) exact n+1"], "page_sentence_count_spacy": 8}, {"page_number": 63, "page_char_count": 1919, "page_word_count": 464, "page_sentence_count_raw": 11, "page_token_count": 479.75, "text": "63    6. Preciza\u021bi ce afi\u0219eaz\u0103 urm\u0103toarea secven\u021b\u0103 de program:   Limbajul C++    int a=0,n;     cin>>n;    do   {   switch(n%10)  {   case 0: case 2:  case 4:case 6:   case 8:   a=a-(n%2)*(n%10);  break;  case 1: case 3:  case 5:case 7: case  9:   a=a+(n%2)*(n%10);  break;  }  n=n/10;   } while(n!=0);  cout<<a<<endl;   Limbajul C    int a=0,n;  scanf(\"%d\",&n);    do   {   switch(n%10)  {   case 0: case 2:  case 4:case 6:   case 8:   a=a-(n%2)*(n%10);  break;   case 1: case 3:  case 5:case 7: case  9:   a=a+(n%2)*(n%10);  break;  }  n=n/10;   } while(n!=0);  printf(\"%d\",a);    Limbajul Pascal  var n,a:integer;  BEGIN  a:=0;  readln(n);  while n>0 do  begin  case  n mod 10 of  0,2,4,6,8:   a:=a-(n mod 2)*   (n mod 10);  1,3,5,7,9:   a:=a+(n mod 2)*  (n mod 10);   end;  n:=n div 10;  end;     writeln(a);  END.  a) suma cifrelor num\u0103rului n b) num\u0103rul cifrelor impare  din num\u0103rul n  c) diferen\u021ba dintre suma  cifrelor  pare  \u0219i  suma  cifrelor impare din num\u0103rul  n  d) num\u0103rul cifrelor prime din  num\u0103rul n  e) suma cifrelor impare din  num\u0103rul n  f) diferen\u021ba dintre suma  cifrelor impare \u0219i suma  cifrelor pare din num\u0103rul n    7. Folosind metoda backtracking se genereaz\u0103 toate \u0219irurile formate din patru caractere  distincte din mul\u021bimea {#,*,&,@,%}. Primele trei solu\u021bii sunt: #*&@,  #*&%,   #*@&. Indica\u021bi care este solu\u021bia generat\u0103 \u00eenainte de &*#@  a) &@%#  b) &#@%  c) &#%@  d) *&@%  e) *&%@  f) &@#%    8. Un graf orientat se nume\u0219te turneu, dac\u0103 \u00eentre oricare dou\u0103 v\u00e2rfuri i \u015fi j, i\u2260j, exist\u0103 un  singur arc. Preciza\u021bi num\u0103rul grafurilor turneu cu n noduri (n num\u0103r natural cunoscut).  a) 4n*(n-1)/2  b) 3n*(n-1)/2  c) 4n*(n+1)/2  d) 2n*(n-1)/2  e) 2n*(n+1)/2  f) 3n*(n+1)/2    9. Preciza\u021bi care din urm\u0103toarele \u0219iruri de numere poate reprezenta gradele v\u00e2rfurilor unui  arbore cu n noduri (n num\u0103r natural cunoscut).  a)  4 1 1 2 1 1  b) 2 1 1 1  c) 1 2 2  d)  1 1 1 2 1 5  e) 1 1 1  f) 1 1 1 2 1 6", "sentences": ["63    6.", "Preciza\u021bi ce afi\u0219eaz\u0103 urm\u0103toarea secven\u021b\u0103 de program:   Limbajul C++    int a=0,n;     cin>>n;    do   {   switch(n%10)  {   case 0: case 2:  case 4:case 6:   case 8:   a=a-(n%2)*(n%10);  break;  case 1: case 3:  case 5:case 7: case  9:   a=a+(n%2)*(n%10);  break;  }  n=n/10;   } while(n!=0);  cout<<a<<endl;   Limbajul C    int a=0,n;  scanf(\"%d\",&n);    do   {   switch(n%10)  {   case 0: case 2:  case 4:case 6:   case 8:   a=a-(n%2)*(n%10);  break;   case 1: case 3:  case 5:case 7: case  9:   a=a+(n%2)*(n%10);  break;  }  n=n/10;   } while(n!=0);  printf(\"%d\",a);    Limbajul Pascal  var n,a:integer;  BEGIN  a:=0;  readln(n);  while n>0 do  begin  case  n mod 10 of  0,2,4,6,8:   a:=a-(n mod 2)*   (n mod 10);  1,3,5,7,9:   a:=a+(n mod 2)*  (n mod 10);   end;  n:=n div 10;  end;     writeln(a);  END.", " a) suma cifrelor num\u0103rului n b) num\u0103rul cifrelor impare  din num\u0103rul n  c) diferen\u021ba dintre suma  cifrelor  pare  \u0219i  suma  cifrelor impare din num\u0103rul  n  d) num\u0103rul cifrelor prime din  num\u0103rul n  e) suma cifrelor impare din  num\u0103rul n  f) diferen\u021ba dintre suma  cifrelor impare \u0219i suma  cifrelor pare din num\u0103rul n    7.", "Folosind metoda backtracking se genereaz\u0103 toate \u0219irurile formate din patru caractere  distincte din mul\u021bimea {#,*,&,@,%}.", "Primele trei solu\u021bii sunt: #*&@,  #*&%,   #*@&.", "Indica\u021bi care este solu\u021bia generat\u0103 \u00eenainte de &*#@  a) &@%#  b) &#@%  c) &#%@  d) *&@%  e) *&%@  f) &@#%    8.", "Un graf orientat se nume\u0219te turneu, dac\u0103 \u00eentre oricare dou\u0103 v\u00e2rfuri i \u015fi j, i\u2260j, exist\u0103 un  singur arc.", "Preciza\u021bi num\u0103rul grafurilor turneu cu n noduri (n num\u0103r natural cunoscut).", " a) 4n*(n-1)/2  b) 3n*(n-1)/2  c) 4n*(n+1)/2  d) 2n*(n-1)/2  e) 2n*(n+1)/2  f) 3n*(n+1)/2    9.", "Preciza\u021bi care din urm\u0103toarele \u0219iruri de numere poate reprezenta gradele v\u00e2rfurilor unui  arbore cu n noduri (n num\u0103r natural cunoscut).", " a)  4 1 1 2 1 1  b) 2 1 1 1  c) 1 2 2  d)  1 1 1 2 1 5  e) 1 1 1  f) 1 1 1 2 1 6"], "page_sentence_count_spacy": 11}, {"page_number": 64, "page_char_count": 1948, "page_word_count": 458, "page_sentence_count_raw": 5, "page_token_count": 487.0, "text": "64    10. Preciza\u021bi care este valoarea  produs\u0103 de subprogramul f, definit mai jos,  \u00een urma apelului   f(s), atunci c\u00e2nd variabila s memoreaz\u0103  \u0219irul de caractere: 123abc45678  Limbajul C++  int f( char s[100])  {int nr=0,i,n=strlen(s),p=1;  for(i=0;s[i]>='0'&&s[i]<='9'; i++)   {nr=nr+p*(s[n-i-1]-'0');      p*=10;}  return nr;  }    Limbajul C  int f( char s[100])  {int nr=0,i,  n=strlen(s),p=1;  for(i=0;s[i]>='0'&&s[i]<='9'; i++)  {nr=nr+p*(s[n-i-1]-'0');      p*=10;}  return nr;}  Limbajul Pascal  function f(s:String):longint;  var n,nr,i,p:longint;  begin  n:=Length(s);nr:=0;i:=1;p:=1;  while (s[i]>='0') and (s[i]<='9') do  begin  nr:=nr+p*(ord(s[n-i+1])-ord('0'));  i:=i+1; p:=p*10;  end;f:=nr;    end;  a) 45678  b) 123  c) 876  d) 678  e) 654  f) 876    11. \u00cen urma apelului f(1,n) al subprogramului f definit mai jos, este calculat\u0103 valoarea  sumei\u2026:  Limbajul C++  float f(int i,int  n)  { if(i<=3*n)      if(i%3!=0)          return f(i+1,n);      else   return  1.0/i+f(i+1,n);     else return 0;}  Limbajul C  float f(int i,int  n)  { if(i<=3*n)     if(i%3!=0)          return f(i+1,n);      else   return  1.0/i+f(i+1,n);    else return 0;}  Limbajul Pascal  function  f(i,n:integer):double;  begin  if i<=3*n then  if i mod 3 =0 then  f:=f(i+1,n)+1/i  else f:=f(i+1,n)  else f:=0  end;  a)    \u2211 \ud835\udfcf\ud835\udc8a \u2044 \ud835\udfd1\ud835\udc8f \ud835\udc8a=\ud835\udfcf   b) \u2211 \ud835\udfcf(\ud835\udfd1\u2217\ud835\udc8a) \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf   c)   \u2211 \ud835\udfcf\ud835\udc8a \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf   d)  \u2211 \ud835\udfcf\ud835\udc8a \u2044 \ud835\udfd0\ud835\udc8f \ud835\udc8a=\ud835\udfcf    e) \u2211 \ud835\udfcf(\ud835\udc8a\u2212\ud835\udfd1) \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf   f)  \u2211 \ud835\udfcf(\ud835\udc8a+ \ud835\udfd1) \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf     12. Preciza\u021bi care este valoarea variabilei x, \u00een urma apelului f(1) al subprogramului f  definit mai jos, pentru n=4 \u0219i p=3.   Limbajul C++  int s[100],n,p,x;  void f(int k)  { int i,j,ok;  if(k==p+1)x++;      else          for(i=1;i<=n;i++)  {s[k]=i;  ok=1;  Limbajul C  int s[100],n,p,x;  void f(int k)  {int i,j,ok;  if(k==p+1) x++;    else          for(i=1;i<=n;i++)  {s[k]=i;  ok=1;  Limbajul  Pascal  type  vector=array[1..100]  of integer;  var n,p,x:integer;  s: vector;    procedure  f(k:integer);", "sentences": ["64    10.", "Preciza\u021bi care este valoarea  produs\u0103 de subprogramul f, definit mai jos,  \u00een urma apelului   f(s), atunci c\u00e2nd variabila s memoreaz\u0103  \u0219irul de caractere: 123abc45678  Limbajul C++  int f( char s[100])  {int nr=0,i,n=strlen(s),p=1;  for(i=0;s[i]>='0'&&s[i]<='9'; i++)   {nr=nr+p*(s[n-i-1]-'0');      p*=10;}  return nr;  }    Limbajul C  int f( char s[100])  {int nr=0,i,  n=strlen(s),p=1;  for(i=0;s[i]>='0'&&s[i]<='9'; i++)  {nr=nr+p*(s[n-i-1]-'0');      p*=10;}  return nr;}  Limbajul Pascal  function f(s:String):longint;  var n,nr,i,p:longint;  begin  n:=Length(s);nr:=0;i:=1;p:=1;  while (s[i]>='0') and (s[i]<='9') do  begin  nr:=nr+p*(ord(s[n-i+1])-ord('0'));  i:=i+1; p:=p*10;  end;f:=nr;    end;  a) 45678  b) 123  c) 876  d) 678  e) 654  f) 876    11.", "\u00cen urma apelului f(1,n) al subprogramului f definit mai jos, este calculat\u0103 valoarea  sumei\u2026:  Limbajul C++  float f(int i,int  n)  { if(i<=3*n)      if(i%3!=0)          return f(i+1,n);      else   return  1.0/i+f(i+1,n);     else return 0;}  Limbajul C  float f(int i,int  n)  { if(i<=3*n)     if(i%3!=0)          return f(i+1,n);      else   return  1.0/i+f(i+1,n);    else return 0;}  Limbajul Pascal  function  f(i,n:integer):double;  begin  if i<=3*n then  if i mod 3 =0 then  f:=f(i+1,n)+1/i  else f:=f(i+1,n)  else f:=0  end;  a)    \u2211 \ud835\udfcf\ud835\udc8a \u2044 \ud835\udfd1\ud835\udc8f \ud835\udc8a=\ud835\udfcf   b) \u2211 \ud835\udfcf(\ud835\udfd1\u2217\ud835\udc8a) \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf   c)   \u2211 \ud835\udfcf\ud835\udc8a \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf   d)  \u2211 \ud835\udfcf\ud835\udc8a \u2044 \ud835\udfd0\ud835\udc8f \ud835\udc8a=\ud835\udfcf    e) \u2211 \ud835\udfcf(\ud835\udc8a\u2212\ud835\udfd1) \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf   f)  \u2211 \ud835\udfcf(\ud835\udc8a+ \ud835\udfd1) \u2044 \ud835\udc8f \ud835\udc8a=\ud835\udfcf     12.", "Preciza\u021bi care este valoarea variabilei x, \u00een urma apelului f(1) al subprogramului f  definit mai jos, pentru n=4 \u0219i p=3.", "  Limbajul C++  int s[100],n,p,x;  void f(int k)  { int i,j,ok;  if(k==p+1)x++;      else          for(i=1;i<=n;i++)  {s[k]=i;  ok=1;  Limbajul C  int s[100],n,p,x;  void f(int k)  {int i,j,ok;  if(k==p+1) x++;    else          for(i=1;i<=n;i++)  {s[k]=i;  ok=1;  Limbajul  Pascal  type  vector=array[1..100]  of integer;  var n,p,x:integer;  s: vector;    procedure  f(k:integer);"], "page_sentence_count_spacy": 5}, {"page_number": 65, "page_char_count": 1356, "page_word_count": 346, "page_sentence_count_raw": 4, "page_token_count": 339.0, "text": "65    for(j=1;j<k;j++)  if(s[k]==s[j])  ok=0;  if(ok) f(k+1);     }}  for(j=1;j<k;j++)  if(s[k]==s[j])  ok=0;  if(ok)f(k+1);      }}  var i,i1,j,ok:integer;  begin  if k=p+1 then  x:=x+1  else  if  k=1 then   for i1:=1 to n do    begin     s[k]:=i1; f(k+1);    end  else  for i:=1 to n do   begin    s[k]:=i;     ok:=1;    for j:=1 to k-1 do     if s[k]=s[j] then       ok:=0;    if ok=1 then f(k+1);       end; end;  a) 120  b) 12  c) 10  d) 8  e) 24  f) 60    13. Preciza\u021bi num\u0103rul maxim de muchii care pot exista \u00eentr-un graf neorientat cu n noduri (n  num\u0103r natural cunoscut):  a) n  b) n*(n+1)/2  c) n*(n-1)/2  d) n*n*(n-1)  e) n+1  f) n-1    14. Dac\u0103 pentru variabila n se cite\u0219te valoarea 12, preciza\u021bi care este valoarea produs\u0103 \u00een urma  apelului f(1,n,n) al subprogramului f definit mai jos:  Limbajul C++  int f(int a,int b, int n)  {     if(a==b)      return (n%a==0?1:0);   else  return   f(a,(a+b)/2,n)+f((a+b)/2+1,b,n); }  Limbajul C  int f(int a,int b, int n)  {     if(a==b)      return (n%a==0?1:0);   else  return  f(a,(a+b)/2,n)+f((a+b)/2+1,b,n);}    Limbajul Pascal  function f(a,b,n:integer):integer;  begin  if a=b then   if n mod a=0 then f:=1  else f:=0  else f:=f(a,(a+b) div 2,n)+f((a+b) div 2+1,b,n);  end;  a) 0  b) 2  c) 4  d) 6  e) 12  f) 8    15. Indica\u021bi ce reprezint\u0103 valoarea afi\u0219at\u0103 \u00een urma rul\u0103ri programului de mai jos:", "sentences": ["65    for(j=1;j<k;j++)  if(s[k]==s[j])  ok=0;  if(ok) f(k+1);     }}  for(j=1;j<k;j++)  if(s[k]==s[j])  ok=0;  if(ok)f(k+1);      }}  var i,i1,j,ok:integer;  begin  if k=p+1 then  x:=x+1  else  if  k=1 then   for i1:=1 to n do    begin     s[k]:=i1; f(k+1);    end  else  for i:=1 to n do   begin    s[k]:=i;     ok:=1;    for j:=1 to k-1 do     if s[k]=s[j] then       ok:=0;    if ok=1 then f(k+1);       end; end;  a) 120  b) 12  c) 10  d) 8  e) 24  f) 60    13.", "Preciza\u021bi num\u0103rul maxim de muchii care pot exista \u00eentr-un graf neorientat cu n noduri (n  num\u0103r natural cunoscut):  a) n  b) n*(n+1)/2  c) n*(n-1)/2  d) n*n*(n-1)  e) n+1  f) n-1    14.", "Dac\u0103 pentru variabila n se cite\u0219te valoarea 12, preciza\u021bi care este valoarea produs\u0103 \u00een urma  apelului f(1,n,n) al subprogramului f definit mai jos:  Limbajul C++  int f(int a,int b, int n)  {     if(a==b)      return (n%a==0?1:0);   else  return   f(a,(a+b)/2,n)+f((a+b)/2+1,b,n); }  Limbajul C  int f(int a,int b, int n)  {     if(a==b)      return (n%a==0?1:0);   else  return  f(a,(a+b)/2,n)+f((a+b)/2+1,b,n);}    Limbajul Pascal  function f(a,b,n:integer):integer;  begin  if a=b then   if n mod a=0 then f:=1  else f:=0  else f:=f(a,(a+b) div 2,n)+f((a+b) div 2+1,b,n);  end;  a) 0  b) 2  c) 4  d) 6  e) 12  f) 8    15.", "Indica\u021bi ce reprezint\u0103 valoarea afi\u0219at\u0103 \u00een urma rul\u0103ri programului de mai jos:"], "page_sentence_count_spacy": 4}, {"page_number": 66, "page_char_count": 1060, "page_word_count": 253, "page_sentence_count_raw": 2, "page_token_count": 265.0, "text": "66    Limbajul C++  #include<iostream>  using namespace std;  int f(int n, int k)  {if(k==1||k==n) return 1;    else   if(k>n)return 0;   else    return     f(n-1,k-1)+k*f(n-1,k); }   int main()  {   int n, k,s=0;     cin>>n;     for(k=1;k<=n;k++)      s=s+f(n,k);     cout<<s; return 0;}    Limbajul C  #include <stdio.h>  int f(int n, int k)  {if(k==1||k==n) return 1;    else      if(k>n)return 0;      else     return      f(n-1,k-1)+k*f(n-1,k); }   int main()  {   int n, k,s=0;     scanf(\"%d\",&n);     for(k=1;k<=n;k++)      s=s+f(n,k);   printf(\"%d\",s); return 0;}  Limbajul Pascal  function f(n,k:integer):integer;  begin  if k=1 then f:=1  else if k=n then f:=1  else if k>n then f:=0  else  f:=f(n-1,k-1)+k*f(n-1,k);   end;  var n,k,s:integer;  begin    readln(n);s:=0;    for k:=1 to n do s:=s+f(n,k);    writeln(s);readln;  end.  a) \ud835\udc68\ud835\udc8f \ud835\udc8c  b)  num\u0103rul submul\u021bimilor  ordonate mul\u021bimii {1,2\u2026n}  c) num\u0103rul total al  parti\u021biilor mul\u021bimii {1,2\u2026n}  d) num\u0103rul submul\u021bimilor  mul\u021bimii {1,2\u2026n}  e) \ud835\udc6a\ud835\udc8f \ud835\udc8c  f) num\u0103rul submul\u021bimilor  ordonate mul\u021bimii {1,2\u2026k}", "sentences": ["66    Limbajul C++  #include<iostream>  using namespace std;  int f(int n, int k)  {if(k==1||k==n) return 1;    else   if(k>n)return 0;   else    return     f(n-1,k-1)+k*f(n-1,k); }   int main()  {   int n, k,s=0;     cin>>n;     for(k=1;k<=n;k++)      s=s+f(n,k);     cout<<s; return 0;}    Limbajul C  #include <stdio.h>  int f(int n, int k)  {if(k==1||k==n) return 1;    else      if(k>n)return 0;      else     return      f(n-1,k-1)+k*f(n-1,k); }   int main()  {   int n, k,s=0;     scanf(\"%d\",&n);     for(k=1;k<=n;k++)      s=s+f(n,k);   printf(\"%d\",s); return 0;}  Limbajul Pascal  function f(n,k:integer):integer;  begin  if k=1 then f:=1  else if k=n then f:=1  else if k>n then f:=0  else  f:=f(n-1,k-1)+k*f(n-1,k);   end;  var n,k,s:integer;  begin    readln(n);s:=0;    for k:=1 to n do s:=s+f(n,k);    writeln(s);readln;  end.", " a) \ud835\udc68\ud835\udc8f \ud835\udc8c  b)  num\u0103rul submul\u021bimilor  ordonate mul\u021bimii {1,2\u2026n}  c) num\u0103rul total al  parti\u021biilor mul\u021bimii {1,2\u2026n}  d) num\u0103rul submul\u021bimilor  mul\u021bimii {1,2\u2026n}  e) \ud835\udc6a\ud835\udc8f \ud835\udc8c  f) num\u0103rul submul\u021bimilor  ordonate mul\u021bimii {1,2\u2026k}"], "page_sentence_count_spacy": 2}, {"page_number": 67, "page_char_count": 1432, "page_word_count": 309, "page_sentence_count_raw": 19, "page_token_count": 358.0, "text": "67    Varianta 13    1. Indica\u021bi c\u00e2te dintre expresiile urm\u0103toarele au valoarea 1 (Limbajul C/C++), respectiv  true (Limbajul Pascal) dac\u0103 \u0219i numai dac\u0103 valorile variabilelor a \u0219i b sunt numere  \u00eentregi pare consecutive.  Limbajul C/C++  1. (a%2)&&(b%2)&&(a-b==2)  2. (a%2)&&(a-b==2||b-a==2)  3. !(a%2)&& abs(a-b)==2  4. !(a%2)&&!(b%2)&& abs(a- b)==2  5. !!(a%2)&&(a-b==2)  6. (a%2==0)&&!(abs(a- b)==2)  Limbajul Pascal  1. (a mod 2<>0) and (b mod  2<>0) and (a-b=2)  2. (a mod 2<>0) and ((a-b=2)  or (b-a=2))  3. not(a mod 2<>0) and  (abs(a-b)=2)  4. not(a mod 2<>0) and   not (b mod 2<>0) and   (abs(a-b)=2)  5. not(not(a mod 2<>0)) and   (a-b=2)  6. (a mod 2=0) and not(abs(a- b)=2)  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    2.  Preciza\u021bi ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei urm\u0103toare, \u00een care se consider\u0103 c\u0103  variabilele a \u0219i b memoreaz\u0103 numere reale.  Limbajul C++  a=5.2;  b=-3.25;  a-=b;  b*=2;  cout<<ceil(a+b)<<\" \"<<  floor(a-b);    Limbajul Pascal  a:=5.2;  b:=-3.25;  a:=a-b;  b:=b*2;  write(round(a+b),' ',trunc(a- b));  Limbajul C  a=5.2;  b=-3.25;  a-=b;   b*=2;  printf(\"%g %g\",ceil(a+b),floor(a-b));  a) -5 8  b) -4 8  c) 1 14  d) 1 15  e) 2 14  f) 2 15    3.  Preciza\u021bi ce se afi\u0219eaz\u0103 la sf\u00e2r\u0219itul execut\u0103rii secven\u021bei urm\u0103toare.  Limbajul C++  void p(int a, int &b)  { a++;     b=b*a;    b-=10;}  int g(int a, int b)  Limbajul Pascal  var a,b:integer;  procedure p(a:integer; var  b:integer);  begin     inc(a);", "sentences": ["67    Varianta 13    1.", "Indica\u021bi c\u00e2te dintre expresiile urm\u0103toarele au valoarea 1 (Limbajul C/C++), respectiv  true (Limbajul Pascal) dac\u0103 \u0219i numai dac\u0103 valorile variabilelor a \u0219i b sunt numere  \u00eentregi pare consecutive.", " Limbajul C/C++  1. (", "a%2)&&(b%2)&&(a-b==2)  2. (", "a%2)&&(a-b==2||b-a==2)  3. !(", "a%2)&& abs(a-b)==2  4. !(", "a%2)&&!(b%2)&& abs(a- b)==2  5. !!(", "a%2)&&(a-b==2)  6. (", "a%2==0)&&!(abs(a- b)==2)  Limbajul Pascal  1. (", "a mod 2<>0) and (b mod  2<>0) and (a-b=2)  2. (", "a mod 2<>0) and ((a-b=2)  or (b-a=2))  3.", "not(a mod 2<>0) and  (abs(a-b)=2)  4.", "not(a mod 2<>0) and   not (b mod 2<>0) and   (abs(a-b)=2)  5.", "not(not(a mod 2<>0)) and   (a-b=2)  6. (", "a mod 2=0) and not(abs(a- b)=2)  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    2.", " Preciza\u021bi ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei urm\u0103toare, \u00een care se consider\u0103 c\u0103  variabilele a \u0219i b memoreaz\u0103 numere reale.", " Limbajul C++  a=5.2;  b=-3.25;  a-=b;  b*=2;  cout<<ceil(a+b)<<\" \"<<  floor(a-b);    Limbajul Pascal  a:=5.2;  b:=-3.25;  a:=a-b;  b:=b*2;  write(round(a+b),' ',trunc(a- b));  Limbajul C  a=5.2;  b=-3.25;  a-=b;   b*=2;  printf(\"%g %g\",ceil(a+b),floor(a-b));  a) -5 8  b) -4 8  c) 1 14  d) 1 15  e) 2 14  f) 2 15    3.", " Preciza\u021bi ce se afi\u0219eaz\u0103 la sf\u00e2r\u0219itul execut\u0103rii secven\u021bei urm\u0103toare.", " Limbajul C++  void p(int a, int &b)  { a++;     b=b*a;    b-=10;}  int g(int a, int b)  Limbajul Pascal  var a,b:integer;  procedure p(a:integer; var  b:integer);  begin     inc(a);"], "page_sentence_count_spacy": 19}, {"page_number": 68, "page_char_count": 1205, "page_word_count": 465, "page_sentence_count_raw": 5, "page_token_count": 301.25, "text": "68    { a*=10;     b+=a;    a=b;     return a;}  int main()  { int a=2,b=7;    p(a,b);    cout<<g(b,a);}       b:=b*a;     b:=b-10;  end;    function  g(a,b:integer):integer;  begin    a:=a*10;    b:=b+a;    a:=b;    g:=a;  end;    begin    a:=2;    b:=7;    p(a,b);    write(g(b,a));  end.  Limbajul C  void p(int a, int *b)  { a++;    *b=*b*a;    *b-=10;}  int g(int a, int b)  { a*=10;    b+=a;    a=b;    return a;}  int main()  { int a=2,b=7;    p(a,&b);    printf(\"%d\",g(b,a)); }  a) 27  b) 41  c) 72  d) 73  e) 112  f) 113    4.  Se consider\u0103 subprogramul f definit mai jos. Preciza\u021bi ce se afi\u0219eaz\u0103 \u00een urma apelului  f(8).  Limbajul C++  void f(int i)  { if (i>1)     if (i%2)         {f(i-1);          cout<<i-1<<\" \";}     else {i--;           f(i);}   }    Limbajul Pascal  procedure f(i:integer);  begin    if i>1 then      if i mod 2<>0 then          begin            f(i-1);            write(i-1,' ');          end        else          begin            dec(i);            f(i);          end;  end;  Limbajul C  void f(int i)  { if (i>1)     if (i%2)         {f(i-1);          printf(\"%d \",i-1);}     else {i--;            f(i);}  }  a) 2 3 5  b) 2 4 6  c) 3 5 7  d) 5 3 2   e) 6 4 2  f) 7 5 3", "sentences": ["68    { a*=10;     b+=a;    a=b;     return a;}  int main()  { int a=2,b=7;    p(a,b);    cout<<g(b,a);}       b:=b*a;     b:=b-10;  end;    function  g(a,b:integer):integer;  begin    a:=a*10;    b:=b+a;    a:=b;    g:=a;  end;    begin    a:=2;    b:=7;    p(a,b);    write(g(b,a));  end.", " Limbajul C  void p(int a, int *b)  { a++;    *b=*b*a;    *b-=10;}  int g(int a, int b)  { a*=10;    b+=a;    a=b;    return a;}  int main()  { int a=2,b=7;    p(a,&b);    printf(\"%d\",g(b,a)); }  a) 27  b) 41  c) 72  d) 73  e) 112  f) 113    4.", " Se consider\u0103 subprogramul f definit mai jos.", "Preciza\u021bi ce se afi\u0219eaz\u0103 \u00een urma apelului  f(8).", " Limbajul C++  void f(int i)  { if (i>1)     if (i%2)         {f(i-1);          cout<<i-1<<\" \";}     else {i--;           f(i);}   }    Limbajul Pascal  procedure f(i:integer);  begin    if i>1 then      if i mod 2<>0 then          begin            f(i-1);            write(i-1,' ');          end        else          begin            dec(i);            f(i);          end;  end;  Limbajul C  void f(int i)  { if (i>1)     if (i%2)         {f(i-1);          printf(\"%d \",i-1);}     else {i--;            f(i);}  }  a) 2 3 5  b) 2 4 6  c) 3 5 7  d) 5 3 2   e) 6 4 2  f) 7 5 3"], "page_sentence_count_spacy": 5}, {"page_number": 69, "page_char_count": 1881, "page_word_count": 419, "page_sentence_count_raw": 13, "page_token_count": 470.25, "text": "69      5. Preciza\u021bi ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei date, \u00een care se consider\u0103 c\u0103  variabilele x \u0219i y sunt de tip \u00eentreg.  Limbajul C++  x=5;  y=2;  cout<<++x/y+++1;  cout<<endl<<x<<\" \"<<y;  Limbajul Pascal  x:=5;  y:=2;  inc(x);  writeln(x div y+1);  inc(y);  writeln(x,' ',y);  Limbajul C  x=5;  y=2;  printf(\"%d\",++x/y+++1);  printf(\"\\n%d %d\",x,y);  a)  4    6  3     b)  4     6 2  c)  4     5 2  d)  3    6 3  e)  3    6 2  f)  3    5 2    6.  \u0218tiind c\u0103 variabila s este de tip \u015fir de caractere, preciza\u021bi ce se va afi\u0219a dup\u0103 executarea  urm\u0103toarei secven\u021be de instruc\u0163iuni.   Limbajul C/C++  strcpy(s, \"ExamenUPB\");  for (i=0;i<strlen(s)/2;i++)       s[i]=s[strlen(s)-i-2];  strcpy(s,s+2);  strcpy(s+strlen(s)-2,  s+strlen(s)-1);  printf(\"%s\",s); | cout<<s;  Limbajul Pascal  s:='ExamenUPB';  for i:=1 to length(s)  div 2  do              s[i]:=s[length(s)-i];  delete(s,1,2);  delete(s,length(s)-1,1);  write(s);  a) UnenUB  b) UnenUP  c) neenUB  d) neenUP  e) nennUB  f) nennUP    7. Indica\u021bi care este num\u0103rul de compara\u021bii executate pentru ordonarea descresc\u0103toare a  unui tablou unidimensional cu 50 elemente, prin metoda interschimb\u0103rii.   a) 25  b) 49  c) 50  d) 1225  e) 1226  f) 2450    8. Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate codurile formate din cinci caractere  distincte ale mul\u021bimii {a,b,c,d,e,f}. Primele cinci solu\u021bii generate sunt:  abcde,abcdf,abced,abcef,abcfd. Indica\u021bi care sunt codurile generate  imediat \u00een fa\u0163a solu\u0163iei dcbae, dar \u0219i imediat dup\u0103 aceasta.  a) dcaef;      dcafe  b) dcafe;    dcbaf  c) dcbaf;    dcbea  d) dcbfe;    dceab  e) dcbef;    dcbfe  f) dcbfa;   dcbaf    9. La o cantin\u0103 se prepar\u0103 zilnic 5 sortimente pentru felul \u00eent\u00e2i, 10 pentru felul doi \u0219i 6  tipuri de desert. Preciza\u021bi c\u00e2te posibilit\u0103\u021bi de a alege un meniu exist\u0103, \u0219tiind c\u0103 un  meniu este alc\u0103tuit din felul \u00eent\u00e2i, felul doi \u0219i facultativ desert.", "sentences": ["69      5.", "Preciza\u021bi ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei date, \u00een care se consider\u0103 c\u0103  variabilele x \u0219i y sunt de tip \u00eentreg.", " Limbajul C++  x=5;  y=2;  cout<<++x/y+++1;  cout<<endl<<x<<\" \"<<y;  Limbajul Pascal  x:=5;  y:=2;  inc(x);  writeln(x div y+1);  inc(y);  writeln(x,' ',y);  Limbajul C  x=5;  y=2;  printf(\"%d\",++x/y+++1);  printf(\"\\n%d %d\",x,y);  a)  4    6  3     b)  4     6 2  c)  4     5 2  d)  3    6 3  e)  3    6 2  f)  3    5 2    6.", " \u0218tiind c\u0103 variabila s este de tip \u015fir de caractere, preciza\u021bi ce se va afi\u0219a dup\u0103 executarea  urm\u0103toarei secven\u021be de instruc\u0163iuni.", "  Limbajul C/C++  strcpy(s, \"ExamenUPB\");  for (i=0;i<strlen(s)/2;i++)       s[i]=s[strlen(s)-i-2];  strcpy(s,s+2);  strcpy(s+strlen(s)-2,  s+strlen(s)-1);  printf(\"%s\",s); | cout<<s;  Limbajul Pascal  s:='ExamenUPB';  for i:=1 to length(s)  div 2  do              s[i]:=s[length(s)-i];  delete(s,1,2);  delete(s,length(s)-1,1);  write(s);  a) UnenUB  b) UnenUP  c) neenUB  d) neenUP  e) nennUB  f) nennUP    7.", "Indica\u021bi care este num\u0103rul de compara\u021bii executate pentru ordonarea descresc\u0103toare a  unui tablou unidimensional cu 50 elemente, prin metoda interschimb\u0103rii.", "  a) 25  b) 49  c) 50  d) 1225  e) 1226  f) 2450    8.", "Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate codurile formate din cinci caractere  distincte ale mul\u021bimii {a,b,c,d,e,f}.", "Primele cinci solu\u021bii generate sunt:  abcde,abcdf,abced,abcef,abcfd.", "Indica\u021bi care sunt codurile generate  imediat \u00een fa\u0163a solu\u0163iei dcbae, dar \u0219i imediat dup\u0103 aceasta.", " a) dcaef;      dcafe  b) dcafe;    dcbaf  c) dcbaf;    dcbea  d) dcbfe;    dceab  e) dcbef;    dcbfe  f) dcbfa;   dcbaf    9.", "La o cantin\u0103 se prepar\u0103 zilnic 5 sortimente pentru felul \u00eent\u00e2i, 10 pentru felul doi \u0219i 6  tipuri de desert.", "Preciza\u021bi c\u00e2te posibilit\u0103\u021bi de a alege un meniu exist\u0103, \u0219tiind c\u0103 un  meniu este alc\u0103tuit din felul \u00eent\u00e2i, felul doi \u0219i facultativ desert."], "page_sentence_count_spacy": 13}, {"page_number": 70, "page_char_count": 2197, "page_word_count": 552, "page_sentence_count_raw": 21, "page_token_count": 549.25, "text": "70    a) 50  b) 80  c) 90  d) 250  e) 300  f) 350    10. Fie un graf neorientat cu 10 noduri. Gradele v\u00e2rfurilor acestuia sunt re\u021binute \u00een \u0219irul:  4,2,2,3,3,3,2,4,2,3. Preciza\u021bi care este num\u0103rul de muchii ce trebuie  ad\u0103ugate pentru ca graful s\u0103 devin\u0103 complet.  a) 45  b) 41  c) 31  d) 27  e) 26  f) 17    11. Fie un graf neorientat complet cu 50 noduri. Preciza\u021bi care este num\u0103rul minim de  muchii care trebuie eliminate pentru ca graful s\u0103 fie hamiltonian.  a) 0  b) 25  c) 50  d) 612  e) 1175  f) 1225    12. Preciza\u021bi c\u00e2\u021bi arbori binari cu 3 noduri, numerotate de la 1 la 3, se pot construi. Un  arbore binar este un arbore \u00een care fiecare nod are cel mult doi descenden\u021bi direc\u021bi  (fii), ordona\u021bi: fiu st\u00e2ng, fiu drept. Dac\u0103 un nod are un singur descendent trebuie  specificat dac\u0103 este fiu st\u00e2ng sau fiu drept.  a) 6  b) 8  c) 9  d) 21  e) 24  f) 30    13. Fie arborele cu r\u0103d\u0103cin\u0103 cu nodurile numerotate de la 1 la 15, reprezentat prin  vectorul de ta\u021bi: (10,8,4,10,1,4,5,10,8,0,3,5,3,12,3). Preciza\u021bi c\u00e2\u021bi  descenden\u021bi are nodul 4.  a) 6  b) 5  c) 4  d) 3  e) 2  f) 1    14. Preciza\u021bi c\u00e2te grafuri neorientate distincte cu 25 noduri, dintre care cel pu\u021bin un nod  este izolat, se pot construi.  a) 2276  b) 2300  c) 3\u22192279  d) 52\u22192276  e) 3\u22192303  f) 52\u22192300    15. Fie secven\u021ba de instruc\u021biuni folosit\u0103 pentru ridicarea la puterea p a unei matrice  p\u0103tratice a, de ordin n. Elementele tabloului a sunt numere \u00eentregi, iar n \u0219i p sunt  numere naturale nenule. Variabilele a, b, c sunt tablouri bidimensionale, cu n linii \u0219i  n coloane, iar variabilele i,j,k sunt de tip \u00eentreg.  Limbajul C/C++  for(i=1;i<=n;i++)    for(j=1;j<=n;j++)      b[i][j]=(i==j);  for(q=1;q<=p;q++)   {for(i=1;i<=n;i++)    for(j=1;j<=n;j++)     {c[i][j]=0;      for(k=1;k<=n;k++)   c[i][j]=  c[i][j]+b[i][k]*a[k][j];              }  for(i=1;i<=n;i++)               for(j=1;j<=n;j++)      b[i][j]=c[i][j];  Limbajul Pascal  for i:=1 to n do    for j:=1 to n do      if i=j  then b[i,j]:=1      else b[i,j]:=0;  for q:=1 to p do     begin      for i:=1 to n do       for j:=1 to n do          begin           c[i,j]:=0;           for k:=1 to n do   c[i,j]:=c[i,j]+b[i,k]*a[k,j];          end;      for i:=1 to n do", "sentences": ["70    a) 50  b) 80  c) 90  d) 250  e) 300  f) 350    10.", "Fie un graf neorientat cu 10 noduri.", "Gradele v\u00e2rfurilor acestuia sunt re\u021binute \u00een \u0219irul:  4,2,2,3,3,3,2,4,2,3.", "Preciza\u021bi care este num\u0103rul de muchii ce trebuie  ad\u0103ugate pentru ca graful s\u0103 devin\u0103 complet.", " a) 45  b) 41  c) 31  d) 27  e) 26  f) 17    11.", "Fie un graf neorientat complet cu 50 noduri.", "Preciza\u021bi care este num\u0103rul minim de  muchii care trebuie eliminate pentru ca graful s\u0103 fie hamiltonian.", " a) 0  b) 25  c) 50  d) 612  e) 1175  f) 1225    12.", "Preciza\u021bi c\u00e2\u021bi arbori binari cu 3 noduri, numerotate de la 1 la 3, se pot construi.", "Un  arbore binar este un arbore \u00een care fiecare nod are cel mult doi descenden\u021bi direc\u021bi  (fii), ordona\u021bi: fiu st\u00e2ng, fiu drept.", "Dac\u0103 un nod are un singur descendent trebuie  specificat dac\u0103 este fiu st\u00e2ng sau fiu drept.", " a) 6  b) 8  c) 9  d) 21  e) 24  f) 30    13.", "Fie arborele cu r\u0103d\u0103cin\u0103 cu nodurile numerotate de la 1 la 15, reprezentat prin  vectorul de ta\u021bi: (10,8,4,10,1,4,5,10,8,0,3,5,3,12,3).", "Preciza\u021bi c\u00e2\u021bi  descenden\u021bi are nodul 4.", " a) 6  b) 5  c) 4  d) 3  e) 2  f) 1    14.", "Preciza\u021bi c\u00e2te grafuri neorientate distincte cu 25 noduri, dintre care cel pu\u021bin un nod  este izolat, se pot construi.", " a) 2276  b) 2300  c) 3\u22192279  d) 52\u22192276  e) 3\u22192303  f) 52\u22192300    15.", "Fie secven\u021ba de instruc\u021biuni folosit\u0103 pentru ridicarea la puterea p a unei matrice  p\u0103tratice a, de ordin n. Elementele tabloului a sunt numere \u00eentregi, iar n \u0219i p sunt  numere naturale nenule.", "Variabilele a, b, c sunt tablouri bidimensionale, cu n linii \u0219i  n coloane, iar variabilele i,j,k sunt de tip \u00eentreg.", " Limbajul C/C++  for(i=1;i<=n;i++)    for(j=1;j<=n;j++)      b[i][j]=(i==j);  for(q=1;q<=p;q++)   {for(i=1;i<=n;i++)    for(j=1;j<=n;j++)     {c[i][j]=0;      for(k=1;k<=n;k++)   c[i][j]=  c[i][j]+b[i][k]*a[k][j];              }  for(i=1;i<=n;i++)               for(j=1;j<=n;j++)      b[i][j]=c[i][j];  Limbajul Pascal  for i:=1 to n do    for j:=1 to n do      if i=j  then b[i,j]:=1      else b[i,j]:=0;  for q:=1 to p do     begin      for i:=1 to n do       for j:=1 to n do          begin           c[i,j]:=0;           for k:=1 to n do   c[i,j]:=c[i,j]+b[i,k]*a[k,j];          end;      for i:=1 to n do"], "page_sentence_count_spacy": 20}, {"page_number": 71, "page_char_count": 278, "page_word_count": 82, "page_sentence_count_raw": 2, "page_token_count": 69.5, "text": "71     }        for j:=1 to n do              b[i,j]:=c[i,j];     end;  Preciza\u021bi de c\u00e2te ori se execut\u0103 opera\u021bia de \u00eenmul\u021bire \u00een cadrul secven\u021bei date pentru  ridicarea la puterea p a matricei p\u0103tratice a de ordin n.  a) (n3)p  b) (p+1)\u2219n3  c) p\u2219n3  d) (p-1)\u2219n3  e) p\u2219n2  f) n3", "sentences": ["71     }        for j:=1 to n do              b[i,j]:=c[i,j];     end;  Preciza\u021bi de c\u00e2te ori se execut\u0103 opera\u021bia de \u00eenmul\u021bire \u00een cadrul secven\u021bei date pentru  ridicarea la puterea p a matricei p\u0103tratice a de ordin n.  a) (n3)p  b) (p+1)\u2219n3  c) p\u2219n3  d) (p-1)\u2219n3  e) p\u2219n2  f) n3"], "page_sentence_count_spacy": 1}, {"page_number": 72, "page_char_count": 1654, "page_word_count": 378, "page_sentence_count_raw": 19, "page_token_count": 413.5, "text": "72    Varianta 14    1. Indica\u0163i care expresie dintre urm\u0103toarele are valoarea 1 (Limbajul C/C++), respectiv  true (Limbajul Pascal) dac\u0103 \u0219i numai dac\u0103 valorile variabilelor a \u0219i b sunt numere  \u00eentregi impare consecutive.  Limbajul C/C++  1. (a%2==1)&&!(b%2)&& abs(a- b)==2  2. !(a%2)&&!(b%2)&& abs(a- b)==2  3. !(!(a%2)&&!(b%2))&&  abs(a-b)==2  4. (a%2==1&&b%2!=1)&&(a- b==2|| b-a==2)  5. !(a%2)&&!(b%2)&&!(abs(a- b)==2)  6. (a%2)&&(b%2)&& abs(a- b)!=2  Limbajul Pascal  1. (a mod 2=1) and (not(b mod  2<>0)) and (abs(a-b)=2)  2. not(a mod 2<>0) and        not(b mod 2<>0) and      (abs(a-b)=2)  3. not(not(a mod 2<>0) and            (not(b mod 2<>0))) and        (abs(a-b)=2)  4. ((a mod 2=1) and             (b mod 2<>1)) and ((a-b=2)  or (b-a=2))  5. not(a mod 2<>0) and        not(b mod 2<>0) and   not(abs(a-b)=2)  6. (a mod 2<>0) and (b mod  2<>0) and (abs(a-b)<>2)  a) 1  b) 2  c) 3  d) 4  e) 5   f) 6    2.  Preciza\u021bi ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei urm\u0103toare, dac\u0103 variabila \u00eentreag\u0103 x  are valoarea ini\u021bial\u0103 1234.  Limbajul C++  x=x%100/10*10/10%10 +  x/10%10;  cout<<ceil(sqrt(x)+0.5)<<  \" \"<< floor(sqrt(x)-0.5);    Limbajul Pascal  x:= x mod 100 div 10*10 div  10 mod 10 +x div 10 mod 10;  write(round(sqrt(x)+0.5),  ' ',trunc(sqrt(x)-0.5));  Limbajul C  x=x%100/10*10/10%10 +  x/10%10;  printf(\"%g %g\",  ceil(sqrt(x)+0.5),  floor(sqrt(x)-0.5));  a) 2 0  b) 2 1  c) 2 2  d) 3 1  e) 3 2  f) 5 3    3.  Preciza\u021bi ce se afi\u0219eaz\u0103 la sf\u00e2r\u0219itul execut\u0103rii secven\u021bei urm\u0103toare.  Limbajul C++  void p(int a, int &b)     { a+=a+b;       b+=a;       a=b-a; }  Limbajul Pascal  var a,b:integer;  procedure p(a:integer; var  b:integer);  begin", "sentences": ["72    Varianta 14    1.", "Indica\u0163i care expresie dintre urm\u0103toarele are valoarea 1 (Limbajul C/C++), respectiv  true (Limbajul Pascal) dac\u0103 \u0219i numai dac\u0103 valorile variabilelor a \u0219i b sunt numere  \u00eentregi impare consecutive.", " Limbajul C/C++  1. (", "a%2==1)&&!(b%2)&& abs(a- b)==2  2. !(", "a%2)&&!(b%2)&& abs(a- b)==2  3. !(!(", "a%2)&&!(b%2))&&  abs(a-b)==2  4. (", "a%2==1&&b%2!=1)&&(a- b==2|| b-a==2)  5. !(", "a%2)&&!(b%2)&&!(abs(a- b)==2)  6. (", "a%2)&&(b%2)&& abs(a- b)!=2  Limbajul Pascal  1. (", "a mod 2=1) and (not(b mod  2<>0)) and (abs(a-b)=2)  2.", "not(a mod 2<>0) and        not(b mod 2<>0) and      (abs(a-b)=2)  3.", "not(not(a mod 2<>0) and            (not(b mod 2<>0))) and        (abs(a-b)=2)  4. ((", "a mod 2=1) and             (b mod 2<>1)) and ((a-b=2)  or (b-a=2))  5.", "not(a mod 2<>0) and        not(b mod 2<>0) and   not(abs(a-b)=2)  6. (", "a mod 2<>0) and (b mod  2<>0) and (abs(a-b)<>2)  a) 1  b) 2  c) 3  d) 4  e) 5   f) 6    2.", " Preciza\u021bi ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei urm\u0103toare, dac\u0103 variabila \u00eentreag\u0103 x  are valoarea ini\u021bial\u0103 1234.", " Limbajul C++  x=x%100/10*10/10%10 +  x/10%10;  cout<<ceil(sqrt(x)+0.5)<<  \" \"<< floor(sqrt(x)-0.5);    Limbajul Pascal  x:= x mod 100 div 10*10 div  10 mod 10 +x div 10 mod 10;  write(round(sqrt(x)+0.5),  ' ',trunc(sqrt(x)-0.5));  Limbajul C  x=x%100/10*10/10%10 +  x/10%10;  printf(\"%g %g\",  ceil(sqrt(x)+0.5),  floor(sqrt(x)-0.5));  a) 2 0  b) 2 1  c) 2 2  d) 3 1  e) 3 2  f) 5 3    3.", " Preciza\u021bi ce se afi\u0219eaz\u0103 la sf\u00e2r\u0219itul execut\u0103rii secven\u021bei urm\u0103toare.", " Limbajul C++  void p(int a, int &b)     { a+=a+b;       b+=a;       a=b-a; }  Limbajul Pascal  var a,b:integer;  procedure p(a:integer; var  b:integer);  begin"], "page_sentence_count_spacy": 19}, {"page_number": 73, "page_char_count": 1406, "page_word_count": 449, "page_sentence_count_raw": 6, "page_token_count": 351.5, "text": "73    int main()    { int a=5,b=10;      p(a,b);      cout<<a<<\" \"<<b;      p(a,b);      cout<<endl<<a<<\" \"<<b;   }       a:=a+a+b;     b:=b+a;     a:=b-a;  end;    begin    a:=5;    b:=10;    p(a,b);     writeln(a,' ',b);    p(a,b);     writeln(a,' ',b);  end.  Limbajul C  void p(int a, int *b)   { a+=a+(*b);     *b+=a;     a=*b-a; }  int main()  { int a=5,b=10;    p(a,&b);      printf(\"%d %d\",a,b);    p(a,&b);    printf(\"\\n%d %d\",a,b);}  a)  5 30    5 70  b)  5 30    5 80  c) 5 30    10 80  d)  10 30    10 30  e)  10 30    30 70  f)  10 30    30 80    4.  Preciza\u021bi care este valoarea returnat\u0103 de func\u021bie la apelul f(1502).   Limbajul C/C++  int f(int i)  { if(i==0) return 10;    else      if(i%10==0 || i%10==5)        return f(i/10)*10+i;           else     return i%10 * f(i/10);  }  Limbajul Pascal  function  f(i:integer):integer;  begin     if i=0 then f:=10   else  if (i mod 10=0) or (i mod 5=0)    then f:=f(i div 10)*10 + i  else     f:=(i mod 10)*f(i div 10);  end;  a) 3175  b) 2600  c) 2330  d) 2050  e) 530  f) 350    5. Preciza\u021bi ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei urm\u0103toare, \u00een care se consider\u0103 c\u0103  variabilele x \u0219i y sunt de tip \u00eentreg.  Limbajul C++  x=2; y=5;  while(x<y)    { cout<<++x+y++<<\" \";      x++; }    Limbajul Pascal  x:=2; y:=5;  while x<y do    begin       inc(x);       write(x+y,' ');       inc(y);       inc(x);    end;  Limbajul C  x=2; y=5;  while(x<y)", "sentences": ["73    int main()    { int a=5,b=10;      p(a,b);      cout<<a<<\" \"<<b;      p(a,b);      cout<<endl<<a<<\" \"<<b;   }       a:=a+a+b;     b:=b+a;     a:=b-a;  end;    begin    a:=5;    b:=10;    p(a,b);     writeln(a,' ',b);    p(a,b);     writeln(a,' ',b);  end.", " Limbajul C  void p(int a, int *b)   { a+=a+(*b);     *b+=a;     a=*b-a; }  int main()  { int a=5,b=10;    p(a,&b);      printf(\"%d %d\",a,b);    p(a,&b);    printf(\"\\n%d %d\",a,b);}  a)  5 30    5 70  b)  5 30    5 80  c) 5 30    10 80  d)  10 30    10 30  e)  10 30    30 70  f)  10 30    30 80    4.", " Preciza\u021bi care este valoarea returnat\u0103 de func\u021bie la apelul f(1502).", "  Limbajul C/C++  int f(int i)  { if(i==0) return 10;    else      if(i%10==0 || i%10==5)        return f(i/10)*10+i;           else     return i%10 * f(i/10);  }  Limbajul Pascal  function  f(i:integer):integer;  begin     if i=0 then f:=10   else  if (i mod 10=0) or (i mod 5=0)    then f:=f(i div 10)*10 + i  else     f:=(i mod 10)*f(i div 10);  end;  a) 3175  b) 2600  c) 2330  d) 2050  e) 530  f) 350    5.", "Preciza\u021bi ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei urm\u0103toare, \u00een care se consider\u0103 c\u0103  variabilele x \u0219i y sunt de tip \u00eentreg.", " Limbajul C++  x=2; y=5;  while(x<y)    { cout<<++x+y++<<\" \";      x++; }    Limbajul Pascal  x:=2; y:=5;  while x<y do    begin       inc(x);       write(x+y,' ');       inc(y);       inc(x);    end;  Limbajul C  x=2; y=5;  while(x<y)"], "page_sentence_count_spacy": 6}, {"page_number": 74, "page_char_count": 1877, "page_word_count": 434, "page_sentence_count_raw": 19, "page_token_count": 469.25, "text": "74    { printf(\"%d \",++x+y++);    x++; }  a) 7 10 13  b) 8 10  c) 8 11 14  d) 9 11  e) 9 12  f) 9 12 15    6.  \u0218tiind c\u0103 variabila s este de tip \u015fir de caractere, preciza\u021bi ce se va afi\u0219a dup\u0103 executarea  urm\u0103toarei secven\u021be de instruc\u0163iuni.   Limbajul C/C++  strcpy(s, \"Examen-UPB\");  for(i=strlen(s)/2;i>0;i--)       s[i]=s[strlen(s)-i];  strcpy(s+strlen(s)/2-1,  s+strlen(s)/2+1);  printf(\"%s\",s); | cout<<s;  Limbajul Pascal  s:='Examen-UPB';  for i:=length(s) div 2 downto 2  do s[i]:=s[length(s)-i+2];  delete(s,length(s) div 2,2);  write(s);  a) -UPB     b) -n-UPB     c) n-UPB     d) EBPUUPB  e) EBPU-UPB  f) EBPU--UPB      7. Indica\u021bi care este num\u0103rul necesar de compara\u021bii pentru ordonarea prin interschimbare  a unui tablou unidimensional cu 100 elemente.  a) 99  b) 2475  c) 4851  d) 4950  e) 5050  f) 10000    8. Indica\u021bi c\u00e2te numere divizibile cu 10, cu 10 cifre, pot fi construite folosind numai  cifrele 0, 1 \u0219i 2.  a) 6561  b) 13122  c) 13212  d) 15322  e) 19683  f) 59049    9. Fie mul\u021bimile A={1,2,3,4}, B={1,2,3}, C={1,2}, D={1,2,3,4}. Preciza\u021bi care  este al 10-lea element al produsului cartezian A\u00d7B\u00d7C\u00d7D, c\u00e2t \u0219i antepenultimul  element.  a) 1212; 4322  b) 1212; 4323  c) 1213; 4322  d) 1221; 4322      e) 1312; 4322    f) 1312; 4323      10. Fie un graf neorientat cu 25 noduri \u0219i 40 muchii. Preciza\u021bi care este num\u0103rul maxim  de noduri izolate pe care le poate avea graful.  a) 16  b) 15  c) 14  d) 13  e) 10  f) 5    11. Fie un graf neorientat cu 100 noduri. Preciza\u021bi care este num\u0103rul minim de muchii  necesar pentru ca graful s\u0103 nu aib\u0103 noduri izolate.  a) 48  b) 49  c) 50  d) 98  e) 99  f) 100    12. Preciza\u021bi care este num\u0103rul maxim de frunze al unui arbore binar cu 100 noduri care  are \u00een\u0103l\u021bimea minim\u0103. Un arbore binar este un arbore \u00een care fiecare nod are cel mult  doi descenden\u021bi direc\u021bi (fii).   a) 99  b) 69  c) 51  d) 50  e) 37  f) 34", "sentences": ["74    { printf(\"%d \",++x+y++);    x++; }  a) 7 10 13  b) 8 10  c) 8 11 14  d) 9 11  e) 9 12  f) 9 12 15    6.", " \u0218tiind c\u0103 variabila s este de tip \u015fir de caractere, preciza\u021bi ce se va afi\u0219a dup\u0103 executarea  urm\u0103toarei secven\u021be de instruc\u0163iuni.", "  Limbajul C/C++  strcpy(s, \"Examen-UPB\");  for(i=strlen(s)/2;i>0;i--)       s[i]=s[strlen(s)-i];  strcpy(s+strlen(s)/2-1,  s+strlen(s)/2+1);  printf(\"%s\",s); | cout<<s;  Limbajul Pascal  s:='Examen-UPB';  for i:=length(s) div 2 downto 2  do s[i]:=s[length(s)-i+2];  delete(s,length(s) div 2,2);  write(s);  a) -UPB     b) -n-UPB     c) n-UPB     d) EBPUUPB  e) EBPU-UPB  f) EBPU--UPB      7.", "Indica\u021bi care este num\u0103rul necesar de compara\u021bii pentru ordonarea prin interschimbare  a unui tablou unidimensional cu 100 elemente.", " a) 99  b) 2475  c) 4851  d) 4950  e) 5050  f) 10000    8.", "Indica\u021bi c\u00e2te numere divizibile cu 10, cu 10 cifre, pot fi construite folosind numai  cifrele 0, 1 \u0219i 2.", " a) 6561  b) 13122  c) 13212  d) 15322  e) 19683  f) 59049    9.", "Fie mul\u021bimile A={1,2,3,4}, B={1,2,3}, C={1,2}, D={1,2,3,4}.", "Preciza\u021bi care  este al 10-lea element al produsului cartezian A\u00d7B\u00d7C\u00d7D, c\u00e2t \u0219i antepenultimul  element.", " a) 1212; 4322  b) 1212; 4323  c) 1213; 4322  d) 1221; 4322      e) 1312; 4322    f) 1312; 4323      10.", "Fie un graf neorientat cu 25 noduri \u0219i 40 muchii.", "Preciza\u021bi care este num\u0103rul maxim  de noduri izolate pe care le poate avea graful.", " a) 16  b) 15  c) 14  d) 13  e) 10  f) 5    11.", "Fie un graf neorientat cu 100 noduri.", "Preciza\u021bi care este num\u0103rul minim de muchii  necesar pentru ca graful s\u0103 nu aib\u0103 noduri izolate.", " a) 48  b) 49  c) 50  d) 98  e) 99  f) 100    12.", "Preciza\u021bi care este num\u0103rul maxim de frunze al unui arbore binar cu 100 noduri care  are \u00een\u0103l\u021bimea minim\u0103.", "Un arbore binar este un arbore \u00een care fiecare nod are cel mult  doi descenden\u021bi direc\u021bi (fii).", "  a) 99  b) 69  c) 51  d) 50  e) 37  f) 34"], "page_sentence_count_spacy": 19}, {"page_number": 75, "page_char_count": 966, "page_word_count": 223, "page_sentence_count_raw": 8, "page_token_count": 241.5, "text": "75    13. Fie arborele cu r\u0103d\u0103cin\u0103 cu nodurile numerotate de la 1 la 15, reprezentat prin vectorul  de ta\u021bi: (10,8,4,10,1,4,5,10,8,0,3,5,3,12,3). Preciza\u021bi c\u00e2te lan\u021buri  elementare distincte de lungime 3, care pleac\u0103 din rad\u0103cin\u0103, exist\u0103.  a) 2  b) 3  c) 4  d) 5  e) 6  f) 7    14. Preciza\u021bi c\u00e2te grafuri orientate distincte cu 25 noduri, dintre care cel pu\u021bin un nod este  izolat, se pot construi.  a) 52\u22192600  b) 3\u22192603  c) 2600  d) 52\u22192552  e) 3\u22192555  f) 2552    15. Preciza\u021bi care este complexitatea timp pentru urm\u0103toarea secven\u021b\u0103 de program, unde n  reprezint\u0103 num\u0103rul de elemente al unui tablou unidimensional v, numerotat de la 1 la  n, cu elemente numere \u00eentregi, iar x un num\u0103r \u00eentreg.  Limbajul C/C++  j=0;  for(i=1; i<=n; i++)    if(v[i]!=x)     { j++; v[j]=v[i]; }  n=j;  Limbajul Pascal  j:=0;  for i:=1 to n do     if v[i]<>x then    begin     inc(j);v[j]:=v[i];           end;    n:=j;  a) O(n)  b) O(logn)  c) O(n\u2219logn)  d) O(n2)  e) O(n3)  f) O(2n)", "sentences": ["75    13.", "Fie arborele cu r\u0103d\u0103cin\u0103 cu nodurile numerotate de la 1 la 15, reprezentat prin vectorul  de ta\u021bi: (10,8,4,10,1,4,5,10,8,0,3,5,3,12,3).", "Preciza\u021bi c\u00e2te lan\u021buri  elementare distincte de lungime 3, care pleac\u0103 din rad\u0103cin\u0103, exist\u0103.", " a) 2  b) 3  c) 4  d) 5  e) 6  f) 7    14.", "Preciza\u021bi c\u00e2te grafuri orientate distincte cu 25 noduri, dintre care cel pu\u021bin un nod este  izolat, se pot construi.", " a) 52\u22192600  b) 3\u22192603  c) 2600  d) 52\u22192552  e) 3\u22192555  f) 2552    15.", "Preciza\u021bi care este complexitatea timp pentru urm\u0103toarea secven\u021b\u0103 de program, unde n  reprezint\u0103 num\u0103rul de elemente al unui tablou unidimensional v, numerotat de la 1 la  n, cu elemente numere \u00eentregi, iar x un num\u0103r \u00eentreg.", " Limbajul C/C++  j=0;  for(i=1; i<=n; i++)    if(v[i]!=x)     { j++; v[j]=v[i]; }  n=j;  Limbajul Pascal  j:=0;  for i:=1 to n do     if v[i]<>x then    begin     inc(j);v[j]:=v[i];           end;    n:=j;  a) O(n)  b) O(logn)  c) O(n\u2219logn)  d) O(n2)  e) O(n3)  f) O(2n)"], "page_sentence_count_spacy": 8}, {"page_number": 76, "page_char_count": 1510, "page_word_count": 382, "page_sentence_count_raw": 5, "page_token_count": 377.5, "text": "76    Varianta 15    1.  Se consider\u0103 variabilele de tip \u00eentreg a=300,b=5,c=3,d=2 \u0219i R, indica\u021bi valoarea  variabilei R \u00een urma execut\u0103rii instruc\u021biunii:  Limbajul C/C++  R=a/b*c/d;  Limbajul Pascal  R:=a div b * c div d;  a) 50  b) 10  c) 40  d) 60  e) 5  f) 90    2. Fie urm\u0103toarele dou\u0103 secven\u021be de cod:  Limbajul C/C++  Secven\u021ba 1:  s=0;  for(i=1;i<=n;i++)  s=s+i*i;    Secven\u021ba 2:  s=0;i=<initial>;  while(<condition>)  {s=s+i*i;i=i-1;  }  Limbajul Pascal  Secven\u021ba 1:  s:=0;  for i:=1 to n do s:=s+i*i;    Secven\u021ba 2:  s:=0; i:=<initial>;  while <condition> do  begin  s:=s+i*i; i:=i-1;   end;  Cu ce trebuie \u00eenlocuite <initial> \u0219i <condition> astfel \u00eenc\u00e2t cele dou\u0103 secven\u021be de cod  s\u0103 fie echivalente (\u00een final variabila s s\u0103 aib\u0103 aceea\u0219i valoare)?  a) 1 \u0219i i<=n  b) n \u0219i i>0  c) 1 \u0219i i<n  d)  n \u0219i i>1 e) 1 \u0219i i<=n-1  f) n-1 \u0219i i>1    3. Preciza\u021bi secven\u021ba de instruc\u021biuni echivalent\u0103 cu urm\u0103toarea secven\u021b\u0103 de cod.  Limbajul C/C++  if (a>b)      if(a%2==0) c=a;     else c=b;  else    if(b%2==0) c=a;    else c=b;  Limbajul Pascal  if a>b then   begin      if a mod 2=0 then c:=a     else c:=b;   end  else    if  b mod 2=0 then c:=a    else c:=b;    Limbajul C/C++  a) if(a>b && a%2==0 ||  b>=a && b%2==0)     c=a;  else c=b;    b) if(a>b && a%2==0 ||  b%2==0) c=a;    else c=b;    c) if(a>b && a%2==0 &&  b>=a && b%2==0)  Limbajul Pascal  a)   if ((a>b) and (a mod 2=0)) or  ((b>=a) and (b mod 2=0)) then   c:=a  else c:=b;  b)   if ((a>b) and (a mod 2=0)) or  (b mod 2=0) then c:=a  else c:=b;  c)", "sentences": ["76    Varianta 15    1.", " Se consider\u0103 variabilele de tip \u00eentreg a=300,b=5,c=3,d=2 \u0219i R, indica\u021bi valoarea  variabilei R \u00een urma execut\u0103rii instruc\u021biunii:  Limbajul C/C++  R=a/b*c/d;  Limbajul Pascal  R:=a div b * c div d;  a) 50  b) 10  c) 40  d) 60  e) 5  f) 90    2.", "Fie urm\u0103toarele dou\u0103 secven\u021be de cod:  Limbajul C/C++  Secven\u021ba 1:  s=0;  for(i=1;i<=n;i++)  s=s+i*i;    Secven\u021ba 2:  s=0;i=<initial>;  while(<condition>)  {s=s+i*i;i=i-1;  }  Limbajul Pascal  Secven\u021ba 1:  s:=0;  for i:=1 to n do s:=s+i*i;    Secven\u021ba 2:  s:=0; i:=<initial>;  while <condition> do  begin  s:=s+i*i; i:=i-1;   end;  Cu ce trebuie \u00eenlocuite <initial> \u0219i <condition> astfel \u00eenc\u00e2t cele dou\u0103 secven\u021be de cod  s\u0103 fie echivalente (\u00een final variabila s s\u0103 aib\u0103 aceea\u0219i valoare)?", " a) 1 \u0219i i<=n  b) n \u0219i i>0  c) 1 \u0219i i<n  d)  n \u0219i i>1 e) 1 \u0219i i<=n-1  f) n-1 \u0219i i>1    3.", "Preciza\u021bi secven\u021ba de instruc\u021biuni echivalent\u0103 cu urm\u0103toarea secven\u021b\u0103 de cod.", " Limbajul C/C++  if (a>b)      if(a%2==0) c=a;     else c=b;  else    if(b%2==0) c=a;    else c=b;  Limbajul Pascal  if a>b then   begin      if a mod 2=0 then c:=a     else c:=b;   end  else    if  b mod 2=0 then c:=a    else c:=b;    Limbajul C/C++  a) if(a>b && a%2==0 ||  b>=a && b%2==0)     c=a;  else c=b;    b) if(a>b && a%2==0 ||  b%2==0) c=a;    else c=b;    c) if(a>b && a%2==0 &&  b>=a && b%2==0)  Limbajul Pascal  a)   if ((a>b) and (a mod 2=0)) or  ((b>=a) and (b mod 2=0)) then   c:=a  else c:=b;  b)   if ((a>b) and (a mod 2=0)) or  (b mod 2=0) then c:=a  else c:=b;  c)"], "page_sentence_count_spacy": 6}, {"page_number": 77, "page_char_count": 1898, "page_word_count": 435, "page_sentence_count_raw": 16, "page_token_count": 474.5, "text": "77      c=a;  else c=b;    d) if(a>b || a%2==0 &&   b%2==0) c=a;  else c=b;    e) if(a>b || a%2==0)c=a;  else c=b;    f) if(a%2==0 && b%2==0)     c=a;  else c=b;  if (a>b) and (a mod 2=0) and  (b>=a) and (b mod 2=0) then   c:=a   else c:=b;  d)   if ((a>b) or (a mod 2=0)) and  (b mod 2=0) then  c:=a   else c:=b;  e)   if (a>b) or (a mod 2=0) then   c:=a   else c:=b;  f)   if (a mod 2=0) and (b mod 2=0)  then  c:=a   else c:=b;    4. Indica\u021bi num\u0103rul de muchii ce trebuie ad\u0103ugate \u00eentr-un graf neorientat care are 8 noduri  \u0219i 20 muchii, astfel \u00eenc\u00e2t acesta s\u0103 devin\u0103 complet.   a)  20  b)  0  c)  4  d)  28  e)  8  f)  30      5. Preciza\u021bi care dintre urm\u0103toarele \u0219iruri de numere pot reprezenta vectorul de ta\u021bi al unui  arbore binar cu r\u0103d\u0103cin\u0103. Se nume\u0219te arbore binar un arbore \u00een care fiecare nod are  maxim doi descenden\u021bi direc\u021bi.  a) (5,8,4,0,4,5,3,2,7,8)  b) (5,1,4,0,4,5,3,1,7,1)   c) (5,8,4,0,4,5,3,6,7,8)  d) (5,8,4,0,4,9,3,6,2,7)  e) (5,0,4,0,4,5,3,1,7,1)  f) (2,1,4,0,4,5,3,1,7,1)    6. Se consider\u0103 un tablou bidimensional A, cu n linii \u015fi n coloane, not\u0103m cu Aij elementul  aflat pe linia i \u015fi coloana j (1\u2264i\u2264n,1\u2264j\u2264n). Preciza\u021bi condi\u0163ia necesar\u0103 ca elementul  Aij s\u0103 fie situat deasupra ambelor diagonale.  Limbajul C/C++  a) i<j && i+j<n+1   b) i>j && i+j>n+1  c) i<j || i+j<n+1  d) i<j && i+j>n+1  e) i>j || i+j>n+1  f) i<j || i+j>n+1    Limbajul Pascal  a) (i<j) and (i+j<n+1)   b) (i>j) and (i+j>n+1)  c) (i<j) or (i+j<n+1)  d) (i<j) and (i+j>n+1)  e) (i>j) or (i+j>n+1)  f) (i<j) or (i+j>n+1)     7. Preciza\u021bi c\u00e2te dintre urm\u0103toarele expresii au valoarea 1 (pentru limbajul C/C++),  respectiv true (pentru limbajul Pascal) dac\u0103 \u0219i numai dac\u0103 \ud835\udc65\u2208(\u2212\u221e, \u221210) \u222a[10,100).  Limbajul C/C++  1. x< -10 && x>=10 && x<100  2. x< -10 || x>=10 && x<100  3. !(x>= -10) || !(!(x>=10)  || x<100)  Limbajul Pascal  1. (x< -10) and (x>=10) and  (x<100)  2. (x< -10) or ((x>=10) and  (x<100))", "sentences": ["77      c=a;  else c=b;    d) if(a>b || a%2==0 &&   b%2==0) c=a;  else c=b;    e) if(a>b || a%2==0)c=a;  else c=b;    f) if(a%2==0 && b%2==0)     c=a;  else c=b;  if (a>b) and (a mod 2=0) and  (b>=a) and (b mod 2=0) then   c:=a   else c:=b;  d)   if ((a>b) or (a mod 2=0)) and  (b mod 2=0) then  c:=a   else c:=b;  e)   if (a>b) or (a mod 2=0) then   c:=a   else c:=b;  f)   if (a mod 2=0) and (b mod 2=0)  then  c:=a   else c:=b;    4.", "Indica\u021bi num\u0103rul de muchii ce trebuie ad\u0103ugate \u00eentr-un graf neorientat care are 8 noduri  \u0219i 20 muchii, astfel \u00eenc\u00e2t acesta s\u0103 devin\u0103 complet.", "  a)  20  b)  0  c)  4  d)  28  e)  8  f)  30      5.", "Preciza\u021bi care dintre urm\u0103toarele \u0219iruri de numere pot reprezenta vectorul de ta\u021bi al unui  arbore binar cu r\u0103d\u0103cin\u0103.", "Se nume\u0219te arbore binar un arbore \u00een care fiecare nod are  maxim doi descenden\u021bi direc\u021bi.", " a) (5,8,4,0,4,5,3,2,7,8)  b) (5,1,4,0,4,5,3,1,7,1)   c) (5,8,4,0,4,5,3,6,7,8)  d) (5,8,4,0,4,9,3,6,2,7)  e) (5,0,4,0,4,5,3,1,7,1)  f) (2,1,4,0,4,5,3,1,7,1)    6.", "Se consider\u0103 un tablou bidimensional A, cu n linii \u015fi n coloane, not\u0103m cu Aij elementul  aflat pe linia i \u015fi coloana j (1\u2264i\u2264n,1\u2264j\u2264n).", "Preciza\u021bi condi\u0163ia necesar\u0103 ca elementul  Aij s\u0103 fie situat deasupra ambelor diagonale.", " Limbajul C/C++  a) i<j && i+j<n+1   b) i>j && i+j>n+1  c) i<j || i+j<n+1  d) i<j && i+j>n+1  e) i>j || i+j>n+1  f) i<j || i+j>n+1    Limbajul Pascal  a) (i<j) and (i+j<n+1)   b) (i>j) and (i+j>n+1)  c) (i<j) or (i+j<n+1)  d) (i<j) and (i+j>n+1)  e) (i>j) or (i+j>n+1)  f) (i<j) or (i+j>n+1)     7.", "Preciza\u021bi c\u00e2te dintre urm\u0103toarele expresii au valoarea 1 (pentru limbajul C/C++),  respectiv true (pentru limbajul Pascal) dac\u0103 \u0219i numai dac\u0103 \ud835\udc65\u2208(\u2212\u221e, \u221210) \u222a[10,100).", " Limbajul C/C++  1.", "x< -10 && x>=10 && x<100  2.", "x< -10 || x>=10 && x<100  3. !(", "x>= -10) || !(!(", "x>=10)  || x<100)  Limbajul Pascal  1. (", "x< -10) and (x>=10) and  (x<100)  2. (", "x< -10) or ((x>=10) and  (x<100))"], "page_sentence_count_spacy": 17}, {"page_number": 78, "page_char_count": 2054, "page_word_count": 497, "page_sentence_count_raw": 20, "page_token_count": 513.5, "text": "78    4. x< -10 || !(!(x>=10) ||  x>=100)  5. x< -10 && x>=10   3. not(x>= -10) or  not(not(x>=10) or (x<100))  4. (x< -10) or not(not(x>=10)  or (x>=100))  5. (x< -10) and (x>=10)   a) 4  b) 1  c) 3  d) 0  e) 5  f) 2    8. \u00cen secven\u0163a de mai jos, variabilele i,j,x \u015fi y sunt de tip \u00eentreg, iar variabila a  memoreaz\u0103 un tablou bidimensional \u00een care prima linie \u015fi prima coloan\u0103 sunt  numerotate cu 1. Toate elementele tabloului primesc valori \u00een urma execut\u0103rii  secven\u0163ei. Preciza\u021bi care este valoarea elementului a[4][4] (pentru limbajul C/C++),  respectiv a[4,4] (pentru limbajul Pascal) \u00een urma execut\u0103rii secven\u0163ei de mai jos.  Limbajul C/C++  x=7928;   for (j=1;j<=4;j++)   {     y=x;     for(i=1;i<=4;i++)     {if(j%2==0)          a[i][j]=10-y%10;      else       a[i][j]=y%10;      y=y/10; }    x++;   }  Limbajul Pascal  x:=7928;  for j:=1 to 4 do  begin   y:=x;   for i:=1 to 4 do    begin    if j mod 2=0 then                  a[i,j]:=10-y mod 10     else    a[i,j]:=y mod 10;    y:=y div 10; end;   x:=x+1;end;  a) 7  b) 9  c) 2  d) 8  e) 3  f) 1    9. Precizati num\u0103rul maxim de componente conexe pe care le poate avea un graf neorientat  cu 30 de noduri \u0219i 20 muchii.  a) 25  b) 15  c) 10  d) 24  e) 5  f) 30    10. Se consider\u0103 un graf neorientat cu 9 noduri, al c\u0103rui vector de muchii este M = {(1,2),  (1,9), (2,3), (3,4), (3,7), (3,8), (4,5), (5,6), (5,7), (6,7), (6,8), (8,9)}. Indica\u021bi num\u0103rul  minim de muchii care trebuie eliminate astfel \u00eenc\u00e2t graful s\u0103 devin\u0103 eulerian, dar s\u0103 nu  mai fie hamiltonian.  a) 2  b) 0  c) 4  d) 3  e) 1  f) 5    11. Se utilizeaz\u0103 metoda backtracking pentru a genera \u0219iruri de c\u00e2te 5 caractere din  mul\u0163imea {a,1,b,2,c,3,d,4} cu proprietatea c\u0103 nu poate sa aib\u0103 dou\u0103 cifre sau  dou\u0103 litere al\u0103turate. \u015etiind c\u0103 primul \u0219ir generat este a1a1a, iar al doilea este a1a1b,  indica\u021bi \u0219irul ob\u0163inut imediat \u00eenainte de 2c1a1.  a) 2b1a1  b) 2b4d3 c) 2b4d4 d) 2c4d4  e) 1c4d4  f) 3c4d4    12. Preciza\u021bi valoarea variabilei a la finalul execut\u0103rii secven\u021bei urm\u0103toare de program.  Limbajul C/C++  Limbajul Pascal", "sentences": ["78    4.", "x< -10 || !(!(", "x>=10) ||  x>=100)  5.", "x< -10 && x>=10   3.", "not(x>= -10) or  not(not(x>=10) or (x<100))  4. (", "x< -10) or not(not(x>=10)  or (x>=100))  5. (", "x< -10) and (x>=10)   a) 4  b) 1  c) 3  d) 0  e) 5  f) 2    8.", "\u00cen secven\u0163a de mai jos, variabilele i,j,x \u015fi y sunt de tip \u00eentreg, iar variabila a  memoreaz\u0103 un tablou bidimensional \u00een care prima linie \u015fi prima coloan\u0103 sunt  numerotate cu 1.", "Toate elementele tabloului primesc valori \u00een urma execut\u0103rii  secven\u0163ei.", "Preciza\u021bi care este valoarea elementului a[4][4] (pentru limbajul C/C++),  respectiv a[4,4] (pentru limbajul Pascal) \u00een urma execut\u0103rii secven\u0163ei de mai jos.", " Limbajul C/C++  x=7928;   for (j=1;j<=4;j++)   {     y=x;     for(i=1;i<=4;i++)     {if(j%2==0)          a[i][j]=10-y%10;      else       a[i][j]=y%10;      y=y/10; }    x++;   }  Limbajul Pascal  x:=7928;  for j:=1 to 4 do  begin   y:=x;   for i:=1 to 4 do    begin    if j mod 2=0 then                  a[i,j]:=10-y mod 10     else    a[i,j]:=y mod 10;    y:=y div 10; end;   x:=x+1;end;  a) 7  b) 9  c) 2  d) 8  e) 3  f) 1    9.", "Precizati num\u0103rul maxim de componente conexe pe care le poate avea un graf neorientat  cu 30 de noduri \u0219i 20 muchii.", " a) 25  b) 15  c) 10  d) 24  e) 5  f) 30    10.", "Se consider\u0103 un graf neorientat cu 9 noduri, al c\u0103rui vector de muchii este M = {(1,2),  (1,9), (2,3), (3,4), (3,7), (3,8), (4,5), (5,6), (5,7), (6,7), (6,8), (8,9)}.", "Indica\u021bi num\u0103rul  minim de muchii care trebuie eliminate astfel \u00eenc\u00e2t graful s\u0103 devin\u0103 eulerian, dar s\u0103 nu  mai fie hamiltonian.", " a) 2  b) 0  c) 4  d) 3  e) 1  f) 5    11.", "Se utilizeaz\u0103 metoda backtracking pentru a genera \u0219iruri de c\u00e2te 5 caractere din  mul\u0163imea {a,1,b,2,c,3,d,4} cu proprietatea c\u0103 nu poate sa aib\u0103 dou\u0103 cifre sau  dou\u0103 litere al\u0103turate.", "\u015etiind c\u0103 primul \u0219ir generat este a1a1a, iar al doilea este a1a1b,  indica\u021bi \u0219irul ob\u0163inut imediat \u00eenainte de 2c1a1.", " a) 2b1a1  b) 2b4d3 c) 2b4d4 d) 2c4d4  e) 1c4d4  f) 3c4d4    12.", "Preciza\u021bi valoarea variabilei a la finalul execut\u0103rii secven\u021bei urm\u0103toare de program.", " Limbajul C/C++  Limbajul Pascal"], "page_sentence_count_spacy": 21}, {"page_number": 79, "page_char_count": 1675, "page_word_count": 424, "page_sentence_count_raw": 8, "page_token_count": 418.75, "text": "79    char a[50]=\"dicarapetacul\";  int i=0,j=strlen(a)-1;      while(i<=j)      {          if(a[i]==a[j])          {  a[i]=a[i+1];              a[j]=a[j]+1;          }          i++; j--;      }  var a:string[50];      i,j:integer;  .....  a:='dicarapetacul';i:=1;  j:=length(a);  while i<=j do  begin      if a[i]=a[j] then          begin              a[i]:=a[i+1];   a[j]:=CHR(ORD(a[j])+1);           end;          i:=i+1; j:=j-1;  end;  a) diarraeetbdul   b) diarrafetbdul  c) diarraeetuuul  d) diarraeetuuul  e) diaraeetuuul  f) diarrraeetuuul    13. \u00cen secven\u0163a de mai jos, variabilele i, \u015fi j sunt de tip \u00eentreg, iar variabila a memoreaz\u0103  un tablou unidimensional \u00een care primul element este numerotat cu 1. Toate elementele  tabloului primesc valori \u00een urma execut\u0103rii secven\u0163ei. Preciza\u021bi care este valoarea  elementului a[4] \u00een urma execut\u0103rii secven\u0163ei de mai jos.  Limbajul C/C++  for(i=1;i<=5;i++)   a[i]=10-i;  for(i=1;i<=5;i++)    if(i<3)   a[i]=a[i]+a[6-i];     else a[i]=a[i]-a[6-i];  Limbajul Pascal  for i:=1 to 5 do     a[i]:=10-i;  for i:=1 to 5 do   if i<3 then     a[i]:=a[i]+a[6-i]    else a[i]:=a[i]-a[6-i];  a) 2  b) 4  c) 0  d) 8   e) -9  f) -8    14. Indica\u021bi valorile variabilelor a \u0219i b,  \u00een urma apelului f(a,b) (pentru Limbajul  C++/Pascal), respectiv f(&a,b) (pentru Limbajul C), al subprogramului f definit  mai jos.  Limbajul C++  int a,b;  void f(int&x,int y)  { int b,c;   a++; b++; x=x*2; y=y*3;    b=x; c=y; c++; }    Limbajul Pascal  var a,b:integer;  procedure f(var x:integer;  y:integer);  var b,c:integer;  begin   inc(a); inc(b);   x:=x*2; y:=y*3;    b:=x; c:=y; inc(c);  end;  Limbajul C  int a,b;  void f(int*x,int y)  { int b,c;", "sentences": ["79    char a[50]=\"dicarapetacul\";  int i=0,j=strlen(a)-1;      while(i<=j)      {          if(a[i]==a[j])          {  a[i]=a[i+1];              a[j]=a[j]+1;          }          i++; j--;      }  var a:string[50];      i,j:integer;  .....  a:='dicarapetacul';i:=1;  j:=length(a);  while i<=j do  begin      if a[i]=a[j] then          begin              a[i]:=a[i+1];   a[j]:=CHR(ORD(a[j])+1);           end;          i:=i+1; j:=j-1;  end;  a) diarraeetbdul   b) diarrafetbdul  c) diarraeetuuul  d) diarraeetuuul  e) diaraeetuuul  f) diarrraeetuuul    13.", "\u00cen secven\u0163a de mai jos, variabilele i, \u015fi j sunt de tip \u00eentreg, iar variabila a memoreaz\u0103  un tablou unidimensional \u00een care primul element este numerotat cu 1.", "Toate elementele  tabloului primesc valori \u00een urma execut\u0103rii secven\u0163ei.", "Preciza\u021bi care este valoarea  elementului a[4] \u00een urma execut\u0103rii secven\u0163ei de mai jos.", " Limbajul C/C++  for(i=1;i<=5;i++)   a[i]=10-i;  for(i=1;i<=5;i++)    if(i<3)   a[i]=a[i]+a[6-i];     else a[i]=a[i]-a[6-i];  Limbajul Pascal  for i:=1 to 5 do     a[i]:=10-i;  for i:=1 to 5 do   if i<3 then     a[i]:=a[i]+a[6-i]    else a[i]:=a[i]-a[6-i];  a) 2  b) 4  c) 0  d) 8   e) -9  f) -8    14.", "Indica\u021bi valorile variabilelor a \u0219i b,  \u00een urma apelului f(a,b) (pentru Limbajul  C++/Pascal), respectiv f(&a,b) (pentru Limbajul C), al subprogramului f definit  mai jos.", " Limbajul C++  int a,b;  void f(int&x,int y)  { int b,c;   a++; b++; x=x*2; y=y*3;    b=x; c=y; c++; }    Limbajul Pascal  var a,b:integer;  procedure f(var x:integer;  y:integer);  var b,c:integer;  begin   inc(a); inc(b);   x:=x*2; y:=y*3;    b:=x; c:=y; inc(c);  end;  Limbajul C  int a,b;  void f(int*x,int y)  { int b,c;"], "page_sentence_count_spacy": 7}, {"page_number": 80, "page_char_count": 683, "page_word_count": 209, "page_sentence_count_raw": 4, "page_token_count": 170.75, "text": "80      a++; b++; *x=*x*2;   y=y*3; b=*x; c=y; c++; }  a) Eroare de  compilare b) 2 0  c) 2 2  d)  2 3  e) 1 1  f) 1 0    15. Se consider\u0103 subprogramul f definit mai jos. Preciza\u021bi ce valoare va avea f(20,2).  Limbajul C++/C  int f(int x,int y)  {int p=1;    if(x>1)    { while(x%y==0)      { p=p*y; x=x/y; }  if(p!=1)   return p+f(x,y+1);    else return f(x,y+1);       }      else return 0;  }  Limbajul Pascal  function   f(x,y:integer):integer;  var p:integer;  begin   p:=1;  if x>1 then  begin    while x mod y=0 do    begin       p:=p*y; x:=x div y; end;     if p<>1 then f:=p+f(x,y+1)        else f:=f(x,y+1);      end    else f:=0; end;  a) 9  b) 4  c) 10  d) 7  e) 11  f) 5", "sentences": ["80      a++; b++; *x=*x*2;   y=y*3; b=*x; c=y; c++; }  a) Eroare de  compilare b) 2 0  c) 2 2  d)  2 3  e) 1 1  f) 1 0    15.", "Se consider\u0103 subprogramul f definit mai jos.", "Preciza\u021bi ce valoare va avea f(20,2).", " Limbajul C++/C  int f(int x,int y)  {int p=1;    if(x>1)    { while(x%y==0)      { p=p*y; x=x/y; }  if(p!=1)   return p+f(x,y+1);    else return f(x,y+1);       }      else return 0;  }  Limbajul Pascal  function   f(x,y:integer):integer;  var p:integer;  begin   p:=1;  if x>1 then  begin    while x mod y=0 do    begin       p:=p*y; x:=x div y; end;     if p<>1 then f:=p+f(x,y+1)        else f:=f(x,y+1);      end    else f:=0; end;  a) 9  b) 4  c) 10  d) 7  e) 11  f) 5"], "page_sentence_count_spacy": 4}, {"page_number": 81, "page_char_count": 1602, "page_word_count": 399, "page_sentence_count_raw": 6, "page_token_count": 400.5, "text": "81    Varianta 16    1.  Se consider\u0103 variabilele de tip \u00eentreg a=15, b=30, c=5, d=10 \u0219i R, indica\u021bi  valoarea variabilei R \u00een urma execut\u0103rii instruc\u021biunii:  Limbajul C/C++ R=a+b/c+d;    Limbajul Pascal R:=a + b div c + d;  a) 19  b) 17  c) 3  d) 31  e) 20  f) 15    2. Fie urm\u0103toarele dou\u0103 secven\u021be de cod:  Limbajul C/C++  Secven\u021ba 1:  s=0;  for(i=1;i<=n;i++)     s=s+i*i;    Secven\u021ba 2:  s=0; i=<initial>;  do  {s=s+i*i;  <instruc\u021biune>  } while(i>=1);  Limbajul Pascal  Secven\u021ba 1:  s:=0;  for i:=1 to n do     s:=s+i*i;    Secven\u021ba 2:  s:=0; i:=<initial>;  repeat  s:=s+i*i;  <instruc\u021biune>  until i=0;  Indica\u021bi cu ce trebuie \u00eenlocuite <initial> \u0219i <instruc\u021biune> astfel \u00eenc\u00e2t cele dou\u0103  secven\u021be de cod s\u0103 fie echivalente (\u00een final variabila s s\u0103 aib\u0103 aceea\u0219i valoare).  Limbajul C/C++  a) n \u0219i i=i-1;  b) 1 \u0219i i=i+1;  c) n \u0219i i=i+1;  d) 0 \u0219i i=i+1;  e) n+1 \u0219i i=i+1;  f) 0 \u0219i i=i-1;  Limbajul Pascal  a) n \u0219i i:=i-1;  b) 1 \u0219i i:=i+1;  c) n \u0219i i:=i+1;  d) 0 \u0219i i:=i+1;  e) n+1 \u0219i i:=i+1;  f) 0 \u0219i i:=i-1;    3. Preciza\u021bi secven\u021ba de instruc\u021biuni echivalent\u0103 cu urm\u0103toarea secven\u021b\u0103 de cod.  Limbajul C/C++  if (a>b)      if(a%2==0)        if(b%2==0) c=a;    else c=b;    Limbajul Pascal  if a>b then   if a mod 2=0 then      if  b mod 2=0 then c:=a    else c:=b;    Limbajul C/C++  a) if(a>b && a%2==0 &&  b%2==0) c=a;  if(a>b && a%2==0 &&  b%2!=0) c=b;    b) if(a>b && a%2==0 &&  b%2==0) c=a;  Limbajul Pascal  a) if (a>b) and (a mod 2=0)  and (b mod 2=0) then c:=a;  if (a>b) and (a mod 2=0)  and (b mod 2<>0) then c:=b;    b) if (a>b) and (a mod 2=0)  and (b mod 2=0) then   c:=a   else c:=b;", "sentences": ["81    Varianta 16    1.", " Se consider\u0103 variabilele de tip \u00eentreg a=15, b=30, c=5, d=10 \u0219i R, indica\u021bi  valoarea variabilei R \u00een urma execut\u0103rii instruc\u021biunii:  Limbajul C/C++ R=a+b/c+d;    Limbajul Pascal R:=a + b div c + d;  a) 19  b) 17  c) 3  d) 31  e) 20  f) 15    2.", "Fie urm\u0103toarele dou\u0103 secven\u021be de cod:  Limbajul C/C++  Secven\u021ba 1:  s=0;  for(i=1;i<=n;i++)     s=s+i*i;    Secven\u021ba 2:  s=0; i=<initial>;  do  {s=s+i*i;  <instruc\u021biune>  } while(i>=1);  Limbajul Pascal  Secven\u021ba 1:  s:=0;  for i:=1 to n do     s:=s+i*i;    Secven\u021ba 2:  s:=0; i:=<initial>;  repeat  s:=s+i*i;  <instruc\u021biune>  until i=0;  Indica\u021bi cu ce trebuie \u00eenlocuite <initial> \u0219i <instruc\u021biune> astfel \u00eenc\u00e2t cele dou\u0103  secven\u021be de cod s\u0103 fie echivalente (\u00een final variabila s s\u0103 aib\u0103 aceea\u0219i valoare).", " Limbajul C/C++  a) n \u0219i i=i-1;  b) 1 \u0219i i=i+1;  c) n \u0219i i=i+1;  d) 0 \u0219i i=i+1;  e) n+1 \u0219i i=i+1;  f) 0 \u0219i i=i-1;  Limbajul Pascal  a) n \u0219i i:=i-1;  b) 1 \u0219i i:=i+1;  c) n \u0219i i:=i+1;  d) 0 \u0219i i:=i+1;  e) n+1 \u0219i i:=i+1;  f) 0 \u0219i i:=i-1;    3.", "Preciza\u021bi secven\u021ba de instruc\u021biuni echivalent\u0103 cu urm\u0103toarea secven\u021b\u0103 de cod.", " Limbajul C/C++  if (a>b)      if(a%2==0)        if(b%2==0) c=a;    else c=b;    Limbajul Pascal  if a>b then   if a mod 2=0 then      if  b mod 2=0 then c:=a    else c:=b;    Limbajul C/C++  a) if(a>b && a%2==0 &&  b%2==0) c=a;  if(a>b && a%2==0 &&  b%2!=0) c=b;    b) if(a>b && a%2==0 &&  b%2==0) c=a;  Limbajul Pascal  a) if (a>b) and (a mod 2=0)  and (b mod 2=0) then c:=a;  if (a>b) and (a mod 2=0)  and (b mod 2<>0) then c:=b;    b) if (a>b) and (a mod 2=0)  and (b mod 2=0) then   c:=a   else c:=b;"], "page_sentence_count_spacy": 6}, {"page_number": 82, "page_char_count": 1853, "page_word_count": 440, "page_sentence_count_raw": 9, "page_token_count": 463.25, "text": "82      else c=b;  c) if(a>b && a%2==0 &&  b%2==0) c=a;  if(a<b && a%2!=0 &&  b%2!=0) c=b;    d) if(a>b && a%2==0 &&  b%2==0) c=a;  if(a<=b && a%2!=0 &&  b%2!=0) c=b;    e) if(a>b && a%2==0 &&  b%2==0) c=a;    f) if(a<=b && a%2!=0 &&  b%2!=0) c=b;    c) if (a>b) and (a mod 2=0)  and (b mod 2=0) then c:=a;  if (a<b) and (a mod 2<>0)  and (b mod 2<>0) then c:=b;    d) if (a>b) and (a mod 2=0)  and (b mod 2=0) then c:=a;  if (a<=b) and (a mod 2<>0)  and (b mod 2<>0) then c:=b;    e) if (a>b) and (a mod 2=0)  and (b mod 2=0) then c:=a;    f) if (a<=b) and (a mod 2<>0)  and (b mod 2<>0) then c:=b;    4. Indica\u021bi num\u0103rul minim de muchii ce trebuie eliminate dintr-un graf neorientat complet  care are 88 noduri astfel \u00eenc\u00e2t acesta s\u0103 devin\u0103 eulerian.    a) 0  b) 84  c) 88  d) 176  e) 10  f) 44    5. Preciza\u021bi descenden\u021bii nodului 5 din arborele dat de urm\u0103torul vector ta\u021bi  (5,8,4,0,4,5,3,6,7,8).   a) 1, 2, 6, 8, 10  b) 1 \u0219i 6  c) 4  d) 1, 6,  7  e) 1 \u0219i 7  f) 6 \u0219i 7    6. Se consider\u0103 un tablou bidimensional A, cu n linii \u015fi n coloane, not\u0103m cu Aij elementul  aflat pe linia i \u015fi coloana j (1\u2264i\u2264n,1\u2264j\u2264n). Preciza\u021bi condi\u0163ia necesar\u0103 ca elementul  Aij s\u0103 fie situat pe prima diagonal\u0103 de sub diagonala secundar\u0103, care este paralel\u0103 cu  aceasta.  a) i+j==n-1 (C/C++)    i+j=n-1  (Pascal)  b) i+j==n+1  (C/C++)    i+j=n+1  (Pascal)  c) i+j==n+2  (C/C++)    i+j=n+2  (Pascal)  d) i==j+1 (C/C++)    i=j+1  (Pascal)  e) i==j (C/C++)    i=j  (Pascal)  f) i+j==n-2  (C/C++)    i+j=n-2  (Pascal)    7. Preciza\u021bi intervalul c\u0103ruia \u00eei apar\u0163ine valoarea memorat\u0103 de variabila real\u0103 x, astfel \u00eenc\u00e2t  expresia urm\u0103toare s\u0103 aib\u0103 valoarea 1 (pentru Limbajul C/C++), true (pentru Limbajul  Pascal)  Limbajul C/C++  x<-10 || !(!(x>=10) ||  x>=100)    Limbajul Pascal  (x<-10) or not(not(x>=10) or  (x>=100))  a) x \u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce) \u222a[\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)  b) \ud835\udc31\u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce] \u222a[\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)", "sentences": ["82      else c=b;  c) if(a>b && a%2==0 &&  b%2==0) c=a;  if(a<b && a%2!=0 &&  b%2!=0) c=b;    d) if(a>b && a%2==0 &&  b%2==0) c=a;  if(a<=b && a%2!=0 &&  b%2!=0) c=b;    e) if(a>b && a%2==0 &&  b%2==0) c=a;    f) if(a<=b && a%2!=0 &&  b%2!=0) c=b;    c) if (a>b) and (a mod 2=0)  and (b mod 2=0) then c:=a;  if (a<b) and (a mod 2<>0)  and (b mod 2<>0) then c:=b;    d) if (a>b) and (a mod 2=0)  and (b mod 2=0) then c:=a;  if (a<=b) and (a mod 2<>0)  and (b mod 2<>0) then c:=b;    e) if (a>b) and (a mod 2=0)  and (b mod 2=0) then c:=a;    f) if (a<=b) and (a mod 2<>0)  and (b mod 2<>0) then c:=b;    4.", "Indica\u021bi num\u0103rul minim de muchii ce trebuie eliminate dintr-un graf neorientat complet  care are 88 noduri astfel \u00eenc\u00e2t acesta s\u0103 devin\u0103 eulerian.", "   a) 0  b) 84  c) 88  d) 176  e) 10  f) 44    5.", "Preciza\u021bi descenden\u021bii nodului 5 din arborele dat de urm\u0103torul vector ta\u021bi  (5,8,4,0,4,5,3,6,7,8).", "  a) 1, 2, 6, 8, 10  b) 1 \u0219i 6  c) 4  d) 1, 6,  7  e) 1 \u0219i 7  f) 6 \u0219i 7    6.", "Se consider\u0103 un tablou bidimensional A, cu n linii \u015fi n coloane, not\u0103m cu Aij elementul  aflat pe linia i \u015fi coloana j (1\u2264i\u2264n,1\u2264j\u2264n).", "Preciza\u021bi condi\u0163ia necesar\u0103 ca elementul  Aij s\u0103 fie situat pe prima diagonal\u0103 de sub diagonala secundar\u0103, care este paralel\u0103 cu  aceasta.", " a) i+j==n-1 (C/C++)    i+j=n-1  (Pascal)  b) i+j==n+1  (C/C++)    i+j=n+1  (Pascal)  c) i+j==n+2  (C/C++)    i+j=n+2  (Pascal)  d) i==j+1 (C/C++)    i=j+1  (Pascal)  e) i==j (C/C++)    i=j  (Pascal)  f) i+j==n-2  (C/C++)    i+j=n-2  (Pascal)    7.", "Preciza\u021bi intervalul c\u0103ruia \u00eei apar\u0163ine valoarea memorat\u0103 de variabila real\u0103 x, astfel \u00eenc\u00e2t  expresia urm\u0103toare s\u0103 aib\u0103 valoarea 1 (pentru Limbajul C/C++), true (pentru Limbajul  Pascal)  Limbajul C/C++  x<-10 || !(!(", "x>=10) ||  x>=100)    Limbajul Pascal  (x<-10) or not(not(x>=10) or  (x>=100))  a) x \u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce) \u222a[\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)  b) \ud835\udc31\u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce] \u222a[\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)"], "page_sentence_count_spacy": 10}, {"page_number": 83, "page_char_count": 2056, "page_word_count": 439, "page_sentence_count_raw": 15, "page_token_count": 514.0, "text": "83    c) \ud835\udc31\u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce) \u222a(\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)  d) \ud835\udc31\u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce) \u222a[\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce]  e) \ud835\udc31\u2208(\u2212\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce) \u222a(\ud835\udfcf\ud835\udfce\ud835\udfce, +\u221e)  f) \ud835\udc31\u2208(\u2212\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)    8. \u00cen secven\u0163a de mai jos, variabilele i,j,x \u015fi y sunt de tip \u00eentreg, iar variabila a  memoreaz\u0103 un tablou bidimensional \u00een care prima linie \u015fi prima coloan\u0103 sunt numerotate  cu 1. Toate elementele tabloului primesc valori \u00een urma execut\u0103rii secven\u0163ei. Preciza\u021bi  care este valoarea elementului a[4][4] (pentru limbajul C/C++), respectiv a[4,4]  (pentru limbajul Pascal) \u00een urma execut\u0103rii secven\u0163ei de mai jos.  Limbajul C/C++  x =3478;  for(j=4;j>=1;j--)  { y=x;    for(i=4;i>=1;i--)    {  if(j%2==0)a[i][j]=10-y%10;  else a[i][j]=y%10;  y=y/10;   }  x++;}  Limbajul Pascal  x:=3478;  for j:=4 downto 1 do  begin   y:=x;   for i:=4 downto 1 do   begin    if j mod 2=0 then         a[i,j]:=10-y mod 10    else a[i,j]:=y mod 10;    y:=y div 10;end;  x:=x+1; end;  a) 7  b) 3  c) 6  d) 4  e) 2  f) 8    9. Preciza\u021bi num\u0103rul maxim de noduri izolate pe care le poate avea un graf neorientat cu  30 de noduri \u0219i 20 de muchii  a) 24  b) 23  c) 15  d) 25  e) 0  f) 10    10. Se consider\u0103 un graf neorientat cu 9 noduri, al c\u0103rui vector de muchii este M = {(1,2),  (1,9), (2,3), (3,4), (3,7), (3,8), (4,5), (5,6), (5,7), (6,7), (6,8), (8,9)}. Indica\u021bi num\u0103rul  minim de muchii care trebuie eliminate astfel \u00eenc\u00e2t graful s\u0103 devin\u0103 eulerian, dar s\u0103  r\u0103m\u00e2n\u0103 hamiltonian.   a) 4  b) 0  c) Nu se poate  d) 2  e) 7  f) 3    11. Se utilizeaz\u0103 metoda backtracking pentru a genera \u0219iruri de c\u00e2te 5 caractere distincte din  mul\u0163imea {a,1,b,2,c,3,d,4} cu proprietatea c\u0103 nu poate s\u0103 aib\u0103 dou\u0103 cifre sau  dou\u0103 litere al\u0103turate. \u015etiind c\u0103 primul \u0219ir generat este a1b2c, iar al doilea este a1b2d,  preciza\u021bi \u0219irul ob\u0163inut imediat \u00eenainte de 2c4a1.  a) 2c3d4 b) 2c1b4 c) 2b4d3  d) 2c3a4  e) 1c3a4  f) 2c1a4    12. Indica\u021bi valoarea variabilei a la finalul execut\u0103rii secven\u021bei urm\u0103toare de program.  Limbajul C/C++  char a[]=\"15iunie1970\";  char v[]=\"aeiouAEIOUn\";  int i;  for(i=0;i<strlen(a);i++)  Limbajul Pascal  var a,v:string;      i:integer;  ...  a:='15iunie1970';", "sentences": ["83    c) \ud835\udc31\u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce) \u222a(\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)  d) \ud835\udc31\u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce) \u222a[\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce]  e) \ud835\udc31\u2208(\u2212\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce) \u222a(\ud835\udfcf\ud835\udfce\ud835\udfce, +\u221e)  f) \ud835\udc31\u2208(\u2212\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)    8.", "\u00cen secven\u0163a de mai jos, variabilele i,j,x \u015fi y sunt de tip \u00eentreg, iar variabila a  memoreaz\u0103 un tablou bidimensional \u00een care prima linie \u015fi prima coloan\u0103 sunt numerotate  cu 1.", "Toate elementele tabloului primesc valori \u00een urma execut\u0103rii secven\u0163ei.", "Preciza\u021bi  care este valoarea elementului a[4][4] (pentru limbajul C/C++), respectiv a[4,4]  (pentru limbajul Pascal) \u00een urma execut\u0103rii secven\u0163ei de mai jos.", " Limbajul C/C++  x =3478;  for(j=4;j>=1;j--)  { y=x;    for(i=4;i>=1;i--)    {  if(j%2==0)a[i][j]=10-y%10;  else a[i][j]=y%10;  y=y/10;   }  x++;}  Limbajul Pascal  x:=3478;  for j:=4 downto 1 do  begin   y:=x;   for i:=4 downto 1 do   begin    if j mod 2=0 then         a[i,j]:=10-y mod 10    else a[i,j]:=y mod 10;    y:=y div 10;end;  x:=x+1; end;  a) 7  b) 3  c) 6  d) 4  e) 2  f) 8    9.", "Preciza\u021bi num\u0103rul maxim de noduri izolate pe care le poate avea un graf neorientat cu  30 de noduri \u0219i 20 de muchii  a) 24  b) 23  c) 15  d) 25  e) 0  f) 10    10.", "Se consider\u0103 un graf neorientat cu 9 noduri, al c\u0103rui vector de muchii este M = {(1,2),  (1,9), (2,3), (3,4), (3,7), (3,8), (4,5), (5,6), (5,7), (6,7), (6,8), (8,9)}.", "Indica\u021bi num\u0103rul  minim de muchii care trebuie eliminate astfel \u00eenc\u00e2t graful s\u0103 devin\u0103 eulerian, dar s\u0103  r\u0103m\u00e2n\u0103 hamiltonian.", "  a) 4  b) 0  c) Nu se poate  d) 2  e) 7  f) 3    11.", "Se utilizeaz\u0103 metoda backtracking pentru a genera \u0219iruri de c\u00e2te 5 caractere distincte din  mul\u0163imea {a,1,b,2,c,3,d,4} cu proprietatea c\u0103 nu poate s\u0103 aib\u0103 dou\u0103 cifre sau  dou\u0103 litere al\u0103turate.", "\u015etiind c\u0103 primul \u0219ir generat este a1b2c, iar al doilea este a1b2d,  preciza\u021bi \u0219irul ob\u0163inut imediat \u00eenainte de 2c4a1.", " a) 2c3d4 b) 2c1b4 c) 2b4d3  d) 2c3a4  e) 1c3a4  f) 2c1a4    12.", "Indica\u021bi valoarea variabilei a la finalul execut\u0103rii secven\u021bei urm\u0103toare de program.", " Limbajul C/C++  char a[]=\"15iunie1970\";  char v[]=\"aeiouAEIOUn\";  int i;  for(i=0;i<strlen(a);i++)  Limbajul Pascal  var a,v:string;      i:integer;  ...  a:='15iunie1970';"], "page_sentence_count_spacy": 14}, {"page_number": 84, "page_char_count": 1346, "page_word_count": 351, "page_sentence_count_raw": 5, "page_token_count": 336.5, "text": "84     if(a[i]>='0' && a[i]<='9')     a[i]=v[a[i]-'0'];  v:='aeiouAEIOUn';  for i:=1 to length(a) do  if (a[i]>='0') and (a[i]<='9')  then  a[i]:=v[ORD(a[i])-ORD('0')+1];  a) Eroare de  compilare   b) iEiunieinOe  c) eAiunieeUIa  d) 152410211970  e) EiunieinO  f) AiunieeUI    13. Se consider\u0103 un tablou unidimensional a cu n numere naturale. Dac\u0103 pentru n se cite\u0219te  valoarea 7, iar a prime\u0219te valorile: 7,4,8,2,9,6 \u0219i 2, preciza\u021bi ce se va afi\u0219a la  sf\u00e2r\u0219itul execut\u0103rii secven\u021bei urm\u0103toare de program.  Limbajul C++  int a[15],i,n,j;  cin>>n;                     for(i=0;i<n;i++)     cin>>a[i];             for(i=0;i<n;i++)    if(a[i]%2==0)  {   for(j=i;j<n-1;j++)        a[j]=a[j+1];   n--;   }  for(i=0;i<n;i++)   cout<<a[i]<<\" \";          Limbajul Pascal  var a:array[1..20] of  integer;      i,j,n,k:integer;  ............  read(n);  for i:=1 to n do read(a[i]);  i:=1;   while i<=n do   begin    if a[i] mod 2=0 then     begin      k:=n-1;       for j:=i to k do  a[j]:=a[j+1];      n:=n-1; end;    i:=i+1; end;  for i:=1 to n do   write(a[i],' ');  Limbajul C  int a[15],i,n,j;  scanf(\"%d\",&n);  for(i=0;i<n;i++)   scanf(\"%d\",&a[i]);  for(i=0;i<n;i++)   if(a[i]%2==0)  {   for(j=i;j<n-1;j++)     a[j]=a[j+1];   n--;   }  for(i=0;i<n;i++)     printf(\"%d \",a[i]);         a) 7 2 9 2  b) 7 9  c) 7 8 9 2  d) 7 4 2 9 6  e) 4 2 6  f) 4 8 2 6", "sentences": ["84     if(a[i]>='0' && a[i]<='9')     a[i]=v[a[i]-'0'];  v:='aeiouAEIOUn';  for i:=1 to length(a) do  if (a[i]>='0') and (a[i]<='9')  then  a[i]:=v[ORD(a[i])-ORD('0')+1];  a) Eroare de  compilare   b) iEiunieinOe  c) eAiunieeUIa  d) 152410211970  e) EiunieinO  f) AiunieeUI    13.", "Se consider\u0103 un tablou unidimensional a cu n numere naturale.", "Dac\u0103 pentru n se cite\u0219te  valoarea 7, iar a prime\u0219te valorile: 7,4,8,2,9,6 \u0219i 2, preciza\u021bi ce se va afi\u0219a la  sf\u00e2r\u0219itul execut\u0103rii secven\u021bei urm\u0103toare de program.", " Limbajul C++  int a[15],i,n,j;  cin>>n;                     for(i=0;i<n;i++)     cin>>a[i];             for(i=0;i<n;i++)    if(a[i]%2==0)  {   for(j=i;j<n-1;j++)        a[j]=a[j+1];   n--;   }  for(i=0;i<n;i++)   cout<<a[i]<<\" \";          Limbajul Pascal  var a:array[1..20] of  integer;      i,j,n,k:integer;  ............  read(n);  for i:=1 to n do read(a[i]);  i:=1;   while i<=n do   begin    if a[i] mod 2=0 then     begin      k:=n-1;       for j:=i to k do  a[j]:=a[j+1];      n:=n-1; end;    i:=i+1; end;  for i:=1 to n do   write(a[i],' ');  Limbajul C  int a[15],i,n,j;  scanf(\"%d\",&n);  for(i=0;i<n;i++)   scanf(\"%d\",&a[i]);  for(i=0;i<n;i++)   if(a[i]%2==0)  {   for(j=i;j<n-1;j++)     a[j]=a[j+1];   n--;   }  for(i=0;i<n;i++)     printf(\"%d \",a[i]);         a) 7 2 9 2  b) 7 9  c) 7 8 9 2  d) 7 4 2 9 6  e) 4 2 6  f) 4 8 2 6"], "page_sentence_count_spacy": 4}, {"page_number": 85, "page_char_count": 1109, "page_word_count": 286, "page_sentence_count_raw": 6, "page_token_count": 277.25, "text": "85    14. Indica\u021bi valorile variabilelor a \u0219i b,  \u00een urma apelului f(a,b,b) (pentru Limbajul  C++/Pascal), respectiv f(&a,b,b) (pentru Limbajul C), al subprogramului f definit  mai jos.  Limbajul C++  int a,b;  void f(int&x,int y,int b)  { a++; b++;    x=x*2; y=y*3;  }    Limbajul Pascal  var a,b:integer;  procedure f(var x:integer;  y,b:integer);  begin    inc(a); inc(b);     x:=x*2; y:=y*3;  end;  Limbajul C  int a,b;  void f(int*x,int y,int b)  { a++; b++;     *x=*x*2; y=y*3;  }  a) Eroare de  compilare  b) 2 3  c) 1 1  d) 2 0  e) 2 2  f) 1 0    15. Se consider\u0103 subprogramul f definit mai jos. Preciza\u021bi ce valoare va avea  f(1234,6789,1).  Limbajul C++/C  int f(int x,int y, int p)  {  if(y!=0)   if(y%2==0)     return  y%10*p+f(x/10,y/10,p*10);   else     return  x%10*p+f(x/10,y/10,p*10);      else  return 0;  }  Limbajul Pascal  function  f(x,y,p:integer):integer;  begin   if y<>0 then    if y mod 2=0 then        f:= y mod 10 * p +        f(x div 10,y div 10,p*10)    else  f:=x mod 10 * p +   f(x div 10,y div 10,p*10)   else  f:=0;  end;  a) 1739  b) 4862  c) 6789  d) 200  e) 6284  f) 1234", "sentences": ["85    14.", "Indica\u021bi valorile variabilelor a \u0219i b,  \u00een urma apelului f(a,b,b) (pentru Limbajul  C++/Pascal), respectiv f(&a,b,b) (pentru Limbajul C), al subprogramului f definit  mai jos.", " Limbajul C++  int a,b;  void f(int&x,int y,int b)  { a++; b++;    x=x*2; y=y*3;  }    Limbajul Pascal  var a,b:integer;  procedure f(var x:integer;  y,b:integer);  begin    inc(a); inc(b);     x:=x*2; y:=y*3;  end;  Limbajul C  int a,b;  void f(int*x,int y,int b)  { a++; b++;     *x=*x*2; y=y*3;  }  a) Eroare de  compilare  b) 2 3  c) 1 1  d) 2 0  e) 2 2  f) 1 0    15.", "Se consider\u0103 subprogramul f definit mai jos.", "Preciza\u021bi ce valoare va avea  f(1234,6789,1).", " Limbajul C++/C  int f(int x,int y, int p)  {  if(y!=0)   if(y%2==0)     return  y%10*p+f(x/10,y/10,p*10);   else     return  x%10*p+f(x/10,y/10,p*10);      else  return 0;  }  Limbajul Pascal  function  f(x,y,p:integer):integer;  begin   if y<>0 then    if y mod 2=0 then        f:= y mod 10 * p +        f(x div 10,y div 10,p*10)    else  f:=x mod 10 * p +   f(x div 10,y div 10,p*10)   else  f:=0;  end;  a) 1739  b) 4862  c) 6789  d) 200  e) 6284  f) 1234"], "page_sentence_count_spacy": 6}, {"page_number": 86, "page_char_count": 1691, "page_word_count": 324, "page_sentence_count_raw": 42, "page_token_count": 422.75, "text": "86    Varianta 17    1. Alege\u021bi secven\u021bele de instruc\u021biuni prin care variabilei \u00eentregi pc i se atribuie valoarea  primei cifre a unui num\u0103r natural dat prin variabila a.  Limbajul C++  1. pc=a/10;  2. pc=a;while(pc>9)pc=pc/10;  3. pc=a%10;  4. pc=a;while(pc>9)pc=pc%10;  5. pc=a;while(pc>0)pc=pc/10;  6. pc=a;while(pc>0)pc=pc%10;    Limbajul Pascal  1. pc:=a div 10;  2. pc:=a; while (pc>9)  do pc:=pc div 10;  3. pc:=a mod 10;  4. pc:=a; while (pc>9)  do pc:=pc mod 10;  5. pc:=a; while (pc>0)  do pc:=pc div 10;  6. pc:=a; while (pc>0)  do pc:=pc mod 10;  Limbajul C  1. pc=a/10;  2. pc=a;while(pc>9)pc=pc/10;  3. pc=a%10;  4. pc=a;while(pc>9)pc=pc%10;  5. pc=a;while(pc>0)pc=pc%10;  6. pc=a;while(pc>0)pc=pc/10;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    2. Preciza\u021bi care dintre urm\u0103toarele secven\u021be de instruc\u021biuni atribuie variabilei \u00eentregi p,  valoarea 3n, unde variabila n reprezint\u0103 un num\u0103r natural dat.  Limbajul C++  1. p=1;for(i=1;i<=n;i++)p*=n;  2. p=3;for(i=1;i<=n;i++)p*=i;  3. p=1;i=0;while(i<n)p*=3;i++;  4. p=1;for(i=1;i<=n;i++)p*=3;  5. p=3;for(i=n;i>=0;i--)p*=3;  6. p=1;for(i=n;i>=0;i--)p*=3;  Limbajul Pascal  1. p:=1;for i:=1 to n  do p:=p*n;  2. p:=3;for i:=1 to n  do p:=p*i;  3. p:=1; i:=0;   while (i<n) do  p:=p*3; inc(i);  4. p:=1;for i:=1 to n  do p:=p*3;  5. p:=3;  for i:=n downto 0 do  p:=p*3;  6. p:=1;   for i:=n downto 0 do  p:=p*3;    Limbajul C  1. p=1;for(i=1;i<=n;i++) p*=n;  2. p=3;for(i=1;i<=n;i++) p*=i;  3. p=1;i=0;while (i<n) p*=3;i++;  4. p=1;for(i=1;i<=n;i++) p*=3;  5. p=3;for(i=n;i>=0;i--) p*=3;  6. p=1;for(i=n;i>=0;i--) p*=3;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    3. Indica\u021bi valoarea returnat\u0103 de func\u021bia definit\u0103 mai jos, la apelul sp(3).", "sentences": ["86    Varianta 17    1.", "Alege\u021bi secven\u021bele de instruc\u021biuni prin care variabilei \u00eentregi pc i se atribuie valoarea  primei cifre a unui num\u0103r natural dat prin variabila a.  Limbajul C++  1.", "pc=a/10;  2.", "pc=a;while(pc>9)pc=pc/10;  3.", "pc=a%10;  4.", "pc=a;while(pc>9)pc=pc%10;  5.", "pc=a;while(pc>0)pc=pc/10;  6.", "pc=a;while(pc>0)pc=pc%10;    Limbajul Pascal  1.", "pc:=a div 10;  2.", "pc:=a; while (pc>9)  do pc:=pc div 10;  3.", "pc:=a mod 10;  4.", "pc:=a; while (pc>9)  do pc:=pc mod 10;  5.", "pc:=a; while (pc>0)  do pc:=pc div 10;  6.", "pc:=a; while (pc>0)  do pc:=pc mod 10;  Limbajul C  1.", "pc=a/10;  2.", "pc=a;while(pc>9)pc=pc/10;  3.", "pc=a%10;  4.", "pc=a;while(pc>9)pc=pc%10;  5.", "pc=a;while(pc>0)pc=pc%10;  6.", "pc=a;while(pc>0)pc=pc/10;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    2.", "Preciza\u021bi care dintre urm\u0103toarele secven\u021be de instruc\u021biuni atribuie variabilei \u00eentregi p,  valoarea 3n, unde variabila n reprezint\u0103 un num\u0103r natural dat.", " Limbajul C++  1.", "p=1;for(i=1;i<=n;i++)p*=n;  2.", "p=3;for(i=1;i<=n;i++)p*=i;  3.", "p=1;i=0;while(i<n)p*=3;i++;  4.", "p=1;for(i=1;i<=n;i++)p*=3;  5.", "p=3;for(i=n;i>=0;i--)p*=3;  6.", "p=1;for(i=n;i>=0;i--)p*=3;  Limbajul Pascal  1.", "p:=1;for i:=1 to n  do p:=p*n;  2.", "p:=3;for i:=1 to n  do p:=p*i;  3.", "p:=1; i:=0;   while (i<n) do  p:=p*3; inc(i);  4.", "p:=1;for i:=1 to n  do p:=p*3;  5.", "p:=3;  for i:=n downto 0 do  p:=p*3;  6.", "p:=1;   for i:=n downto 0 do  p:=p*3;    Limbajul C  1.", "p=1;for(i=1;i<=n;i++) p*=n;  2.", "p=3;for(i=1;i<=n;i++) p*=i;  3.", "p=1;i=0;while (i<n) p*=3;i++;  4.", "p=1;for(i=1;i<=n;i++) p*=3;  5.", "p=3;for(i=n;i>=0;i--) p*=3;  6.", "p=1;for(i=n;i>=0;i--) p*=3;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    3.", "Indica\u021bi valoarea returnat\u0103 de func\u021bia definit\u0103 mai jos, la apelul sp(3)."], "page_sentence_count_spacy": 41}, {"page_number": 87, "page_char_count": 1538, "page_word_count": 305, "page_sentence_count_raw": 27, "page_token_count": 384.5, "text": "87    Limbajul C  int sp(int n)  {  if(n>1)    return   sp(n-1)+n*(n+1)*(n+2);   else return 6;}    Limbajul Pascal  function  sp(n:integer):integer;  Begin  if(n>1) then    sp:=sp(n-1)+n*(n+1)*(n+2)      else        sp:=6;  End;  Limbajul C++  int sp(int n)  {if(n>1) return   sp(n-1)+n*(n+1)*(n+2);     else return 6;}  a) 30  b) 60  c) 90  d) 120  e) 150  f) 180    4. Indica\u021bi expresia corect\u0103 din punct de vedere sintactic \u0219i care are ca valoare 32020.  Limbajul C++  1. exp(2020*log(3))  2. exp(log(2020))*exp(3)  3. log(3)*exp(2020)  4. log(3*exp(2020))  5. exp(log(2020)*log(3))  6. log(exp(2020*log(3)))    Limbajul Pascal  1. exp(2020*ln(3))  2. exp(ln(2020))*exp(3)  3. ln(3)*exp(2020)  4. ln(3*exp(2020))  5. exp(log(2020)*ln(3))  6. log(exp(2020*ln(3)))  Limbajul C  1. exp(2020*log(3))  2. exp(log(2020))*exp(3)  3. log(3)*exp(2020)   4. log(3*exp(2020))  5. exp(log(2020)*log(3))  6. log(exp(2020*log(3)))  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    5. Fie graful neorientat G=(V,M), unde V este mul\u021bimea nodurilor grafului,  card(V)=n, respectiv, M este mul\u021bimea muchiilor grafului, iar card(M)=m. Graful  dat are p componente conexe. Dac\u0103 n=1010, m=2020 iar p=100, preciza\u021bi care este  num\u0103rul maximal de cicluri independente care pot fi construite concomitent pe graf.  Prin cicluri independente se \u00een\u021belege, cicluri care con\u0163in cel pu\u0163in c\u00e2te o muchie care  apar\u0163ine doar unuia din ele.  a) 1001  b) 1010  c) 1011  d) 1100  e) 1101  f) 1110    6. Indica\u021bi valoarea variabilei text dup\u0103 executarea instruc\u0163iunilor de mai jos.", "sentences": ["87    Limbajul C  int sp(int n)  {  if(n>1)    return   sp(n-1)+n*(n+1)*(n+2);   else return 6;}    Limbajul Pascal  function  sp(n:integer):integer;  Begin  if(n>1) then    sp:=sp(n-1)+n*(n+1)*(n+2)      else        sp:=6;  End;  Limbajul C++  int sp(int n)  {if(n>1) return   sp(n-1)+n*(n+1)*(n+2);     else return 6;}  a) 30  b) 60  c) 90  d) 120  e) 150  f) 180    4.", "Indica\u021bi expresia corect\u0103 din punct de vedere sintactic \u0219i care are ca valoare 32020.", " Limbajul C++  1.", "exp(2020*log(3))  2.", "exp(log(2020))*exp(3)  3.", "log(3)*exp(2020)  4.", "log(3*exp(2020))  5.", "exp(log(2020)*log(3))  6.", "log(exp(2020*log(3)))    Limbajul Pascal  1.", "exp(2020*ln(3))  2.", "exp(ln(2020))*exp(3)  3.", "ln(3)*exp(2020)  4.", "ln(3*exp(2020))  5.", "exp(log(2020)*ln(3))  6.", "log(exp(2020*ln(3)))  Limbajul C  1.", "exp(2020*log(3))  2.", "exp(log(2020))*exp(3)  3.", "log(3)*exp(2020)   4.", "log(3*exp(2020))  5.", "exp(log(2020)*log(3))  6.", "log(exp(2020*log(3)))  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    5.", "Fie graful neorientat G=(V,M), unde V este mul\u021bimea nodurilor grafului,  card(V)=n, respectiv, M este mul\u021bimea muchiilor grafului, iar card(M)=m.", "Graful  dat are p componente conexe.", "Dac\u0103 n=1010, m=2020 iar p=100, preciza\u021bi care este  num\u0103rul maximal de cicluri independente care pot fi construite concomitent pe graf.", " Prin cicluri independente se \u00een\u021belege, cicluri care con\u0163in cel pu\u0163in c\u00e2te o muchie care  apar\u0163ine doar unuia din ele.", " a) 1001  b) 1010  c) 1011  d) 1100  e) 1101  f) 1110    6.", "Indica\u021bi valoarea variabilei text dup\u0103 executarea instruc\u0163iunilor de mai jos."], "page_sentence_count_spacy": 27}, {"page_number": 88, "page_char_count": 1553, "page_word_count": 253, "page_sentence_count_raw": 8, "page_token_count": 388.25, "text": "88    Limbajul C++  char text[250];  strncpy(text,  strstr(\"Admitere Poli 2020\",  \"oli\"),9);  text[9]='\\0';  Limbajul Pascal  var  text:string[250];p:integer;  Begin  text:=\u2019Admitere Poli 2020\u2019;  p:=pos(\u2019oli\u2019,text);  text:=copy(text,p,9);  End.  Limbajul C  char text[250];  strncpy(text,  strstr(\"Admitere Poli 2020\",  \"oli\"),9);  text[9]='\\0';  a) Admitere  b) Admitere 2020  c) Admitere Poli  d) Poli 2020  e) oli 2020  f) 2020    7. Indica\u021bi valoarea variabilei text dup\u0103 executarea secven\u021bei de instruc\u0163iuni de mai jos.  Limbajul C++  char text[250];  strcpy(text,strstr(\"Admitere Politehnica Bucuresti  2020\", \"Poli\")+strlen(\"240820201731\"));  cout<<strcat(text,\" ADMIS\");    Limbajul C  char text[250];  strcpy(text,strstr(\"Admitere Politehnica Bucuresti  2020\", \"Poli\")+strlen(\"240820201731\"));  printf(\" %s \\n\", strcat(text,\" ADMIS\"));    Limbajul Pascal  var text:string[250];p:integer;  Begin  text:='Admitere Politehnica Bucuresti 2020';  p:=pos('Poli',text);  text:=copy(text,p+length('240820201731'),length(text));  text:=concat(text,' ADMIS'); writeln(text); End.  a) Admitere 2020 ADMIS  b) Admitere 2020  c) Bucuresti ADMIS  d) Bucuresti 2020 ADMIS  e) Politehnica ADMIS  f) Politehnica 2020  ADMIS    8. Utiliz\u00e2nd metoda backtracking, se genereaz\u0103 toate modalit\u0103\u021bile de a se \u00eembr\u0103ca un  inginer. \u0218tiind c\u0103 el are la dispozi\u021bie 12 c\u0103m\u0103\u0219i, 8 pantaloni \u0219i 9 cravate, indica\u021bi  num\u0103rul de  modalit\u0103\u021bi de a se \u00eembr\u0103ca, folosind toate cele trei elemente vestimentare,  pe care le are inginerul.   a) 864  b) 204  c) 168  d) 108  e) 96  f) 29", "sentences": ["88    Limbajul C++  char text[250];  strncpy(text,  strstr(\"Admitere Poli 2020\",  \"oli\"),9);  text[9]='\\0';  Limbajul Pascal  var  text:string[250];p:integer;  Begin  text:=\u2019Admitere Poli 2020\u2019;  p:=pos(\u2019oli\u2019,text);  text:=copy(text,p,9);  End.", " Limbajul C  char text[250];  strncpy(text,  strstr(\"Admitere Poli 2020\",  \"oli\"),9);  text[9]='\\0';  a) Admitere  b) Admitere 2020  c) Admitere Poli  d) Poli 2020  e) oli 2020  f) 2020    7.", "Indica\u021bi valoarea variabilei text dup\u0103 executarea secven\u021bei de instruc\u0163iuni de mai jos.", " Limbajul C++  char text[250];  strcpy(text,strstr(\"Admitere Politehnica Bucuresti  2020\", \"Poli\")+strlen(\"240820201731\"));  cout<<strcat(text,\" ADMIS\");    Limbajul C  char text[250];  strcpy(text,strstr(\"Admitere Politehnica Bucuresti  2020\", \"Poli\")+strlen(\"240820201731\"));  printf(\" %s \\n\", strcat(text,\" ADMIS\"));    Limbajul Pascal  var text:string[250];p:integer;  Begin  text:='Admitere Politehnica Bucuresti 2020';  p:=pos('Poli',text);  text:=copy(text,p+length('240820201731'),length(text));  text:=concat(text,' ADMIS'); writeln(text); End.", " a) Admitere 2020 ADMIS  b) Admitere 2020  c) Bucuresti ADMIS  d) Bucuresti 2020 ADMIS  e) Politehnica ADMIS  f) Politehnica 2020  ADMIS    8.", "Utiliz\u00e2nd metoda backtracking, se genereaz\u0103 toate modalit\u0103\u021bile de a se \u00eembr\u0103ca un  inginer.", "\u0218tiind c\u0103 el are la dispozi\u021bie 12 c\u0103m\u0103\u0219i, 8 pantaloni \u0219i 9 cravate, indica\u021bi  num\u0103rul de  modalit\u0103\u021bi de a se \u00eembr\u0103ca, folosind toate cele trei elemente vestimentare,  pe care le are inginerul.", "  a) 864  b) 204  c) 168  d) 108  e) 96  f) 29"], "page_sentence_count_spacy": 8}, {"page_number": 89, "page_char_count": 2149, "page_word_count": 595, "page_sentence_count_raw": 10, "page_token_count": 537.25, "text": "89    9. Preciza\u021bi care este cea mai mare valoare pe care o poate lua variabila \u00eentreag\u0103 n astfel  \u00eenc\u00e2t s\u0103 se afi\u0219eze mesajul Corect.  Limbajul C  if(n<17-3*n)   printf(\"Corect\");  else              printf(\"Incorect\");  Limbajul C++  if(n<17-3*n)  cout<<\"Corect\";  else             cout<<\"Incorect\";  Limbajul Pascal  if n<17-3*n then  write(\"Corect\")  else             write(\"Incorect\");  a) 17  b) 15  c) 12  d) 10  e) 7   f) 4    10. Preciza\u021bi care este valoarea ini\u021bial\u0103 a variabilei \u00eentregi n pentru ca secven\u021ba de program  de mai jos s\u0103 afi\u0219eze $$$$$.  Limbajul C    while(n!=3)     { n--;      printf(\"$$\");}  Limbajul C++  while(n!=3)     { n--;     cout<<\"$$\";}  Limbajul Pascal   while n<>3 do  begin  dec(n);  write('$$');end;  a) 1  b) 2  c) 3  d) 3  e) 5 f) nici o valoare    11. Se construie\u0219te un tablou bidimensional cu n linii \u0219i n coloane, \u00een variabila A prin  secven\u021ba de mai jos, unde variabila n este un num\u0103r natural nenul dat.  Limbajul C  for(i=1;i<=n;i++)  for(j=1;j<=n;j++)  A[i][j]=(2*i+j)/2;  Limbajul C++  for(i=1;i<=n;i++)  for(j=1;j<=n;j++)  A[i][j]=(2*i+j)/2;  Limbajul Pascal  for i:=1 to n do  for i:=1 to n do  A[i,j]:=(2*i+j)/2;  Preciza\u021bi suma elementelor alfate pe diagonala principal\u0103 a tabloului bidimensional A,  \u00een urma execu\u021biei secven\u021bei de mai sus.  a)   3 4 \u2219(\ud835\udc5b+ 1) \u2219\ud835\udc5b  b)   3 4 \u2219\ud835\udc5b2  c)   4 3 \u2219\ud835\udc5b2  d)   1 4 \u2219(\ud835\udc5b+ 1) \u2219\ud835\udc5b  e)   1 4 \u2219\ud835\udc5b2  f)   1 3 \u2219\ud835\udc5b2    12. Se consider\u0103 declar\u0103rile de mai jos. Indica\u021bi tipul expresiei aa.a.a  Limbajul C  struct S1  {int a;  char b;};  struct S2  {float a; double  b;};  struct S3  {struct S1 a;  struct S2 b;  } aa, bb;  Limbajul C++  struct S1  {int a;  char b;};  struct S2  {float a; double  b;};  struct S3  {struct S1 a;  struct S2 b;  } aa, bb;  Limbajul Pascal  Type S1=Record            a:  integer;          b: char;         End;        S2=Record         a: real;         b: real;           End;         S3=Record            a: S1;            b: S2;            End;  var aa,bb:S3;  a) long/ long/ longint  b) float/ float/ real c) int/ int/ integer   d) double/ double/ real e) char/ char/char  f) nu putem avea \u00een \u00eenregistr\u0103ri  diferite, c\u00e2mpuri cu acela\u0219i nume", "sentences": ["89    9.", "Preciza\u021bi care este cea mai mare valoare pe care o poate lua variabila \u00eentreag\u0103 n astfel  \u00eenc\u00e2t s\u0103 se afi\u0219eze mesajul Corect.", " Limbajul C  if(n<17-3*n)   printf(\"Corect\");  else              printf(\"Incorect\");  Limbajul C++  if(n<17-3*n)  cout<<\"Corect\";  else             cout<<\"Incorect\";  Limbajul Pascal  if n<17-3*n then  write(\"Corect\")  else             write(\"Incorect\");  a) 17  b) 15  c) 12  d) 10  e) 7   f) 4    10.", "Preciza\u021bi care este valoarea ini\u021bial\u0103 a variabilei \u00eentregi n pentru ca secven\u021ba de program  de mai jos s\u0103 afi\u0219eze $$$$$.", " Limbajul C    while(n!=3)     { n--;      printf(\"$$\");}  Limbajul C++  while(n!=3)     { n--;     cout<<\"$$\";}  Limbajul Pascal   while n<>3 do  begin  dec(n);  write('$$');end;  a) 1  b) 2  c) 3  d) 3  e) 5 f) nici o valoare    11.", "Se construie\u0219te un tablou bidimensional cu n linii \u0219i n coloane, \u00een variabila A prin  secven\u021ba de mai jos, unde variabila n este un num\u0103r natural nenul dat.", " Limbajul C  for(i=1;i<=n;i++)  for(j=1;j<=n;j++)  A[i][j]=(2*i+j)/2;  Limbajul C++  for(i=1;i<=n;i++)  for(j=1;j<=n;j++)  A[i][j]=(2*i+j)/2;  Limbajul Pascal  for i:=1 to n do  for i:=1 to n do  A[i,j]:=(2*i+j)/2;  Preciza\u021bi suma elementelor alfate pe diagonala principal\u0103 a tabloului bidimensional A,  \u00een urma execu\u021biei secven\u021bei de mai sus.", " a)   3 4 \u2219(\ud835\udc5b+ 1) \u2219\ud835\udc5b  b)   3 4 \u2219\ud835\udc5b2  c)   4 3 \u2219\ud835\udc5b2  d)   1 4 \u2219(\ud835\udc5b+ 1) \u2219\ud835\udc5b  e)   1 4 \u2219\ud835\udc5b2  f)   1 3 \u2219\ud835\udc5b2    12.", "Se consider\u0103 declar\u0103rile de mai jos.", "Indica\u021bi tipul expresiei aa.a.a  Limbajul C  struct S1  {int a;  char b;};  struct S2  {float a; double  b;};  struct S3  {struct S1 a;  struct S2 b;  } aa, bb;  Limbajul C++  struct S1  {int a;  char b;};  struct S2  {float a; double  b;};  struct S3  {struct S1 a;  struct S2 b;  } aa, bb;  Limbajul Pascal  Type S1=Record            a:  integer;          b: char;         End;        S2=Record         a: real;         b: real;           End;         S3=Record            a: S1;            b: S2;            End;  var aa,bb:S3;  a) long/ long/ longint  b) float/ float/ real c) int/ int/ integer   d) double/ double/ real e) char/ char/char  f) nu putem avea \u00een \u00eenregistr\u0103ri  diferite, c\u00e2mpuri cu acela\u0219i nume"], "page_sentence_count_spacy": 10}, {"page_number": 90, "page_char_count": 1230, "page_word_count": 318, "page_sentence_count_raw": 8, "page_token_count": 307.5, "text": "90      13. Stabili\u021bi care este valoarea ini\u021bial\u0103 a variabilei naturale i pentru ca secven\u021ba de  program de mai jos s\u0103 afi\u0219eze valorile 1 2 3 4 5 6 7.  Limbajul C  k=1;  for(i=\u2026;i<=2020;i++)  {   printf(\"%d \",k);   k++;  }  Limbajul C++  k=1;  for(i=\u2026;i<=2020;i++)  {   cout<<k<<\" \";   k++;  }  Limbajul Pascal  k:=1;  for i=\u2026 to 2020 do  Begin   Write(k,' ');   inc(k);  end;  a) 7  b) 17  c) 283  d) 314  e) 2013  f) 2014    14. Se consider\u0103 o mul\u021bime A cu n numere naturale. Preciza\u021bi care este complexitatea  temporal\u0103 pentru a genera toate submul\u021bimile care au proprietatea c\u0103 suma elementelor  fiec\u0103rei submul\u021bimi generate este divizibil\u0103 cu n.   a) O(n\u2219log(n))  b) O(n+log(n))  c) O(2n)  d) O(n3)  e) O(n2)  f) O(n)    15. Preciza\u021bi complexitatea timp pentru secven\u021ba de program de mai jos.  Limbajul C  k=0;  for(int a=n;a>=1;a/=2)    for(int b=a;b>=1;b--)        k++;  printf(\"%i \\n\",k);    Limbajul Pascal  k:=0;a:=n;  while(a>=1) do   begin    b:=a;      while(b>=1) do         begin          k++;          dec(b);        end;    a:=a div 2;  end;  write(k);  Limbajul C++  k=0;  for(int a=n;a>=1;a/=2)    for(int b=a;b>=1;b--)        k++;  cout<<k;  a) O(n\u2219log(n))  b) O(n+log(n))  c) O(2n)  d) O(n2)  e) O(n)  f) O(1)", "sentences": ["90      13.", "Stabili\u021bi care este valoarea ini\u021bial\u0103 a variabilei naturale i pentru ca secven\u021ba de  program de mai jos s\u0103 afi\u0219eze valorile 1 2 3 4 5 6 7.", " Limbajul C  k=1;  for(i=\u2026;i<=2020;i++)  {   printf(\"%d \",k);   k++;  }  Limbajul C++  k=1;  for(i=\u2026;i<=2020;i++)  {   cout<<k<<\" \";   k++;  }  Limbajul Pascal  k:=1;  for i=\u2026 to 2020 do  Begin   Write(k,' ');   inc(k);  end;  a) 7  b) 17  c) 283  d) 314  e) 2013  f) 2014    14.", "Se consider\u0103 o mul\u021bime A cu n numere naturale.", "Preciza\u021bi care este complexitatea  temporal\u0103 pentru a genera toate submul\u021bimile care au proprietatea c\u0103 suma elementelor  fiec\u0103rei submul\u021bimi generate este divizibil\u0103 cu n.   a) O(n\u2219log(n))  b) O(n+log(n))  c) O(2n)  d) O(n3)  e) O(n2)  f) O(n)    15.", "Preciza\u021bi complexitatea timp pentru secven\u021ba de program de mai jos.", " Limbajul C  k=0;  for(int a=n;a>=1;a/=2)    for(int b=a;b>=1;b--)        k++;  printf(\"%i \\n\",k);    Limbajul Pascal  k:=0;a:=n;  while(a>=1) do   begin    b:=a;      while(b>=1) do         begin          k++;          dec(b);        end;    a:=a div 2;  end;  write(k);  Limbajul C++  k=0;  for(int a=n;a>=1;a/=2)    for(int b=a;b>=1;b--)        k++;  cout<<k;  a) O(n\u2219log(n))  b) O(n+log(n))  c) O(2n)  d) O(n2)  e) O(n)  f) O(1)"], "page_sentence_count_spacy": 7}, {"page_number": 91, "page_char_count": 1506, "page_word_count": 308, "page_sentence_count_raw": 31, "page_token_count": 376.5, "text": "91    Varianta 18    1. Preciza\u021bi care dintre urm\u0103toarele secven\u021be de instruc\u021biuni atribuie variabilei \u00eentregi pc  valoarea 100, unde a=559020.   Limbajul C  1. pc=a/100*a%10;  2. pc=a;while(pc>9)pc=pc/10;  pc*=a%100;  3. pc=a%100;  4. pc=a;while(pc>9)pc:=pc%10;  pc*=a%100;  5. pc=a/10;  while(pc>0)pc=pc/10;  pc*=a%100;  6. pc=a;while(pc>0)pc=pc/10;  pc*=a%100;    Limbajul Pascal  1. pc:=a div 10 * a mod 10;  2. pc:=a;   while (pc>9) do       pc:=pc div 10;   pc:=pc*(a mod 100);  3. pc:=a mod 100;  4. pc:=a;   while (pc>9) do   pc:=pc mod 10;  pc:=pc*(a mod 100);  5. pc:=a/10;   while (pc>0) do        pc:=pc div 10;   pc:=pc*(a mod 100);  6. pc:=a;   while (pc>0) do        pc:=pc div 10;   pc:=pc*(a mod 100);  Limbajul C++  1. pc=a/100*a%10;  2. pc=a;while(pc>9)pc=pc/10;  pc*=a%100;  3. pc=a%100;  4. pc=a;while(pc>9)pc=pc%10;  pc*=a%100;  5. pc=a/10;  while(pc>9)pc=pc/10;  pc*=a%100;  6. pc=a;while(pc>0)pc=pc/10;  pc*=a%100;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    2. Preciza\u021bi care dintre urm\u0103toarele secven\u021be de instruc\u021biuni de mai jos, atribuie variabilei  \u00eentregi p valoarea \u00eemp\u0103r\u021birii \u00eentregi a num\u0103rului a la num\u0103rul b, unde variabilele a \u0219i b  reprezint\u0103 dou\u0103 numere \u00eentregi date.  Limbajul C  1. p=1;s=0;  for(i=1;i<=b;i++)  p-=b;s++;  2. p=a;  for(i=1;i<=b;i++)p-=i;  3. p=1;i=0;  while(i<b) p-=a;i++;   4. p=0;s=a;  Limbajul Pascal  1. p:=1;s:=0;for i:=1 to b  do p:=p-n;inc(s);  2. p:=a;for i:=1 to b do  p:=p-i;  3. p:=1;i:=0;  while i<b do  p:=p*a;inc(i);  4. p:=0;s:=a;while(s>0)", "sentences": ["91    Varianta 18    1.", "Preciza\u021bi care dintre urm\u0103toarele secven\u021be de instruc\u021biuni atribuie variabilei \u00eentregi pc  valoarea 100, unde a=559020.", "  Limbajul C  1.", "pc=a/100*a%10;  2.", "pc=a;while(pc>9)pc=pc/10;  pc*=a%100;  3.", "pc=a%100;  4.", "pc=a;while(pc>9)pc:=pc%10;  pc*=a%100;  5.", "pc=a/10;  while(pc>0)pc=pc/10;  pc*=a%100;  6.", "pc=a;while(pc>0)pc=pc/10;  pc*=a%100;    Limbajul Pascal  1.", "pc:=a div 10 * a mod 10;  2.", "pc:=a;   while (pc>9) do       pc:=pc div 10;   pc:=pc*(a mod 100);  3.", "pc:=a mod 100;  4.", "pc:=a;   while (pc>9) do   pc:=pc mod 10;  pc:=pc*(a mod 100);  5.", "pc:=a/10;   while (pc>0) do        pc:=pc div 10;   pc:=pc*(a mod 100);  6.", "pc:=a;   while (pc>0) do        pc:=pc div 10;   pc:=pc*(a mod 100);  Limbajul C++  1.", "pc=a/100*a%10;  2.", "pc=a;while(pc>9)pc=pc/10;  pc*=a%100;  3.", "pc=a%100;  4.", "pc=a;while(pc>9)pc=pc%10;  pc*=a%100;  5.", "pc=a/10;  while(pc>9)pc=pc/10;  pc*=a%100;  6.", "pc=a;while(pc>0)pc=pc/10;  pc*=a%100;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    2.", "Preciza\u021bi care dintre urm\u0103toarele secven\u021be de instruc\u021biuni de mai jos, atribuie variabilei  \u00eentregi p valoarea \u00eemp\u0103r\u021birii \u00eentregi a num\u0103rului a la num\u0103rul b, unde variabilele a \u0219i b  reprezint\u0103 dou\u0103 numere \u00eentregi date.", " Limbajul C  1.", "p=1;s=0;  for(i=1;i<=b;i++)  p-=b;s++;  2.", "p=a;  for(i=1;i<=b;i++)p-=i;  3.", "p=1;i=0;  while(i<b) p-=a;i++;   4.", "p=0;s=a;  Limbajul Pascal  1.", "p:=1;s:=0;for i:=1 to b  do p:=p-n;inc(s);  2.", "p:=a;for i:=1 to b do  p:=p-i;  3.", "p:=1;i:=0;  while i<b do  p:=p*a;inc(i);  4.", "p:=0;s:=a;while(s>0)"], "page_sentence_count_spacy": 31}, {"page_number": 92, "page_char_count": 1348, "page_word_count": 286, "page_sentence_count_raw": 20, "page_token_count": 337.0, "text": "92    for(i=1;i<=b&&s>0;i++)  {p++;s-=b;}  5. p=a;  for(i=0;i<=b;i++)p-=b;  6. p=1;  for(i=0;i<=b;i++)p-=b;    begin inc(p);s:=s-b;  end;  5. p:=a;for i:=0 to b do  p:=p-b;  6. p:=1;for i:=0 to b do  p:=p-b;  Limbajul C++  1. p=1;s=0;  for(i=1;i<=b;i++)  p-=b;s++;  2. p=a;  for(i=1;i<=b;i++)p-=i;  3. p=1;i=0;while(i<b)p-=a;  i++;   4. p=0;s=a;  for(i=1;i<=b&&s>0;i++)  {p++;s-=b;}  5. p=a;  for(i=0;i<=b;i++)p-=b;  6. p=1;  for(i=0;i<=b;i++)p-=b;    a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    3.  Preciza\u021bi care este valoarea returnat\u0103 de func\u021bia definit\u0103 mai jos, la apelul sp(5).  Limbajul C++  float sp(int n)  {if(n>1)   return sp(n-1)+1./(n*(n+1));   else return 0.5;}    Limbajul Pascal  function  sp(n:integer):real;  Begin  if(n>1) then  sp:=sp(n-1)+1/(n*(n+1))     else        sp:=0.5;  end;  Limbajul C  float sp(int n)  {if(n>1)   return sp(n-1)+1./(n*(n+1));   else return 0.5;}  a) 0.83  b) 0.82  c) 0.81  d) 0.38  e) 0.28  f) 0.18    4. Preciza\u021bi care dintre urm\u0103toarele expresii de mai jos reprezint\u0103 valoare polinomului   \ud835\udc5d= \u2211 (\ud835\udc5b\u2212\ud835\udc58) \u2219\ud835\udc4b\ud835\udc58 \ud835\udc5b \ud835\udc58=0 , pentru un num\u0103r x real pozitiv, iar n este un num\u0103r natural, x \u0219i n  sunt introduse de la tastatur\u0103.  Limbajul C  1. p=0;for(k=0;k<=n;k++)       p=p+(n-k)*pow(x,k);  2. 2. p=1;for(k=0;k<=n;k++)  Limbajul Pascal  1. p:=0;for k:=0 to n do    p:=p+(n-k)*exp(k*ln(x));  2. p:=1;for k:=0 to n do", "sentences": ["92    for(i=1;i<=b&&s>0;i++)  {p++;s-=b;}  5.", "p=a;  for(i=0;i<=b;i++)p-=b;  6.", "p=1;  for(i=0;i<=b;i++)p-=b;    begin inc(p);s:=s-b;  end;  5.", "p:=a;for i:=0 to b do  p:=p-b;  6.", "p:=1;for i:=0 to b do  p:=p-b;  Limbajul C++  1.", "p=1;s=0;  for(i=1;i<=b;i++)  p-=b;s++;  2.", "p=a;  for(i=1;i<=b;i++)p-=i;  3.", "p=1;i=0;while(i<b)p-=a;  i++;   4.", "p=0;s=a;  for(i=1;i<=b&&s>0;i++)  {p++;s-=b;}  5.", "p=a;  for(i=0;i<=b;i++)p-=b;  6.", "p=1;  for(i=0;i<=b;i++)p-=b;    a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    3.", " Preciza\u021bi care este valoarea returnat\u0103 de func\u021bia definit\u0103 mai jos, la apelul sp(5).", " Limbajul C++  float sp(int n)  {if(n>1)   return sp(n-1)+1./(n*(n+1));   else return 0.5;}    Limbajul Pascal  function  sp(n:integer):real;  Begin  if(n>1) then  sp:=sp(n-1)+1/(n*(n+1))     else        sp:=0.5;  end;  Limbajul C  float sp(int n)  {if(n>1)   return sp(n-1)+1./(n*(n+1));   else return 0.5;}  a) 0.83  b) 0.82  c) 0.81  d) 0.38  e) 0.28  f) 0.18    4.", "Preciza\u021bi care dintre urm\u0103toarele expresii de mai jos reprezint\u0103 valoare polinomului   \ud835\udc5d= \u2211 (\ud835\udc5b\u2212\ud835\udc58) \u2219\ud835\udc4b\ud835\udc58 \ud835\udc5b \ud835\udc58=0 , pentru un num\u0103r x real pozitiv, iar n este un num\u0103r natural, x \u0219i n  sunt introduse de la tastatur\u0103.", " Limbajul C  1.", "p=0;for(k=0;k<=n;k++)       p=p+(n-k)*pow(x,k);  2.", "2.", "p=1;for(k=0;k<=n;k++)  Limbajul Pascal  1.", "p:=0;for k:=0 to n do    p:=p+(n-k)*exp(k*ln(x));  2.", "p:=1;for k:=0 to n do"], "page_sentence_count_spacy": 20}, {"page_number": 93, "page_char_count": 1671, "page_word_count": 267, "page_sentence_count_raw": 22, "page_token_count": 417.75, "text": "93         p=p+(n-k)*pow(x,k);  3. 3. p=1;for(k=0;k<n;k++)      p=p+(n-k)*pow(x,k);  4. 4. p=0;for(k=0;k<=n+1;k++)       p=p+(n-k)*pow(x,k);  5. p=1;for(k=0;k<=n+1;k++)      p=p+(n-k)*pow(x,k);  6. p=0;for(k=0;k<n;k++)      p=p+(n-k)*pow(x,k);     p:=p+(n-k)*exp(k*ln(x));  3. p:=1;for k:=0 to n-1 do   p:=p+(n-k)*exp(k*ln(x));  4. p:=0;for k:=0 to n+1 do   p:=p+(n-k)*exp(k*ln(x));  5. p:=1;for k:=0 to n+1 do   p:=p+(n-k)*exp(k*ln(x));  6. p:=0;for k:=0 to n-1 do   p:=p+(n-k)*exp(k*ln(x));  Limbajul C++  1. p=0;for(k=0;k<=n;k++)p=p+(n-k)*pow(x,k);  2. p=1;for(k=0;k<=n;k++)p=p+(n-k)*pow(x,k);  3. p=1;for(k=0;k<n;k++)p=p+(n-k)*pow(x,k);  4. p=0;for(k=0;k<=n+1;k++)p=p+(n-k)*pow(x,k);  5. p=1;for(k=0;k<=n+1;k++)p=p+(n-k)*pow(x,k);  6. p=0;for(k=0;k<n;k++)p=p+(n-k)*pow(x,k);  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    5. Fie graful neorientat G=(V,M), unde V este mul\u021bimea nodurilor grafului, card(V)=n,  respectiv, M este mul\u021bimea muchiilor grafului, iar card(M)=m. Av\u00e2nd la dispozi\u021bie cele  n noduri se pot construi 32768 de grafuri neorintate distincte, preciza\u021bi valoarea  variabilei n.  a) 15  b) 14  c) 13  d) 8  e) 7  f) 6    6. Preciza\u021bi care este valoare variabilei text dup\u0103 executarea instruc\u0163iunilor de mai jos.  Limbajul C  char text[250]=\"\";  strncpy(text,strstr(\"Admitere Poli 2020\",\"Poli\"),9);  text[9]='\\0';  for(int k=strlen(text)-1;k>=0;k--) printf(\"%c\",text[k]);    Limbajul C++  char text[250];  strncpy(text,strstr(\"Admitere Poli 2020\",\"Poli\"),9);  text[9]='\\0';  for(int k=strlen(text)-1;k>=0;k--) cout<<text[k];  cout<<text;    Limbajul Pascal   var text:string[250];  c:char;  p,k:integer;  Begin  text:='Admitere Poli 2020'; p:=pos('Poli',text);", "sentences": ["93         p=p+(n-k)*pow(x,k);  3.", "3.", "p=1;for(k=0;k<n;k++)      p=p+(n-k)*pow(x,k);  4.", "4.", "p=0;for(k=0;k<=n+1;k++)       p=p+(n-k)*pow(x,k);  5.", "p=1;for(k=0;k<=n+1;k++)      p=p+(n-k)*pow(x,k);  6.", "p=0;for(k=0;k<n;k++)      p=p+(n-k)*pow(x,k);     p:=p+(n-k)*exp(k*ln(x));  3.", "p:=1;for k:=0 to n-1 do   p:=p+(n-k)*exp(k*ln(x));  4.", "p:=0;for k:=0 to n+1 do   p:=p+(n-k)*exp(k*ln(x));  5.", "p:=1;for k:=0 to n+1 do   p:=p+(n-k)*exp(k*ln(x));  6.", "p:=0;for k:=0 to n-1 do   p:=p+(n-k)*exp(k*ln(x));  Limbajul C++  1.", "p=0;for(k=0;k<=n;k++)p=p+(n-k)*pow(x,k);  2.", "p=1;for(k=0;k<=n;k++)p=p+(n-k)*pow(x,k);  3.", "p=1;for(k=0;k<n;k++)p=p+(n-k)*pow(x,k);  4.", "p=0;for(k=0;k<=n+1;k++)p=p+(n-k)*pow(x,k);  5.", "p=1;for(k=0;k<=n+1;k++)p=p+(n-k)*pow(x,k);  6.", "p=0;for(k=0;k<n;k++)p=p+(n-k)*pow(x,k);  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    5.", "Fie graful neorientat G=(V,M), unde V este mul\u021bimea nodurilor grafului, card(V)=n,  respectiv, M este mul\u021bimea muchiilor grafului, iar card(M)=m.", "Av\u00e2nd la dispozi\u021bie cele  n noduri se pot construi 32768 de grafuri neorintate distincte, preciza\u021bi valoarea  variabilei n.  a) 15  b) 14  c) 13  d) 8  e) 7  f) 6    6.", "Preciza\u021bi care este valoare variabilei text dup\u0103 executarea instruc\u0163iunilor de mai jos.", " Limbajul C  char text[250]=\"\";  strncpy(text,strstr(\"Admitere Poli 2020\",\"Poli\"),9);  text[9]='\\0';  for(int k=strlen(text)-1;k>=0;k--) printf(\"%c\",text[k]);    Limbajul C++  char text[250];  strncpy(text,strstr(\"Admitere Poli 2020\",\"Poli\"),9);  text[9]='\\0';  for(int k=strlen(text)-1;k>=0;k--) cout<<text[k];  cout<<text;    Limbajul Pascal   var text:string[250];  c:char;  p,k:integer;  Begin  text:='Admitere Poli 2020'; p:=pos('Poli',text);"], "page_sentence_count_spacy": 21}, {"page_number": 94, "page_char_count": 1466, "page_word_count": 220, "page_sentence_count_raw": 7, "page_token_count": 366.5, "text": "94    text:=copy(text,p,length(text));  for k:=1 to length(text) div 2 do   begin     c:=text[k];text[k]:=text[length(text)-k+1];     text[length(text)-k+1]:=c;   end;  writeln(text);  End.  a) Poli 2020  b) oli 2020  c) Admitere Poli   d) 0202 iloP eretimdA  e) 0202 eretimdA  f) 0202 iloP    7. Preciza\u021bi ce valoare are variabila text dup\u0103 executarea instruc\u0163iunii de mai jos.  Limbajul C  char text[250],nou[250];  strcpy(text,strstr(\"Admitere Politehnica Bucuresti 2020\",  \"ere\")+strlen(\"2408\"));  strcpy(nou,text); strnset(nou,'X',12);  strncat(text,nou,12); printf(\"%s \\n\", text);    Limbajul C++  char text[250],nou[250];  strcpy(text,strstr(\"Admitere Politehnica Bucuresti 2020\",  \"ere\")+strlen(\"2408\"));  strcpy(nou,text); strnset(nou,'X',12);  strncat(text,nou,12); cout<<text;    Limbajul Pascal  var text:string[250];  c:char;  p,i:integer;  Begin  text:='Admitere Poli 2020'; p:=pos('Poli',text);  text:=copy(text,p,length(text));  for i:=1 to length(text) div 2 do  begin  c:=text[i]; text[i]:=text[length(text)-i+1];  text[length(text)-i+1]:=c;  end;  writeln(text);  End.  a) Bucuresti 2020XXXXXX  b) Politehnica Bucuresti 2020XXXXXX  c) Politehnica 2020XXXXXXXXXX  d) Politehnica Bucuresti 2020XXXXXXXXXXXX  e) Bucuresti 2020XXXXXXXXXXXX  f) Bucuresti 2020XXXXXX    8. Utiliz\u00e2nd metoda backtracking, se genereaz\u0103 toate modalit\u0103\u021bile de a se forma o echip\u0103 de  ingineri cu 5 membrii. Echipa trebuie s\u0103 fie mixt\u0103, format\u0103 din exact 2 ingineri \u0219i restul", "sentences": ["94    text:=copy(text,p,length(text));  for k:=1 to length(text) div 2 do   begin     c:=text[k];text[k]:=text[length(text)-k+1];     text[length(text)-k+1]:=c;   end;  writeln(text);  End.", " a) Poli 2020  b) oli 2020  c) Admitere Poli   d) 0202 iloP eretimdA  e) 0202 eretimdA  f) 0202 iloP    7.", "Preciza\u021bi ce valoare are variabila text dup\u0103 executarea instruc\u0163iunii de mai jos.", " Limbajul C  char text[250],nou[250];  strcpy(text,strstr(\"Admitere Politehnica Bucuresti 2020\",  \"ere\")+strlen(\"2408\"));  strcpy(nou,text); strnset(nou,'X',12);  strncat(text,nou,12); printf(\"%s \\n\", text);    Limbajul C++  char text[250],nou[250];  strcpy(text,strstr(\"Admitere Politehnica Bucuresti 2020\",  \"ere\")+strlen(\"2408\"));  strcpy(nou,text); strnset(nou,'X',12);  strncat(text,nou,12); cout<<text;    Limbajul Pascal  var text:string[250];  c:char;  p,i:integer;  Begin  text:='Admitere Poli 2020'; p:=pos('Poli',text);  text:=copy(text,p,length(text));  for i:=1 to length(text) div 2 do  begin  c:=text[i]; text[i]:=text[length(text)-i+1];  text[length(text)-i+1]:=c;  end;  writeln(text);  End.", " a) Bucuresti 2020XXXXXX  b) Politehnica Bucuresti 2020XXXXXX  c) Politehnica 2020XXXXXXXXXX  d) Politehnica Bucuresti 2020XXXXXXXXXXXX  e) Bucuresti 2020XXXXXXXXXXXX  f) Bucuresti 2020XXXXXX    8.", "Utiliz\u00e2nd metoda backtracking, se genereaz\u0103 toate modalit\u0103\u021bile de a se forma o echip\u0103 de  ingineri cu 5 membrii.", "Echipa trebuie s\u0103 fie mixt\u0103, format\u0103 din exact 2 ingineri \u0219i restul"], "page_sentence_count_spacy": 7}, {"page_number": 95, "page_char_count": 2580, "page_word_count": 566, "page_sentence_count_raw": 19, "page_token_count": 645.0, "text": "95    inginere. \u0218tiind c\u0103 institu\u021bia are 24 ingineri, iar inginere de 3 ori mai multe, care este  num\u0103rul de echipe de ingineri care se pot forma?  a) 283946040 b) 283948060  c)283946080  d) 16832340 e) 16832380  f) 16460640    9. Fiind date dou\u0103 tablouri unidimensionale ordonate, fiecare cu n valori, se dore\u0219te  ob\u021binerea unui al treilea tablou unidimensional ordonat, care va con\u021bine, toate elementele  celor dou\u0103 tablouri \u00een ordine descresc\u0103toare. Algoritmul descris, efectueaz\u0103 \u00een medie, nr  compara\u021bii pentru a ordona elementele celor doi vectori. Num\u0103rul nr reprezint\u0103  complexitatea algoritmului de sortare \u0219i este:  a) O(n2)  b) O(n3)  c) O(n)  d)O(n2+n) e) O(log(3)\u2219n)  f)O(log(2))    10. Fie trei tije numerotate cu 1, 2 \u0219i 3. Problema const\u0103 \u00een mutarea celor n discuri de pe tija  1, pe tija 2, prin intermediul tijei 3, cu urm\u0103toarele restric\u021bii: la fiecare mutare se  deplaseaz\u0103 un singur disc; discurile se mut\u0103 numai de pe o tij\u0103 pe alta; un disc cu diametru  mai mare nu poate fi a\u0219ezat peste un disc cu diametru mai mic. Pentru n = 1, mut\u0103m  discul pe ultima tije. Pentru n=2, se fac mut\u0103rile 1\u21923, 1\u21922, 3\u21922. \u00cen cazul \u00een care  n>3 problema se complic\u0103. Respect\u00e2nd restric\u021biile date se realizeaz\u0103 un algoritm de  rezolvare a problemei. Preciza\u021bi complexitatea algoritmului de rezolvare al problemei  prezentate.  a) \u03b8(n\u2219log3(n3))  b) \u03b8(3n\u2219log3(n))  c) \u03b8(3n)  d) \u03b8(2n)  e) \u03b8(n2\u2219log(n2))  f) \u03b8(2n\u2219log(2n))    11. Se construie\u0219te un tablou bidimensional cu n\u00d7n elemente, \u00een variabila A prin secven\u021ba  de mai jos, unde variabila n este un num\u0103r natural nenul dat de la tastatur\u0103.  Limbajul C  for(i=1;i<=n;i++)  for(j=1;j<=n;j++)  A[i][j]=(3*i+2*j)/2;  Limbajul C++  for(i=1;i<=n;i++)  for(j=1;j<=n;j++)  A[i][j]=(3*i+2*j)/2;  Limbajul Pascal  for i:=1 to n do  for i:=1 to n do  A[i,j]:=(3*i+2*j)/2 ;  Preciza\u021bi care este suma elementelor de pe diagonala secundar\u0103 a tabloului bidimensional  A, \u00een urma execu\u021biei secven\u021bei de mai sus.  a)   5 4 \u2219(\ud835\udc5b+ 1) \u2219\ud835\udc5b  b)  3 4 \u2219(\ud835\udc5b+ 1) \u2219\ud835\udc5b  c)   5 4 \u2219\ud835\udc5b2  d)  3 4 \u2219\ud835\udc5b2  e)  3 4 \u2219(\ud835\udc5b\u22121) \u2219\ud835\udc5b  f)  5 4 \u2219(\ud835\udc5b\u22121) \u2219\ud835\udc5b    12. Se consider\u0103 declar\u0103rile de mai jos. Preciza\u021bi care este tipul expresiei bb.b.b.  Limbajul C  struct S1{ int a;char b;};  struct S2{ float a;double b;};  struct S3{struct S1 a;           struct S2 b;} aa, bb;    Limbajul Pascal  Type S1=Record         a: integer;         b: char; End;       S2=Record         a: real;         b: real;      End;       S3=Record         a: S1;         b: S2;   Limbajul C++  struct S1{ int a;char b;};  struct S2{ float a;double b;};  struct S3{struct S1 a;       struct S2 b;} aa, bb;", "sentences": ["95    inginere.", "\u0218tiind c\u0103 institu\u021bia are 24 ingineri, iar inginere de 3 ori mai multe, care este  num\u0103rul de echipe de ingineri care se pot forma?", " a) 283946040 b) 283948060  c)283946080  d) 16832340 e) 16832380  f) 16460640    9.", "Fiind date dou\u0103 tablouri unidimensionale ordonate, fiecare cu n valori, se dore\u0219te  ob\u021binerea unui al treilea tablou unidimensional ordonat, care va con\u021bine, toate elementele  celor dou\u0103 tablouri \u00een ordine descresc\u0103toare.", "Algoritmul descris, efectueaz\u0103 \u00een medie, nr  compara\u021bii pentru a ordona elementele celor doi vectori.", "Num\u0103rul nr reprezint\u0103  complexitatea algoritmului de sortare \u0219i este:  a) O(n2)  b) O(n3)  c) O(n)  d)O(n2+n) e) O(log(3)\u2219n)  f)O(log(2))    10.", "Fie trei tije numerotate cu 1, 2 \u0219i 3.", "Problema const\u0103 \u00een mutarea celor n discuri de pe tija  1, pe tija 2, prin intermediul tijei 3, cu urm\u0103toarele restric\u021bii: la fiecare mutare se  deplaseaz\u0103 un singur disc; discurile se mut\u0103 numai de pe o tij\u0103 pe alta; un disc cu diametru  mai mare nu poate fi a\u0219ezat peste un disc cu diametru mai mic.", "Pentru n = 1, mut\u0103m  discul pe ultima tije.", "Pentru n=2, se fac mut\u0103rile 1\u21923, 1\u21922, 3\u21922.", "\u00cen cazul \u00een care  n>3 problema se complic\u0103.", "Respect\u00e2nd restric\u021biile date se realizeaz\u0103 un algoritm de  rezolvare a problemei.", "Preciza\u021bi complexitatea algoritmului de rezolvare al problemei  prezentate.", " a) \u03b8(n\u2219log3(n3))  b) \u03b8(3n\u2219log3(n))  c) \u03b8(3n)  d) \u03b8(2n)  e) \u03b8(n2\u2219log(n2))  f) \u03b8(2n\u2219log(2n))    11.", "Se construie\u0219te un tablou bidimensional cu n\u00d7n elemente, \u00een variabila A prin secven\u021ba  de mai jos, unde variabila n este un num\u0103r natural nenul dat de la tastatur\u0103.", " Limbajul C  for(i=1;i<=n;i++)  for(j=1;j<=n;j++)  A[i][j]=(3*i+2*j)/2;  Limbajul C++  for(i=1;i<=n;i++)  for(j=1;j<=n;j++)  A[i][j]=(3*i+2*j)/2;  Limbajul Pascal  for i:=1 to n do  for i:=1 to n do  A[i,j]:=(3*i+2*j)/2 ;  Preciza\u021bi care este suma elementelor de pe diagonala secundar\u0103 a tabloului bidimensional  A, \u00een urma execu\u021biei secven\u021bei de mai sus.", " a)   5 4 \u2219(\ud835\udc5b+ 1) \u2219\ud835\udc5b  b)  3 4 \u2219(\ud835\udc5b+ 1) \u2219\ud835\udc5b  c)   5 4 \u2219\ud835\udc5b2  d)  3 4 \u2219\ud835\udc5b2  e)  3 4 \u2219(\ud835\udc5b\u22121) \u2219\ud835\udc5b  f)  5 4 \u2219(\ud835\udc5b\u22121) \u2219\ud835\udc5b    12.", "Se consider\u0103 declar\u0103rile de mai jos.", "Preciza\u021bi care este tipul expresiei bb.b.b.", " Limbajul C  struct S1{ int a;char b;};  struct S2{ float a;double b;};  struct S3{struct S1 a;           struct S2 b;} aa, bb;    Limbajul Pascal  Type S1=Record         a: integer;         b: char; End;       S2=Record         a: real;         b: real;      End;       S3=Record         a: S1;         b: S2;   Limbajul C++  struct S1{ int a;char b;};  struct S2{ float a;double b;};  struct S3{struct S1 a;       struct S2 b;} aa, bb;"], "page_sentence_count_spacy": 20}, {"page_number": 96, "page_char_count": 1723, "page_word_count": 417, "page_sentence_count_raw": 10, "page_token_count": 430.75, "text": "96       End;  var  aa,bb:S3;  a) long/ long/ longint  b) float/ float/ real  c) double/double/ real  d) int/ int/ integer  e) char/ char/ char  f) nu putem avea \u00een \u00eenregistr\u0103ri diferite,  c\u00e2mpuri cu acela\u0219i nume    13. Preciza\u021bi care vor fi valorile afi\u0219ate \u00een urma rul\u0103rii programului de mai jos pentru  variabilele a=2020, iar b=17.  Limbajul C  #include<stdio.h>   int a,b;  void f(int n,int m)  {  if(n!=m)    if(n>m)      f(n-m,m);     else     f(n,m-n);  else   {printf(\"%i\",a*b/n);   printf(\"%i \",m);   }  }  int main()  {scanf(\"%i \",&a);   scanf(\"%i \",&b);   f(a,b);   return 0;  }  Limbajul C++  #include<iostream>  using namespace  std;   int a,b;  void f(int n,int m)  {  if(n!=m)    if(n>m)       f(n-m,m);      else       f(n,m-n);    else  cout<<a*b/n<<\"  \"<<m;  }  int main()  { cin>>a>>b;    f(a,b);  return 0;  }  Limbajul Pascal  var a,b:integer;  procedure  f(n,m:integer);  Begin  if n<>m then   if n>m then    f(n-m,m)   else    f(n,m-n)  else   write(a*b div n,'  ',m);  end;  begin   readln(a,b);   f(a,b);  end.  a) 8080 4  b) 6060 5  c) 4040 6  d) 2020 2020 e) 34340 1  f) 16144 2    14. Se consider\u0103 un graf neorientat conex cu n noduri \u0219i m muchii, iar gradul fiec\u0103rui nod  este par. Preciza\u021bi care este complexitatea temporal\u0103 pentru determinarea unui ciclu  eulerian \u00een acest graf pentru algoritmii care pornesc de la o parcurgere. Graful este  reprezentat folosind liste de adiace\u021b\u0103.  a) O(n+m)  b) O(n)  c) O(n\u2219m)  d) O(m)  e) O(m\u2219log(2))  f) O(n\u2219log(2))    15. Preciza\u021bi complexitatea timp pentru secven\u021ba de program de mai jos.  Limbajul C  k=0;  for(int a=n;a>=1;a--)    for(int b=n;b>=1;b--)        k++;  printf(\"%i \\n\",k);  Limbajul Pascal  k:=0;  a:=n;  while(a>=1) do   begin    b:=n;", "sentences": ["96       End;  var  aa,bb:S3;  a) long/ long/ longint  b) float/ float/ real  c) double/double/ real  d) int/ int/ integer  e) char/ char/ char  f) nu putem avea \u00een \u00eenregistr\u0103ri diferite,  c\u00e2mpuri cu acela\u0219i nume    13.", "Preciza\u021bi care vor fi valorile afi\u0219ate \u00een urma rul\u0103rii programului de mai jos pentru  variabilele a=2020, iar b=17.", " Limbajul C  #include<stdio.h>   int a,b;  void f(int n,int m)  {  if(n!=m)    if(n>m)      f(n-m,m);     else     f(n,m-n);  else   {printf(\"%i\",a*b/n);   printf(\"%i \",m);   }  }  int main()  {scanf(\"%i \",&a);   scanf(\"%i \",&b);   f(a,b);   return 0;  }  Limbajul C++  #include<iostream>  using namespace  std;   int a,b;  void f(int n,int m)  {  if(n!=m)    if(n>m)       f(n-m,m);      else       f(n,m-n);    else  cout<<a*b/n<<\"  \"<<m;  }  int main()  { cin>>a>>b;    f(a,b);  return 0;  }  Limbajul Pascal  var a,b:integer;  procedure  f(n,m:integer);  Begin  if n<>m then   if n>m then    f(n-m,m)   else    f(n,m-n)  else   write(a*b div n,'  ',m);  end;  begin   readln(a,b);   f(a,b);  end.", " a) 8080 4  b) 6060 5  c) 4040 6  d) 2020 2020 e) 34340 1  f) 16144 2    14.", "Se consider\u0103 un graf neorientat conex cu n noduri \u0219i m muchii, iar gradul fiec\u0103rui nod  este par.", "Preciza\u021bi care este complexitatea temporal\u0103 pentru determinarea unui ciclu  eulerian \u00een acest graf pentru algoritmii care pornesc de la o parcurgere.", "Graful este  reprezentat folosind liste de adiace\u021b\u0103.", " a) O(n+m)  b) O(n)  c) O(n\u2219m)  d) O(m)  e) O(m\u2219log(2))  f) O(n\u2219log(2))    15.", "Preciza\u021bi complexitatea timp pentru secven\u021ba de program de mai jos.", " Limbajul C  k=0;  for(int a=n;a>=1;a--)    for(int b=n;b>=1;b--)        k++;  printf(\"%i \\n\",k);  Limbajul Pascal  k:=0;  a:=n;  while(a>=1) do   begin    b:=n;"], "page_sentence_count_spacy": 10}, {"page_number": 97, "page_char_count": 264, "page_word_count": 99, "page_sentence_count_raw": 1, "page_token_count": 66.0, "text": "97      Limbajul C++  k=0;  for(int a=n;a>=1;a--)    for(int b=n;b>=1;b--)        k++;  cout<<k;      while(b>=1) do         begin          k++;           dec(b);        end;    dec(a);  end;  write(k);  a) O(n\u2219log n)  b)O(2n)  c) O(n3)  d) O(n2)  e) O(n)  f) O(1)", "sentences": ["97      Limbajul C++  k=0;  for(int a=n;a>=1;a--)    for(int b=n;b>=1;b--)        k++;  cout<<k;      while(b>=1) do         begin          k++;           dec(b);        end;    dec(a);  end;  write(k);  a) O(n\u2219log n)  b)O(2n)  c) O(n3)  d) O(n2)  e) O(n)  f) O(1)"], "page_sentence_count_spacy": 1}, {"page_number": 98, "page_char_count": 1612, "page_word_count": 427, "page_sentence_count_raw": 9, "page_token_count": 403.0, "text": "98    Varianta 19    1. Ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei de cod de mai jos:  Limbajul C++  int main() {   int p, *q; p = 45; q = &p;  cout << q[0];    }    Limbajul Pascal  var  p:integer; q:^integer;  begin        p := 45; q := @p;           write(q^);  end.  Limbajul C  int main() {   int p,*q; p = 45; q = &p;   printf(\"%d\", q[0]);  }  a) 100  b) 45  c) Eroare  d) 0  e) 43  f) 1    2. Fie secven\u021ba de cod urm\u0103toare, \u00een care se consider\u0103 c\u0103 variabilele a,i,n re\u021bin numere  \u00eentregi:  Limbajul C++  cin>>n; a = 1; i = 2;  while(i<n && a>0){       if(n%i == 0) a=0;       else       i++; cout<<i;}    Limbajul Pascal  read(n);  a := 1; i := 2;  while ((i<n) and (a>0)) do  begin   if(n mod i = 0) then         a:=0   else      inc(i);      write(i);  end;  Limbajul C  scanf(\"%d\",&n); a = 1; i = 2;  while (i<n && a>0) {    if(n%i == 0) a = 0;    else i++; printf(\"%d\",i);}  Definim, \u00een acest context, opera\u021bie drept o instruc\u021biune de atribuire sau o expresie de   incrementare. Care este num\u0103rul minim de opera\u021bii ce se pot executa \u00een secven\u021ba de  mai sus, \u00een func\u021bie de valoarea citit\u0103 pentru variabila n?  a) 2n-1  b) n-1  c) 5  d) 3  e) 2  f) 4    3. Fie graful orientat G=(V,U) unde V={1,2,3,4,5,6,7} este mul\u021bimea  v\u00e2rfurilor, iar U={(2,1),(2,3),(5,2),(5,6),(3,4),(4,5),(4,7),  (6,7)} reprezint\u0103 mul\u021bimea arcelor. C\u00e2te componente tare conexe con\u021bine graful?  a) 6  b) 2  c) 3  d) 1  e) 5  f) 4    4. Fie arborele cu r\u0103d\u0103cin\u0103 cu nodurile numerotate de la 1 la 15, reprezentat prin vectorul  de ta\u021bi: {3,8,5,5,0,8,3,5,1,7,7,5,4,3,6}. C\u00e2\u021bi descenden\u021bi are nodul 3?  a) 3  b) 4  c) 5  d) 6  e) 2  f) 7", "sentences": ["98    Varianta 19    1.", "Ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei de cod de mai jos:  Limbajul C++  int main() {   int p, *q; p = 45; q = &p;  cout << q[0];    }    Limbajul Pascal  var  p:integer; q:^integer;  begin        p := 45; q := @p;           write(q^);  end.", " Limbajul C  int main() {   int p,*q; p = 45; q = &p;   printf(\"%d\", q[0]);  }  a) 100  b) 45  c) Eroare  d) 0  e) 43  f) 1    2.", "Fie secven\u021ba de cod urm\u0103toare, \u00een care se consider\u0103 c\u0103 variabilele a,i,n re\u021bin numere  \u00eentregi:  Limbajul C++  cin>>n; a = 1; i = 2;  while(i<n && a>0){       if(n%i == 0) a=0;       else       i++; cout<<i;}    Limbajul Pascal  read(n);  a := 1; i := 2;  while ((i<n) and (a>0)) do  begin   if(n mod i = 0) then         a:=0   else      inc(i);      write(i);  end;  Limbajul C  scanf(\"%d\",&n); a = 1; i = 2;  while (i<n && a>0) {    if(n%i == 0) a = 0;    else i++; printf(\"%d\",i);}  Definim, \u00een acest context, opera\u021bie drept o instruc\u021biune de atribuire sau o expresie de   incrementare.", "Care este num\u0103rul minim de opera\u021bii ce se pot executa \u00een secven\u021ba de  mai sus, \u00een func\u021bie de valoarea citit\u0103 pentru variabila n?", " a) 2n-1  b) n-1  c) 5  d) 3  e) 2  f) 4    3.", "Fie graful orientat G=(V,U) unde V={1,2,3,4,5,6,7} este mul\u021bimea  v\u00e2rfurilor, iar U={(2,1),(2,3),(5,2),(5,6),(3,4),(4,5),(4,7),  (6,7)} reprezint\u0103 mul\u021bimea arcelor.", "C\u00e2te componente tare conexe con\u021bine graful?", " a) 6  b) 2  c) 3  d) 1  e) 5  f) 4    4.", "Fie arborele cu r\u0103d\u0103cin\u0103 cu nodurile numerotate de la 1 la 15, reprezentat prin vectorul  de ta\u021bi: {3,8,5,5,0,8,3,5,1,7,7,5,4,3,6}.", "C\u00e2\u021bi descenden\u021bi are nodul 3?", " a) 3  b) 4  c) 5  d) 6  e) 2  f) 7"], "page_sentence_count_spacy": 12}, {"page_number": 99, "page_char_count": 1632, "page_word_count": 500, "page_sentence_count_raw": 8, "page_token_count": 408.0, "text": "99    5. Fie secven\u021ba de cod urm\u0103toare, \u00een care se consider\u0103 c\u0103 variabilele x \u0219i y re\u021bin numere  \u00eentregi:   Limbajul C++  void q (..... , .....)   { x = 10; y = 20;}  int main() { x = 1; y = 2;           q(x,y); cout<<x<<y;           q(y,x); cout<<x<<y;  }    Limbajul Pascal  procedure q( ... , ...) ;      begin           x := 10; y := 20;     end;  begin     x := 1; y := 2;      q(x,y); write(x,y);     q(y,x); write(x,y);   end.  Limbajul C  void q (..... , .....)    {*x = 10; y = 20;}  int main() { x = 1; y = 2;                    q(&x,y);printf(\"%d%d\",x,y);               q(&y,x);printf(\"%d%d\",x,y);  }  Care este varianta corect\u0103 a parametrilor formali din antetul subprogramului q pentru  care se va afi\u0219a secven\u021ba 1021010?  Limbajul C++  a)   int x, int y  b)  int &x, int &y  c)   int &x, int  y  d)   int x, int &y  e)  int y, int &x  f)  int y, int x    Limbajul C  a)   int x,int y  b)   int *x, int *y  c)  int *x, int y  d)   int x, int *y  e)  int y, int *x  f)   int y, int x    Limbajul Pascal  a)   x:integer;  y:integer;  b)  var x:integer;  var y: integer;  c)  var x:  integer;   y: integer;  d)  x:integer;   var y:integer;  e)   y:integer;   var x:integer;  f)   y:integer;   x:integer;    6. Num\u0103rul grafurilor complete orientate cu 24 de noduri este:  a) 2276  b) 9138  c) 3138  d) 4256  e) 9276  f) 2256    7. Fie secven\u021ba de cod urm\u0103toare \u00een care se consider\u0103 c\u0103 variabilele u \u0219i v re\u021bin numere  \u00eentregi:  Limbajul C++  int main() { u = 4; v = 4;   cout << u++*++v;   u>v ? cout<<\"u\" : cout <<\"v\";}    Limbajul Pascal  begin   u:=4; v:=4; inc(v);         write (u*v);   if(u>v)  then        write('u')", "sentences": ["99    5.", "Fie secven\u021ba de cod urm\u0103toare, \u00een care se consider\u0103 c\u0103 variabilele x \u0219i y re\u021bin numere  \u00eentregi:   Limbajul C++  void q (..... , .....)   { x = 10; y = 20;}  int main() { x = 1; y = 2;           q(x,y); cout<<x<<y;           q(y,x); cout<<x<<y;  }    Limbajul Pascal  procedure q( ... , ...) ;      begin           x := 10; y := 20;     end;  begin     x := 1; y := 2;      q(x,y); write(x,y);     q(y,x); write(x,y);   end.", " Limbajul C  void q (..... , .....)    {*x = 10; y = 20;}  int main() { x = 1; y = 2;                    q(&x,y);printf(\"%d%d\",x,y);               q(&y,x);printf(\"%d%d\",x,y);  }  Care este varianta corect\u0103 a parametrilor formali din antetul subprogramului q pentru  care se va afi\u0219a secven\u021ba 1021010?", " Limbajul C++  a)   int x, int y  b)  int &x, int &y  c)   int &x, int  y  d)   int x, int &y  e)  int y, int &x  f)  int y, int x    Limbajul C  a)   int x,int y  b)   int *x, int *y  c)  int *x, int y  d)   int x, int *y  e)  int y, int *x  f)   int y, int x    Limbajul Pascal  a)   x:integer;  y:integer;  b)  var x:integer;  var y: integer;  c)  var x:  integer;   y: integer;  d)  x:integer;   var y:integer;  e)   y:integer;   var x:integer;  f)   y:integer;   x:integer;    6.", "Num\u0103rul grafurilor complete orientate cu 24 de noduri este:  a) 2276  b) 9138  c) 3138  d) 4256  e) 9276  f) 2256    7.", "Fie secven\u021ba de cod urm\u0103toare \u00een care se consider\u0103 c\u0103 variabilele u \u0219i v re\u021bin numere  \u00eentregi:  Limbajul C++  int main() { u = 4; v = 4;   cout << u++*++v;   u>v ?", "cout<<\"u\" : cout <<\"v\";}    Limbajul Pascal  begin   u:=4; v:=4; inc(v);         write (u*v);   if(u>v)  then        write('u')"], "page_sentence_count_spacy": 7}, {"page_number": 100, "page_char_count": 1732, "page_word_count": 503, "page_sentence_count_raw": 8, "page_token_count": 433.0, "text": "100    Limbajul C  int main() {u = 4; v = 4;  printf(\"%d\",u++*++v);  u>v ? printf(\"u\") :  printf(\"v\");}    else       write('v');   end.  Ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei:  a) 20v  b) 25v  c) 20u  d) 25u  e) 16u  f) 16v     8. Se consider\u0103 graful  orientat G=(V,U) unde card(V) = 6 \u0219i U={(3,1),(1,2),(2,3),  (4,1),(2,5),(5,3),(3,4)}. Indica\u021bi num\u0103rul minim de muchii ce trebuie eliminate pentru  a deveni aciclic?  a) 5  b) 2  c) 3  d) 4  e) 0  f) 1     9. C\u00e2te grafuri neorientate distincte cu 4 noduri care au adiacente nodurile 1 \u0219i 2,  respectiv nodurile 3 \u0219i 4 sunt? Dou\u0103 grafuri se consider\u0103 distincte dac\u0103 matricile lor  de adiacen\u021b\u0103 sunt diferite.  a) 18  b) 15  c) 20  d) 12  e) 16  f) 10    10. Fie secven\u021ba de cod urm\u0103toare, unde toate variabilele re\u021bin numere \u00eentregi \u0219i n<m:  Limbajul C++  int main()  {k=0;   cin>>n>>m;  for(i=1;i<=n;i++)cin>>v[i];   for(i=1;i<=m;i++)   {cin>>x; li=1;ls=n;    while(li<=ls)    { m1=(li+ls)/2;   if(x==v[m1]){li=ls+1;k++;}    else    if(x>v[m1]) li=m1+1;    else  ls=m1-1;}    }cout<<k; }    Limbajul Pascal  begin   k:=0;    read(n,m);   for i:=1 to n do        read(v[i]);    for i:=1 to m do     begin      read(x);      li := 1;  ls := n;      while(li <= ls) do           begin        m1 := (li+ls) div 2;        if(x = v[m1]) then           begin            li:=ls+1; inc(k);                end          else        if(x>v[m1]) then           li := m1+1                               else ls := m1-1;           end;       end;write(k);  end.  Limbajul C  int main( ){   k=0;scanf(\"%d%d\",&n,&m);  for(i=1;i<=n;i++)   scanf(\"%d\",&v[i]);  for(i=1;i<=m;i++)  {scanf(\"%d\",&x);li=1;ls=n;   while(li<=ls){m1=(li+ls)/2;   if(x==v[m1]){li=ls+1;k++;}    else    if(x>v[m1])li=m1+1;", "sentences": ["100    Limbajul C  int main() {u = 4; v = 4;  printf(\"%d\",u++*++v);  u>v ?", "printf(\"u\") :  printf(\"v\");}    else       write('v');   end.", " Ce se va afi\u0219a \u00een urma rul\u0103rii secven\u021bei:  a) 20v  b) 25v  c) 20u  d) 25u  e) 16u  f) 16v     8.", "Se consider\u0103 graful  orientat G=(V,U) unde card(V) = 6 \u0219i U={(3,1),(1,2),(2,3),  (4,1),(2,5),(5,3),(3,4)}.", "Indica\u021bi num\u0103rul minim de muchii ce trebuie eliminate pentru  a deveni aciclic?", " a) 5  b) 2  c) 3  d) 4  e) 0  f) 1     9.", "C\u00e2te grafuri neorientate distincte cu 4 noduri care au adiacente nodurile 1 \u0219i 2,  respectiv nodurile 3 \u0219i 4 sunt?", "Dou\u0103 grafuri se consider\u0103 distincte dac\u0103 matricile lor  de adiacen\u021b\u0103 sunt diferite.", " a) 18  b) 15  c) 20  d) 12  e) 16  f) 10    10.", "Fie secven\u021ba de cod urm\u0103toare, unde toate variabilele re\u021bin numere \u00eentregi \u0219i n<m:  Limbajul C++  int main()  {k=0;   cin>>n>>m;  for(i=1;i<=n;i++)cin>>v[i];   for(i=1;i<=m;i++)   {cin>>x; li=1;ls=n;    while(li<=ls)    { m1=(li+ls)/2;   if(x==v[m1]){li=ls+1;k++;}    else    if(x>v[m1]) li=m1+1;    else  ls=m1-1;}    }cout<<k; }    Limbajul Pascal  begin   k:=0;    read(n,m);   for i:=1 to n do        read(v[i]);    for i:=1 to m do     begin      read(x);      li := 1;  ls := n;      while(li <= ls) do           begin        m1 := (li+ls) div 2;        if(x = v[m1]) then           begin            li:=ls+1; inc(k);                end          else        if(x>v[m1]) then           li := m1+1                               else ls := m1-1;           end;       end;write(k);  end.", " Limbajul C  int main( ){   k=0;scanf(\"%d%d\",&n,&m);  for(i=1;i<=n;i++)   scanf(\"%d\",&v[i]);  for(i=1;i<=m;i++)  {scanf(\"%d\",&x);li=1;ls=n;   while(li<=ls){m1=(li+ls)/2;   if(x==v[m1]){li=ls+1;k++;}    else    if(x>v[m1])li=m1+1;"], "page_sentence_count_spacy": 11}, {"page_number": 101, "page_char_count": 1492, "page_word_count": 360, "page_sentence_count_raw": 6, "page_token_count": 373.0, "text": "101       else  ls = m1-1;}  }   printf(\"%d\",k);  }  Care este complexitatea acestei secven\u021be de cod?  a) O(m\u2219log (n))  b) O(n\u2219log m)  c) O(n\u2219m)  d) O(n\u2219m\u2219log n)  e) O(n\u2219n)  f) O(m\u2219n)    11. Fie secven\u021ba de cod urm\u0103toare:  Limbajul C++  int f(int a[],int li,int ls)  { if(li==ls) return a[li];    else   return f(a,li,(li+ls)/2) +  f(a,(li+ls)/2+1, ls);}  int main()  { int n, a[20],i;  cin>>n;  for(i=1;i<=n;i++) cin>>a[i];   cout<<f(a,1,n);  }  Limbajul Pascal  type    vector=array[1..20] of  integer;  var n,i:integer;a:vector;  function f(var a:vector;  li,ls:integer):integer;  begin  if(li=ls) then f:=a[li]       else   f:=f(a,li,(li+ls) div 2)+  f(a,(li+ls) div 2+1, ls ) ;   end;   begin       read(n);       for i:=1 to n do           read (a[i])   ;         write(f(a,1,n));   end.    Limbajul C  int f(int a[],int li,int ls)  {   if(li == ls) return a[li];     else   return f(a,li, (li+ls)/2) +  f(a,(li+ls)/2+1, ls);    }  int main()  {int n,a[20],i;  scanf(\"%d\", &n);   for(i=1; i<=n; i++)     scanf(\"%d\", &a[i]);  printf(\"%d\",f(a,1,n));  }   Care este complexitatea acestei secven\u021be de cod?  a) O(n\u2219log n)  b) O(log n)  c) O(n)  d) O(n2)  e) O(n2+1)  f) O(n2-1)    12. Se consider\u0103 un arbore \u00een care fiecare nod intern (nod care nu este pe ultimul nivel)  are doi descenden\u021bi direc\u021bi. Dac\u0103 arborele are 38 niveluri (r\u0103d\u0103cina se afl\u0103 pe nivelul  0) c\u00e2te noduri are arborele?  a) 237  b) 419-1  c) 238+1  d) 237+1  e) 233+1  f) 239    13. Ce se va afi\u0219a pentru secven\u021ba de cod:", "sentences": ["101       else  ls = m1-1;}  }   printf(\"%d\",k);  }  Care este complexitatea acestei secven\u021be de cod?", " a) O(m\u2219log (n))  b) O(n\u2219log m)  c) O(n\u2219m)  d) O(n\u2219m\u2219log n)  e) O(n\u2219n)  f) O(m\u2219n)    11.", "Fie secven\u021ba de cod urm\u0103toare:  Limbajul C++  int f(int a[],int li,int ls)  { if(li==ls) return a[li];    else   return f(a,li,(li+ls)/2) +  f(a,(li+ls)/2+1, ls);}  int main()  { int n, a[20],i;  cin>>n;  for(i=1;i<=n;i++) cin>>a[i];   cout<<f(a,1,n);  }  Limbajul Pascal  type    vector=array[1..20] of  integer;  var n,i:integer;a:vector;  function f(var a:vector;  li,ls:integer):integer;  begin  if(li=ls) then f:=a[li]       else   f:=f(a,li,(li+ls) div 2)+  f(a,(li+ls) div 2+1, ls ) ;   end;   begin       read(n);       for i:=1 to n do           read (a[i])   ;         write(f(a,1,n));   end.", "   Limbajul C  int f(int a[],int li,int ls)  {   if(li == ls) return a[li];     else   return f(a,li, (li+ls)/2) +  f(a,(li+ls)/2+1, ls);    }  int main()  {int n,a[20],i;  scanf(\"%d\", &n);   for(i=1; i<=n; i++)     scanf(\"%d\", &a[i]);  printf(\"%d\",f(a,1,n));  }   Care este complexitatea acestei secven\u021be de cod?", " a) O(n\u2219log n)  b) O(log n)  c) O(n)  d) O(n2)  e) O(n2+1)  f) O(n2-1)    12.", "Se consider\u0103 un arbore \u00een care fiecare nod intern (nod care nu este pe ultimul nivel)  are doi descenden\u021bi direc\u021bi.", "Dac\u0103 arborele are 38 niveluri (r\u0103d\u0103cina se afl\u0103 pe nivelul  0) c\u00e2te noduri are arborele?", " a) 237  b) 419-1  c) 238+1  d) 237+1  e) 233+1  f) 239    13.", "Ce se va afi\u0219a pentru secven\u021ba de cod:"], "page_sentence_count_spacy": 9}, {"page_number": 102, "page_char_count": 1647, "page_word_count": 433, "page_sentence_count_raw": 5, "page_token_count": 411.75, "text": "102    Limbajul C++  int x,y;  void f(int &y, int x)         {x++; y=y+x;}  int main() {  x = 4; y = 2;cout<<x<<y<<\" \";  f(x,y); cout<<x<<y<<\" \";   f(x,x); cout<<x<<y<<\" \";  f(y,x); cout<<x<<y<<\" \";}  Limbajul Pascal  var x,y:integer;  procedure f(var y:integer;  x:integer);   begin      inc(x);      y:=y+x;   end;  begin   x:=4;y:=2;write(x,y,' ');    f(x,y); write(x,y,' ');    f(x,x); write(x,y,' ');    f(y,x); write(x,y,' ');    end.    Limbajul C  int x,y;  void f(int *y,int x)  {x++;*y=*y+x;}  int main() {  x = 4; y = 2;printf(\"%d%d \",x,y);  f(&x,y); printf(\"%d%d \", x,y);  f(&x,x); printf(\"%d%d \", x,y);   f(&y,x); printf(\"%d%d \", x,y);  }  a) 42 72 152 1518  b) 42 215 42 518  c) 42 27 415 158  d) 42 62 41 58  e) 42 62 45 58  f) 42 72 415 58    14. Folosind algoritmul de sortare prin inser\u0163ie, pentru ordonarea cresc\u0103toare a tabloului  unidimensional v=[6,5,4,3,2,1] se efectueaz\u0103 45 de pa\u0219i (de exemplu pentru  deplasarea elementului cu valoarea 6 pe pozi\u021bia 2 se execut\u0103 5 pa\u0219i):                Preciza\u021bi c\u00e2\u021bi pa\u0219i se execut\u0103 folosind acela\u0219i algoritm pentru ordonarea cresc\u0103toare a  tabloului v=[1000,999,...,3,2,1]   a) 1001999  b) 1001997  c) 1001998  d) 1002000  e) 1001897 f) 1001887    15. Fie subprogramul de mai jos:    Limbajul C++  void f(int n,int k) {int i;  for(i = 1; i <= n; i++)    {if(i%k == 0)cout<<i<<\" \";        f(n-1,k);}}      Limbajul Pascal  procedure f (n,k:integer);  var i : integer;    begin      for i := 1 to n do       begin       if(i mod k = 0) then           write(i,' ');  Limbajul C  P1: \ud835\udc56\u21902  P2:  \ud835\udc65\u2190\ud835\udc63[\ud835\udc56]  P3:  \ud835\udc57\u2190\ud835\udc56\u22121;  P4:  \ud835\udc63[\ud835\udc57+ 1] \u2190\ud835\udc63[\ud835\udc57];  P5:  \ud835\udc63[\ud835\udc57] \u2190\ud835\udc65.     6  P4  P2  p1  P3  5  4  3  2  1  P5", "sentences": ["102    Limbajul C++  int x,y;  void f(int &y, int x)         {x++; y=y+x;}  int main() {  x = 4; y = 2;cout<<x<<y<<\" \";  f(x,y); cout<<x<<y<<\" \";   f(x,x); cout<<x<<y<<\" \";  f(y,x); cout<<x<<y<<\" \";}  Limbajul Pascal  var x,y:integer;  procedure f(var y:integer;  x:integer);   begin      inc(x);      y:=y+x;   end;  begin   x:=4;y:=2;write(x,y,' ');    f(x,y); write(x,y,' ');    f(x,x); write(x,y,' ');    f(y,x); write(x,y,' ');    end.", "   Limbajul C  int x,y;  void f(int *y,int x)  {x++;*y=*y+x;}  int main() {  x = 4; y = 2;printf(\"%d%d \",x,y);  f(&x,y); printf(\"%d%d \", x,y);  f(&x,x); printf(\"%d%d \", x,y);   f(&y,x); printf(\"%d%d \", x,y);  }  a) 42 72 152 1518  b) 42 215 42 518  c) 42 27 415 158  d) 42 62 41 58  e) 42 62 45 58  f) 42 72 415 58    14.", "Folosind algoritmul de sortare prin inser\u0163ie, pentru ordonarea cresc\u0103toare a tabloului  unidimensional v=[6,5,4,3,2,1] se efectueaz\u0103 45 de pa\u0219i (de exemplu pentru  deplasarea elementului cu valoarea 6 pe pozi\u021bia 2 se execut\u0103 5 pa\u0219i):                Preciza\u021bi c\u00e2\u021bi pa\u0219i se execut\u0103 folosind acela\u0219i algoritm pentru ordonarea cresc\u0103toare a  tabloului v=[1000,999,...,3,2,1]   a) 1001999  b) 1001997  c) 1001998  d) 1002000  e) 1001897 f) 1001887    15.", "Fie subprogramul de mai jos:    Limbajul C++  void f(int n,int k) {int i;  for(i = 1; i <= n; i++)    {if(i%k == 0)cout<<i<<\" \";        f(n-1,k);}}      Limbajul Pascal  procedure f (n,k:integer);  var i : integer;    begin      for i := 1 to n do       begin       if(i mod k = 0) then           write(i,' ');  Limbajul C  P1: \ud835\udc56\u21902  P2:  \ud835\udc65\u2190\ud835\udc63[\ud835\udc56]  P3:  \ud835\udc57\u2190\ud835\udc56\u22121;  P4:  \ud835\udc63[\ud835\udc57+ 1] \u2190\ud835\udc63[\ud835\udc57];  P5:  \ud835\udc63[\ud835\udc57] \u2190\ud835\udc65.     6  P4  P2  p1  P3  5  4  3  2  1  P5"], "page_sentence_count_spacy": 4}, {"page_number": 103, "page_char_count": 317, "page_word_count": 98, "page_sentence_count_raw": 1, "page_token_count": 79.25, "text": "103    void f(int n,int k){int i;   for(i = 1; i <= n; i++)  {if(i%k==0)printf(\"%d   \",i);       f(n-1,k);}     }           f(n-1,k);       end;    end;  De c\u00e2te ori se execut\u0103 instruc\u021biunea de decizie \u00een cadrul subprogramului, dac\u0103 apelul  este f(3,1)?  a) 15 ori  b) 14 ori  c) 16 ori  d) 8 ori  e) 9 ori  f) 10 ori", "sentences": ["103    void f(int n,int k){int i;   for(i = 1; i <= n; i++)  {if(i%k==0)printf(\"%d   \",i);       f(n-1,k);}     }           f(n-1,k);       end;    end;  De c\u00e2te ori se execut\u0103 instruc\u021biunea de decizie \u00een cadrul subprogramului, dac\u0103 apelul  este f(3,1)?", " a) 15 ori  b) 14 ori  c) 16 ori  d) 8 ori  e) 9 ori  f) 10 ori"], "page_sentence_count_spacy": 2}, {"page_number": 104, "page_char_count": 1501, "page_word_count": 463, "page_sentence_count_raw": 4, "page_token_count": 375.25, "text": "104    Varianta 20    1. Fie subprogramul:  Limbajul C/C++  int f (int n, int s){   if (n < s) return 0;   else   if(n%s == 0)     return 1+ f(n/s,s+1);    else     return f(n/s,s);   }  Limbajul Pascal  function f(n,s:integer):  integer;  begin   if (n < s) then f:=0   else if (n mod s =0) then     f:= 1 + f(n div s,s+1)     else  f:= f(n div s,s);   end;  Subprogramul se execut\u0103 pentru urm\u0103toarele seturi de valori n=720,s=2;  n=120,s=3;n=120,s=1; n=720,s=1. Pentru c\u00e2te dintre apeluri subprogramul  f va returna valoarea 5?  a) un apel  b) 2 apeluri  c) 3 apeluri  d) niciun apel  e) 4 apeluri  f) 5 apeluri    2. Fie subprogramul de mai jos unde n \u0219i c sunt variabile \u00eentregi:   Limbajul C++  int f(int &n, int c){    int a = n%10;       if(n == 0) return 0;    else    if(a == c)   {n=n/10;  return 1+f(n,c);}       else  {n=n/10%10;return f(n,c);  }}    Limbajul Pascal  function  f(var  n:integer;  c:integer) : integer;  var a : integer;  begin   a := n mod 10;     if(n = 0) then f := 0     else      if(a = c) then       begin         n:=n div 10;         f:=1+f(n , c);        end      else        begin         n:=n div 10 mod 10;          f:=f(n,c);            end;       end;  Limbajul C   int f (int *n, int c) {   int a = *n %10;   if(*n == 0) return 0;   else    if(a==c)   {*n=*n/10;  return 1+f(n,c);}     else    {*n=(*n)/10%10;     return f(n,c);}   }   Care sunt variabilele ale c\u0103ror valori sunt re\u021binute \u00een stiva subprogramului?  a) n,c,a  b) c,a  c) n,c  d) a  e) c  f) n,a", "sentences": ["104    Varianta 20    1.", "Fie subprogramul:  Limbajul C/C++  int f (int n, int s){   if (n < s) return 0;   else   if(n%s == 0)     return 1+ f(n/s,s+1);    else     return f(n/s,s);   }  Limbajul Pascal  function f(n,s:integer):  integer;  begin   if (n < s) then f:=0   else if (n mod s =0) then     f:= 1 + f(n div s,s+1)     else  f:= f(n div s,s);   end;  Subprogramul se execut\u0103 pentru urm\u0103toarele seturi de valori n=720,s=2;  n=120,s=3;n=120,s=1; n=720,s=1.", "Pentru c\u00e2te dintre apeluri subprogramul  f va returna valoarea 5?", " a) un apel  b) 2 apeluri  c) 3 apeluri  d) niciun apel  e) 4 apeluri  f) 5 apeluri    2.", "Fie subprogramul de mai jos unde n \u0219i c sunt variabile \u00eentregi:   Limbajul C++  int f(int &n, int c){    int a = n%10;       if(n == 0) return 0;    else    if(a == c)   {n=n/10;  return 1+f(n,c);}       else  {n=n/10%10;return f(n,c);  }}    Limbajul Pascal  function  f(var  n:integer;  c:integer) : integer;  var a : integer;  begin   a := n mod 10;     if(n = 0) then f := 0     else      if(a = c) then       begin         n:=n div 10;         f:=1+f(n , c);        end      else        begin         n:=n div 10 mod 10;          f:=f(n,c);            end;       end;  Limbajul C   int f (int *n, int c) {   int a = *n %10;   if(*n == 0) return 0;   else    if(a==c)   {*n=*n/10;  return 1+f(n,c);}     else    {*n=(*n)/10%10;     return f(n,c);}   }   Care sunt variabilele ale c\u0103ror valori sunt re\u021binute \u00een stiva subprogramului?", " a) n,c,a  b) c,a  c) n,c  d) a  e) c  f) n,a"], "page_sentence_count_spacy": 6}, {"page_number": 105, "page_char_count": 2149, "page_word_count": 412, "page_sentence_count_raw": 15, "page_token_count": 537.25, "text": "105    3. Fie G un graf neorientat cu n>0 v\u00e2rfuri \u0219i m>0 muchii, reprezentat prin liste de  adiacen\u021b\u0103. Complexitatea unui algoritm care afi\u0219eaz\u0103 matricea de adiacen\u021b\u0103 asociat\u0103  grafului este:  a) O(m\u2219log n) b) O(m\u2219n) c) O(n2)  d) O(m2)  e) O(m2+1)  f) O(m2-1)    4. Variabilele x \u0219i y re\u021bin numere \u00eentregi.Care dintre expresiile de mai jos are valoarea 1  (Limbajul C/C++), True (Limbajul Pascal) \u0219tiind c\u0103 x>-1 \u0219i y<3?   Limbajul C/C++  a) x*y+y-3*x-3>0    b)!(x*y+y-3*x-3>=0)  c)(x-1)*(y-3)<0  d) (x+1)*(y-3)>0  e)(x-1)*(y+3)>0  f) (x+1)*(y+3)>0  Limbajul Pascal  a) x*y+y-3*x-3>0  b)NOT(x*y+y-3*x-3>=0) c)(x-1)*(y-3)<0  d) (x+1)*(y-3)>0  e)(x-1)*(y+3)>0  f)(x+1)*(y+3)>0    5. Se consider\u0103 num\u0103rul natural n=231045. Dac\u0103 se determin\u0103 toate submul\u021bimile  formate din cifrele lui n care au suma valorilor componentelor egal\u0103 cu 10, c\u00e2te  submul\u021bimi con\u021bin cifra 0?  a) 3  b) 5  c) 2  d) 1  e) 4  f) 6    6. Se consider\u0103 \u0219irul {a,b,c,u,i,e}. Se genereaz\u0103 folosind metoda backtracking, \u00een  ordine lexicografic\u0103, toate cuvintele de trei litere distincte, care con\u021bin dou\u0103 vocale.  Dac\u0103 primele trei solu\u021bii sunt abe,abi,abu care este a 9-a solu\u021bie?  a) aic  b) aib  c) aec  d) aub  e) ace  f) aei    7. \u00cen c\u00e2te moduri se poate scrie num\u0103rul 12 ca sum\u0103 de numere prime?  a) 5  b) 3  c) 7  d) 6  e) 5  f) 4     8. Se consider\u0103 mul\u021bimea de cuvinte {info, mate, fizica, chimie, biologie}. Se genereaz\u0103  folosind metoda backtracking, lexicografic, \u00een ordinea invers\u0103 citirii cuv\u00e2ntului,   submultimi de c\u00e2te trei cuvinte distincte. Dac\u0103 primele trei solu\u021bii sunt:  {fizica,  biologie, chimie};{fizica, biologie, mate};{fizica, biologie, info};  \u00eenaintea solu\u021biei  {chimie, mate, info} este solu\u021bia:  a) {biologie, mate,info}  b) {biologie, chimie,mate}  c) {chimie, biologie,  info}    d) {chimie,mate,biologie}  e) {fizica, mate,biologie}  f) {chimie,fizica, biologie}     9. Se consider\u0103 un arbore cu r\u0103d\u0103cin\u0103 \u00een care fiecare nod intern (nod care nu este pe ultimul  nivel) are doi descenden\u021bi direc\u021bi. Dac\u0103 arborele are k niveluri (r\u0103d\u0103cina se afl\u0103 pe  nivelul 0) c\u00e2te noduri sunt pe nivelul k ?  a) 2k+1  b) 2k-1+1  c) 2k  d) 2k-1  e) 2k-2+1  f) 2k+1+1", "sentences": ["105    3.", "Fie G un graf neorientat cu n>0 v\u00e2rfuri \u0219i m>0 muchii, reprezentat prin liste de  adiacen\u021b\u0103.", "Complexitatea unui algoritm care afi\u0219eaz\u0103 matricea de adiacen\u021b\u0103 asociat\u0103  grafului este:  a) O(m\u2219log n) b) O(m\u2219n) c) O(n2)  d) O(m2)  e) O(m2+1)  f) O(m2-1)    4.", "Variabilele x \u0219i y re\u021bin numere \u00eentregi.", "Care dintre expresiile de mai jos are valoarea 1  (Limbajul C/C++), True (Limbajul Pascal) \u0219tiind c\u0103 x>-1 \u0219i y<3?", "  Limbajul C/C++  a) x*y+y-3*x-3>0    b)!(x*y+y-3*x-3>=0)  c)(x-1)*(y-3)<0  d) (x+1)*(y-3)>0  e)(x-1)*(y+3)>0  f) (x+1)*(y+3)>0  Limbajul Pascal  a) x*y+y-3*x-3>0  b)NOT(x*y+y-3*x-3>=0) c)(x-1)*(y-3)<0  d) (x+1)*(y-3)>0  e)(x-1)*(y+3)>0  f)(x+1)*(y+3)>0    5.", "Se consider\u0103 num\u0103rul natural n=231045.", "Dac\u0103 se determin\u0103 toate submul\u021bimile  formate din cifrele lui n care au suma valorilor componentelor egal\u0103 cu 10, c\u00e2te  submul\u021bimi con\u021bin cifra 0?", " a) 3  b) 5  c) 2  d) 1  e) 4  f) 6    6.", "Se consider\u0103 \u0219irul {a,b,c,u,i,e}.", "Se genereaz\u0103 folosind metoda backtracking, \u00een  ordine lexicografic\u0103, toate cuvintele de trei litere distincte, care con\u021bin dou\u0103 vocale.", " Dac\u0103 primele trei solu\u021bii sunt abe,abi,abu care este a 9-a solu\u021bie?", " a) aic  b) aib  c) aec  d) aub  e) ace  f) aei    7.", "\u00cen c\u00e2te moduri se poate scrie num\u0103rul 12 ca sum\u0103 de numere prime?", " a) 5  b) 3  c) 7  d) 6  e) 5  f) 4     8.", "Se consider\u0103 mul\u021bimea de cuvinte {info, mate, fizica, chimie, biologie}.", "Se genereaz\u0103  folosind metoda backtracking, lexicografic, \u00een ordinea invers\u0103 citirii cuv\u00e2ntului,   submultimi de c\u00e2te trei cuvinte distincte.", "Dac\u0103 primele trei solu\u021bii sunt:  {fizica,  biologie, chimie};{fizica, biologie, mate};{fizica, biologie, info};  \u00eenaintea solu\u021biei  {chimie, mate, info} este solu\u021bia:  a) {biologie, mate,info}  b) {biologie, chimie,mate}  c) {chimie, biologie,  info}    d) {chimie,mate,biologie}  e) {fizica, mate,biologie}  f) {chimie,fizica, biologie}     9.", "Se consider\u0103 un arbore cu r\u0103d\u0103cin\u0103 \u00een care fiecare nod intern (nod care nu este pe ultimul  nivel) are doi descenden\u021bi direc\u021bi.", "Dac\u0103 arborele are k niveluri (r\u0103d\u0103cina se afl\u0103 pe  nivelul 0) c\u00e2te noduri sunt pe nivelul k ?", " a) 2k+1  b) 2k-1+1  c) 2k  d) 2k-1  e) 2k-2+1  f) 2k+1+1"], "page_sentence_count_spacy": 21}, {"page_number": 106, "page_char_count": 1655, "page_word_count": 503, "page_sentence_count_raw": 7, "page_token_count": 413.75, "text": "106    10. Se consider\u0103 \u0219irul primelor nxm numere naturale unde n\u22651 \u0219i m\u22651. Dac\u0103 se afi\u0219eaz\u0103  c\u00e2te m numere pe o linie, num\u0103rul 123 se afl\u0103 pe linia 4 \u0219i coloana 3, atunci pe ce linie  \u0219i coloan\u0103 se afl\u0103 num\u0103rul 167?  a) linia 5,     coloana 7  b) linia 4,     coloana 7  c) linia 6,  coloana 4  d) linia 6,  coloana 2  e) linia 5,  coloana 2  f) linia 5,   coloana 3    11. Fie secven\u021ba de cod urm\u0103toare \u00een care se consider\u0103 c\u0103 variabilele a,i,n re\u021bin numere  \u00eentregi.  Limbajul C++  int main(){   cin>>n; a = 1; i = 2;  while (i<n && a>0) {        if(n%i ==  0)  a = 0;         else   i++; cout<<i;   }}    Limbajul Pascal  read(n); a := 1; i := 2;  while (i<n) and (a>0) do      begin      if(n mod i = 0) then              a:=0           else              inc(i);           write(i);     end;  Limbajul C  int main(){ scanf(\"%d\",&n);   a = 1; i = 2;   while (i<n &&a>0){      if(n%i ==  0) a = 0;         else i++;  printf(\"%d\",i);   }}  Definim, \u00een acest context, opera\u021bie drept o instruc\u021biune de atribuire sau o expresie de   incrementare. Care este num\u0103rul maxim de opera\u021bii ce se pot executa \u00een secven\u021ba de  mai sus, \u00een func\u021bie de valoarea citit\u0103 pentru variabila n?  a) 2n+2  b) 2n  c) n-1  d) 2n+3  e) n  f) n+1    12. Fie secven\u021ba de program unde variabila i re\u021bine un num\u0103r \u00eentreg:  Limbajul C++   i = 4;   while (i <= 25)  {cout<<i/10+i%10<<\" \";  i+=2;  }  Limbajul Pascal  i := 4;    while i<=25 do    begin  write(i div 10+i mod 10,'  ');          i:=i+2;        end;    Limbajul C  i = 4;  while (i <= 25)   {printf(\"%d \",i/10+i%10);  i+=2;  }  Ultimele trei numere afi\u0219ate sunt:  a) 2 4 7  b) 2 4 9  c) 6 2 4  d) 9 2 4  e) 2 4 6  f) 9 2 1", "sentences": ["106    10.", "Se consider\u0103 \u0219irul primelor nxm numere naturale unde n\u22651 \u0219i m\u22651.", "Dac\u0103 se afi\u0219eaz\u0103  c\u00e2te m numere pe o linie, num\u0103rul 123 se afl\u0103 pe linia 4 \u0219i coloana 3, atunci pe ce linie  \u0219i coloan\u0103 se afl\u0103 num\u0103rul 167?", " a) linia 5,     coloana 7  b) linia 4,     coloana 7  c) linia 6,  coloana 4  d) linia 6,  coloana 2  e) linia 5,  coloana 2  f) linia 5,   coloana 3    11.", "Fie secven\u021ba de cod urm\u0103toare \u00een care se consider\u0103 c\u0103 variabilele a,i,n re\u021bin numere  \u00eentregi.", " Limbajul C++  int main(){   cin>>n; a = 1; i = 2;  while (i<n && a>0) {        if(n%i ==  0)  a = 0;         else   i++; cout<<i;   }}    Limbajul Pascal  read(n); a := 1; i := 2;  while (i<n) and (a>0) do      begin      if(n mod i = 0) then              a:=0           else              inc(i);           write(i);     end;  Limbajul C  int main(){ scanf(\"%d\",&n);   a = 1; i = 2;   while (i<n &&a>0){      if(n%i ==  0) a = 0;         else i++;  printf(\"%d\",i);   }}  Definim, \u00een acest context, opera\u021bie drept o instruc\u021biune de atribuire sau o expresie de   incrementare.", "Care este num\u0103rul maxim de opera\u021bii ce se pot executa \u00een secven\u021ba de  mai sus, \u00een func\u021bie de valoarea citit\u0103 pentru variabila n?", " a) 2n+2  b) 2n  c) n-1  d) 2n+3  e) n  f) n+1    12.", "Fie secven\u021ba de program unde variabila i re\u021bine un num\u0103r \u00eentreg:  Limbajul C++   i = 4;   while (i <= 25)  {cout<<i/10+i%10<<\" \";  i+=2;  }  Limbajul Pascal  i := 4;    while i<=25 do    begin  write(i div 10+i mod 10,'  ');          i:=i+2;        end;    Limbajul C  i = 4;  while (i <= 25)   {printf(\"%d \",i/10+i%10);  i+=2;  }  Ultimele trei numere afi\u0219ate sunt:  a) 2 4 7  b) 2 4 9  c) 6 2 4  d) 9 2 4  e) 2 4 6  f) 9 2 1"], "page_sentence_count_spacy": 9}, {"page_number": 107, "page_char_count": 1308, "page_word_count": 347, "page_sentence_count_raw": 3, "page_token_count": 327.0, "text": "107      13. Fie secven\u021ba de cod de mai jos:  Limbajul C/C++  float s,p;  float s1(int n){  if(n==0) return 2;else  if(n==1) return s;else  return s*s1(n-1)-     p*s1(n-2);  }  Limbajul Pascal  var s,p : float;  function s1(n : integer) :  real;  begin  if (n = 0) then s1:=2  else   if (n = 1) then  s1:=s  else s1:=s*s1(n-1)-p*s1(n-2);  end;  Dac\u0103 la apelul subprogramului s1 se returneaz\u0103 valoarea 82, ce valori ini\u021biale au  variabilele n, s \u0219i p \u00een aceast\u0103 ordine?  a) 4 3 4   b) 4 4 3  c) 4 2 3  d) 3 3 2  e) 3 1 2  f) 3 4 2    14. Fie secven\u021ba de cod unde toate variabilele sunt \u00eentregi:  Limbajul C++  s=0; cin>>n>>k;  for(i=1;i<=n;i++)   for(j=1;j<=n;j++)   { if (i > j) t = i - j;    else t = j - i;    if(i==j || t<=k || j==n-i+1 || (i+j>=n-k+1 && i+j<=n+k+1))       a[i][j] = 1;    else a[i][j] = 2;   if(a[i][j] == 2) s++;}    Limbajul C  s=0; scanf(\"%d%d\",&n,&k);  for(i=1;i<=n;i++)   for(j=1;j<=n;j++)   {if (i > j) t = i - j;    else t = j - i;    if(i==j || t<=k || j==n-i+1 || (i+j>=n-k+1 && i+j<=n+k+1))         a[i][j] = 1;     else a[i][j] = 2;      if(a[i][j] == 2) s++;}    Limbajul Pascal  s:=0; read(n,k);  for i:=1 to n do   for j:=1 to n do    begin     if(i>j) then  t:=i-j     else  t:=j-i;     if((i=j) or (t<=k) or (j=n-i+1) or ((i+j>=n-k+1) and (i+j<=  n+k+1))) then  a[i,j]:=1", "sentences": ["107      13.", "Fie secven\u021ba de cod de mai jos:  Limbajul C/C++  float s,p;  float s1(int n){  if(n==0) return 2;else  if(n==1) return s;else  return s*s1(n-1)-     p*s1(n-2);  }  Limbajul Pascal  var s,p : float;  function s1(n : integer) :  real;  begin  if (n = 0) then s1:=2  else   if (n = 1) then  s1:=s  else s1:=s*s1(n-1)-p*s1(n-2);  end;  Dac\u0103 la apelul subprogramului s1 se returneaz\u0103 valoarea 82, ce valori ini\u021biale au  variabilele n, s \u0219i p \u00een aceast\u0103 ordine?", " a) 4 3 4   b) 4 4 3  c) 4 2 3  d) 3 3 2  e) 3 1 2  f) 3 4 2    14.", "Fie secven\u021ba de cod unde toate variabilele sunt \u00eentregi:  Limbajul C++  s=0; cin>>n>>k;  for(i=1;i<=n;i++)   for(j=1;j<=n;j++)   { if (i > j) t = i - j;    else t = j - i;    if(i==j || t<=k || j==n-i+1 || (i+j>=n-k+1 && i+j<=n+k+1))       a[i][j] = 1;    else a[i][j] = 2;   if(a[i][j] == 2) s++;}    Limbajul C  s=0; scanf(\"%d%d\",&n,&k);  for(i=1;i<=n;i++)   for(j=1;j<=n;j++)   {if (i > j) t = i - j;    else t = j - i;    if(i==j || t<=k || j==n-i+1 || (i+j>=n-k+1 && i+j<=n+k+1))         a[i][j] = 1;     else a[i][j] = 2;      if(a[i][j] == 2) s++;}    Limbajul Pascal  s:=0; read(n,k);  for i:=1 to n do   for j:=1 to n do    begin     if(i>j) then  t:=i-j     else  t:=j-i;     if((i=j) or (t<=k) or (j=n-i+1) or ((i+j>=n-k+1) and (i+j<=  n+k+1))) then  a[i,j]:=1"], "page_sentence_count_spacy": 4}, {"page_number": 108, "page_char_count": 891, "page_word_count": 282, "page_sentence_count_raw": 2, "page_token_count": 222.75, "text": "108       else  a[i,j]:=2;     if(a[i,j] = 2) then inc(s);      end;  Pentru ce valori ale lui n \u0219i k variabila s va avea valoarea 8?  a) n=6; k=2  b) n=6; k=1  c) n=5; k=2  d)  n=7; k=1  e) n=4;  k=2  f) n=6;  k=3    15. Se consider\u0103 un tablou bidimensional \u00een care a[i][j]=j+3(i-1), (1 \u2264\ud835\udc56, \ud835\udc57\u22643)  Fie secven\u021ba de cod de mai jos:    Limbajul C++       k = 0;  for(i=1; i<=3; i++)  {for(j =1; j<=3-k; j++)        cout<<a[\u03b1][\u03b2]<<\" \";         k++; }    Limbajul Pascal  k := 0;  for i:=1 to 3 do   begin     for j:=1 to 3-k do       write(a[\u03b1,\u03b2],' ');     inc(k); end;    Limbajul C  k=0;  for(i=1; i<=3; i++)   {for(j =1;j<=3-k; j++)     printf(\"%d \",a[\u03b1][\u03b2]);     k++;}  Ce valori au \u03b1 \u0219i \u03b2 dac\u0103 la execu\u021bia secven\u021bei se afi\u0219eaz\u0103 \u0219irul  3 5 7 2 4 1?  a) \u03b1=3-j-k;    \u03b2= j  b) \u03b1=j;   \u03b2= 3-j-k  c)   \u03b1=j;      \u03b2= 4-j-k   d) \u03b1=4-j-k;       \u03b2= j  e) \u03b1=4+j-k;       \u03b2= j-1  f) \u03b1=4+j+k;       \u03b2= j+1", "sentences": ["108       else  a[i,j]:=2;     if(a[i,j] = 2) then inc(s);      end;  Pentru ce valori ale lui n \u0219i k variabila s va avea valoarea 8?", " a) n=6; k=2  b) n=6; k=1  c) n=5; k=2  d)  n=7; k=1  e) n=4;  k=2  f) n=6;  k=3    15.", "Se consider\u0103 un tablou bidimensional \u00een care a[i][j]=j+3(i-1), (1 \u2264\ud835\udc56, \ud835\udc57\u22643)  Fie secven\u021ba de cod de mai jos:    Limbajul C++       k = 0;  for(i=1; i<=3; i++)  {for(j =1; j<=3-k; j++)        cout<<a[\u03b1][\u03b2]<<\" \";         k++; }    Limbajul Pascal  k := 0;  for i:=1 to 3 do   begin     for j:=1 to 3-k do       write(a[\u03b1,\u03b2],' ');     inc(k); end;    Limbajul C  k=0;  for(i=1; i<=3; i++)   {for(j =1;j<=3-k; j++)     printf(\"%d \",a[\u03b1][\u03b2]);     k++;}  Ce valori au \u03b1 \u0219i \u03b2 dac\u0103 la execu\u021bia secven\u021bei se afi\u0219eaz\u0103 \u0219irul  3 5 7 2 4 1?", " a) \u03b1=3-j-k;    \u03b2= j  b) \u03b1=j;   \u03b2= 3-j-k  c)   \u03b1=j;      \u03b2= 4-j-k   d) \u03b1=4-j-k;       \u03b2= j  e) \u03b1=4+j-k;       \u03b2= j-1  f) \u03b1=4+j+k;       \u03b2= j+1"], "page_sentence_count_spacy": 4}, {"page_number": 109, "page_char_count": 2023, "page_word_count": 323, "page_sentence_count_raw": 4, "page_token_count": 505.75, "text": "109    Varianta 21    1. Preciza\u021bi care dintre urm\u0103toarele expresii are valoarea true \u00een Pascal sau 1 \u00een C/C++  dac\u0103 \u0219i numai dac\u0103 num\u0103rul \u00eentreg x are exact trei cifre?  Limbajul C++  a) (x%1000==0) || (x%100!=0)  b) (x/10==0) && (x/100==0)  c) (x%10==0) && (x/10==0)  d) (x/1000==0) && (x/100!=0)  e) (x/1000==0) || (x/100==0)  f) !((x/1000==0) && (x/100!=0))  Limbajul Pascal  a) (x mod 1000=0) or   (x mod 100<>0)  b) (x div 10=0) and   (x div 100=0)  c) (x mod 10=0) and   (x div 10=0)  d) (x div 1000=0) and   (x div 100<>0)  e) (x div 1000=0) or   (x div 100=0)  f) not((x div 1000=0) and   (x div 100<>0))    Limbajul C  a)(x%1000==0)|| (x%100!=0)    b)(x/10==0) && (x/100==0)  c)(x%10==0) && (x/10==0)  d)(x/1000==0) && (x/100!=0)  e)(x/1000==0) || (x/100==0)  f)!((x/1000==0) && (x/100!=0))    2. Robo\u021belul Bob se mi\u0219c\u0103 \u00eentr-un plan cartezian. Pentru a re\u021bine pozi\u021bia robotului definim  urm\u0103toarea structur\u0103:  Limbajul C  typedef struct  {    float x,y;  } robot;  robot bob;  Limbajul C++  struct robot  {    float x,y;  };  robot bob;  Limbajul Pascal  type robot=record       x,y:real;       end;    var bob:robot;  Preciza\u021bi care dintre expresiile de mai jos este adev\u0103rat\u0103 dac\u0103 \u0219i numai dac\u0103 robo\u021belul  se afl\u0103 \u00een interiorul sau pe laturile p\u0103tratului de coordonate (-2,-2),(-2,2),  (2,2),(2,-2)?  Limbajul C++  a) (robot.x>=-2)&&(robot.x<=2)&&(robot.y>=-2)&&(robot.y<=2)  b) (robot.x<=-2)||(robot.x>=2)||(robot.y<=-2)||(robot.y>=2)  c) (bob.x<=-2)||(bob.x>=2)||(bob.y>=-2)||(bob.y<=2)  d) (bob.x>=-2)&&(bob.x<=2)&&(bob.y>=-2)&&(bob.y<=2)  e) (bob.x>=-2)&&(bob.x<=2)||(bob.x>=-2)&&(bob.x<=2)  f) (robot.x>=-2)&&(robot.x<=2)||(robot.x>=-2)&&(robot.x<=2)    Limbajul C  a) (robot.x>=-2)&&(robot.x<=2)&&(robot.y>=-2)&&(robot.y<=2)  b) (robot.x<=-2)||(robot.x>=2)||(robot.y<=-2)||(robot.y>=2)  c) (bob.x<=-2)||(bob.x>=2)||(bob.y>=-2)||(bob.y<=2)  d) (bob.x>=-2)&&(bob.x<=2)&&(bob.y>=-2)&&(bob.y<=2)  e) (bob.x>=-2)&&(bob.x<=2)||(bob.x>=-2)&&(bob.x<=2)  f) (robot.x>=-2)&&(robot.x<=2)||(robot.x>=-2)&&(robot.x<=2)", "sentences": ["109    Varianta 21    1.", "Preciza\u021bi care dintre urm\u0103toarele expresii are valoarea true \u00een Pascal sau 1 \u00een C/C++  dac\u0103 \u0219i numai dac\u0103 num\u0103rul \u00eentreg x are exact trei cifre?", " Limbajul C++  a) (x%1000==0) || (x%100!=0)  b) (x/10==0) && (x/100==0)  c) (x%10==0) && (x/10==0)  d) (x/1000==0) && (x/100!=0)  e) (x/1000==0) || (x/100==0)  f) !((", "x/1000==0) && (x/100!=0))  Limbajul Pascal  a) (x mod 1000=0) or   (x mod 100<>0)  b) (x div 10=0) and   (x div 100=0)  c) (x mod 10=0) and   (x div 10=0)  d) (x div 1000=0) and   (x div 100<>0)  e) (x div 1000=0) or   (x div 100=0)  f) not((x div 1000=0) and   (x div 100<>0))    Limbajul C  a)(x%1000==0)|| (x%100!=0)    b)(x/10==0) && (x/100==0)  c)(x%10==0) && (x/10==0)  d)(x/1000==0) && (x/100!=0)  e)(x/1000==0) || (x/100==0)  f)!((x/1000==0) && (x/100!=0))    2.", "Robo\u021belul Bob se mi\u0219c\u0103 \u00eentr-un plan cartezian.", "Pentru a re\u021bine pozi\u021bia robotului definim  urm\u0103toarea structur\u0103:  Limbajul C  typedef struct  {    float x,y;  } robot;  robot bob;  Limbajul C++  struct robot  {    float x,y;  };  robot bob;  Limbajul Pascal  type robot=record       x,y:real;       end;    var bob:robot;  Preciza\u021bi care dintre expresiile de mai jos este adev\u0103rat\u0103 dac\u0103 \u0219i numai dac\u0103 robo\u021belul  se afl\u0103 \u00een interiorul sau pe laturile p\u0103tratului de coordonate (-2,-2),(-2,2),  (2,2),(2,-2)?", " Limbajul C++  a) (robot.x>=-2)&&(robot.x<=2)&&(robot.y>=-2)&&(robot.y<=2)  b) (robot.x<=-2)||(robot.x>=2)||(robot.y<=-2)||(robot.y>=2)  c) (bob.x<=-2)||(bob.x>=2)||(bob.y>=-2)||(bob.y<=2)  d) (bob.x>=-2)&&(bob.x<=2)&&(bob.y>=-2)&&(bob.y<=2)  e) (bob.x>=-2)&&(bob.x<=2)||(bob.x>=-2)&&(bob.x<=2)  f) (robot.x>=-2)&&(robot.x<=2)||(robot.x>=-2)&&(robot.x<=2)    Limbajul C  a) (robot.x>=-2)&&(robot.x<=2)&&(robot.y>=-2)&&(robot.y<=2)  b) (robot.x<=-2)||(robot.x>=2)||(robot.y<=-2)||(robot.y>=2)  c) (bob.x<=-2)||(bob.x>=2)||(bob.y>=-2)||(bob.y<=2)  d) (bob.x>=-2)&&(bob.x<=2)&&(bob.y>=-2)&&(bob.y<=2)  e) (bob.x>=-2)&&(bob.x<=2)||(bob.x>=-2)&&(bob.x<=2)  f) (robot.x>=-2)&&(robot.x<=2)||(robot.x>=-2)&&(robot.x<=2)"], "page_sentence_count_spacy": 7}, {"page_number": 110, "page_char_count": 1388, "page_word_count": 336, "page_sentence_count_raw": 5, "page_token_count": 347.0, "text": "110    Limbajul Pascal  a) (robot.x>=-2) and (robot.x<=2) and (robot.y>=-2) and  (robot.y<=2)  b) (robot.x<=-2) or (robot.x>=2) or (robot.y<=-2) or   (robot.y>=2)  c) (bob.x<=-2) or (bob.x>=2) or (bob.y>=-2) or (bob.y<=2)  d) (bob.x>=-2) and (bob.x<=2) and (bob.y>=-2) and (bob.y<=2)  e) (bob.x>=-2) and (bob.x<=2) or (bob.x>=-2) and (bob.x<=2)  f) (robot.x>=-2) and (robot.x<=2) or (robot.x>=-2) and  (robot.x<=2)    3. Preciza\u021bi ce se va afi\u0219a \u00een urma execu\u021biei urm\u0103torului program?  Limbajul C++  #include <iostream>  using namespace std;  int main()  {  int i,s=0;      for(i=1;i<=5;i++);           s=s+i;      cout<<s; return 0;}    Limbajul Pascal  var i,s:integer;  begin  s:=0;  for i:=1 to 5 do;       i:=i+1;  s:=s+i; write(s);   end.  Limbajul C  #include <stdio.h>  int main()  { int i,s=0;     for(i=1;i<=5;i++);           s=s+i;      printf(\"%d\",s);  return 0; }  a) Programul nu va afi\u0219a nimic, va  genera eroare de compilare.  b) 15  c) 6  d) 5  e) 0  f) 10    4. Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?  Limbajul C++  #include <iostream>  using namespace std;  int main()  {     char sir[]=\"ANA\";      int i=0;      while(sir[i])          sir[i++]++;      cout<<sir;      return 0;  }    Limbajul Pascal  var sir:string;      i:integer;  begin    sir:='ANA';    for i:=1 to length(sir) do        sir[i]:=succ(sir[i]);    write(sir);  end.", "sentences": ["110    Limbajul Pascal  a) (robot.x>=-2) and (robot.x<=2) and (robot.y>=-2) and  (robot.y<=2)  b) (robot.x<=-2) or (robot.x>=2) or (robot.y<=-2) or   (robot.y>=2)  c) (bob.x<=-2) or (bob.x>=2) or (bob.y>=-2) or (bob.y<=2)  d) (bob.x>=-2) and (bob.x<=2) and (bob.y>=-2) and (bob.y<=2)  e) (bob.x>=-2) and (bob.x<=2) or (bob.x>=-2) and (bob.x<=2)  f) (robot.x>=-2) and (robot.x<=2) or (robot.x>=-2) and  (robot.x<=2)    3.", "Preciza\u021bi ce se va afi\u0219a \u00een urma execu\u021biei urm\u0103torului program?", " Limbajul C++  #include <iostream>  using namespace std;  int main()  {  int i,s=0;      for(i=1;i<=5;i++);           s=s+i;      cout<<s; return 0;}    Limbajul Pascal  var i,s:integer;  begin  s:=0;  for i:=1 to 5 do;       i:=i+1;  s:=s+i; write(s);   end.", " Limbajul C  #include <stdio.h>  int main()  { int i,s=0;     for(i=1;i<=5;i++);           s=s+i;      printf(\"%d\",s);  return 0; }  a) Programul nu va afi\u0219a nimic, va  genera eroare de compilare.", " b) 15  c) 6  d) 5  e) 0  f) 10    4.", "Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?", " Limbajul C++  #include <iostream>  using namespace std;  int main()  {     char sir[]=\"ANA\";      int i=0;      while(sir[i])          sir[i++]++;      cout<<sir;      return 0;  }    Limbajul Pascal  var sir:string;      i:integer;  begin    sir:='ANA';    for i:=1 to length(sir) do        sir[i]:=succ(sir[i]);    write(sir);  end."], "page_sentence_count_spacy": 7}, {"page_number": 111, "page_char_count": 1246, "page_word_count": 281, "page_sentence_count_raw": 4, "page_token_count": 311.5, "text": "111    Limbajul C  #include <stdio.h>  int main()  {   char sir[]=\"ANA\";      int i=0;      while(sir[i])          sir[i++]++;      printf(\"%s\",sir);      return 0;  }    a) ANA  b) A  c) AN  d) BOB  e) BAB  f) COC    5. Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?  Limbajul C++  #include <iostream>  using namespace std;  struct coordonate{     int abscisa,ordonata;  };  int main()  { coordonate abscisa;    abscisa.abscisa=100;    abscisa.ordonata=200;  cout<<abscisa.abscisa<<\" \";    cout<<abscisa.ordonata;    return 0;}    Limbajul Pascal  type coordonate=record  abscisa,ordonata:integer;  end;    var abscisa:coordonate;    begin  abscisa.abscisa:=100;  abscisa.ordonata:=200;  write(abscisa.abscisa,' ');  write(abscisa.ordonata);  end.  Limbajul C  #include <stdio.h>  typedef struct {       int abscisa,ordonata;  }coordonate;  int main()  {    coordonate abscisa;    abscisa.abscisa=100;    abscisa.ordonata=200;    printf(\"%d \",abscisa.abscisa);        printf(\"%d\", abscisa.ordonata);    return 0;  }  a) Programul nu va afi\u0219a  nimic, va genera eroare  de compilare deoarece  numele variabilei de tip  struct nu poate coincide  cu numele c\u00e2mpului.  b) 0 0  c) 100 200  d) 200 100  e) 100  100  f) 200 200", "sentences": ["111    Limbajul C  #include <stdio.h>  int main()  {   char sir[]=\"ANA\";      int i=0;      while(sir[i])          sir[i++]++;      printf(\"%s\",sir);      return 0;  }    a) ANA  b) A  c) AN  d) BOB  e) BAB  f) COC    5.", "Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?", " Limbajul C++  #include <iostream>  using namespace std;  struct coordonate{     int abscisa,ordonata;  };  int main()  { coordonate abscisa;    abscisa.abscisa=100;    abscisa.ordonata=200;  cout<<abscisa.abscisa<<\" \";    cout<<abscisa.ordonata;    return 0;}    Limbajul Pascal  type coordonate=record  abscisa,ordonata:integer;  end;    var abscisa:coordonate;    begin  abscisa.abscisa:=100;  abscisa.ordonata:=200;  write(abscisa.abscisa,' ');  write(abscisa.ordonata);  end.", " Limbajul C  #include <stdio.h>  typedef struct {       int abscisa,ordonata;  }coordonate;  int main()  {    coordonate abscisa;    abscisa.abscisa=100;    abscisa.ordonata=200;    printf(\"%d \",abscisa.abscisa);        printf(\"%d\", abscisa.ordonata);    return 0;  }  a) Programul nu va afi\u0219a  nimic, va genera eroare  de compilare deoarece  numele variabilei de tip  struct nu poate coincide  cu numele c\u00e2mpului.", " b) 0 0  c) 100 200  d) 200 100  e) 100  100  f) 200 200"], "page_sentence_count_spacy": 5}, {"page_number": 112, "page_char_count": 1446, "page_word_count": 429, "page_sentence_count_raw": 6, "page_token_count": 361.5, "text": "112      6. Care va fi valoarea returnat\u0103 de func\u021bia f prezentat\u0103 mai jos?  Limbajul C/C++  char f()  { int i,j,mat[5][5];   char v='a';   for(i=0;i<5;i++)    for(j=0;j<5;j++)     { mat[i][j]=v;         v++; }      return mat[2][3]; }  Limbajul Pascal  type matrice=array[0..4,0..4] of               char;     function  f:char;    var i,j:integer;     mat:matrice;     v:char;  begin    v:='a';    for i:=0 to 4 do     for j:=0 to 4 do      begin       mat[i,j]:=v;v:=succ(v);      end;    f:=mat[2,3];  end;  a) e  b) i  c) n  d) m  e) o  f) p    7. Se consider\u0103 graful neorientat G reprezentat prin urm\u0103toarea matrice de adiacen\u021b\u0103:  \ud835\udc34= (         0 1 1 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)           Preciza\u021bi num\u0103rul componentelor conexe ale grafului G.  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    8. Corecta\u021bi secven\u021ba de program de mai jos astfel \u00eenc\u00e2t s\u0103 realizeze corect c\u0103utarea unui  num\u0103r \u00eentreg x \u00eentr-un vector v cu n elemente numere \u00eentregi ordonate cresc\u0103tor.  Limbajul C/C++  p=0;  u=n-1;  q=0;  while(p<=u && q==0)  {   m=(p+u)/2;   if(x==v[m]) q=1;   else if(x<v[m]) u=m-1;        else p=m-1;   }  if(q==1)    printf(\"Elementul a fost  gasit\");   else  Limbajul Pascal  p:=0;  u:=n-1;  q:=0;  while (p<=u) and (q=0) do  begin   m:=(p+u) div 2;   if(x=v[m]) then  q:=1   else if x<v[m] then u:=m-1        else p:=m-1;   end;   if q=1 then  write('Elementul a fost  gasit')    else", "sentences": ["112      6.", "Care va fi valoarea returnat\u0103 de func\u021bia f prezentat\u0103 mai jos?", " Limbajul C/C++  char f()  { int i,j,mat[5][5];   char v='a';   for(i=0;i<5;i++)    for(j=0;j<5;j++)     { mat[i][j]=v;         v++; }      return mat[2][3]; }  Limbajul Pascal  type matrice=array[0..4,0..4] of               char;     function  f:char;    var i,j:integer;     mat:matrice;     v:char;  begin    v:='a';    for i:=0 to 4 do     for j:=0 to 4 do      begin       mat[i,j]:=v;v:=succ(v);      end;    f:=mat[2,3];  end;  a) e  b) i  c) n  d) m  e) o  f) p    7.", "Se consider\u0103 graful neorientat G reprezentat prin urm\u0103toarea matrice de adiacen\u021b\u0103:  \ud835\udc34= (         0 1 1 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)           Preciza\u021bi num\u0103rul componentelor conexe ale grafului G.  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    8.", "Corecta\u021bi secven\u021ba de program de mai jos astfel \u00eenc\u00e2t s\u0103 realizeze corect c\u0103utarea unui  num\u0103r \u00eentreg x \u00eentr-un vector v cu n elemente numere \u00eentregi ordonate cresc\u0103tor.", " Limbajul C/C++  p=0;  u=n-1;  q=0;  while(p<=u && q==0)  {   m=(p+u)/2;   if(x==v[m]) q=1;   else if(x<v[m]) u=m-1;        else p=m-1;   }  if(q==1)    printf(\"Elementul a fost  gasit\");   else  Limbajul Pascal  p:=0;  u:=n-1;  q:=0;  while (p<=u) and (q=0) do  begin   m:=(p+u) div 2;   if(x=v[m]) then  q:=1   else if x<v[m] then u:=m-1        else p:=m-1;   end;   if q=1 then  write('Elementul a fost  gasit')    else"], "page_sentence_count_spacy": 6}, {"page_number": 113, "page_char_count": 2080, "page_word_count": 551, "page_sentence_count_raw": 2, "page_token_count": 520.0, "text": "113      printf(\"Elementul nu a  fost gasit\");        write('Elementul nu a  fost gasit');  Limbajul C/C++  a) Instruc\u021biunea   while(p<=u && q==0)  trebuie \u00eenlocuit\u0103 cu  while(p>=u && q==0)  b) Instruc\u021biunea   m=(p+u)/2;   trebuie \u00eenlocuit\u0103 cu m=(p+u)%2;  c) Instruc\u021biunea p=m-1; trebuie  \u00eenlocuit\u0103 cu p=m+1;  d) Instruc\u021biunea  u=m-1; trebuie  \u00eenlocuit\u0103 cu u=m+1;  e) Instruc\u021biunea if(x<v[m]) trebuie  \u00eenlocuit\u0103 cu if(x>v[m])  f) Instruc\u021biunea q=1; trebuie \u00eenlocuit\u0103  cu q=0;  Limbajul Pascal  a) Instruc\u021biunea  while (p<=u) and (q=0) do  trebuie \u00eenlocuit\u0103 cu  while (p>=u) and (q=0) do  b) Instruc\u021biunea   m:=(p+u) div 2; trebuie  \u00eenlocuit\u0103 cu  m:=(p+u) mod 2;  c) Instruc\u021biunea p:=m-1; trebuie  \u00eenlocuit\u0103 cu p:=m+1;  d) Instruc\u021biunea u:=m-1; trebuie  \u00eenlocuit\u0103 cu u:=m+1;  e) Instruc\u021biunea if x<v[m] trebuie  \u00eenlocuit\u0103 cu if x>v[m]  f) Instruc\u021biunea q:=1; trebuie \u00eenlocuit\u0103  cu q:=0;    9. Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei programului urm\u0103tor?  Limbajul C++  #include <iostream>  using namespace std;  int main()  { const int m=4,n=5;      int i,j,aux;      char a[m][n]=        {{'a','b','c','d','e'},        {'f','g','h','i','j'},          {'k','l','m','n','o'},         {'p','q','r','s','t'}};                                           for(i=0;i<2;i++)    { aux=a[2][n-1];      for(j=n-1;j>0;j--)          a[2][j]=a[2][j-1];      a[2][0]=aux;  }  for(i=0;i<2;i++)      { aux=a[m-1][2];        for(j=m-1;j>0;j--)            a[j][2]=a[j-1][2];        a[0][2]=aux;    }  for(i=0;i<m;i++){     for(j=0;j<n;j++)         cout<<a[i][j]<<\" \";   Limbajul Pascal  const m=4; n=5;  var i,j:integer;      aux:char;    a:array[0..m-1,0..n-1]        of  char=        (('a','b','c','d','e'),                  ('f','g','h','i','j'),                ('k','l','m','n','o'),                 ('p','q','r','s','t'));  begin  for i:=0 to 1 do   begin     aux:=a[2,n-1];    for j:=n-1 downto 1 do        a[2,j]:=a[2,j-1];     a[2,0]:=aux; end;  for i:=0 to 1 do   begin     aux:=a[m-1,2];    for j:=m-1 downto 1 do       a[j,2]:=a[j-1,2];     a[0,2]:=aux; end;  for i:=0 to m-1 do", "sentences": ["113      printf(\"Elementul nu a  fost gasit\");        write('Elementul nu a  fost gasit');  Limbajul C/C++  a) Instruc\u021biunea   while(p<=u && q==0)  trebuie \u00eenlocuit\u0103 cu  while(p>=u && q==0)  b) Instruc\u021biunea   m=(p+u)/2;   trebuie \u00eenlocuit\u0103 cu m=(p+u)%2;  c) Instruc\u021biunea p=m-1; trebuie  \u00eenlocuit\u0103 cu p=m+1;  d) Instruc\u021biunea  u=m-1; trebuie  \u00eenlocuit\u0103 cu u=m+1;  e) Instruc\u021biunea if(x<v[m]) trebuie  \u00eenlocuit\u0103 cu if(x>v[m])  f) Instruc\u021biunea q=1; trebuie \u00eenlocuit\u0103  cu q=0;  Limbajul Pascal  a) Instruc\u021biunea  while (p<=u) and (q=0) do  trebuie \u00eenlocuit\u0103 cu  while (p>=u) and (q=0) do  b) Instruc\u021biunea   m:=(p+u) div 2; trebuie  \u00eenlocuit\u0103 cu  m:=(p+u) mod 2;  c) Instruc\u021biunea p:=m-1; trebuie  \u00eenlocuit\u0103 cu p:=m+1;  d) Instruc\u021biunea u:=m-1; trebuie  \u00eenlocuit\u0103 cu u:=m+1;  e) Instruc\u021biunea if x<v[m] trebuie  \u00eenlocuit\u0103 cu if x>v[m]  f) Instruc\u021biunea q:=1; trebuie \u00eenlocuit\u0103  cu q:=0;    9.", "Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei programului urm\u0103tor?", " Limbajul C++  #include <iostream>  using namespace std;  int main()  { const int m=4,n=5;      int i,j,aux;      char a[m][n]=        {{'a','b','c','d','e'},        {'f','g','h','i','j'},          {'k','l','m','n','o'},         {'p','q','r','s','t'}};                                           for(i=0;i<2;i++)    { aux=a[2][n-1];      for(j=n-1;j>0;j--)          a[2][j]=a[2][j-1];      a[2][0]=aux;  }  for(i=0;i<2;i++)      { aux=a[m-1][2];        for(j=m-1;j>0;j--)            a[j][2]=a[j-1][2];        a[0][2]=aux;    }  for(i=0;i<m;i++){     for(j=0;j<n;j++)         cout<<a[i][j]<<\" \";   Limbajul Pascal  const m=4; n=5;  var i,j:integer;      aux:char;    a:array[0..m-1,0..n-1]        of  char=        (('a','b','c','d','e'),                  ('f','g','h','i','j'),                ('k','l','m','n','o'),                 ('p','q','r','s','t'));  begin  for i:=0 to 1 do   begin     aux:=a[2,n-1];    for j:=n-1 downto 1 do        a[2,j]:=a[2,j-1];     a[2,0]:=aux; end;  for i:=0 to 1 do   begin     aux:=a[m-1,2];    for j:=m-1 downto 1 do       a[j,2]:=a[j-1,2];     a[0,2]:=aux; end;  for i:=0 to m-1 do"], "page_sentence_count_spacy": 3}, {"page_number": 114, "page_char_count": 1361, "page_word_count": 491, "page_sentence_count_raw": 3, "page_token_count": 340.25, "text": "114       cout<<endl;  }  return 0; }       begin     for j:=0 to n-1 do        write(a[i,j],' ');     writeln; end;  end.  Limbajul C  #include <stdio.h>  int main()  { const int m=4,n=5;    int i,j,aux;    char a[4][5]={{'a','b','c','d','e'},                    {'f','g','h','i','j'},                   {'k','l','m','n','o'},                    {'p','q','r','s','t'}};                                for(i=0;i<2;i++)    { aux=a[2][n-1];      for(j=n-1;j>0;j--)          a[2][j]=a[2][j-1];      a[2][0]=aux;     }  for(i=0;i<2;i++)    {      aux=a[m-1][2];      for(j=m-1;j>0;j--)          a[j][2]=a[j-1][2];      a[0][2]=aux;      }  for(i=0;i<m;i++){     for(j=0;j<n;j++)   printf(\"%c %c\",a[i][j],' ');                 printf(\"\\n\");    }  return 0;  }  a)  a b c d e  f g h i j  n o k l m  p q r s t  b)  a b m d e  f g r i j  k l c n o  p q h s t  c)  d e a b c  i j f g h  l m n o k  s t p q r  d)   a b k d e   f g r i j   n o c l m   p q h s t  e)  e d c b a  f g h i j  k l m n o  p q r s t  f)   a b c d e  f g h i j  k l m n o  t s r q p    10. Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?  Limbajul C++  #include <iostream>  using namespace std;  int a=5, b=10, c=15;  void f(int a,int &b,int &c)  { a=a+5; b=b+10; c=c+15;  Limbajul Pascal  var a,b,c:integer;  procedure f(a:integer;var  b:integer; var  c:integer);  begin", "sentences": ["114       cout<<endl;  }  return 0; }       begin     for j:=0 to n-1 do        write(a[i,j],' ');     writeln; end;  end.", " Limbajul C  #include <stdio.h>  int main()  { const int m=4,n=5;    int i,j,aux;    char a[4][5]={{'a','b','c','d','e'},                    {'f','g','h','i','j'},                   {'k','l','m','n','o'},                    {'p','q','r','s','t'}};                                for(i=0;i<2;i++)    { aux=a[2][n-1];      for(j=n-1;j>0;j--)          a[2][j]=a[2][j-1];      a[2][0]=aux;     }  for(i=0;i<2;i++)    {      aux=a[m-1][2];      for(j=m-1;j>0;j--)          a[j][2]=a[j-1][2];      a[0][2]=aux;      }  for(i=0;i<m;i++){     for(j=0;j<n;j++)   printf(\"%c %c\",a[i][j],' ');                 printf(\"\\n\");    }  return 0;  }  a)  a b c d e  f g h i j  n o k l m  p q r s t  b)  a b m d e  f g r i j  k l c n o  p q h s t  c)  d e a b c  i j f g h  l m n o k  s t p q r  d)   a b k d e   f g r i j   n o c l m   p q h s t  e)  e d c b a  f g h i j  k l m n o  p q r s t  f)   a b c d e  f g h i j  k l m n o  t s r q p    10.", "Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?", " Limbajul C++  #include <iostream>  using namespace std;  int a=5, b=10, c=15;  void f(int a,int &b,int &c)  { a=a+5; b=b+10; c=c+15;  Limbajul Pascal  var a,b,c:integer;  procedure f(a:integer;var  b:integer; var  c:integer);  begin"], "page_sentence_count_spacy": 4}, {"page_number": 115, "page_char_count": 1866, "page_word_count": 475, "page_sentence_count_raw": 9, "page_token_count": 466.5, "text": "115    }  int main()  { f(a,b,c);f(a,a,b);    cout<<\"a=\"<<a;    cout<<\"b=\"<<b;    cout<<\"c=\"<<c;    return 0;  }      a:=a+5;b:=b+10;c:=c+15;  end;  begin   a:=5; b:=10; c:=15;   f(a,b,c);f(a,a,b);   write('a=',a);   write('b=',b);   write('c=',c);  end.  Limbajul C  #include <stdio.h>  int a=5, b=10, c=15;  void f(int a, int *b, int *c)  {  a=a+5; *b=*b+10; *c=*c+15; }  int main()  { f(a,&b,&c); f(a,&a,&b);    printf(\"a=%d\",a ); printf(\"b=%d\",b); printf(\"c=%d\",c);      return 0; }  a) a=5         b=5             c=20  b) a=15         b=35             c=30  c) a=10         b=20         c=30   d) a=5        b=10        c=15  e) a=15        b=5        c=30  f) a=10        b=5        c=30    11. Un echipaj va pleca spre Marte \u00een misiunea POLI. El este alc\u0103tuit din c\u0103pitan 1 - Andrei,  c\u0103pitan 2 - Marian \u0219i cercet\u0103torii Alina, Dana \u0219i Marius. S\u0103pt\u0103m\u00e2nal membrii  echipajului trebuie s\u0103 transmit\u0103 un raport respect\u00e2nd o anumit\u0103 ordine: \u00eentotdeauna  raportul c\u0103pitanului 1 trebuie s\u0103 fie \u00eenaintea raportului c\u0103pitanului 2. \u0218tiind c\u0103 primele  trei solu\u021bii posibile de raportare sunt:  Andrei Marian Alina Dana Marius  Andrei Marian Alina Marius Dana  Andrei Marian Dana Alina Marius  afi\u0219a\u021bi a zecea solu\u021bie.  a) Marius  Dana   Alina  Andrei  Marian  b) Dana  Marius   Alina  Andrei  Marian  c) Marius  Andrei  Marian   Alina  Dana  d) Andrei   Alina   Dana   Marius  Marian  e) Andrei  Alina  Dana  Marian  Marius  f) Andrei  Alina  Marius  Marian  Dana    12. \u00cenlocui\u021bi valoarea lui v[3] cu una dintre urm\u0103toarele valori astfel \u00eenc\u00e2t func\u021bia s\u0103  returneze 0 \u00een C/C++ sau false \u00een Pascal pentru apelul f(5).  Limbajul C++  int v[]={15,12,7,20,-1,-5};  int f(int n)  {if(n==0)  return 0;   else   return   v[n-1]<v[n] || f(n-1);}  Limbajul Pascal  var v:array[0..5] of  integer=(15,12,7,20,-1,-5);  function  f(n:integer):boolean;  begin    if n=0 then f:=false", "sentences": ["115    }  int main()  { f(a,b,c);f(a,a,b);    cout<<\"a=\"<<a;    cout<<\"b=\"<<b;    cout<<\"c=\"<<c;    return 0;  }      a:=a+5;b:=b+10;c:=c+15;  end;  begin   a:=5; b:=10; c:=15;   f(a,b,c);f(a,a,b);   write('a=',a);   write('b=',b);   write('c=',c);  end.", " Limbajul C  #include <stdio.h>  int a=5, b=10, c=15;  void f(int a, int *b, int *c)  {  a=a+5; *b=*b+10; *c=*c+15; }  int main()  { f(a,&b,&c); f(a,&a,&b);    printf(\"a=%d\",a ); printf(\"b=%d\",b); printf(\"c=%d\",c);      return 0; }  a) a=5         b=5             c=20  b) a=15         b=35             c=30  c) a=10         b=20         c=30   d) a=5        b=10        c=15  e) a=15        b=5        c=30  f) a=10        b=5        c=30    11.", "Un echipaj va pleca spre Marte \u00een misiunea POLI.", "El este alc\u0103tuit din c\u0103pitan 1 - Andrei,  c\u0103pitan 2 - Marian \u0219i cercet\u0103torii Alina, Dana \u0219i Marius.", "S\u0103pt\u0103m\u00e2nal membrii  echipajului trebuie s\u0103 transmit\u0103 un raport respect\u00e2nd o anumit\u0103 ordine: \u00eentotdeauna  raportul c\u0103pitanului 1 trebuie s\u0103 fie \u00eenaintea raportului c\u0103pitanului 2.", "\u0218tiind c\u0103 primele  trei solu\u021bii posibile de raportare sunt:  Andrei Marian Alina Dana Marius  Andrei Marian Alina Marius Dana  Andrei Marian Dana Alina Marius  afi\u0219a\u021bi a zecea solu\u021bie.", " a) Marius  Dana   Alina  Andrei  Marian  b) Dana  Marius   Alina  Andrei  Marian  c) Marius  Andrei  Marian   Alina  Dana  d) Andrei   Alina   Dana   Marius  Marian  e) Andrei  Alina  Dana  Marian  Marius  f) Andrei  Alina  Marius  Marian  Dana    12.", "\u00cenlocui\u021bi valoarea lui v[3] cu una dintre urm\u0103toarele valori astfel \u00eenc\u00e2t func\u021bia s\u0103  returneze 0 \u00een C/C++ sau false \u00een Pascal pentru apelul f(5).", " Limbajul C++  int v[]={15,12,7,20,-1,-5};  int f(int n)  {if(n==0)  return 0;   else   return   v[n-1]<v[n] || f(n-1);}  Limbajul Pascal  var v:array[0..5] of  integer=(15,12,7,20,-1,-5);  function  f(n:integer):boolean;  begin    if n=0 then f:=false"], "page_sentence_count_spacy": 9}, {"page_number": 116, "page_char_count": 1926, "page_word_count": 454, "page_sentence_count_raw": 10, "page_token_count": 481.5, "text": "116        else   f:=(v[n-1]<v[n]) or f(n-1);  end;  Limbajul C  int v[]={15,12,7,20,-1,-5};  int f(int n)  { if(n==0) return 0;     else   return   v[n-1]<v[n] || f(n-1); }  a) -2  b) -3  c) 16  d) 4  e) 24  f) 30    13. Se consider\u0103 graful neorientat G=({1,2,3,4,5,6},{(1,2),(1,3),(1,4),(2,3)}).  Preciza\u021bi care este num\u0103rul grafurilor par\u021biale ale grafului G?  a) 10  b) 12  c) 8  d) 16  e) 2  f) 4    14. Preciza\u021bi de c\u00e2te ori se va executa instruc\u021biunea de afi\u0219are (cout, printf sau write)  \u00een  secven\u021ba de cod de mai jos?  Limbajul C++  for(i=1;i<=10;i++)     for(j=1;j<=i;j++)        for(k=1;k<=j;k++)            cout<<i+j+k;  Limbajul Pascal  for i:=1 to 10 do    for j:=1 to i do      for k:=1 to j do          write(i+j+k);  Limbajul C  for(i=1;i<=10;i++)     for(j=1;j<=i;j++)        for(k=1;k<=j;k++)               printf(\"%d\",i+j+k);                a) 220  b) 110  c) 100  d) 55  e) 150  f) 200    15. Dorim s\u0103 cript\u0103m un cuv\u00e2nt scris cu litere mari astfel: fiecare liter\u0103 este codificat\u0103 prin  codul ei la care se adaug\u0103 un num\u0103r k (k>=0). Num\u0103rul k se nume\u0219te cheie de criptare.  De exemplu, dac\u0103 avem litera C \u0219i k este 6,  vom ob\u021bine dup\u0103 criptare litera I. Vom  considera literele a\u0219ezate pe un cerc, dup\u0103 Z vine A. Presupunem c\u0103 \u0219irul ini\u021bial este  re\u021binut \u00een variabila sir iar rezultatul ob\u021binut \u00een urma cript\u0103rii tot \u00een variabila sir.  Consider\u00e2nd prima parte a programului cea de mai jos,  preciza\u021bi care dintre  urm\u0103toarele secven\u021be realizeaz\u0103 criptarea corect\u0103 a unui \u0219ir de caractere citit de la  tastatur\u0103 cu o cheie k citit\u0103 de la tastatur\u0103?  Limbajul C++  char sir[255];  unsigned int k,i;  cin>>sir;  cin>>k;     Limbajul C  char sir[255];  unsigned int k,i;  scanf(\"%s\",sir);  scanf(\"%u\",&k);  Limbajul Pascal  var sir:string;        i,k:word;  begin      read(sir);      read(k);  Limbajul C++/C  a) for(i=0;i<strlen(sir);i++) sir[i]=sir[i]+k;  b) for(i=0;i<strlen(sir);i++) sir[i]=sir[i+k-'A'];", "sentences": ["116        else   f:=(v[n-1]<v[n]) or f(n-1);  end;  Limbajul C  int v[]={15,12,7,20,-1,-5};  int f(int n)  { if(n==0) return 0;     else   return   v[n-1]<v[n] || f(n-1); }  a) -2  b) -3  c) 16  d) 4  e) 24  f) 30    13.", "Se consider\u0103 graful neorientat G=({1,2,3,4,5,6},{(1,2),(1,3),(1,4),(2,3)}).", " Preciza\u021bi care este num\u0103rul grafurilor par\u021biale ale grafului G?", " a) 10  b) 12  c) 8  d) 16  e) 2  f) 4    14.", "Preciza\u021bi de c\u00e2te ori se va executa instruc\u021biunea de afi\u0219are (cout, printf sau write)  \u00een  secven\u021ba de cod de mai jos?", " Limbajul C++  for(i=1;i<=10;i++)     for(j=1;j<=i;j++)        for(k=1;k<=j;k++)            cout<<i+j+k;  Limbajul Pascal  for i:=1 to 10 do    for j:=1 to i do      for k:=1 to j do          write(i+j+k);  Limbajul C  for(i=1;i<=10;i++)     for(j=1;j<=i;j++)        for(k=1;k<=j;k++)               printf(\"%d\",i+j+k);                a) 220  b) 110  c) 100  d) 55  e) 150  f) 200    15.", "Dorim s\u0103 cript\u0103m un cuv\u00e2nt scris cu litere mari astfel: fiecare liter\u0103 este codificat\u0103 prin  codul ei la care se adaug\u0103 un num\u0103r k (k>=0).", "Num\u0103rul k se nume\u0219te cheie de criptare.", " De exemplu, dac\u0103 avem litera C \u0219i k este 6,  vom ob\u021bine dup\u0103 criptare litera I. Vom  considera literele a\u0219ezate pe un cerc, dup\u0103 Z vine A. Presupunem c\u0103 \u0219irul ini\u021bial este  re\u021binut \u00een variabila sir iar rezultatul ob\u021binut \u00een urma cript\u0103rii tot \u00een variabila sir.", " Consider\u00e2nd prima parte a programului cea de mai jos,  preciza\u021bi care dintre  urm\u0103toarele secven\u021be realizeaz\u0103 criptarea corect\u0103 a unui \u0219ir de caractere citit de la  tastatur\u0103 cu o cheie k citit\u0103 de la tastatur\u0103?", " Limbajul C++  char sir[255];  unsigned int k,i;  cin>>sir;  cin>>k;     Limbajul C  char sir[255];  unsigned int k,i;  scanf(\"%s\",sir);  scanf(\"%u\",&k);  Limbajul Pascal  var sir:string;        i,k:word;  begin      read(sir);      read(k);  Limbajul C++/C  a) for(i=0;i<strlen(sir);i++) sir[i]=sir[i]+k;  b) for(i=0;i<strlen(sir);i++) sir[i]=sir[i+k-'A'];"], "page_sentence_count_spacy": 11}, {"page_number": 117, "page_char_count": 976, "page_word_count": 227, "page_sentence_count_raw": 1, "page_token_count": 244.0, "text": "117    c) for(i=0;i<strlen(sir);i++) sir[i]=sir['Z'-'A'+k];  d) for(i=0;i<strlen(sir);i++)        sir[i]='A'+(sir[i]-'A'+k)%('Z'-'A'+1);  e) for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+'Z'-'A')%('Z'-'A'+1);     f) for(i=0;i<strlen(sir);i++)       sir[i]='A'+(sir[i]-'A'+k)%('Z'-'A'+k);    Limbajul Pascal  a) for i:=1 to length(sir) do     sir[i]:=chr(ord(sir[i])+k);  b) for i:=1 to length(sir) do     sir[i]:=chr(ord(sir[i+k-ord('A')]));  c) for i:=1 to length(sir) do          sir[i]:=chr(ord(sir[ord('Z')-ord('A')+k]));  d) for i:=1 to length(sir) do                            sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')+k) mod                (ord('Z')-ord('A')+1));  e) for i:=1 to length(sir) do        sir[i]:=chr(ord('A')+(ord(sir[i])- ord('A')+    ord('Z')-ord('A')) mod (ord('Z')- ord('A')+1));                      f) for i:=1 to length(sir) do                           sir[i]:=chr(ord('A')+(ord(sir[i])- ord('A')+k)          mod (ord('Z')-ord('A')+k));", "sentences": ["117    c) for(i=0;i<strlen(sir);i++) sir[i]=sir['Z'-'A'+k];  d) for(i=0;i<strlen(sir);i++)        sir[i]='A'+(sir[i]-'A'+k)%('Z'-'A'+1);  e) for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+'Z'-'A')%('Z'-'A'+1);     f) for(i=0;i<strlen(sir);i++)       sir[i]='A'+(sir[i]-'A'+k)%('Z'-'A'+k);    Limbajul Pascal  a) for i:=1 to length(sir) do     sir[i]:=chr(ord(sir[i])+k);  b) for i:=1 to length(sir) do     sir[i]:=chr(ord(sir[i+k-ord('A')]));  c) for i:=1 to length(sir) do          sir[i]:=chr(ord(sir[ord('Z')-ord('A')+k]));  d) for i:=1 to length(sir) do                            sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')+k) mod                (ord('Z')-ord('A')+1));  e) for i:=1 to length(sir) do        sir[i]:=chr(ord('A')+(ord(sir[i])- ord('A')+    ord('Z')-ord('A')) mod (ord('Z')- ord('A')+1));                      f) for i:=1 to length(sir) do                           sir[i]:=chr(ord('A')+(ord(sir[i])- ord('A')+k)          mod (ord('Z')-ord('A')+k));"], "page_sentence_count_spacy": 1}, {"page_number": 118, "page_char_count": 1247, "page_word_count": 345, "page_sentence_count_raw": 6, "page_token_count": 311.75, "text": "118    Varianta 22    1. Consider\u0103m descompunerea \u00een factori primi a unui num\u0103r reprezentat\u0103 prin intermediul  unui arbore, ca \u00een exemplul de mai jos.                          Folosind aceea\u0219i reprezentare, preciza\u021bi c\u00e2te frunze are arborele ob\u021binut pentru num\u0103rul  4800.  a) 10  b) 12  c) 9  d) 15  e) 6  f) 16    2. Preciza\u021bi ce se va afi\u0219a \u00een urma execu\u021biei urm\u0103torului program?  Limbajul C++  #include <iostream>  using namespace std;  int  v[]={5,2,9,11,22,17},n=6;  int calcul(int n)  {int i,poz,max;   max=v[0]; poz=0;   for(i=1;i<n;i++)    if(v[i]>max)      {max=v[i]; poz=i;}      return poz;}  int main()  { cout<<v[calcul(n)];   return 0; }    Limbajul Pascal  var n:integer;      v:array[0..5] of         integer=(5,2,9,11,22,17);                    function  calcul(n:integer):integer;  var i,poz,max:integer;  begin    max:=v[0]; poz:=0;    for i:=1 to n-1 do      if v[i]>max then       begin          max:=v[i];          poz:=i;        end;      calcul:=poz;  end;    begin  n:=6;  write(v[calcul(n)]);  end.  Limbajul C  #include <stdio.h>  int  v[]={5,2,9,11,22,17},n=6;  int calcul(int n)  { int i,poz,max;     max=v[0];poz=0;      for(i=1;i<n;i++)        if(v[i]>max)      { max=v[i]; poz=i;}      return poz; }  12  2  6  2  3", "sentences": ["118    Varianta 22    1.", "Consider\u0103m descompunerea \u00een factori primi a unui num\u0103r reprezentat\u0103 prin intermediul  unui arbore, ca \u00een exemplul de mai jos.", "                         Folosind aceea\u0219i reprezentare, preciza\u021bi c\u00e2te frunze are arborele ob\u021binut pentru num\u0103rul  4800.", " a) 10  b) 12  c) 9  d) 15  e) 6  f) 16    2.", "Preciza\u021bi ce se va afi\u0219a \u00een urma execu\u021biei urm\u0103torului program?", " Limbajul C++  #include <iostream>  using namespace std;  int  v[]={5,2,9,11,22,17},n=6;  int calcul(int n)  {int i,poz,max;   max=v[0]; poz=0;   for(i=1;i<n;i++)    if(v[i]>max)      {max=v[i]; poz=i;}      return poz;}  int main()  { cout<<v[calcul(n)];   return 0; }    Limbajul Pascal  var n:integer;      v:array[0..5] of         integer=(5,2,9,11,22,17);                    function  calcul(n:integer):integer;  var i,poz,max:integer;  begin    max:=v[0]; poz:=0;    for i:=1 to n-1 do      if v[i]>max then       begin          max:=v[i];          poz:=i;        end;      calcul:=poz;  end;    begin  n:=6;  write(v[calcul(n)]);  end.", " Limbajul C  #include <stdio.h>  int  v[]={5,2,9,11,22,17},n=6;  int calcul(int n)  { int i,poz,max;     max=v[0];poz=0;      for(i=1;i<n;i++)        if(v[i]>max)      { max=v[i]; poz=i;}      return poz; }  12  2  6  2  3"], "page_sentence_count_spacy": 7}, {"page_number": 119, "page_char_count": 2000, "page_word_count": 435, "page_sentence_count_raw": 18, "page_token_count": 500.0, "text": "119    int main()  {printf(\"%d\",v[calcul(n)]);     return 0; }  a) Programul nu va afi\u0219a nimic, va  genera eroare de compilare  deoarece apelul de func\u021bii nu este  permis ca indice \u00eentr-un tablou  unidimensional.  b) 22  c) 17  d) 2  e) 11  f) 9      3. Pentru care dintre urm\u0103toarele apeluri func\u021bia f va returna valoarea 1?  Limbajul C/C++  int f(int n)  {   int m=0,n1=n;   while(n!=0)   { m=m*10+n%10;     n=n/10;   }   if(m==n1)return 1;   else return 0;  }  Limbajul Pascal  function f(n:integer):integer;  var m,n1:integer;  begin    m:=0; n1:=n;    while n<>0 do    begin      m:=m*10+n mod 10; n:=n div 10;    end;    if m=n1 then f:=1     else f:=0; end;  a) f(123)  b) f(24)  c)f(2112)  d) f(17)  e) f(75)  f) f(1592)    4. \u00centr-un plan cartezian se g\u0103sesc 8 robo\u021bi da\u021bi prin coordonatele lor. Coordonatele celor  8  robo\u021bi  sunt:  (2,2),(2,4),(2,6),(2,8),(4,2),(6,2),(6,-2),  (-2,-2). Doi robo\u021bi A \u0219i B se numesc vecini dac\u0103 se g\u0103sesc pe o paralel\u0103 la axele de  coordonate \u0219i nu exist\u0103 un robot C situat \u00eentre A \u0219i B pe aceea\u0219i paralel\u0103. \u021ain\u00e2nd cont de  regulile de mai sus, construi\u021bi un graf neorientat cu 8 noduri. Nodurile grafului sunt  numerotate \u00een ordinea coordonatelor (nodul 1 are coordonatele (2,2), nodul 2  coordonatele (2,4) \u0219.a.m.d.). Dac\u0103 robotul 1 este vecin cu robotul 2 atunci va exista  muchie de la 1 la 2 \u00een graf.   Preciza\u021bi care dintre urm\u0103toarele afirma\u021bii despre graful astfel ob\u021binut este adev\u0103rat\u0103?  a) Graful   este   eulerian.  b) Graful  este  hamiltonian.  c) Graful   este   complet.  d) Graful  este  aciclic.  e) Graful  con\u021bine dou\u0103  componente  conexe.  f) Graful  con\u021bine trei  componente  conexe.    5. Corecta\u021bi secven\u021ba de program de mai jos astfel \u00eenc\u00e2t ea s\u0103 reprezinte calculul corect al  valorii polinomului P(x)=a0+a1x+a2x2+\u2026+anxn \u00eentr-un punct c dat.  Limbajul C/C++  p=0;  for(i=0;i<=n;i++)       p=p*c+a[i];    Limbajul Pascal  p:=0;  for i:=0 to n do     p:=p*c+a[i];  Limbajul C/C++  a) Instruc\u021biunea p=p*c+a[i]; trebuie  Limbajul Pascal", "sentences": ["119    int main()  {printf(\"%d\",v[calcul(n)]);     return 0; }  a) Programul nu va afi\u0219a nimic, va  genera eroare de compilare  deoarece apelul de func\u021bii nu este  permis ca indice \u00eentr-un tablou  unidimensional.", " b) 22  c) 17  d) 2  e) 11  f) 9      3.", "Pentru care dintre urm\u0103toarele apeluri func\u021bia f va returna valoarea 1?", " Limbajul C/C++  int f(int n)  {   int m=0,n1=n;   while(n!=0)   { m=m*10+n%10;     n=n/10;   }   if(m==n1)return 1;   else return 0;  }  Limbajul Pascal  function f(n:integer):integer;  var m,n1:integer;  begin    m:=0; n1:=n;    while n<>0 do    begin      m:=m*10+n mod 10; n:=n div 10;    end;    if m=n1 then f:=1     else f:=0; end;  a) f(123)  b) f(24)  c)f(2112)  d) f(17)  e) f(75)  f) f(1592)    4.", "\u00centr-un plan cartezian se g\u0103sesc 8 robo\u021bi da\u021bi prin coordonatele lor.", "Coordonatele celor  8  robo\u021bi  sunt:  (2,2),(2,4),(2,6),(2,8),(4,2),(6,2),(6,-2),  (-2,-2).", "Doi robo\u021bi A \u0219i B se numesc vecini dac\u0103 se g\u0103sesc pe o paralel\u0103 la axele de  coordonate \u0219i nu exist\u0103 un robot C situat \u00eentre A \u0219i B pe aceea\u0219i paralel\u0103.", "\u021ain\u00e2nd cont de  regulile de mai sus, construi\u021bi un graf neorientat cu 8 noduri.", "Nodurile grafului sunt  numerotate \u00een ordinea coordonatelor (nodul 1 are coordonatele (2,2), nodul 2  coordonatele (2,4) \u0219.a.m.d.).", "Dac\u0103 robotul 1 este vecin cu robotul 2 atunci va exista  muchie de la 1 la 2 \u00een graf.", "  Preciza\u021bi care dintre urm\u0103toarele afirma\u021bii despre graful astfel ob\u021binut este adev\u0103rat\u0103?", " a) Graful   este   eulerian.", " b) Graful  este  hamiltonian.", " c) Graful   este   complet.", " d) Graful  este  aciclic.", " e) Graful  con\u021bine dou\u0103  componente  conexe.", " f) Graful  con\u021bine trei  componente  conexe.", "   5.", "Corecta\u021bi secven\u021ba de program de mai jos astfel \u00eenc\u00e2t ea s\u0103 reprezinte calculul corect al  valorii polinomului P(x)=a0+a1x+a2x2+\u2026+anxn \u00eentr-un punct c dat.", " Limbajul C/C++  p=0;  for(i=0;i<=n;i++)       p=p*c+a[i];    Limbajul Pascal  p:=0;  for i:=0 to n do     p:=p*c+a[i];  Limbajul C/C++  a) Instruc\u021biunea p=p*c+a[i]; trebuie  Limbajul Pascal"], "page_sentence_count_spacy": 20}, {"page_number": 120, "page_char_count": 1834, "page_word_count": 389, "page_sentence_count_raw": 11, "page_token_count": 458.5, "text": "120    \u00eenlocuit\u0103 cu p=p*a[i]+c;  b) Instruc\u021biunea  for(i=0;i<=n;i++)  trebuie \u00eenlocuit\u0103 cu   for(i=n;i>=0;i--)  c) Instruc\u021biunea p=p*c+a[i];   trebuie \u00eenlocuit\u0103 cu p=c*a[i]+p;  d) Variabila p trebuie ini\u021bializat\u0103 cu -1.  e) Variabila p trebuie ini\u021bializat\u0103 cu 1.  f) Instruc\u021biunea  for(i=0;i<=n;i++)  trebuie \u00eenlocuit\u0103 cu  for(i=1;i<=n;i++)  a) Instruc\u021biunea p:=p*c+a[i]; trebuie  \u00eenlocuit\u0103 cu p:=p*a[i]+c;  b) Instruc\u021biunea for i:=0 to n do  trebuie \u00eenlocuit\u0103 cu   for i:=n downto 0 do  c) Instruc\u021biunea p:=p*c+a[i];   trebuie \u00eenlocuit\u0103 cu   p:=c*a[i]+p;  d) Variabila p trebuie ini\u021bializat\u0103 cu -1.  e) Variabila p trebuie ini\u021bializat\u0103 cu 1.  f) Instruc\u021biunea for i:=0 to n do   trebuie \u00eenlocuit\u0103 cu  for i:=1 to n do     6. Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?  Limbajul C++  #include <iostream>  using namespace std;  int i;  int g(int i)  {    return i+3; }  int f(int i)  {    return i+g(i); }  int main()  {   i=3;      cout<<i+f(g(i));      return 0; }    Limbajul Pascal  var i:integer;  function g(i:integer):integer;  begin    g:=i+3;   end;  function f(i:integer):integer;  begin    f:=i+g(i);   end;  begin    i:=3; write(i+f(g(i))); end.  Limbajul C  #include <stdio.h>  int i;  int g(int i)  {   return i+3; }  int f(int i)  {    return i+g(i); }  int main()  {    i=3; printf(\"%d\",i+f(g(i))); return 0; }  a) 18  b) 6  c) 15  d) 0  e) 9  f) 12    7. Preciza\u021bi care dintre urm\u0103toarele \u0219iruri de numere poate reprezenta \u0219irul gradelor  nodurilor unui graf neorientat cu 7 noduri?  a) (1,1,0,1,2,1,6)  b) (1,1,1,2,2,5,6) c) (1,1,1,1,2,1,6)  d) (3,3,3,3,3,3,6)  e)  (1,2,0,0,2,1,5)  f) (0,0,0,1,1,2,3)    8. Robotul Robi se afl\u0103 \u00eentr-un plan cartezian \u0219i are \u00een jurul lui un grup de n robo\u021bi. El  \u201cm\u0103n\u00e2nc\u0103\u201d robotul cel mai apropiat din grupul de robo\u021bi. At\u00e2t robotul Robi c\u00e2t \u0219i ceilal\u021bi", "sentences": ["120    \u00eenlocuit\u0103 cu p=p*a[i]+c;  b) Instruc\u021biunea  for(i=0;i<=n;i++)  trebuie \u00eenlocuit\u0103 cu   for(i=n;i>=0;i--)  c) Instruc\u021biunea p=p*c+a[i];   trebuie \u00eenlocuit\u0103 cu p=c*a[i]+p;  d) Variabila p trebuie ini\u021bializat\u0103 cu -1.", " e) Variabila p trebuie ini\u021bializat\u0103 cu 1.", " f) Instruc\u021biunea  for(i=0;i<=n;i++)  trebuie \u00eenlocuit\u0103 cu  for(i=1;i<=n;i++)  a) Instruc\u021biunea p:=p*c+a[i]; trebuie  \u00eenlocuit\u0103 cu p:=p*a[i]+c;  b) Instruc\u021biunea for i:=0 to n do  trebuie \u00eenlocuit\u0103 cu   for i:=n downto 0 do  c) Instruc\u021biunea p:=p*c+a[i];   trebuie \u00eenlocuit\u0103 cu   p:=c*a[i]+p;  d) Variabila p trebuie ini\u021bializat\u0103 cu -1.", " e) Variabila p trebuie ini\u021bializat\u0103 cu 1.", " f) Instruc\u021biunea for i:=0 to n do   trebuie \u00eenlocuit\u0103 cu  for i:=1 to n do     6.", "Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?", " Limbajul C++  #include <iostream>  using namespace std;  int i;  int g(int i)  {    return i+3; }  int f(int i)  {    return i+g(i); }  int main()  {   i=3;      cout<<i+f(g(i));      return 0; }    Limbajul Pascal  var i:integer;  function g(i:integer):integer;  begin    g:=i+3;   end;  function f(i:integer):integer;  begin    f:=i+g(i);   end;  begin    i:=3; write(i+f(g(i))); end.", " Limbajul C  #include <stdio.h>  int i;  int g(int i)  {   return i+3; }  int f(int i)  {    return i+g(i); }  int main()  {    i=3; printf(\"%d\",i+f(g(i))); return 0; }  a) 18  b) 6  c) 15  d) 0  e) 9  f) 12    7.", "Preciza\u021bi care dintre urm\u0103toarele \u0219iruri de numere poate reprezenta \u0219irul gradelor  nodurilor unui graf neorientat cu 7 noduri?", " a) (1,1,0,1,2,1,6)  b) (1,1,1,2,2,5,6) c) (1,1,1,1,2,1,6)  d) (3,3,3,3,3,3,6)  e)  (1,2,0,0,2,1,5)  f) (0,0,0,1,1,2,3)    8.", "Robotul Robi se afl\u0103 \u00eentr-un plan cartezian \u0219i are \u00een jurul lui un grup de n robo\u021bi.", "El  \u201cm\u0103n\u00e2nc\u0103\u201d robotul cel mai apropiat din grupul de robo\u021bi.", "At\u00e2t robotul Robi c\u00e2t \u0219i ceilal\u021bi"], "page_sentence_count_spacy": 13}, {"page_number": 121, "page_char_count": 1885, "page_word_count": 547, "page_sentence_count_raw": 5, "page_token_count": 471.25, "text": "121    robo\u021bi sunt identifica\u021bi prin coordonatele lor. Datele de intrare se citesc de la tastatur\u0103  astfel: n, num\u0103rul robo\u021bilor din grup, apoi coordonatele robotului Robi \u0219i \u00een continuare  coordonatele celor n robo\u021bi. Corecta\u021bi programul de mai jos astfel \u00eenc\u00e2t s\u0103 afi\u0219eze corect  coordonatele robotului care va fi \u201cm\u00e2ncat\u201d. \u00cen cazul \u00een care exist\u0103 mai mul\u021bi robo\u021bi la  aceea\u0219i distan\u021b\u0103 fa\u021b\u0103 de Robi, este m\u00e2ncat primul robot \u00eent\u00e2lnit la distan\u021ba respectiv\u0103.  Limbajul C++  #include <iostream>  #include <cmath>  using namespace std;  struct robot{     float x,y;     };  float distanta (robot r1,                   robot r2)  {      return sqrt((r1.x-r2.x)*        (r1.x-r2.x)+        (r1.y-r2.y)*(r1.y- r2.y));  }  int gaseste(robot robi,   robot a[], int n)  {      float min,d;      int i,poz;      min=distanta(robi,a[0]);      poz=1;      for(i=1;i<n;i++)      {           d=distanta(robi,a[i]);          if(d<min){              min=d;              poz=i;          }      }    return poz;  }  int main()  {   int n,i,k;      robot robi,a[21];      cin>>n;      cin>>robi.x>>robi.y;      for(i=0;i<n;i++)          cin>>a[i].x>>a[i].y;      k=gaseste(robi,a,n);  Limbajul Pascal  type robot=record          x,y:real;       end;       vector=array[0..20] of  robot;  var a:vector;      robi:robot;      n,i,k:integer;    function  distanta(r1,r2:robot):real;  begin     distanta:=   sqrt((r1.x-r2.x)*(r1.x- r2.x)+         (r1.y-r2.y)*(r1.y- r2.y));  end;  function gaseste(robi:robot;             a:vector;n:integer):integer;  var min,d:real;      i,poz:integer;  begin    min:=distanta(robi,a[0]);    poz:=1;    for i:=1 to n-1 do    begin       d:=distanta(robi,a[i]);       if d<min then         begin            min:=d;            poz:=i;          end;     end;   gaseste:=poz;  end;  begin    read(n);    read(robi.x,robi.y);    for i:=0 to n-1 do       readln(a[i].x,a[i].y);", "sentences": ["121    robo\u021bi sunt identifica\u021bi prin coordonatele lor.", "Datele de intrare se citesc de la tastatur\u0103  astfel: n, num\u0103rul robo\u021bilor din grup, apoi coordonatele robotului Robi \u0219i \u00een continuare  coordonatele celor n robo\u021bi.", "Corecta\u021bi programul de mai jos astfel \u00eenc\u00e2t s\u0103 afi\u0219eze corect  coordonatele robotului care va fi \u201cm\u00e2ncat\u201d.", "\u00cen cazul \u00een care exist\u0103 mai mul\u021bi robo\u021bi la  aceea\u0219i distan\u021b\u0103 fa\u021b\u0103 de Robi, este m\u00e2ncat primul robot \u00eent\u00e2lnit la distan\u021ba respectiv\u0103.", " Limbajul C++  #include <iostream>  #include <cmath>  using namespace std;  struct robot{     float x,y;     };  float distanta (robot r1,                   robot r2)  {      return sqrt((r1.x-r2.x)*        (r1.x-r2.x)+        (r1.y-r2.y)*(r1.y- r2.y));  }  int gaseste(robot robi,   robot a[], int n)  {      float min,d;      int i,poz;      min=distanta(robi,a[0]);      poz=1;      for(i=1;i<n;i++)      {           d=distanta(robi,a[i]);          if(d<min){              min=d;              poz=i;          }      }    return poz;  }  int main()  {   int n,i,k;      robot robi,a[21];      cin>>n;      cin>>robi.x>>robi.y;      for(i=0;i<n;i++)          cin>>a[i].x>>a[i].y;      k=gaseste(robi,a,n);  Limbajul Pascal  type robot=record          x,y:real;       end;       vector=array[0..20] of  robot;  var a:vector;      robi:robot;      n,i,k:integer;    function  distanta(r1,r2:robot):real;  begin     distanta:=   sqrt((r1.x-r2.x)*(r1.x- r2.x)+         (r1.y-r2.y)*(r1.y- r2.y));  end;  function gaseste(robi:robot;             a:vector;n:integer):integer;  var min,d:real;      i,poz:integer;  begin    min:=distanta(robi,a[0]);    poz:=1;    for i:=1 to n-1 do    begin       d:=distanta(robi,a[i]);       if d<min then         begin            min:=d;            poz:=i;          end;     end;   gaseste:=poz;  end;  begin    read(n);    read(robi.x,robi.y);    for i:=0 to n-1 do       readln(a[i].x,a[i].y);"], "page_sentence_count_spacy": 5}, {"page_number": 122, "page_char_count": 851, "page_word_count": 258, "page_sentence_count_raw": 2, "page_token_count": 212.75, "text": "122        cout<<a[k].x<<\"  \"<<a[k].y;      return 0;  }      k:=gaseste(robi,a,n);    write(a[k].x,' ',a[k].y);  end.        Limbajul C  #include <stdio.h>  #include <math.h>  typedef struct {     float x,y;     }robot;    float distanta (robot r1, robot r2)  {    return sqrt((r1.x-r2.x)*     (r1.x-r2.x)+     (r1.y-r2.y)*(r1.y-r2.y));  }    int gaseste(robot robi,      robot a[],int n)  {      float min,d;      int i,poz;      min=distanta(robi,a[0]);      poz=1;      for(i=1;i<n;i++)      {          d=distanta(robi,a[i]);          if(d<min){              min=d;              poz=i;          }      }    return poz;  }  int main()  {   int n,i,k;   robot robi,a[21];   scanf(\"%d\",&n);   scanf(\"%f %f\",&robi.x,&robi.y);   for(i=0;i<n;i++)     scanf(\"%f %f\", &a[i].x, &a[i].y);   k=gaseste(robi,a,n);   printf(\"%f %f\",a[k].x,a[k].y);   return 0;}", "sentences": ["122        cout<<a[k].x<<\"  \"<<a[k].y;      return 0;  }      k:=gaseste(robi,a,n);    write(a[k].x,' ',a[k].y);  end.", "       Limbajul C  #include <stdio.h>  #include <math.h>  typedef struct {     float x,y;     }robot;    float distanta (robot r1, robot r2)  {    return sqrt((r1.x-r2.x)*     (r1.x-r2.x)+     (r1.y-r2.y)*(r1.y-r2.y));  }    int gaseste(robot robi,      robot a[],int n)  {      float min,d;      int i,poz;      min=distanta(robi,a[0]);      poz=1;      for(i=1;i<n;i++)      {          d=distanta(robi,a[i]);          if(d<min){              min=d;              poz=i;          }      }    return poz;  }  int main()  {   int n,i,k;   robot robi,a[21];   scanf(\"%d\",&n);   scanf(\"%f %f\",&robi.x,&robi.y);   for(i=0;i<n;i++)     scanf(\"%f %f\", &a[i].x, &a[i].y);   k=gaseste(robi,a,n);   printf(\"%f %f\",a[k].x,a[k].y);   return 0;}"], "page_sentence_count_spacy": 2}, {"page_number": 123, "page_char_count": 1920, "page_word_count": 341, "page_sentence_count_raw": 2, "page_token_count": 480.0, "text": "123    Limbajul C++  a) Instruc\u021biunea if(d<min) trebuie \u00eenlocuit\u0103 cu if(d>min)  b) Instruc\u021biunea min=d; trebuie \u00eenlocuit\u0103 cu  d=min;  c)  Instruc\u021biunea min=distanta(robi,a[0]);  trebuie \u00eenlocuit\u0103 cu  min=distanta(robi,a[1]);  d) Instruc\u021biunea   poz=1;  trebuie \u00eenlocuit\u0103 cu  poz=0;  e) Secven\u021ba de instruc\u021biuni  for(i=0;i<n;i++)scanf(\"%f%f\",&a[i].x,&a[i].y);   trebuie \u00eenlocuit\u0103 cu    for(i=0;i<n;i++) scanf(\"%f%f\",&a.x[i],&a.y[i]);    f) Instruc\u021biunea poz=i;  trebuie \u00eenlocuit\u0103 cu i=poz;    Limbajul C  a) Instruc\u021biunea if(d<min)trebuie \u00eenlocuit\u0103 cu if(d>min)  b) Instruc\u021biunea min=d; trebuie \u00eenlocuit\u0103 cu d=min;  c) Instruc\u021biunea min=distanta(robi,a[0]); trebuie \u00eenlocuit\u0103 cu  min=distanta(robi,a[1]);     d) Instruc\u021biunea   poz=1;  trebuie \u00eenlocuit\u0103 cu poz=0;  e) Secven\u021ba de instruc\u021biuni   for(i=0;i<n;i++) cin>>a[i].x>>a[i].y;   trebuie \u00eenlocuit\u0103 cu   for(i=0;i<n;i++) cin>>a.x[i]>>a.y[i];  f) Instruc\u021biunea poz=i; trebuie \u00eenlocuit\u0103 cu i=poz;    Limbajul Pascal  a) Instruc\u021biunea if d<min then  trebuie \u00eenlocuit\u0103 cu  if d>min then  b) Instruc\u021biunea   min:=d; trebuie \u00eenlocuit\u0103 cu d:=min;  c) Instruc\u021biunea min:=distanta(robi,a[0]); trebuie \u00eenlocuit\u0103 cu   min:=distanta(robi,a[1]);  d) Instruc\u021biunea   poz:=1;  trebuie \u00eenlocuit\u0103 cu poz:=0;  e) Secven\u021ba de instruc\u021biuni   for i:=0 to n-1 do readln(a[i].x, a[i].y);   trebuie \u00eenlocuit\u0103 cu   for i:=0 to n-1 do readln(a.x[i], a.y[i]);  f) Instruc\u021biunea  poz:=i; trebuie \u00eenlocuit\u0103 cu i:=poz;    9. Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?  Limbajul C++  #include <iostream>  using namespace std;  int f()  {cout<<1<<\" \";       return 3; }  int main()  { int s=0,i;  for(i=1;i<=f();i++)  Limbajul C  #include <stdio.h>  int f()  { printf(\"1 \");    return 3; }  int main()  { int s=0,i;   for(i=1;i<=f();i++)     s=s+i;  Limbajul Pascal  var s,i:integer;  function f:integer;  begin   write('1 ');f:=3;  end;  begin  s:=0;  for i:=1 to f do", "sentences": ["123    Limbajul C++  a) Instruc\u021biunea if(d<min) trebuie \u00eenlocuit\u0103 cu if(d>min)  b) Instruc\u021biunea min=d; trebuie \u00eenlocuit\u0103 cu  d=min;  c)  Instruc\u021biunea min=distanta(robi,a[0]);  trebuie \u00eenlocuit\u0103 cu  min=distanta(robi,a[1]);  d) Instruc\u021biunea   poz=1;  trebuie \u00eenlocuit\u0103 cu  poz=0;  e) Secven\u021ba de instruc\u021biuni  for(i=0;i<n;i++)scanf(\"%f%f\",&a[i].x,&a[i].y);   trebuie \u00eenlocuit\u0103 cu    for(i=0;i<n;i++) scanf(\"%f%f\",&a.x[i],&a.y[i]);    f) Instruc\u021biunea poz=i;  trebuie \u00eenlocuit\u0103 cu i=poz;    Limbajul C  a) Instruc\u021biunea if(d<min)trebuie \u00eenlocuit\u0103 cu if(d>min)  b) Instruc\u021biunea min=d; trebuie \u00eenlocuit\u0103 cu d=min;  c) Instruc\u021biunea min=distanta(robi,a[0]); trebuie \u00eenlocuit\u0103 cu  min=distanta(robi,a[1]);     d) Instruc\u021biunea   poz=1;  trebuie \u00eenlocuit\u0103 cu poz=0;  e) Secven\u021ba de instruc\u021biuni   for(i=0;i<n;i++) cin>>a[i].x>>a[i].y;   trebuie \u00eenlocuit\u0103 cu   for(i=0;i<n;i++) cin>>a.x[i]>>a.y[i];  f) Instruc\u021biunea poz=i; trebuie \u00eenlocuit\u0103 cu i=poz;    Limbajul Pascal  a) Instruc\u021biunea if d<min then  trebuie \u00eenlocuit\u0103 cu  if d>min then  b) Instruc\u021biunea   min:=d; trebuie \u00eenlocuit\u0103 cu d:=min;  c) Instruc\u021biunea min:=distanta(robi,a[0]); trebuie \u00eenlocuit\u0103 cu   min:=distanta(robi,a[1]);  d) Instruc\u021biunea   poz:=1;  trebuie \u00eenlocuit\u0103 cu poz:=0;  e) Secven\u021ba de instruc\u021biuni   for i:=0 to n-1 do readln(a[i].x, a[i].y);   trebuie \u00eenlocuit\u0103 cu   for i:=0 to n-1 do readln(a.x[i], a.y[i]);  f) Instruc\u021biunea  poz:=i; trebuie \u00eenlocuit\u0103 cu i:=poz;    9.", "Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?", " Limbajul C++  #include <iostream>  using namespace std;  int f()  {cout<<1<<\" \";       return 3; }  int main()  { int s=0,i;  for(i=1;i<=f();i++)  Limbajul C  #include <stdio.h>  int f()  { printf(\"1 \");    return 3; }  int main()  { int s=0,i;   for(i=1;i<=f();i++)     s=s+i;  Limbajul Pascal  var s,i:integer;  function f:integer;  begin   write('1 ');f:=3;  end;  begin  s:=0;  for i:=1 to f do"], "page_sentence_count_spacy": 3}, {"page_number": 124, "page_char_count": 1603, "page_word_count": 457, "page_sentence_count_raw": 6, "page_token_count": 400.75, "text": "124      s=s+i;  cout<<s; return 0;}  printf(\"%d\",s);  return 0;}     s:=s+i;  writeln(s);end.    Limbajul C++  a) Programul nu va afi\u0219a  nimic, va genera  eroare de compilare  deoarece nu este  permis apelul unei  func\u021bii ca valoare  final\u0103 a contorului.  b) 1 1 1 1 6  c) 1 1 1 6  d) 1 1 6  e) 1 10  f) 1 0  Limbajul C  a) Programul nu va afi\u0219a  nimic, va genera  eroare de compilare  deoarece nu este  permis apelul unei  func\u021bii ca valoare  final\u0103 a contorului.  b) 1 1 1 1 6  c) 1 1 1 6  d) 1 1 6  e) 1 10  f) 1 0  Limbajul Pascal  a) Programul nu va  afi\u0219a nimic, va genera  eroare de compilare  deoarece nu este  permis apelul unei  func\u021bii ca valoare  final\u0103 a contorului.  b) 1 6  c) 1 1 1 6  d) 1 1 6  e) 1 10  f) 1 0    10. Ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program dac\u0103 de la tastatur\u0103 se  cite\u0219te cuv\u00e2ntul caiet ?  Limbajul C++  #include <iostream>  #include <string.h>  using namespace std;  int main()  {char a[255];  int i,j,l,n;  cin.get(a,255);i=0;  n=strlen(a);  while(i<n)  if(strchr(\"aeiou\",a[i]))   { for(l=1;l<=2;l++)     { n++;       for(j=n;j>i;j--)         a[j]=a[j-1];           }        a[i+1]='p';         a[i+2]=a[i]; i=i+3;        }        else i++;     cout<<a; return 0; }    Limbajul Pascal  var a:string[255];      i,j,l,n:integer;  begin   readln(a); i:=1;   n:=length(a);   while i<=n do  if pos(a[i],'aeiou')<>0 then     begin      for l:=1 to 2 do        begin         n:=n+1;       for j:=n downto i+1 do             a[j]:=a[j-1];         end;    a[i+1]:='p';a[i+2]:=a[i];    i:=i+3; end   else i:=i+1;  for i:=1 to n do     write(a[i]);  end.", "sentences": ["124      s=s+i;  cout<<s; return 0;}  printf(\"%d\",s);  return 0;}     s:=s+i;  writeln(s);end.", "   Limbajul C++  a) Programul nu va afi\u0219a  nimic, va genera  eroare de compilare  deoarece nu este  permis apelul unei  func\u021bii ca valoare  final\u0103 a contorului.", " b) 1 1 1 1 6  c) 1 1 1 6  d) 1 1 6  e) 1 10  f) 1 0  Limbajul C  a) Programul nu va afi\u0219a  nimic, va genera  eroare de compilare  deoarece nu este  permis apelul unei  func\u021bii ca valoare  final\u0103 a contorului.", " b) 1 1 1 1 6  c) 1 1 1 6  d) 1 1 6  e) 1 10  f) 1 0  Limbajul Pascal  a) Programul nu va  afi\u0219a nimic, va genera  eroare de compilare  deoarece nu este  permis apelul unei  func\u021bii ca valoare  final\u0103 a contorului.", " b) 1 6  c) 1 1 1 6  d) 1 1 6  e) 1 10  f) 1 0    10.", "Ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program dac\u0103 de la tastatur\u0103 se  cite\u0219te cuv\u00e2ntul caiet ?", " Limbajul C++  #include <iostream>  #include <string.h>  using namespace std;  int main()  {char a[255];  int i,j,l,n;  cin.get(a,255);i=0;  n=strlen(a);  while(i<n)  if(strchr(\"aeiou\",a[i]))   { for(l=1;l<=2;l++)     { n++;       for(j=n;j>i;j--)         a[j]=a[j-1];           }        a[i+1]='p';         a[i+2]=a[i]; i=i+3;        }        else i++;     cout<<a; return 0; }    Limbajul Pascal  var a:string[255];      i,j,l,n:integer;  begin   readln(a); i:=1;   n:=length(a);   while i<=n do  if pos(a[i],'aeiou')<>0 then     begin      for l:=1 to 2 do        begin         n:=n+1;       for j:=n downto i+1 do             a[j]:=a[j-1];         end;    a[i+1]:='p';a[i+2]:=a[i];    i:=i+3; end   else i:=i+1;  for i:=1 to n do     write(a[i]);  end."], "page_sentence_count_spacy": 7}, {"page_number": 125, "page_char_count": 1131, "page_word_count": 366, "page_sentence_count_raw": 4, "page_token_count": 282.75, "text": "125    Limbajul C  #include <stdio.h>  #include <string.h>  int main()  {   char a[255];      int i,j,l,n;      scanf(\"%s\",a); i=0; n=strlen(a);      while(i<n)        if(strchr(\"aeiou\",a[i]))        {           for(l=1;l<=2;l++)           {             n++;             for(j=n;j>i;j--)                a[j]=a[j-1];           }           a[i+1]='p'; a[i+2]=a[i]; i=i+3;        }        else i++;     printf(\"%s\",a); return 0;  }  a) cpapipet  b) ct  c) cpcapaipiepetpt  d) capaipiepet  e) tepeipiapac  f) pcpaieptp    11. Ce va afi\u0219a urm\u0103toarea func\u021bie la apelul f(30)?  Limbajul C/C++  int f(int n)  {      if(n>50) return n-5;      else          return f(f(n+7));  }  Limbajul Pascal  function f(n:integer):integer;  begin    if n>50 then       f:=n-5     else       f:=f(f(n+7));  end;  a) 47  b) 50  c) 150  d) 42  e) 44  f) 60    12. Fie f:A\u2192B. Func\u021bia f este injectiv\u0103 dac\u0103 \u2200 x,y\u2208A, x\u2260y f(x)\u2260f(y)  Pentru func\u021bia f:{1,2,3}\u2192{1,2,3,4,5}, folosind metoda backtracking, primele  trei func\u021bii injective generate sunt:  x:     1 2 3  f(x): 1 2 3  --------------  x:     1 2 3  f(x): 1 2 4  --------------  x:     1 2 3  f(x): 1 2 5", "sentences": ["125    Limbajul C  #include <stdio.h>  #include <string.h>  int main()  {   char a[255];      int i,j,l,n;      scanf(\"%s\",a); i=0; n=strlen(a);      while(i<n)        if(strchr(\"aeiou\",a[i]))        {           for(l=1;l<=2;l++)           {             n++;             for(j=n;j>i;j--)                a[j]=a[j-1];           }           a[i+1]='p'; a[i+2]=a[i]; i=i+3;        }        else i++;     printf(\"%s\",a); return 0;  }  a) cpapipet  b) ct  c) cpcapaipiepetpt  d) capaipiepet  e) tepeipiapac  f) pcpaieptp    11.", "Ce va afi\u0219a urm\u0103toarea func\u021bie la apelul f(30)?", " Limbajul C/C++  int f(int n)  {      if(n>50) return n-5;      else          return f(f(n+7));  }  Limbajul Pascal  function f(n:integer):integer;  begin    if n>50 then       f:=n-5     else       f:=f(f(n+7));  end;  a) 47  b) 50  c) 150  d) 42  e) 44  f) 60    12.", "Fie f:A\u2192B. Func\u021bia f este injectiv\u0103 dac\u0103 \u2200 x,y\u2208A, x\u2260y f(x)\u2260f(y)  Pentru func\u021bia f:{1,2,3}\u2192{1,2,3,4,5}, folosind metoda backtracking, primele  trei func\u021bii injective generate sunt:  x:     1 2 3  f(x): 1 2 3  --------------  x:     1 2 3  f(x): 1 2 4  --------------  x:     1 2 3  f(x): 1 2 5"], "page_sentence_count_spacy": 4}, {"page_number": 126, "page_char_count": 1692, "page_word_count": 452, "page_sentence_count_raw": 10, "page_token_count": 423.0, "text": "126    Preciza\u021bi care este a zecea func\u021bie generat\u0103.  a) 5 4 3  b) 4 3 2  c) 2 1 3  d) 1 5 2  e) 1 4 5  f) 1 5 3    13. Num\u0103rul ciclurilor hamiltoniene distincte ale unui graf neorientat complet G cu n\u22653  noduri este egal cu  a) n  b)  (\ud835\udc5b\u22121)! 2   c) n!  d)  \ud835\udc5b\u2217(\ud835\udc5b\u22121) 2   e) n*(n-1)  f)  \ud835\udc5b 2    14. Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?  Limbajul C++  #include <iostream>  using namespace std;  int v[]={15,12,7,20,-1,-5};  int f(int n)  { cout<<n<<\" \";    if(n==0) return 0;   else    return     v[n-1]<v[n] || f(n-1);  }  int main()  { cout<<f(5); return 0; }    Limbajul Pascal  var v:array[0..5] of  integer=(15,12,7,20,-1,-5);    function  f(n:integer):boolean;  begin    write(n,' ');    if n=0 then f:=false    else f:=(v[n-1]<v[n]) or  f(n-1);  end;  begin     write(f(5));  end.  Limbajul C  #include <stdio.h>  int v[]={15,12,7,20,-1,-5};  int f(int n)  {    printf(\"%d \",n);    if(n==0)return 0;    else return v[n-1]<v[n] || f(n-1);  }  int main()  {  printf(\"%d\",f(5)); return 0; }  Limbajul C  a) 5 4 3 2 1 0  b) 5 4 3 2 1 0 1  c) 5 4 3  d) 5 4 3 1  e) 4 3 1  f) 5 4 3 0 0  Limbajul C++  a) 5 4 3 2 1 0  b) 5 4 3 2 1 0 1  c) 5 4 3  d) 5 4 3 1  e) 4 3 1  f) 5 4 3 0 0  Limbajul Pascal  a) 5 4 3 2 1 false  b) 5 4 3 2 1 0 true  c) 5 4 3  d) 5 4 3 true  e) 4 3 true  f) 5 4 3 0 false    15. Dorim s\u0103 decript\u0103m un cuv\u00e2nt scris cu litere mari astfel: fiecare liter\u0103 este codificat\u0103 prin  codul ei din care se scade un num\u0103r k (k>=0). Num\u0103rul k se nume\u0219te cheie de decriptare.  De exemplu, dac\u0103 avem litera I \u0219i k este 6,  vom ob\u021bine dup\u0103 decriptare litera C. Vom  considera literele a\u0219ezate pe un cerc, dup\u0103 Z vine A. Presupunem c\u0103 \u0219irul ini\u021bial este", "sentences": ["126    Preciza\u021bi care este a zecea func\u021bie generat\u0103.", " a) 5 4 3  b) 4 3 2  c) 2 1 3  d) 1 5 2  e) 1 4 5  f) 1 5 3    13.", "Num\u0103rul ciclurilor hamiltoniene distincte ale unui graf neorientat complet G cu n\u22653  noduri este egal cu  a) n  b)  (\ud835\udc5b\u22121)!", "2   c) n!", " d)  \ud835\udc5b\u2217(\ud835\udc5b\u22121) 2   e) n*(n-1)  f)  \ud835\udc5b 2    14.", "Preciza\u021bi ce se va afi\u0219a pe ecran \u00een urma execu\u021biei urm\u0103torului program?", " Limbajul C++  #include <iostream>  using namespace std;  int v[]={15,12,7,20,-1,-5};  int f(int n)  { cout<<n<<\" \";    if(n==0) return 0;   else    return     v[n-1]<v[n] || f(n-1);  }  int main()  { cout<<f(5); return 0; }    Limbajul Pascal  var v:array[0..5] of  integer=(15,12,7,20,-1,-5);    function  f(n:integer):boolean;  begin    write(n,' ');    if n=0 then f:=false    else f:=(v[n-1]<v[n]) or  f(n-1);  end;  begin     write(f(5));  end.", " Limbajul C  #include <stdio.h>  int v[]={15,12,7,20,-1,-5};  int f(int n)  {    printf(\"%d \",n);    if(n==0)return 0;    else return v[n-1]<v[n] || f(n-1);  }  int main()  {  printf(\"%d\",f(5)); return 0; }  Limbajul C  a) 5 4 3 2 1 0  b) 5 4 3 2 1 0 1  c) 5 4 3  d) 5 4 3 1  e) 4 3 1  f) 5 4 3 0 0  Limbajul C++  a) 5 4 3 2 1 0  b) 5 4 3 2 1 0 1  c) 5 4 3  d) 5 4 3 1  e) 4 3 1  f) 5 4 3 0 0  Limbajul Pascal  a) 5 4 3 2 1 false  b) 5 4 3 2 1 0 true  c) 5 4 3  d) 5 4 3 true  e) 4 3 true  f) 5 4 3 0 false    15.", "Dorim s\u0103 decript\u0103m un cuv\u00e2nt scris cu litere mari astfel: fiecare liter\u0103 este codificat\u0103 prin  codul ei din care se scade un num\u0103r k (k>=0).", "Num\u0103rul k se nume\u0219te cheie de decriptare.", " De exemplu, dac\u0103 avem litera I \u0219i k este 6,  vom ob\u021bine dup\u0103 decriptare litera C. Vom  considera literele a\u0219ezate pe un cerc, dup\u0103 Z vine A. Presupunem c\u0103 \u0219irul ini\u021bial este"], "page_sentence_count_spacy": 11}, {"page_number": 127, "page_char_count": 1613, "page_word_count": 298, "page_sentence_count_raw": 2, "page_token_count": 403.25, "text": "127    re\u021binut \u00een variabila sir iar rezultatul ob\u021binut \u00een urma decript\u0103rii tot \u00een variabila sir.  Consider\u00e2nd prima parte a programului cea de mai jos, care dintre urm\u0103toarele secven\u021be  realizeaz\u0103 decriptarea corect\u0103 a unui \u0219ir de caractere citit de la tastatur\u0103 cu o cheie k citit\u0103  de la tastatur\u0103?  Limbajul C++  char sir[255];  int d;  unsigned int k,i;  cin>>sir;  cin>>k;    Limbajul C     char sir[255];  int d;  unsigned int k,i;  scanf(\"%s\",sir);  scanf(\"%u\",&k);  Limbajul Pascal  var sir:string;      d:integer;      i,k:word;  begin      read(sir);      read(k);  Limbajul C++/C  a) d = 'Z'-'A';    for(i=0;i<strlen(sir);i++)         sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'+1);  b) d = k;    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'+1);  c) d = 'Z'-'A'+1-k;    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'-d)%('Z'-'A'+1);  d) d = 'Z'-'A'+1-k;    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'+1);  e) d = k;    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'+26);  f) d = 'Z'-'A';    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'-25);    Limbajul Pascal  a) d:=ord('Z')-ord('A');    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])- ord('A')+d ) mod      (ord('Z')-ord('A')+1));  b) d:=k;    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')-d) mod   (ord('Z')-ord('A')+1));  c) d:=ord('Z')-ord('A')+1-k;    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')-d) mod  (ord('Z')-ord('A')+1));  d) d:=ord('Z')-ord('A')+1-k;    for i:=1 to length(sir) do", "sentences": ["127    re\u021binut \u00een variabila sir iar rezultatul ob\u021binut \u00een urma decript\u0103rii tot \u00een variabila sir.", " Consider\u00e2nd prima parte a programului cea de mai jos, care dintre urm\u0103toarele secven\u021be  realizeaz\u0103 decriptarea corect\u0103 a unui \u0219ir de caractere citit de la tastatur\u0103 cu o cheie k citit\u0103  de la tastatur\u0103?", " Limbajul C++  char sir[255];  int d;  unsigned int k,i;  cin>>sir;  cin>>k;    Limbajul C     char sir[255];  int d;  unsigned int k,i;  scanf(\"%s\",sir);  scanf(\"%u\",&k);  Limbajul Pascal  var sir:string;      d:integer;      i,k:word;  begin      read(sir);      read(k);  Limbajul C++/C  a) d = 'Z'-'A';    for(i=0;i<strlen(sir);i++)         sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'+1);  b) d = k;    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'+1);  c) d = 'Z'-'A'+1-k;    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'-d)%('Z'-'A'+1);  d) d = 'Z'-'A'+1-k;    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'+1);  e) d = k;    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'+26);  f) d = 'Z'-'A';    for(i=0;i<strlen(sir);i++)      sir[i]='A'+(sir[i]-'A'+d)%('Z'-'A'-25);    Limbajul Pascal  a) d:=ord('Z')-ord('A');    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])- ord('A')+d ) mod      (ord('Z')-ord('A')+1));  b) d:=k;    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')-d) mod   (ord('Z')-ord('A')+1));  c) d:=ord('Z')-ord('A')+1-k;    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')-d) mod  (ord('Z')-ord('A')+1));  d) d:=ord('Z')-ord('A')+1-k;    for i:=1 to length(sir) do"], "page_sentence_count_spacy": 3}, {"page_number": 128, "page_char_count": 336, "page_word_count": 45, "page_sentence_count_raw": 1, "page_token_count": 84.0, "text": "128      sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')+d) mod  (ord('Z')-ord('A')+1));  e) d:=k;    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')-d) mod  (ord('Z')-ord('A')+26));  f) d:=ord('Z')-ord('A');    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')+d)mod  (ord('Z')-ord('A')-25));", "sentences": ["128      sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')+d) mod  (ord('Z')-ord('A')+1));  e) d:=k;    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')-d) mod  (ord('Z')-ord('A')+26));  f) d:=ord('Z')-ord('A');    for i:=1 to length(sir) do    sir[i]:=chr(ord('A')+(ord(sir[i])-ord('A')+d)mod  (ord('Z')-ord('A')-25));"], "page_sentence_count_spacy": 1}, {"page_number": 129, "page_char_count": 1682, "page_word_count": 429, "page_sentence_count_raw": 9, "page_token_count": 420.5, "text": "129    Varianta 23  1. Trei variabile de tip \u00eentreg au valorile a=13, b=5, c=3. Dintre expresiile urm\u0103toare,  cea care are valoarea 1 (C++/C) respectiv true (Pascal) este:  Limbajul C++/C  a) a/c*2<5+c*4%5  b) c%b==a%c  c) b+a/10!=b%c*a/c  d) (b>c) && !(b*c%7==2*a-b*b)  e) c%b*10<a*2  f) c/b*b/c==1  Limbajul Pascal  a) a div c *2 < (5+c*4 mod 5)  b) c mod b =a mod c  c) b+a div 10 <>b mod c *a div c  d) (b>c) and not((b*c mod 7)=(2*a-b*b))  e) c mod b*10 < a*2  f) c div b * b div c = 1    2. \u00centr-un graf neorientat cu 13 noduri, fiecare nod are gradul d. Valoarea lui d nu poate  fi:  a) 2  b) 4  c) 6  d) 8  e) 10  f) 11    3. Variabila i este de tip \u00eentreg. Num\u0103rul total al atribuirilor care se execut\u0103 \u00een urma rul\u0103rii  secven\u021bei urm\u0103toare este:  Limbajul C++/C  i=1;  while(i*i<2020)       i=i*2;                                                                    Limbajul Pascal  i:=1;  while i*i<2020 do     i:=i*2;  a) 5  b) 6  c) 7  d) 9  e) 11  f) 12    4. Consider\u00e2nd c\u0103 variabila s poate re\u021bine un \u0219ir cu cel mult 100 de caractere \u0219i variabila  i este de tip \u00eentreg, \u00een urma execut\u0103rii urm\u0103toarei secven\u021be de instruc\u021biuni, lungimea  efectiv\u0103 a \u0219irului  s este:  Limbajul C++/C  strcpy(s,\"2020+2020=4040\");  for(i=0;i<strlen(s);i++)  if(strchr(\"0123456789\",s[i]))    strcpy(s+i,s+i+1);  Limbajul Pascal  s:=\u20192020+2020=4040\u2019;  for i:=1 to length(s) do   if pos(s[i],\u20190123456789\u2019)<>0  then delete(s,i,1);  a) 0  b)  2  c)  5  d)  6  e)  8  f)  11    5. Pentru a verifica dac\u0103 elementele unui tablou unidimensional cu n elemente numere  \u00eentregi sunt distincte dou\u0103 c\u00e2te dou\u0103, num\u0103rul de compara\u021bii executate este:  a) 2n  b) n(n-1)/2  c) n(n-1)  d) (n-1)2  e) n2  f) n!", "sentences": ["129    Varianta 23  1.", "Trei variabile de tip \u00eentreg au valorile a=13, b=5, c=3.", "Dintre expresiile urm\u0103toare,  cea care are valoarea 1 (C++/C) respectiv true (Pascal) este:  Limbajul C++/C  a) a/c*2<5+c*4%5  b) c%b==a%c  c) b+a/10!=b%c*a/c  d) (b>c) && !(", "b*c%7==2*a-b*b)  e) c%b*10<a*2  f) c/b*b/c==1  Limbajul Pascal  a) a div c *2 < (5+c*4 mod 5)  b) c mod b =a mod c  c) b+a div 10 <>b mod c *a div c  d) (b>c) and not((b*c mod 7)=(2*a-b*b))  e) c mod b*10 < a*2  f) c div b * b div c = 1    2.", "\u00centr-un graf neorientat cu 13 noduri, fiecare nod are gradul d. Valoarea lui d nu poate  fi:  a) 2  b) 4  c) 6  d) 8  e) 10  f) 11    3.", "Variabila i este de tip \u00eentreg.", "Num\u0103rul total al atribuirilor care se execut\u0103 \u00een urma rul\u0103rii  secven\u021bei urm\u0103toare este:  Limbajul C++/C  i=1;  while(i*i<2020)       i=i*2;                                                                    Limbajul Pascal  i:=1;  while i*i<2020 do     i:=i*2;  a) 5  b) 6  c) 7  d) 9  e) 11  f) 12    4.", "Consider\u00e2nd c\u0103 variabila s poate re\u021bine un \u0219ir cu cel mult 100 de caractere \u0219i variabila  i este de tip \u00eentreg, \u00een urma execut\u0103rii urm\u0103toarei secven\u021be de instruc\u021biuni, lungimea  efectiv\u0103 a \u0219irului  s este:  Limbajul C++/C  strcpy(s,\"2020+2020=4040\");  for(i=0;i<strlen(s);i++)  if(strchr(\"0123456789\",s[i]))    strcpy(s+i,s+i+1);  Limbajul Pascal  s:=\u20192020+2020=4040\u2019;  for i:=1 to length(s) do   if pos(s[i],\u20190123456789\u2019)<>0  then delete(s,i,1);  a) 0  b)  2  c)  5  d)  6  e)  8  f)  11    5.", "Pentru a verifica dac\u0103 elementele unui tablou unidimensional cu n elemente numere  \u00eentregi sunt distincte dou\u0103 c\u00e2te dou\u0103, num\u0103rul de compara\u021bii executate este:  a) 2n  b) n(n-1)/2  c) n(n-1)  d) (n-1)2  e) n2  f) n!"], "page_sentence_count_spacy": 9}, {"page_number": 130, "page_char_count": 1788, "page_word_count": 405, "page_sentence_count_raw": 7, "page_token_count": 447.0, "text": "130      6. \u00cen urma execut\u0103rii urm\u0103toarei secven\u021be de program, variabila x, de tip \u00eentreg, va avea  valoarea:  Limbajul C++/C  x=15;  x=x*3/4*4/3;  do {if(x%2==0) x=x/2;      else x=x-5;     }while(x>0);  Limbajul Pascal  x:=15;  x:=x*3 div 4*4 div 3;  repeat   if x mod 2=0 then x:=x div 2  else x:=x-5;  until x<=0;  a) -6  b) -5  c) -4  d) 0  e) 2  f) 5    7. Utiliz\u00e2nd un algoritm backtracking se genereaz\u0103 \u00een ordine cresc\u0103toare toate numerele  naturale cu patru cifre care au suma cifrelor egal\u0103 cu 4. Primele  trei solu\u021bii sunt: 1003,  1012, 1021.  \u00cen \u0219irul generat, num\u0103rul 2020 ocup\u0103 pozi\u021bia:  a) 10  b) 11  c) 12  d) 13  e) 14  f) 15    8. Dac\u0103 s, i, j, n sunt variabile de tip \u00eentreg \u0219i a este un tablou bidimensional cu n linii  \u0219i n coloane numerotate de la 1 la n, urm\u0103torul algoritm calculeaz\u0103:  Limbajul C++/C  s=0;  for(i=1;i<=n;i++)    for(j=1;j<i;j++)      s=s+a[i][j];  Limbajul Pascal  s:=0;  for i:=1 to n do    for j:=1 to i-1 do      s:=s+a[i,j];  a) suma elementelor de sub diagonala principal\u0103 exclusiv elementele diagonalei  principale  b) suma elementelor de sub diagonala secundar\u0103 exclusiv elementele diagonalei  secundare  c) num\u0103rul elementelor de deasupra diagonalei principale inclusiv elementele  diagonalei principale  d) suma elementelor de pe diagonala principal\u0103  e) suma elementelor de sub diagonala principal\u0103 inclusiv elementele diagonalei  principale  f) suma elementelor de deasupra diagonalei secundare inclusiv elementele diagonalei  secundare    9. Se consider\u0103 urm\u0103toarele declara\u021bii de tipuri \u0219i variabile:  Limbajul C++  struct a    { int b;      char c[10];   };  struct d   { char e[10];      float f;      a g;  Limbajul Pascal  type a=record      b:integer;     c:string[10]   end;   d=record      e: string[10];      f: real;      g:a", "sentences": ["130      6.", "\u00cen urma execut\u0103rii urm\u0103toarei secven\u021be de program, variabila x, de tip \u00eentreg, va avea  valoarea:  Limbajul C++/C  x=15;  x=x*3/4*4/3;  do {if(x%2==0) x=x/2;      else x=x-5;     }while(x>0);  Limbajul Pascal  x:=15;  x:=x*3 div 4*4 div 3;  repeat   if x mod 2=0 then x:=x div 2  else x:=x-5;  until x<=0;  a) -6  b) -5  c) -4  d) 0  e) 2  f) 5    7.", "Utiliz\u00e2nd un algoritm backtracking se genereaz\u0103 \u00een ordine cresc\u0103toare toate numerele  naturale cu patru cifre care au suma cifrelor egal\u0103 cu 4.", "Primele  trei solu\u021bii sunt: 1003,  1012, 1021.", " \u00cen \u0219irul generat, num\u0103rul 2020 ocup\u0103 pozi\u021bia:  a) 10  b) 11  c) 12  d) 13  e) 14  f) 15    8.", "Dac\u0103 s, i, j, n sunt variabile de tip \u00eentreg \u0219i a este un tablou bidimensional cu n linii  \u0219i n coloane numerotate de la 1 la n, urm\u0103torul algoritm calculeaz\u0103:  Limbajul C++/C  s=0;  for(i=1;i<=n;i++)    for(j=1;j<i;j++)      s=s+a[i][j];  Limbajul Pascal  s:=0;  for i:=1 to n do    for j:=1 to i-1 do      s:=s+a[i,j];  a) suma elementelor de sub diagonala principal\u0103 exclusiv elementele diagonalei  principale  b) suma elementelor de sub diagonala secundar\u0103 exclusiv elementele diagonalei  secundare  c) num\u0103rul elementelor de deasupra diagonalei principale inclusiv elementele  diagonalei principale  d) suma elementelor de pe diagonala principal\u0103  e) suma elementelor de sub diagonala principal\u0103 inclusiv elementele diagonalei  principale  f) suma elementelor de deasupra diagonalei secundare inclusiv elementele diagonalei  secundare    9.", "Se consider\u0103 urm\u0103toarele declara\u021bii de tipuri \u0219i variabile:  Limbajul C++  struct a    { int b;      char c[10];   };  struct d   { char e[10];      float f;      a g;  Limbajul Pascal  type a=record      b:integer;     c:string[10]   end;   d=record      e: string[10];      f: real;      g:a"], "page_sentence_count_spacy": 7}, {"page_number": 131, "page_char_count": 1592, "page_word_count": 432, "page_sentence_count_raw": 5, "page_token_count": 398.0, "text": "131     } h;    end;  var h:d;  Limbajul C  typedef struct     { int b;      char c[10];   }a;  typedef struct    { char e[10];      float f;      a g;   }d;  d h;      Dintre urm\u0103toarele expresii, de tip caracter este:  a) g.e[2]  b) h.a.c  c) h.a.c[0]  d) h.c[2]  e) h.g.c[2]  f) d.e[2]    10. Se consider\u0103 un arbore cu 8 noduri \u0219i muchiile [1,2], [2,3], [3,6], [4,3],  [5,7], [7,2], [8,2]. Pentru ca arborele s\u0103 con\u021bin\u0103 un num\u0103r maxim de lan\u021buri  elementare de lungime 3 care nu con\u021bin r\u0103d\u0103cina, se poate alege ca r\u0103d\u0103cin\u0103 oricare  dintre nodurile:  a) 1, 2, 4, 5  b) 1, 2, 5, 6  c) 1, 3, 6, 7  d) 2, 3, 4, 5, 6  e) 1, 4, 5, 6, 8  f) 2, 3, 4, 7, 8    11. \u00cen urma execut\u0103rii urm\u0103toarei secven\u021be de program tabloul unidimensional a, cu 6  elemente numerotate de la 1 la 6, va con\u021bine valorile:  Limbajul C++/C  for (i=1;i<=6;i++)   if (i%2!=0) a[i]=i/2;   else a[i]=7-i;  for(i=6;i>=3;i--)    a[a[i]]=2*i%7;  Limbajul Pascal  for i:=1 to 6 do  if i mod 2<>0 then a[i]:=i div 2  else a[i]:=7-i;  for i:=6 downto 3 do   a[a[i]]:=2*i mod 7;  a) 0 5 6 1 3 5  b) 5 3 1 3 2 1  c) 6 3 6 2 2 3  d) 6 1 5 2 6 3  e) 6 3 1 2 2 1  f) 6 3 1 3 2 1    12. Pentru apelul s(2020,2) al subprogramului de mai jos, enun\u021bul adev\u0103rat este:  Limbajul C++/C  int s(int n, int d)  {      if(n==1) return 0;      if (n%d==0)         return 1+s(n/d,d);      else          return s(n,d+1);  }  Limbajul Pascal  function s(n,d:integer): integer;  begin  if n=1 then     s:=0  else if n mod d=0 then      s:=1+s(n div d,d)   else s:=s(n,d+1)  end;  a) s(2020,2)=3 \u0219i reprezint\u0103 num\u0103rul divizorilor primi ai num\u0103rului 2020", "sentences": ["131     } h;    end;  var h:d;  Limbajul C  typedef struct     { int b;      char c[10];   }a;  typedef struct    { char e[10];      float f;      a g;   }d;  d h;      Dintre urm\u0103toarele expresii, de tip caracter este:  a) g.e[2]  b) h.a.c  c) h.a.c[0]  d) h.c[2]  e) h.g.c[2]  f) d.e[2]    10.", "Se consider\u0103 un arbore cu 8 noduri \u0219i muchiile [1,2], [2,3], [3,6], [4,3],  [5,7], [7,2], [8,2].", "Pentru ca arborele s\u0103 con\u021bin\u0103 un num\u0103r maxim de lan\u021buri  elementare de lungime 3 care nu con\u021bin r\u0103d\u0103cina, se poate alege ca r\u0103d\u0103cin\u0103 oricare  dintre nodurile:  a) 1, 2, 4, 5  b) 1, 2, 5, 6  c) 1, 3, 6, 7  d) 2, 3, 4, 5, 6  e) 1, 4, 5, 6, 8  f) 2, 3, 4, 7, 8    11.", "\u00cen urma execut\u0103rii urm\u0103toarei secven\u021be de program tabloul unidimensional a, cu 6  elemente numerotate de la 1 la 6, va con\u021bine valorile:  Limbajul C++/C  for (i=1;i<=6;i++)   if (i%2!=0) a[i]=i/2;   else a[i]=7-i;  for(i=6;i>=3;i--)    a[a[i]]=2*i%7;  Limbajul Pascal  for i:=1 to 6 do  if i mod 2<>0 then a[i]:=i div 2  else a[i]:=7-i;  for i:=6 downto 3 do   a[a[i]]:=2*i mod 7;  a) 0 5 6 1 3 5  b) 5 3 1 3 2 1  c) 6 3 6 2 2 3  d) 6 1 5 2 6 3  e) 6 3 1 2 2 1  f) 6 3 1 3 2 1    12.", "Pentru apelul s(2020,2) al subprogramului de mai jos, enun\u021bul adev\u0103rat este:  Limbajul C++/C  int s(int n, int d)  {      if(n==1) return 0;      if (n%d==0)         return 1+s(n/d,d);      else          return s(n,d+1);  }  Limbajul Pascal  function s(n,d:integer): integer;  begin  if n=1 then     s:=0  else if n mod d=0 then      s:=1+s(n div d,d)   else s:=s(n,d+1)  end;  a) s(2020,2)=3 \u0219i reprezint\u0103 num\u0103rul divizorilor primi ai num\u0103rului 2020"], "page_sentence_count_spacy": 5}, {"page_number": 132, "page_char_count": 1530, "page_word_count": 375, "page_sentence_count_raw": 4, "page_token_count": 382.5, "text": "132    b) s(2020,2)=4 \u0219i reprezint\u0103 num\u0103rul divizorilor primi ai num\u0103rului 2020  c) s(2020,2)=4 \u0219i reprezint\u0103 suma exponen\u021bilor divizorilor primi din  descompunerea \u00een factori primi a num\u0103rului 2020  d) s(2020,2)=6 \u0219i reprezint\u0103 suma exponen\u021bilor divizorilor primi din  descompunerea \u00een factori primi a num\u0103rului 2020  e) s(2020,2)=10 \u0219i reprezint\u0103 num\u0103rul divizorilor proprii ai num\u0103rului 2020  f) s(2020,2)=12 \u0219i reprezint\u0103 num\u0103rul divizorilor num\u0103rului 2020    13. Num\u0103rul de grafuri neorientate cu \u0219ase noduri, \u00een care nodul 1 are gradul 1 \u0219i nodul 2  are gradul 2 este:  a) 92  b) 1280  c) 1536  d) 1792  e) 1920  f) 2560    14. \u00cen urma rul\u0103rii programului urm\u0103tor vor fi afi\u0219ate valorile:  Limbajul C++  #include <iostream>  using namespace std;  void f (int &a, int b)  { int x=3;    a--;     b++;    x--;   cout<<a<<' '<<b<<' '<<x<<' ';  }  int main()  { int i, x=4, y=6;    for(i=1;i<=3;i++)       f(x,x+y);    cout<<x<<' '<<y;     return 0;  }  Limbajul C  #include <stdio.h>  #include <stdlib.h>  void f (int *a, int b)  { int x=3;    (*a)--;      b++;     x--;     printf(\"%d %d %d \",*a,b,x);  }  int main()  { int i, x=4, y=6;    for(i=1; i<=3; i++)        f(&x,x+y);    printf(\"%d %d\",x,y);    return 0;  }    Limbajul Pascal  program main;  var x, y, i: integer;  procedure f (var a: integer; b:integer);  var x:integer;  begin    x:=3;    dec(a); inc(b); dec(x);    write(a,\u2019 \u2019,b,\u2019 \u2019,x,\u2019 \u2019);  end;  begin    x:=4;    y:=6;    for i:=1 to 3 do         f(x,x+y);    write(x,\u2019 \u2019,y)  end.  a) 3 11 2 3 6  b) 3 11 2 4 6", "sentences": ["132    b) s(2020,2)=4 \u0219i reprezint\u0103 num\u0103rul divizorilor primi ai num\u0103rului 2020  c) s(2020,2)=4 \u0219i reprezint\u0103 suma exponen\u021bilor divizorilor primi din  descompunerea \u00een factori primi a num\u0103rului 2020  d) s(2020,2)=6 \u0219i reprezint\u0103 suma exponen\u021bilor divizorilor primi din  descompunerea \u00een factori primi a num\u0103rului 2020  e) s(2020,2)=10 \u0219i reprezint\u0103 num\u0103rul divizorilor proprii ai num\u0103rului 2020  f) s(2020,2)=12 \u0219i reprezint\u0103 num\u0103rul divizorilor num\u0103rului 2020    13.", "Num\u0103rul de grafuri neorientate cu \u0219ase noduri, \u00een care nodul 1 are gradul 1 \u0219i nodul 2  are gradul 2 este:  a) 92  b) 1280  c) 1536  d) 1792  e) 1920  f) 2560    14.", "\u00cen urma rul\u0103rii programului urm\u0103tor vor fi afi\u0219ate valorile:  Limbajul C++  #include <iostream>  using namespace std;  void f (int &a, int b)  { int x=3;    a--;     b++;    x--;   cout<<a<<' '<<b<<' '<<x<<' ';  }  int main()  { int i, x=4, y=6;    for(i=1;i<=3;i++)       f(x,x+y);    cout<<x<<' '<<y;     return 0;  }  Limbajul C  #include <stdio.h>  #include <stdlib.h>  void f (int *a, int b)  { int x=3;    (*a)--;      b++;     x--;     printf(\"%d %d %d \",*a,b,x);  }  int main()  { int i, x=4, y=6;    for(i=1; i<=3; i++)        f(&x,x+y);    printf(\"%d %d\",x,y);    return 0;  }    Limbajul Pascal  program main;  var x, y, i: integer;  procedure f (var a: integer; b:integer);  var x:integer;  begin    x:=3;    dec(a); inc(b); dec(x);    write(a,\u2019 \u2019,b,\u2019 \u2019,x,\u2019 \u2019);  end;  begin    x:=4;    y:=6;    for i:=1 to 3 do         f(x,x+y);    write(x,\u2019 \u2019,y)  end.", " a) 3 11 2 3 6  b) 3 11 2 4 6"], "page_sentence_count_spacy": 4}, {"page_number": 133, "page_char_count": 740, "page_word_count": 175, "page_sentence_count_raw": 8, "page_token_count": 185.0, "text": "133    c) 3 11 3 2 10 2 1 9 1 1 6  d) 2 11 2 0 9 0 -2 7 -2 -2 6  e) 3 11 2 3 11 2 3 11 2 4 6  f) 3 11 2 2 10 2 1 9 2 1 6    15. Se sorteaz\u0103 cresc\u0103tor tabloul v=(3, 4, 2, 5, 1, 7, 6). O propozi\u021bie fals\u0103 este:  a) Sort\u00e2nd prin metoda Bubble Sort se fac 7 interschimb\u0103ri.  b) Aplic\u00e2nd metoda de sortare prin interclasare numerele 1 \u0219i 4 nu se compar\u0103.  c) Aplic\u00e2nd metoda de sortare prin selec\u021bie se execut\u0103 cel mult 6 interschimb\u0103ri.  d) Sort\u00e2nd prin selec\u021bia minimului, numerele 2 \u0219i 3 se compar\u0103 de dou\u0103 ori.  e) Aplic\u00e2nd metoda de sortare Bubble Sort se poate ob\u021bine ca etap\u0103 intermediar\u0103 tabloul  v=(3, 2, 4, 1, 5, 6, 7).  f) Aplic\u00e2nd metoda de sortare prin inser\u021bie se poate ob\u021bine ca etap\u0103 intermediar\u0103 tabloul  v=(1, 3, 4, 2, 5, 7, 6).", "sentences": ["133    c) 3 11 3 2 10 2 1 9 1 1 6  d) 2 11 2 0 9 0 -2 7 -2 -2 6  e) 3 11 2 3 11 2 3 11 2 4 6  f) 3 11 2 2 10 2 1 9 2 1 6    15.", "Se sorteaz\u0103 cresc\u0103tor tabloul v=(3, 4, 2, 5, 1, 7, 6).", "O propozi\u021bie fals\u0103 este:  a) Sort\u00e2nd prin metoda Bubble Sort se fac 7 interschimb\u0103ri.", " b) Aplic\u00e2nd metoda de sortare prin interclasare numerele 1 \u0219i 4 nu se compar\u0103.", " c) Aplic\u00e2nd metoda de sortare prin selec\u021bie se execut\u0103 cel mult 6 interschimb\u0103ri.", " d) Sort\u00e2nd prin selec\u021bia minimului, numerele 2 \u0219i 3 se compar\u0103 de dou\u0103 ori.", " e) Aplic\u00e2nd metoda de sortare Bubble Sort se poate ob\u021bine ca etap\u0103 intermediar\u0103 tabloul  v=(3, 2, 4, 1, 5, 6, 7).", " f) Aplic\u00e2nd metoda de sortare prin inser\u021bie se poate ob\u021bine ca etap\u0103 intermediar\u0103 tabloul  v=(1, 3, 4, 2, 5, 7, 6)."], "page_sentence_count_spacy": 8}, {"page_number": 134, "page_char_count": 1810, "page_word_count": 407, "page_sentence_count_raw": 16, "page_token_count": 452.5, "text": "134    Varianta 24     1. Expresia de mai jos are valoarea 1 (C++/C) respectiv true (Pascal) dac\u0103 \u0219i numai  dac\u0103 n este:  Limbajul C++/C  n%2==1 && n*n<100  Limbajul Pascal   (n mod 2=1) and (n*n<100)  a) num\u0103r \u00eentreg impar mai mic dec\u00e2t 10  b) num\u0103r \u00eentreg impar, din intervalul (-10,10)  c) num\u0103r natural mai mic dec\u00e2t 100  d) num\u0103r natural impar de o singur\u0103 cifr\u0103  e) num\u0103r \u00eentreg par mai mic dec\u00e2t 10  f) num\u0103r natural impar cu cel mult dou\u0103 cifre    2. Dac\u0103 a este un tablou bidimensional cu n linii \u0219i n coloane, numerotate de la 1 la n,  elementul de pe linia i \u0219i coloana j se afl\u0103 pe diagonala secundar\u0103 dac\u0103 \u00eentre indici  exist\u0103 rela\u021bia:  a) i<j  b) i>j  c) i=j  d) i+j=n-1  e) i+j=n  f) i+j=n+1    3. Graful neorientat complet G are 10 noduri. Un enun\u021b adev\u0103rat este:  a) G este arbore  b) G are 50 de muchii  c) G nu este graf hamiltonian \u0219i nici eulerian  d) G este graf hamiltonian dar nu eulerian  e) G nu este graf hamiltonian dar este graf eulerian  f) G este graf hamiltonian \u0219i eulerian    4. Se consider\u0103 c\u0103 d, i, k, n sunt variabile de tip \u00eentreg \u0219i a este un tablou unidimensional  cu n numere \u00eentregi numerotate de la 1 la n. La finalul execu\u021biei secven\u021bei urm\u0103toare,  variabila k are valoarea 1 dac\u0103 \u0219i numai dac\u0103 elementele tabloului a formeaz\u0103 o  progresie aritmetic\u0103. Expresia corect\u0103 care completeaz\u0103 punctele de suspensie este:  Limbajul C++/C  k=1;   d=a[2]-a[1];  for(i=3;i<=n;i++)    if ( . . . . )        k=0;  Limbajul Pascal  k:=1;   d:=a[2]-a[1];  for i:=3 to n do    if  . . . .  then       k:=0;  Limbajul C++/C  a)  a[i+1]-a[i]!=d  b)  a[i]-a[i+1]!=d  c)  a[i]-a[i-1]!=d    d)  a[i+1]-a[i]==d    e)  a[i]+a[i+1]!=d  f)  a[i]-a[i-1]==d  Limbajul Pascal  a) a[i+1]-a[i]<>d  b)  a[i]-a[i+1] <>d  c) a[i]-a[i-1]<>d    d)  a[i+1]-a[i]=d    e) a[i]+a[i+1]<>d  f) a[i]-a[i-1]=d", "sentences": ["134    Varianta 24     1.", "Expresia de mai jos are valoarea 1 (C++/C) respectiv true (Pascal) dac\u0103 \u0219i numai  dac\u0103 n este:  Limbajul C++/C  n%2==1 && n*n<100  Limbajul Pascal   (n mod 2=1) and (n*n<100)  a) num\u0103r \u00eentreg impar mai mic dec\u00e2t 10  b) num\u0103r \u00eentreg impar, din intervalul (-10,10)  c) num\u0103r natural mai mic dec\u00e2t 100  d) num\u0103r natural impar de o singur\u0103 cifr\u0103  e) num\u0103r \u00eentreg par mai mic dec\u00e2t 10  f) num\u0103r natural impar cu cel mult dou\u0103 cifre    2.", "Dac\u0103 a este un tablou bidimensional cu n linii \u0219i n coloane, numerotate de la 1 la n,  elementul de pe linia i \u0219i coloana j se afl\u0103 pe diagonala secundar\u0103 dac\u0103 \u00eentre indici  exist\u0103 rela\u021bia:  a) i<j  b) i>j  c) i=j  d) i+j=n-1  e) i+j=n  f) i+j=n+1    3.", "Graful neorientat complet G are 10 noduri.", "Un enun\u021b adev\u0103rat este:  a) G este arbore  b) G are 50 de muchii  c) G nu este graf hamiltonian \u0219i nici eulerian  d) G este graf hamiltonian dar nu eulerian  e) G nu este graf hamiltonian dar este graf eulerian  f) G este graf hamiltonian \u0219i eulerian    4.", "Se consider\u0103 c\u0103 d, i, k, n sunt variabile de tip \u00eentreg \u0219i a este un tablou unidimensional  cu n numere \u00eentregi numerotate de la 1 la n. La finalul execu\u021biei secven\u021bei urm\u0103toare,  variabila k are valoarea 1 dac\u0103 \u0219i numai dac\u0103 elementele tabloului a formeaz\u0103 o  progresie aritmetic\u0103.", "Expresia corect\u0103 care completeaz\u0103 punctele de suspensie este:  Limbajul C++/C  k=1;   d=a[2]-a[1];  for(i=3;i<=n;i++)    if ( . . . . )", "       k=0;  Limbajul Pascal  k:=1;   d:=a[2]-a[1];  for i:=3 to n do    if  . . . .", " then       k:=0;  Limbajul C++/C  a)  a[i+1]-a[i]!=d  b)  a[i]-a[i+1]!=d  c)  a[i]-a[i-1]!=d    d)  a[i+1]-a[i]==d    e)  a[i]+a[i+1]!=d  f)  a[i]-a[i-1]==d  Limbajul Pascal  a) a[i+1]-a[i]<>d  b)  a[i]-a[i+1] <>d  c) a[i]-a[i-1]<>d    d)  a[i+1]-a[i]=d    e) a[i]+a[i+1]<>d  f) a[i]-a[i-1]=d"], "page_sentence_count_spacy": 9}, {"page_number": 135, "page_char_count": 2235, "page_word_count": 520, "page_sentence_count_raw": 12, "page_token_count": 558.75, "text": "135    5. Se consider\u0103 un arbore cu 8 noduri \u0219i muchiile [1,2], [2,3], [3,6], [4,3], [5,7], [7,2],  [8,2]. \u00cen\u0103l\u021bimea arborelui este egal\u0103 cu lungimea celui mai lung lan\u021b elementar care  une\u0219te r\u0103d\u0103cina de o frunz\u0103. Arborele dat are \u00een\u0103l\u021bime minim\u0103 dac\u0103 se va alege ca  r\u0103d\u0103cin\u0103 nodul:  a) 1  b)  2  c)  3  d) 5  e) 7  f) 8    6. \u00cen urma execu\u021biei secven\u021bei urm\u0103toare, \u00een care toate variabilele sunt de tip \u00eentreg,  valoarea variabilei n este:  Limbajul C++/C  n=0;  a=11357; b=1426; p=1;      while(a!=b)      {  x=a%10;y=b%10;          if(x<y) n=n+p*x;          else n=n+p*y;          p=p*10;a=a/10;b=b/10;      }  Limbajul Pascal  n:=0; a:=11357; b:=1426; p:=1;  while a<>b do begin  x:=a mod 10; y:=b mod 10;  if x<y then n:=n+p*x  else n:=n+p*y;  p:=p*10;  a:=a div 10; b:=b  div 10  end;  a) 1326  b) 1356  c) 6241  d) 11326   e) 11457  f) 62411    7. Fie enun\u021bul: \u201epentru a sorta descresc\u0103tor un tablou unidimensional cu 20 de elemente  numere reale, utiliz\u00e2nd metoda selec\u021biei, nu sunt necesare mai mult de x determin\u0103ri  ale valorii maxime\u201d. Enun\u021bul este adev\u0103rat dac\u0103 x este egal cu:  a) 0  b) 10  c) 19  d) 20  e) 190  f) 400    8. Matricea al\u0103turat\u0103 este matricea de adiacen\u021b\u0103 a unui graf:   0 1 1 0  1 0 1 0  1 0 0 0  0 1 0 0  a) orientat cu 6 noduri \u0219i 3 arce  b) neorientat cu 4 noduri \u0219i 3 muchii  c) orientat cu 4 noduri \u0219i 6 arce  d) neorientat cu 6 noduri \u0219i 6 muchii  e) orientat cu 4 noduri \u0219i 3 arce  f) neorientat cu 4 noduri \u0219i 6 muchii    9. Utiliz\u00e2nd un algoritm backtracking se genereaz\u0103 \u00een ordine lexicografic\u0103 toate  anagramele cuv\u00e2ntului roman. Solu\u021bia generat\u0103 imediat \u00eenainte de cuv\u00e2ntul norma \u0219i  solu\u021bia generat\u0103 imediat dup\u0103 cuv\u00e2ntul norma sunt:  a) nramo \u0219i noram  b) nramo \u0219i nrmao  c) nomra \u0219i noram  d) nomra \u0219i nramo  e) noram \u0219i nramo  f) nomar \u0219i nramo    10. Variabilele i, j, k sunt de tip \u00eentreg iar s re\u021bine un \u0219ir de caractere format din litere  mici \u0219i spa\u021bii (cuvintele sunt desp\u0103r\u021bite printr-un singur spa\u021biu). \u00cen urma execut\u0103rii  urm\u0103toarei secven\u021be de program, variabila k are valoarea 0 dac\u0103 \u0219irul s este ini\u021bial:  Limbajul C++/C  for(i=0;i<strlen(s);i++)     if(s[i]==' ')        strcpy(s+i,s+i+1);  Limbajul Pascal  for i:=1 to length(s) do    if s[i]=\u2019 \u2019  then      delete(s,i,1);", "sentences": ["135    5.", "Se consider\u0103 un arbore cu 8 noduri \u0219i muchiile [1,2], [2,3], [3,6], [4,3], [5,7], [7,2],  [8,2].", "\u00cen\u0103l\u021bimea arborelui este egal\u0103 cu lungimea celui mai lung lan\u021b elementar care  une\u0219te r\u0103d\u0103cina de o frunz\u0103.", "Arborele dat are \u00een\u0103l\u021bime minim\u0103 dac\u0103 se va alege ca  r\u0103d\u0103cin\u0103 nodul:  a) 1  b)  2  c)  3  d) 5  e) 7  f) 8    6.", "\u00cen urma execu\u021biei secven\u021bei urm\u0103toare, \u00een care toate variabilele sunt de tip \u00eentreg,  valoarea variabilei n este:  Limbajul C++/C  n=0;  a=11357; b=1426; p=1;      while(a!=b)      {  x=a%10;y=b%10;          if(x<y) n=n+p*x;          else n=n+p*y;          p=p*10;a=a/10;b=b/10;      }  Limbajul Pascal  n:=0; a:=11357; b:=1426; p:=1;  while a<>b do begin  x:=a mod 10; y:=b mod 10;  if x<y then n:=n+p*x  else n:=n+p*y;  p:=p*10;  a:=a div 10; b:=b  div 10  end;  a) 1326  b) 1356  c) 6241  d) 11326   e) 11457  f) 62411    7.", "Fie enun\u021bul: \u201epentru a sorta descresc\u0103tor un tablou unidimensional cu 20 de elemente  numere reale, utiliz\u00e2nd metoda selec\u021biei, nu sunt necesare mai mult de x determin\u0103ri  ale valorii maxime\u201d.", "Enun\u021bul este adev\u0103rat dac\u0103 x este egal cu:  a) 0  b) 10  c) 19  d) 20  e) 190  f) 400    8.", "Matricea al\u0103turat\u0103 este matricea de adiacen\u021b\u0103 a unui graf:   0 1 1 0  1 0 1 0  1 0 0 0  0 1 0 0  a) orientat cu 6 noduri \u0219i 3 arce  b) neorientat cu 4 noduri \u0219i 3 muchii  c) orientat cu 4 noduri \u0219i 6 arce  d) neorientat cu 6 noduri \u0219i 6 muchii  e) orientat cu 4 noduri \u0219i 3 arce  f) neorientat cu 4 noduri \u0219i 6 muchii    9.", "Utiliz\u00e2nd un algoritm backtracking se genereaz\u0103 \u00een ordine lexicografic\u0103 toate  anagramele cuv\u00e2ntului roman.", "Solu\u021bia generat\u0103 imediat \u00eenainte de cuv\u00e2ntul norma \u0219i  solu\u021bia generat\u0103 imediat dup\u0103 cuv\u00e2ntul norma sunt:  a) nramo \u0219i noram  b) nramo \u0219i nrmao  c) nomra \u0219i noram  d) nomra \u0219i nramo  e) noram \u0219i nramo  f) nomar \u0219i nramo    10.", "Variabilele i, j, k sunt de tip \u00eentreg iar s re\u021bine un \u0219ir de caractere format din litere  mici \u0219i spa\u021bii (cuvintele sunt desp\u0103r\u021bite printr-un singur spa\u021biu).", "\u00cen urma execut\u0103rii  urm\u0103toarei secven\u021be de program, variabila k are valoarea 0 dac\u0103 \u0219irul s este ini\u021bial:  Limbajul C++/C  for(i=0;i<strlen(s);i++)     if(s[i]==' ')        strcpy(s+i,s+i+1);  Limbajul Pascal  for i:=1 to length(s) do    if s[i]=\u2019 \u2019  then      delete(s,i,1);"], "page_sentence_count_spacy": 12}, {"page_number": 136, "page_char_count": 1568, "page_word_count": 523, "page_sentence_count_raw": 5, "page_token_count": 392.0, "text": "136    i=0;   j=strlen(s)-1;   k=1;  while(i<j)     {         if (s[i]!=s[j])           k=0;       i++;        j--;        }  i:=1;   j:=length(s);   k:=1;  while i<j do    begin      if s[i]<>s[j] then        k:=0;      inc(i);       dec(j)   end;  a) atasata  b) o rama maro  c) o rama alba  d) elisa vasile  e) nora aron  f) vasile elisav    11. Dac\u0103 din programul principal se apeleaz\u0103 f(f(3)), num\u0103rul de autoapeluri ale  func\u021biei f , definit\u0103 mai jos, este:  Limbajul C++/C  int f (int a)  {     if (a<2)        return 1;    else       return f(a-1)+2*f(a-3);  }  Limbajul Pascal  function f(a:integer):integer;  begin   if a<2 then     f:=1  else     f:=f(a-1)+2*f(a-3)  end;  a) 8  b) 9  c) 10  d) 14  e) 15  f) 16    12. Secven\u021ba de mai jos construie\u0219te tabloul bidimensional a cu n linii \u0219i n coloane,  numerotate de la 1 la n. Pentru n=4, suma elementelor de pe diagonala principal\u0103 este:  Limbajul C++/C  x=1;  y=1;  for(i=1;i<=n;i++)    for(j=1;j<=n+1-i;j++)       {          a[i][j]=x;         x++;       }  for(j=n;j>=1;j--)     for(i=n;i>=n+1-j;i--)       {          a[i][j]=y;         y++;       }  Limbajul Pascal  x:=1;   y:=1;  for i:=1 to n do    for j:=1 to n+1-i do      begin          a[i,j]:=x;        inc(x)       end;  for j:=n downto 1 do     for i:=n downto n+1-j do       begin           a[i,j]:=y;         inc(y)       end;  a) 9  b) 12  c) 14  d) 16  e) 28  f) 30    13. Pentru func\u021bia dat\u0103 mai jos, f(95) \u0219i f(59) au valorile:  Limbajul C++/C  int f (int x)  {    if (x>=100)  Limbajul Pascal  function f (x:integer) :  integer;  begin", "sentences": ["136    i=0;   j=strlen(s)-1;   k=1;  while(i<j)     {         if (s[i]!=s[j])           k=0;       i++;        j--;        }  i:=1;   j:=length(s);   k:=1;  while i<j do    begin      if s[i]<>s[j] then        k:=0;      inc(i);       dec(j)   end;  a) atasata  b) o rama maro  c) o rama alba  d) elisa vasile  e) nora aron  f) vasile elisav    11.", "Dac\u0103 din programul principal se apeleaz\u0103 f(f(3)), num\u0103rul de autoapeluri ale  func\u021biei f , definit\u0103 mai jos, este:  Limbajul C++/C  int f (int a)  {     if (a<2)        return 1;    else       return f(a-1)+2*f(a-3);  }  Limbajul Pascal  function f(a:integer):integer;  begin   if a<2 then     f:=1  else     f:=f(a-1)+2*f(a-3)  end;  a) 8  b) 9  c) 10  d) 14  e) 15  f) 16    12.", "Secven\u021ba de mai jos construie\u0219te tabloul bidimensional a cu n linii \u0219i n coloane,  numerotate de la 1 la n. Pentru n=4, suma elementelor de pe diagonala principal\u0103 este:  Limbajul C++/C  x=1;  y=1;  for(i=1;i<=n;i++)    for(j=1;j<=n+1-i;j++)       {          a[i][j]=x;         x++;       }  for(j=n;j>=1;j--)     for(i=n;i>=n+1-j;i--)       {          a[i][j]=y;         y++;       }  Limbajul Pascal  x:=1;   y:=1;  for i:=1 to n do    for j:=1 to n+1-i do      begin          a[i,j]:=x;        inc(x)       end;  for j:=n downto 1 do     for i:=n downto n+1-j do       begin           a[i,j]:=y;         inc(y)       end;  a) 9  b) 12  c) 14  d) 16  e) 28  f) 30    13.", "Pentru func\u021bia dat\u0103 mai jos, f(95) \u0219i f(59) au valorile:  Limbajul C++/C  int f (int x)  {    if (x>=100)  Limbajul Pascal  function f (x:integer) :  integer;  begin"], "page_sentence_count_spacy": 4}, {"page_number": 137, "page_char_count": 1775, "page_word_count": 534, "page_sentence_count_raw": 4, "page_token_count": 443.75, "text": "137         return x+2;    else        return f (f(x+2)+1);  }    if x>=100 then       f:=x+2    else       f:=f(f(x+2)+1)   end;  a) 103 \u0219i 146  b) 109 \u0219i 162  c) 110 \u0219i 163  d) 103 \u0219i 163  e) 112 \u0219i 157  f) 112 \u0219i 166    14. Sort\u00e2nd cresc\u0103tor prin metoda selec\u021biei, cu num\u0103r minim de interschimb\u0103ri (se  interschimb\u0103 doar elemente distincte), tablourile unidimensionale v=(3, 8, 2, 7),  x=(4, 5, 1, 7), y=(4, 7, 9, 6) \u0219i z=(6, 3, 2, 9) se calculeaz\u0103 num\u0103rul opera\u021biilor  (compar\u0103ri \u0219i atribuiri) efectuate. Afirma\u021bia adev\u0103rat\u0103 este:  a) Pentru v \u0219i y s-a realizat un num\u0103r egal de opera\u021bii  b) Pentru v \u0219i z s-a realizat un num\u0103r egal de opera\u021bii  c) Cel mai mare num\u0103r de opera\u021bii s-a efectuat pentru x  d) Cel mai mare num\u0103r de opera\u021bii s-a efectuat pentru y  e) Cel mai mic num\u0103r de opera\u021bii s-a efectuat pentru z  f) Cel mai mic num\u0103r de opera\u021bii s-a efectuat pentru y    15. \u00cen urma execut\u0103rii secven\u021bei de program de mai jos se afi\u0219eaz\u0103:  Limbajul C++/C  int f (int a, int b, int e)  {     int x;    if(a<2)         return e+1;    if(a%b==0)     {         if(e==0)          cout<<b<<' ';        |printf(\"%d \",b);         e++;         return f(a/b,b,e);    }  else    {     x=e+1;     e=0;     b++;     return x*f(a,b,e);   }  }  int main()  { int x,y,e;    cin>>x;  |scanf(\"%d\u201d,&x);    y=2;    e=0;    cout<<f(x,y,e);      |printf(\"%d\u201d,f(x,y,e));  Limbajul Pascal  program p;  var x,y,e: integer;  function f(a,b,e:integer) :integer;  var x:integer;  begin   if a<2 then     f:=e+1   else    begin     if a mod b=0 then       begin       if e=0 then        write(b,\u2019 \u2018);       inc(e);       f:=f(a div b,b,e)      end     else       begin        x:=e+1;e:=0;inc(b);        f:=x*f(a,b,e)       end    end  end;  begin    read(x);    y:=2;    e:=0;    writeln(f(x,y,e))", "sentences": ["137         return x+2;    else        return f (f(x+2)+1);  }    if x>=100 then       f:=x+2    else       f:=f(f(x+2)+1)   end;  a) 103 \u0219i 146  b) 109 \u0219i 162  c) 110 \u0219i 163  d) 103 \u0219i 163  e) 112 \u0219i 157  f) 112 \u0219i 166    14.", "Sort\u00e2nd cresc\u0103tor prin metoda selec\u021biei, cu num\u0103r minim de interschimb\u0103ri (se  interschimb\u0103 doar elemente distincte), tablourile unidimensionale v=(3, 8, 2, 7),  x=(4, 5, 1, 7), y=(4, 7, 9, 6) \u0219i z=(6, 3, 2, 9) se calculeaz\u0103 num\u0103rul opera\u021biilor  (compar\u0103ri \u0219i atribuiri) efectuate.", "Afirma\u021bia adev\u0103rat\u0103 este:  a) Pentru v \u0219i y s-a realizat un num\u0103r egal de opera\u021bii  b) Pentru v \u0219i z s-a realizat un num\u0103r egal de opera\u021bii  c) Cel mai mare num\u0103r de opera\u021bii s-a efectuat pentru x  d) Cel mai mare num\u0103r de opera\u021bii s-a efectuat pentru y  e) Cel mai mic num\u0103r de opera\u021bii s-a efectuat pentru z  f) Cel mai mic num\u0103r de opera\u021bii s-a efectuat pentru y    15.", "\u00cen urma execut\u0103rii secven\u021bei de program de mai jos se afi\u0219eaz\u0103:  Limbajul C++/C  int f (int a, int b, int e)  {     int x;    if(a<2)         return e+1;    if(a%b==0)     {         if(e==0)          cout<<b<<' ';        |printf(\"%d \",b);         e++;         return f(a/b,b,e);    }  else    {     x=e+1;     e=0;     b++;     return x*f(a,b,e);   }  }  int main()  { int x,y,e;    cin>>x;  |scanf(\"%d\u201d,&x);    y=2;    e=0;    cout<<f(x,y,e);      |printf(\"%d\u201d,f(x,y,e));  Limbajul Pascal  program p;  var x,y,e: integer;  function f(a,b,e:integer) :integer;  var x:integer;  begin   if a<2 then     f:=e+1   else    begin     if a mod b=0 then       begin       if e=0 then        write(b,\u2019 \u2018);       inc(e);       f:=f(a div b,b,e)      end     else       begin        x:=e+1;e:=0;inc(b);        f:=x*f(a,b,e)       end    end  end;  begin    read(x);    y:=2;    e:=0;    writeln(f(x,y,e))"], "page_sentence_count_spacy": 4}, {"page_number": 138, "page_char_count": 490, "page_word_count": 89, "page_sentence_count_raw": 2, "page_token_count": 122.5, "text": "138    }  end.  a) divizorii proprii ai num\u0103rului x  b) num\u0103rul de divizori proprii ai num\u0103rului x  c) divizorii proprii \u0219i num\u0103rul divizorilor proprii ai num\u0103rului x  d) divizorii primi ai lui x \u0219i num\u0103rul tuturor divizorilor lui x  e) divizorii proprii ai num\u0103rului x \u0219i produsul exponen\u021bilor divizorilor primi din  descompunerea \u00een factori primi a num\u0103rului x  f) divizorii primi ai num\u0103rului x \u0219i produsul exponen\u021bilor divizorilor primi din  descompunerea \u00een factori primi a num\u0103rului x", "sentences": ["138    }  end.", " a) divizorii proprii ai num\u0103rului x  b) num\u0103rul de divizori proprii ai num\u0103rului x  c) divizorii proprii \u0219i num\u0103rul divizorilor proprii ai num\u0103rului x  d) divizorii primi ai lui x \u0219i num\u0103rul tuturor divizorilor lui x  e) divizorii proprii ai num\u0103rului x \u0219i produsul exponen\u021bilor divizorilor primi din  descompunerea \u00een factori primi a num\u0103rului x  f) divizorii primi ai num\u0103rului x \u0219i produsul exponen\u021bilor divizorilor primi din  descompunerea \u00een factori primi a num\u0103rului x"], "page_sentence_count_spacy": 2}, {"page_number": 139, "page_char_count": 1124, "page_word_count": 263, "page_sentence_count_raw": 5, "page_token_count": 281.0, "text": "139    Varianta 25   1. Se d\u0103 o variabil\u0103 a care re\u021bine un num\u0103r natural nenul. Care dintre urm\u0103toarele  expresii are valoarea 0/false?  a) C++/C: a*(a+1)/2<a*a+1  Pascal: a*(a+1) DIV 2<a*a+1  b) C++/C: 4*a*(a-1)<a*a-2  Pascal: 4*a*(a-1)<a*a-2  c) C++/C: a>0 && (a%10+(a+1)%10)  Pascal: a>0 AND (a MOD 10+(a+1) MOD 10)  d) C++/C: a%2+(a+1)%2==1  Pascal: a MOD 2+(a+1) MOD 2 = 1  e) C++/C: (a-1)*(a+1)>a*a-2  Pascal: (a-1)*(a+1)>a*a-2  f) C++/C: a*(a+1)>=a*a+1  Pascal: a*(a+1)>=a*a+1    2. \u00cen secven\u021ba de program variabilele i \u0219i j sunt de tip \u00eentreg iar A este un tablou  bidimensional cu 5 linii \u0219i 5 coloane numerotate de al 0 la 4,   \ud835\udc68= (     \ud835\udfcf \ud835\udfd0 \ud835\udfd1 \ud835\udfd4 \ud835\udfd5 \ud835\udfd6 \ud835\udfcf \ud835\udfd0 \ud835\udfd1 \ud835\udfd2 \ud835\udfd3 \ud835\udfd7 \ud835\udfce \ud835\udfd2 \ud835\udfd3 \ud835\udfd4 \ud835\udfd5 \ud835\udfd6 \ud835\udfcf \ud835\udfd0 \ud835\udfd1 \ud835\udfd7 \ud835\udfce \ud835\udfd2 \ud835\udfd3)    . \u00cen urma execut\u0103rii urm\u0103toarelor instruc\u021biuni se va afi\u0219a:    Limbajul C++  i=4;  j=0;  cout<<A[i][j];  while(j!=4)   {    i--;    cout<<A[i][j];    j++;    cout<<A[i][j];   }    Limbajul C  i=4;  j=0;  printf(\"%d\",A[i][j]);  while(j!=4)   {    i--;    printf(\"%d\",A[i][j]);    j++;    printf(\"%d\",A[i][j]);   }    Limbajul Pascal  i:=4;  j:=0;  write(A[i][j]);  while j<>4 do   begin    i:=i-1; write(A[i][j]);    j:=j+1;", "sentences": ["139    Varianta 25   1.", "Se d\u0103 o variabil\u0103 a care re\u021bine un num\u0103r natural nenul.", "Care dintre urm\u0103toarele  expresii are valoarea 0/false?", " a) C++/C: a*(a+1)/2<a*a+1  Pascal: a*(a+1) DIV 2<a*a+1  b) C++/C: 4*a*(a-1)<a*a-2  Pascal: 4*a*(a-1)<a*a-2  c) C++/C: a>0 && (a%10+(a+1)%10)  Pascal: a>0 AND (a MOD 10+(a+1) MOD 10)  d) C++/C: a%2+(a+1)%2==1  Pascal: a MOD 2+(a+1) MOD 2 = 1  e) C++/C: (a-1)*(a+1)>a*a-2  Pascal: (a-1)*(a+1)>a*a-2  f) C++/C: a*(a+1)>=a*a+1  Pascal: a*(a+1)>=a*a+1    2.", "\u00cen secven\u021ba de program variabilele i \u0219i j sunt de tip \u00eentreg iar A este un tablou  bidimensional cu 5 linii \u0219i 5 coloane numerotate de al 0 la 4,   \ud835\udc68= (     \ud835\udfcf \ud835\udfd0 \ud835\udfd1 \ud835\udfd4 \ud835\udfd5 \ud835\udfd6 \ud835\udfcf \ud835\udfd0 \ud835\udfd1 \ud835\udfd2 \ud835\udfd3 \ud835\udfd7 \ud835\udfce \ud835\udfd2 \ud835\udfd3 \ud835\udfd4 \ud835\udfd5 \ud835\udfd6 \ud835\udfcf \ud835\udfd0 \ud835\udfd1 \ud835\udfd7 \ud835\udfce \ud835\udfd2 \ud835\udfd3)    .", "\u00cen urma execut\u0103rii urm\u0103toarelor instruc\u021biuni se va afi\u0219a:    Limbajul C++  i=4;  j=0;  cout<<A[i][j];  while(j!=4)   {    i--;    cout<<A[i][j];    j++;    cout<<A[i][j];   }    Limbajul C  i=4;  j=0;  printf(\"%d\",A[i][j]);  while(j!=4)   {    i--;    printf(\"%d\",A[i][j]);    j++;    printf(\"%d\",A[i][j]);   }    Limbajul Pascal  i:=4;  j:=0;  write(A[i][j]);  while j<>4 do   begin    i:=i-1; write(A[i][j]);    j:=j+1;"], "page_sentence_count_spacy": 6}, {"page_number": 140, "page_char_count": 1758, "page_word_count": 441, "page_sentence_count_raw": 13, "page_token_count": 439.5, "text": "140      write(A[i][j])   end;  a) 167238945  b) 127834905  c) 549832761  d) 509438721  e) 127850943  f) 509412783  3. Fie o coad\u0103 ini\u021bial vid\u0103. Cu ajutorul subprogramelor Ad(x) respectiv El() este  ad\u0103ugat elementul x respectiv \u0219ters un element din coad\u0103. Care va fi suma elementelor  din coad\u0103 \u00een urma execut\u0103rii opera\u021biilor urm\u0103toare?   Ad(3) El() Ad(7) Ad(9) El() Ad(5) Ad(2) El()  a) 12  b) 14  c) 10  d) 15  e) 7  f) 16      4. Fie  \ud835\udc40= (       \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfcf \ud835\udfcf \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce)        matricea de adiacen\u021b\u0103 a unui graf neorientat G.   Num\u0103rul de componente conexe ale grafului G este:  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    5. Num\u0103rul de noduri \u0219i num\u0103rul de frunze ale arborelui cu r\u0103d\u0103cin\u0103 memorat \u00een urm\u0103torul  vector de ta\u021bi (\ud835\udfce, \ud835\udfcf, \ud835\udfcf, \ud835\udfd0, \ud835\udfd0, \ud835\udfd1, \ud835\udfd4, \ud835\udfd5, \ud835\udfd5) este:  a) 9 0  b) 9 5  c) 8 4  d) 1 2  e) 8 3  f) 9 4    6. Se d\u0103 mul\u021bimea A={1,2,3,4}. Un algoritm genereaz\u0103 \u00een ordine cresc\u0103toare, toate  numerele naturale de n cifre, folosind cifre din mul\u021bimea A, numere care au suma  cifrelor egal\u0103 cu 6. Dac\u0103 pentru n=3, primele trei solu\u021bii generate sunt, \u00een ordine, 114,  123, 132, num\u0103rul de ordine al solu\u021biei 312 este:  a) 4  b) 5  c) 6  d) 7  e) 8  f) 9    7. Variabila i memoreaz\u0103 un num\u0103r natural, iar variabila a memoreaz\u0103 \u0219irul examen. \u00cen  urma execut\u0103rii urm\u0103toarelor instruc\u021biuni se va afi\u0219a:  Limbajul C++/C  for(i=0;i<5;i++)    if(a[i]<a[i+1])      a[i]=a[i+1];  cout<<a; | printf(\"%s\",a);  Limbajul Pascal  for i:=0 to 4 do    if a[i]<a[i+1] then      a[i]:=a[i+1];  write(a);      a) xxmmnn  b) exmmnn  c) fxbmfn  d) exxxxn  e) xamenn  f) nemaxe    8. Fie subprogramul recursiv:  Limbajul C++/C  void numar(int n)  {   if(n<=100)  Limbajul Pascal  procedure numar(n: longint);  begin    if n<=100 then", "sentences": ["140      write(A[i][j])   end;  a) 167238945  b) 127834905  c) 549832761  d) 509438721  e) 127850943  f) 509412783  3.", "Fie o coad\u0103 ini\u021bial vid\u0103.", "Cu ajutorul subprogramelor Ad(x) respectiv El() este  ad\u0103ugat elementul x respectiv \u0219ters un element din coad\u0103.", "Care va fi suma elementelor  din coad\u0103 \u00een urma execut\u0103rii opera\u021biilor urm\u0103toare?", "  Ad(3) El() Ad(7) Ad(9) El() Ad(5) Ad(2) El()  a) 12  b) 14  c) 10  d) 15  e) 7  f) 16      4.", "Fie  \ud835\udc40= (       \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfcf \ud835\udfcf \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce \ud835\udfce)        matricea de adiacen\u021b\u0103 a unui graf neorientat G.   Num\u0103rul de componente conexe ale grafului G este:  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    5.", "Num\u0103rul de noduri \u0219i num\u0103rul de frunze ale arborelui cu r\u0103d\u0103cin\u0103 memorat \u00een urm\u0103torul  vector de ta\u021bi (\ud835\udfce, \ud835\udfcf, \ud835\udfcf, \ud835\udfd0, \ud835\udfd0, \ud835\udfd1, \ud835\udfd4, \ud835\udfd5, \ud835\udfd5) este:  a) 9 0  b) 9 5  c) 8 4  d) 1 2  e) 8 3  f) 9 4    6.", "Se d\u0103 mul\u021bimea A={1,2,3,4}.", "Un algoritm genereaz\u0103 \u00een ordine cresc\u0103toare, toate  numerele naturale de n cifre, folosind cifre din mul\u021bimea A, numere care au suma  cifrelor egal\u0103 cu 6.", "Dac\u0103 pentru n=3, primele trei solu\u021bii generate sunt, \u00een ordine, 114,  123, 132, num\u0103rul de ordine al solu\u021biei 312 este:  a) 4  b) 5  c) 6  d) 7  e) 8  f) 9    7.", "Variabila i memoreaz\u0103 un num\u0103r natural, iar variabila a memoreaz\u0103 \u0219irul examen.", "\u00cen  urma execut\u0103rii urm\u0103toarelor instruc\u021biuni se va afi\u0219a:  Limbajul C++/C  for(i=0;i<5;i++)    if(a[i]<a[i+1])      a[i]=a[i+1];  cout<<a; | printf(\"%s\",a);  Limbajul Pascal  for i:=0 to 4 do    if a[i]<a[i+1] then      a[i]:=a[i+1];  write(a);      a) xxmmnn  b) exmmnn  c) fxbmfn  d) exxxxn  e) xamenn  f) nemaxe    8.", "Fie subprogramul recursiv:  Limbajul C++/C  void numar(int n)  {   if(n<=100)  Limbajul Pascal  procedure numar(n: longint);  begin    if n<=100 then"], "page_sentence_count_spacy": 13}, {"page_number": 141, "page_char_count": 1423, "page_word_count": 490, "page_sentence_count_raw": 5, "page_token_count": 355.75, "text": "141      cout<<'\\n';      |printf(\"\\n\");   else    {     if(n%10<5)       cout<<n%10;       |printf(\"%d\", n%10);     numar(n/10);     if(n%10>5)       cout<<n%10;      |printf(\"%d\", n%10);     }  }      writeln    else      begin        if n mod 10 < 5 then          write(n mod 10);       numar(n div 10);       if n mod 10 > 5 then         write(n mod 10)    end  end;  \u00cen urma apelului numar(824972345) se va afi\u0219a:  a) 4324    79  b) 4324       97  c) 4234      79  d) 4234       97  e) 3244       97  f) 2443       97    9. \u00cen urma execut\u0103rii urm\u0103toarelor instruc\u021biuni se va afi\u0219a valoarea:   Limbajul C++/C  int a=360,b=0,c=2;  while(a!=1)  {    if(!(a%c))    {      while(!(a%c))         a/=c;      b++;    }    c++;  }  cout<<b; | printf(\"%d\", b);    Limbajul Pascal  var a,b,c: integer;  begin     a:=360; b:=0; c:=2;     while a<>1 do     begin       if a mod c=0 then       begin         while a mod c=0 do           a:=a div c;         b:=b+1       end;       c:=c+1     end;     write(b)  end.      a) 2  b) 3  c) 4  d) 5  e) 6  f) 7    10. Fie tablou unidimensional v=(5,8,1,3,6,7,4,9), elementele fiind numerotate de  la 0 la 7. Dup\u0103 executarea urm\u0103toarelor instruc\u021biuni, tabloul unidimensional v va  con\u021bine valorile:   Limbajul C++/C  i=0;  while(i<=3)  {   if(v[i]<5)      v[i]=2*v[i];   if(v[7-i]>v[i])  Limbajul Pascal  i:=0;  while i<=3 do  begin  if v[i]<5 then      v[i]:=2*v[i];  if v[7-i]>v[i] then", "sentences": ["141      cout<<'\\n';      |printf(\"\\n\");   else    {     if(n%10<5)       cout<<n%10;       |printf(\"%d\", n%10);     numar(n/10);     if(n%10>5)       cout<<n%10;      |printf(\"%d\", n%10);     }  }      writeln    else      begin        if n mod 10 < 5 then          write(n mod 10);       numar(n div 10);       if n mod 10 > 5 then         write(n mod 10)    end  end;  \u00cen urma apelului numar(824972345) se va afi\u0219a:  a) 4324    79  b) 4324       97  c) 4234      79  d) 4234       97  e) 3244       97  f) 2443       97    9.", "\u00cen urma execut\u0103rii urm\u0103toarelor instruc\u021biuni se va afi\u0219a valoarea:   Limbajul C++/C  int a=360,b=0,c=2;  while(a!=1)  {    if(!(a%c))    {      while(!(a%c))         a/=c;      b++;    }    c++;  }  cout<<b; | printf(\"%d\", b);    Limbajul Pascal  var a,b,c: integer;  begin     a:=360; b:=0; c:=2;     while a<>1 do     begin       if a mod c=0 then       begin         while a mod c=0 do           a:=a div c;         b:=b+1       end;       c:=c+1     end;     write(b)  end.", "     a) 2  b) 3  c) 4  d) 5  e) 6  f) 7    10.", "Fie tablou unidimensional v=(5,8,1,3,6,7,4,9), elementele fiind numerotate de  la 0 la 7.", "Dup\u0103 executarea urm\u0103toarelor instruc\u021biuni, tabloul unidimensional v va  con\u021bine valorile:   Limbajul C++/C  i=0;  while(i<=3)  {   if(v[i]<5)      v[i]=2*v[i];   if(v[7-i]>v[i])  Limbajul Pascal  i:=0;  while i<=3 do  begin  if v[i]<5 then      v[i]:=2*v[i];  if v[7-i]>v[i] then"], "page_sentence_count_spacy": 5}, {"page_number": 142, "page_char_count": 1552, "page_word_count": 433, "page_sentence_count_raw": 7, "page_token_count": 388.0, "text": "142       v[7-i]=v[7-i]-v[i];   i=i+1;  }     v[7-i]:=v[7-i]-v[i];  i:=i+1  end;    a)  v=(5,8,2,6,6,4,4,3)  b)  v=(5,8,2,6,6,7,8,9)    c)  v=(5,8,2,6,6,5,4,4)     d)  v=(5,8,2,6,6,6,4,4)    e)  v=(5,8,8,6,6,4,4,4)  f)  v=(5,5,2,2,6,6,4,4)      11. Variabilele s, i, c sunt de tip \u00eentreg. Variabila c memoreaz\u0103 un num\u0103r natural par. \u00cen  urma execut\u0103rii secven\u021bei de instruc\u021biuni, variabila s are valoarea:  Limbajul C/C++  s=0;  for(i=1;i<=c/2;i++)     s=s+i;  s=2*s;  cout<<s; | printf(\"%d\", s);  Limbajul Pascal  s:=0;  for i:=1 to (c DIV 2) do    s:=s+i;  s:=2*s;  write(s);    a)  \ud835\udc84\u2219(\ud835\udc84+\ud835\udfcf) \ud835\udfd0   b) \ud835\udc84\u2219(\ud835\udc84+ \ud835\udfcf)  c)  \ud835\udc84\u2219(\ud835\udc84+\ud835\udfcf) \ud835\udfd2   d)  \ud835\udc84\u2219(\ud835\udc84+\ud835\udfd0) \ud835\udfd2    e)  \ud835\udc84\u2219(\ud835\udc84\u2212\ud835\udfcf) \ud835\udfd0   f)  \ud835\udc84\u2219(\ud835\udc84\u2212\ud835\udfcf) \ud835\udfd2     12. Variabilele i \u0219i c sunt de tip \u00eentreg, iar tablou unidimensional a are valorile                               (1, 2, 3, 4, 5, 6, 7), primul element se afl\u0103 pe pozi\u021bia 1, al doilea element se afl\u0103 pe  pozi\u021bia 2, \u0219.a.m.d. \u00cen urma execut\u0103rii instruc\u021biunilor, tabloul a va con\u021bine valorile:  Limbajul C++/C  for(i=1;i<=7;i++)  {int c;   c=a[i];   a[i]=a[7-i+1];   a[7-i+1]=c;  }  Limbajul Pascal  for i:=1 to 7 do   begin    c:=a[i];    a[i]:=a[7-i+1];    a[7-i+1]:=c   end;    a) 1 2 3 4 5 6 7  b) 7 6 5 4 3 2 1  c) 7 6 5 4 5 6 7  d) 1 2 3 4 3 2 1  e) 4 3 2 1 2 3 4  f) 4 5 6 7 6 5 4    13. \u00cen urma execut\u0103rii urm\u0103torului program se va afi\u0219a:  Limbajul C++/C  int main()  {   int c,i,nr=0;   for(i=200; i<=300; i++)    {     c=i;     while(c!=0)      {  Limbajul Pascal  var nr, i, c: integer;  begin  nr:=0;  for i:=200 to 300 do   begin    c:=i;    while c<>0 do     begin", "sentences": ["142       v[7-i]=v[7-i]-v[i];   i=i+1;  }     v[7-i]:=v[7-i]-v[i];  i:=i+1  end;    a)  v=(5,8,2,6,6,4,4,3)  b)  v=(5,8,2,6,6,7,8,9)    c)  v=(5,8,2,6,6,5,4,4)     d)  v=(5,8,2,6,6,6,4,4)    e)  v=(5,8,8,6,6,4,4,4)  f)  v=(5,5,2,2,6,6,4,4)      11.", "Variabilele s, i, c sunt de tip \u00eentreg.", "Variabila c memoreaz\u0103 un num\u0103r natural par.", "\u00cen  urma execut\u0103rii secven\u021bei de instruc\u021biuni, variabila s are valoarea:  Limbajul C/C++  s=0;  for(i=1;i<=c/2;i++)     s=s+i;  s=2*s;  cout<<s; | printf(\"%d\", s);  Limbajul Pascal  s:=0;  for i:=1 to (c DIV 2) do    s:=s+i;  s:=2*s;  write(s);    a)  \ud835\udc84\u2219(\ud835\udc84+\ud835\udfcf) \ud835\udfd0   b) \ud835\udc84\u2219(\ud835\udc84+ \ud835\udfcf)  c)  \ud835\udc84\u2219(\ud835\udc84+\ud835\udfcf) \ud835\udfd2   d)  \ud835\udc84\u2219(\ud835\udc84+\ud835\udfd0) \ud835\udfd2    e)  \ud835\udc84\u2219(\ud835\udc84\u2212\ud835\udfcf) \ud835\udfd0   f)  \ud835\udc84\u2219(\ud835\udc84\u2212\ud835\udfcf) \ud835\udfd2     12.", "Variabilele i \u0219i c sunt de tip \u00eentreg, iar tablou unidimensional a are valorile                               (1, 2, 3, 4, 5, 6, 7), primul element se afl\u0103 pe pozi\u021bia 1, al doilea element se afl\u0103 pe  pozi\u021bia 2, \u0219.a.m.d. \u00cen urma execut\u0103rii instruc\u021biunilor, tabloul a va con\u021bine valorile:  Limbajul C++/C  for(i=1;i<=7;i++)  {int c;   c=a[i];   a[i]=a[7-i+1];   a[7-i+1]=c;  }  Limbajul Pascal  for i:=1 to 7 do   begin    c:=a[i];    a[i]:=a[7-i+1];    a[7-i+1]:=c   end;    a) 1 2 3 4 5 6 7  b) 7 6 5 4 3 2 1  c) 7 6 5 4 5 6 7  d) 1 2 3 4 3 2 1  e) 4 3 2 1 2 3 4  f) 4 5 6 7 6 5 4    13.", "\u00cen urma execut\u0103rii urm\u0103torului program se va afi\u0219a:  Limbajul C++/C  int main()  {   int c,i,nr=0;   for(i=200; i<=300; i++)    {     c=i;     while(c!=0)      {  Limbajul Pascal  var nr, i, c: integer;  begin  nr:=0;  for i:=200 to 300 do   begin    c:=i;    while c<>0 do     begin"], "page_sentence_count_spacy": 6}, {"page_number": 143, "page_char_count": 1151, "page_word_count": 305, "page_sentence_count_raw": 3, "page_token_count": 287.75, "text": "143         if(c%2==1)          nr++;       c=c/10;      }    }   cout<<nr; | printf(\"%d\", nr);   return 0;}     if c mod 2 = 1 then       nr:=nr+1;     c:=c div 10     end    end;  write(nr)  end.    a) 50  b) 99  c) 100  d) 101  e) 102  f) 103    14. Subprogramul mat definit mai jos, cu doi parametri:  \u2219  n, prin care prime\u0219te un num\u0103r natural nenul (n\u2264100),  \u2219  d, prin care prime\u0219te elementele unui  tablou bidimensional cu n linii \u0219i n  coloane, numerotate de la 1 la n, determin\u0103:    Limbajul C++/C  int mat(int n, int d[][100])  {int e[100][100],i,j,k,p,matrice=0;   if(n==1) {matrice=d[1][1];              return matrice;}   else   {    for(i=1;i<=n;i++)    {     for(k=2;k<=n;k++)      for(j=1;j<i;j++)       e[k-1][j]=d[k][j];     for(k=2;k<=n;k++)      for(j=i+1;j<=n;j++)       e[k-1][j-1]=d[k][j];     if((i+1)%2==0) p=1;     else p=-1;     matrice=matrice+p*d[1][i]*mat(n-1,e);}   return matrice;   }}    Limbajul Pascal  type matrix = array[1..100,1..100] of integer;  function mat(n:integer; d:matrix):integer;  var e: matrix;      i,j,k,p,matrice: integer;  begin  matrice:=0;  if n=1 then  begin   matrice:=d[1][1];   mat:=matrice;", "sentences": ["143         if(c%2==1)          nr++;       c=c/10;      }    }   cout<<nr; | printf(\"%d\", nr);   return 0;}     if c mod 2 = 1 then       nr:=nr+1;     c:=c div 10     end    end;  write(nr)  end.", "   a) 50  b) 99  c) 100  d) 101  e) 102  f) 103    14.", "Subprogramul mat definit mai jos, cu doi parametri:  \u2219  n, prin care prime\u0219te un num\u0103r natural nenul (n\u2264100),  \u2219  d, prin care prime\u0219te elementele unui  tablou bidimensional cu n linii \u0219i n  coloane, numerotate de la 1 la n, determin\u0103:    Limbajul C++/C  int mat(int n, int d[][100])  {int e[100][100],i,j,k,p,matrice=0;   if(n==1) {matrice=d[1][1];              return matrice;}   else   {    for(i=1;i<=n;i++)    {     for(k=2;k<=n;k++)      for(j=1;j<i;j++)       e[k-1][j]=d[k][j];     for(k=2;k<=n;k++)      for(j=i+1;j<=n;j++)       e[k-1][j-1]=d[k][j];     if((i+1)%2==0) p=1;     else p=-1;     matrice=matrice+p*d[1][i]*mat(n-1,e);}   return matrice;   }}    Limbajul Pascal  type matrix = array[1..100,1..100] of integer;  function mat(n:integer; d:matrix):integer;  var e: matrix;      i,j,k,p,matrice: integer;  begin  matrice:=0;  if n=1 then  begin   matrice:=d[1][1];   mat:=matrice;"], "page_sentence_count_spacy": 3}, {"page_number": 144, "page_char_count": 1068, "page_word_count": 314, "page_sentence_count_raw": 2, "page_token_count": 267.0, "text": "144    end  else  begin   for i:=1 to n do     begin     for k:=2 to n do       for j:=1 to i-1 do         e[k-1][j]:=d[k][j];     for k:=2 to n do       for j:=i+1 to n do         e[k-1][j-1]:=d[k][j];     if (i+j) MOD 2 =0 then        p:=1     else p:=-1;     matrice:=matrice+p*d[1][i]*mat(n-1,e);     end;   mat:=matrice end end;  a) p\u0103tratul matricei  b) transpusa matricei  c) determinantul matricei  d) matricea invers\u0103  e) \u00eenmul\u021birea a dou\u0103 matrice  f) \u00eenmul\u021birea matricei cu o constant\u0103    15. \u00cen urma execut\u0103rii subprogramului, pentru parametrii v, n, k, cu valorile de intrare  \ud835\udc97= ( \ud835\udfce \ud835\udfcf \ud835\udfd2 \ud835\udfd3 \ud835\udfd0 \ud835\udfd1 \ud835\udfd4 \ud835\udfd5 \ud835\udfd6 \ud835\udfd7 \ud835\udfd0 \ud835\udfd1 \ud835\udfce \ud835\udfcf \ud835\udfd2 \ud835\udfd3 ), n=4 \u0219i k=2*n, se va afi\u0219a:    Limbajul C++/C  void afis(int v[][100],int n,int k)  {int i;  if(k!=1)    {     if(k%2==0){       for(i=1;i<=n;i++)         if(k-i<=n && k-i>0)            cout<<v[i][k-i]; | printf(\"%d\", v[i][k-i]);  }     else {       for(i=n;i>=1;i--)         if(k-i<=n && k-i>0)            cout<<v[i][k-i]; | printf(\"%d\", v[i][k-i]);  }     afis(v,n,k-1);    }}    Limbajul Pascal  type matrice = array of array of integer;", "sentences": ["144    end  else  begin   for i:=1 to n do     begin     for k:=2 to n do       for j:=1 to i-1 do         e[k-1][j]:=d[k][j];     for k:=2 to n do       for j:=i+1 to n do         e[k-1][j-1]:=d[k][j];     if (i+j) MOD 2 =0 then        p:=1     else p:=-1;     matrice:=matrice+p*d[1][i]*mat(n-1,e);     end;   mat:=matrice end end;  a) p\u0103tratul matricei  b) transpusa matricei  c) determinantul matricei  d) matricea invers\u0103  e) \u00eenmul\u021birea a dou\u0103 matrice  f) \u00eenmul\u021birea matricei cu o constant\u0103    15.", "\u00cen urma execut\u0103rii subprogramului, pentru parametrii v, n, k, cu valorile de intrare  \ud835\udc97= ( \ud835\udfce \ud835\udfcf \ud835\udfd2 \ud835\udfd3 \ud835\udfd0 \ud835\udfd1 \ud835\udfd4 \ud835\udfd5 \ud835\udfd6 \ud835\udfd7 \ud835\udfd0 \ud835\udfd1 \ud835\udfce \ud835\udfcf \ud835\udfd2 \ud835\udfd3 ), n=4 \u0219i k=2*n, se va afi\u0219a:    Limbajul C++/C  void afis(int v[][100],int n,int k)  {int i;  if(k!=1)    {     if(k%2==0){       for(i=1;i<=n;i++)         if(k-i<=n && k-i>0)            cout<<v[i][k-i]; | printf(\"%d\", v[i][k-i]);  }     else {       for(i=n;i>=1;i--)         if(k-i<=n && k-i>0)            cout<<v[i][k-i]; | printf(\"%d\", v[i][k-i]);  }     afis(v,n,k-1);    }}    Limbajul Pascal  type matrice = array of array of integer;"], "page_sentence_count_spacy": 2}, {"page_number": 145, "page_char_count": 499, "page_word_count": 156, "page_sentence_count_raw": 1, "page_token_count": 124.75, "text": "145    procedure afis(var v:matrice; n:integer; k:integer);  var i: integer;  begin  if k<>1 then    begin      if (k MOD 2)=0 then        begin        for i:=1 to n do          if(k-i<=n) AND (k-i>0) then             write(v[i][k-i]);        end      else        for i:=n downto 1 do          if(k-i<=n) AND (k-i>0)              write(v[i][k-i])    afis(v,n,k-1)  end end;  a) 5143073692852140  b) 5417032963258410  c) 0148523692307145  d) 0412582963703415  e) 0167093290672145  f) 5498563245014398", "sentences": ["145    procedure afis(var v:matrice; n:integer; k:integer);  var i: integer;  begin  if k<>1 then    begin      if (k MOD 2)=0 then        begin        for i:=1 to n do          if(k-i<=n) AND (k-i>0) then             write(v[i][k-i]);        end      else        for i:=n downto 1 do          if(k-i<=n) AND (k-i>0)              write(v[i][k-i])    afis(v,n,k-1)  end end;  a) 5143073692852140  b) 5417032963258410  c) 0148523692307145  d) 0412582963703415  e) 0167093290672145  f) 5498563245014398"], "page_sentence_count_spacy": 1}, {"page_number": 146, "page_char_count": 1546, "page_word_count": 314, "page_sentence_count_raw": 6, "page_token_count": 386.5, "text": "146    Varianta 26    1. Se d\u0103 o variabil\u0103 a care re\u021bine un num\u0103r natural nenul. Expresia care are valoarea  0/false pentru orice num\u0103r natural nenul a este:  a) C++/C: (a/3+a/7)%9        Pascal: (a DIV 3+a DIV 7) MOD 9  b) C++/C: (a%10+a%100/10)/10        Pascal: ((a MOD 10)+(a MOD 100) DIV 10) DIV 10  c) C++/C: ((10-a%10)+(10-a%100/10))/10        Pascal: ((10-(a MOD 10))+(10-(a MOD 100) DIV 10)) DIV 10  d) C++/C: (a%5+a%7)/10  Pascal: (a MOD 4+a MOD 6) DIV 10  e) C++/C: (a%3+a%7)/9  Pascal: (a MOD 3+a MOD 7) DIV 9  f) C++/C: (a%10+a/10)/9  Pascal: (a MOD 10+a DIV 10) DIV 9    2. Se d\u0103 un tablou unidimensional v=(3,5,8,4,2,6,9,1) \u00een care primul element se  afl\u0103 pe pozi\u021bia 0 \u0219i i o variabil\u0103 de tip \u00eentreg. \u00cen urma execut\u0103rii secven\u021bei de instruc\u021biuni,  elementele tabloului unidimensional v sunt:  Limbajul C++/C  i=0;  while(i<=6)  {  j=i+1;  v[i]=v[i]+v[j];  v[j]=v[i]-v[j];  v[i]=v[i]-v[j];  i=i+2;  }  Limbajul Pascal  i:=0;  while i<=6 do  begin  j:=i+1;  v[i]:=v[i]+v[j];  v[j]:=v[i]-v[j];  v[i]:=v[i]-v[j];  i:=i+2  end;    a) v=(5,8,4,2,6,9,1,3)  b) v=(5,3,4,8,6,2,1,9)  c) v=(11,3,20,8,10,2,19,9)  d) v=(5,-7,4,0,6,10,1,6)  e) v=(3,1,9,6,2,4,8,5)  f) v=(9,1,2,6,8,4,3,5)      3. \u0218tiind c\u0103 variabila i este de tip \u00eentreg \u0219i variabila a de tip \u0219ir de caractere re\u021bine cuv\u00e2ntul  politehnica, \u00een urma execut\u0103rii instruc\u021biunilor se va afi\u0219a:  Limbajul C++/C  for(i=0;i<=7;i++)     if(a[i]<'n')     a[i]='A'-'a'+a[i];  cout<<a; | printf(\"%s\", a);  Limbajul Pascal  for i:=1 to 8 do   begin    if a[i]<'n' then      a[i]:=upcase(a[i])", "sentences": ["146    Varianta 26    1.", "Se d\u0103 o variabil\u0103 a care re\u021bine un num\u0103r natural nenul.", "Expresia care are valoarea  0/false pentru orice num\u0103r natural nenul a este:  a) C++/C: (a/3+a/7)%9        Pascal: (a DIV 3+a DIV 7) MOD 9  b) C++/C: (a%10+a%100/10)/10        Pascal: ((a MOD 10)+(a MOD 100) DIV 10) DIV 10  c) C++/C: ((10-a%10)+(10-a%100/10))/10        Pascal: ((10-(a MOD 10))+(10-(a MOD 100) DIV 10)) DIV 10  d) C++/C: (a%5+a%7)/10  Pascal: (a MOD 4+a MOD 6) DIV 10  e) C++/C: (a%3+a%7)/9  Pascal: (a MOD 3+a MOD 7) DIV 9  f) C++/C: (a%10+a/10)/9  Pascal: (a MOD 10+a DIV 10) DIV 9    2.", "Se d\u0103 un tablou unidimensional v=(3,5,8,4,2,6,9,1) \u00een care primul element se  afl\u0103 pe pozi\u021bia 0 \u0219i i o variabil\u0103 de tip \u00eentreg.", "\u00cen urma execut\u0103rii secven\u021bei de instruc\u021biuni,  elementele tabloului unidimensional v sunt:  Limbajul C++/C  i=0;  while(i<=6)  {  j=i+1;  v[i]=v[i]+v[j];  v[j]=v[i]-v[j];  v[i]=v[i]-v[j];  i=i+2;  }  Limbajul Pascal  i:=0;  while i<=6 do  begin  j:=i+1;  v[i]:=v[i]+v[j];  v[j]:=v[i]-v[j];  v[i]:=v[i]-v[j];  i:=i+2  end;    a) v=(5,8,4,2,6,9,1,3)  b) v=(5,3,4,8,6,2,1,9)  c) v=(11,3,20,8,10,2,19,9)  d) v=(5,-7,4,0,6,10,1,6)  e) v=(3,1,9,6,2,4,8,5)  f) v=(9,1,2,6,8,4,3,5)      3.", "\u0218tiind c\u0103 variabila i este de tip \u00eentreg \u0219i variabila a de tip \u0219ir de caractere re\u021bine cuv\u00e2ntul  politehnica, \u00een urma execut\u0103rii instruc\u021biunilor se va afi\u0219a:  Limbajul C++/C  for(i=0;i<=7;i++)     if(a[i]<'n')     a[i]='A'-'a'+a[i];  cout<<a; | printf(\"%s\", a);  Limbajul Pascal  for i:=1 to 8 do   begin    if a[i]<'n' then      a[i]:=upcase(a[i])"], "page_sentence_count_spacy": 6}, {"page_number": 147, "page_char_count": 1375, "page_word_count": 448, "page_sentence_count_raw": 6, "page_token_count": 343.75, "text": "147     end;  write(a);    a) poLItEHnICA  b) POliTehnica  c) POliTehnica  d) POliTehNICA  e) poliTEHNICA  f) poLItEHnica     4.  Fie un tablou bidimensional A, cu 4 linii \u0219i 4 coloane numerotate de la 0 la 3 care con\u021bine  elemente de tip \u00eentreg \u0219i dou\u0103 variabile i \u0219i j de tip \u00eentreg. Valorile ce vor fi re\u021binute \u00een  tabloul bidimensional A dup\u0103 executarea urm\u0103toarelor instruc\u021biuni sunt:  Limbajul C++/C  i=3;  while(i>=0)   {    j=3;    while(j>=0)     {      if((i+j)%2==0)        A[i][j]=i+j;      else        if(i>j) A[i][j]=i;        else A[i][j]=j;      j--;     }    i--;   }  Limbajul Pascal  i:=3;  while i>=0 do   begin   j:=3;   while j>=0 do     begin     if (i+j) MOD 2 =0 then       A[i,j]:=i+j     else       if i>j then         A[i,j]:=i       else         A[i,j]:=j;     j:=j-1     end;   i:=i-1   end;    a) \ud835\udc34= ( 0 0 0 2 2 0 1 4 2 1 0 4 4 2 2 6 )  b) \ud835\udc34= ( 0 1 1 1 0 3 3 1 0 3 3 1 2 5 5 3 )  c) \ud835\udc34= ( 0 1 1 1 2 3 3 3 2 3 3 3 2 5 5 3 )  d) \ud835\udc34= ( 0 1 1 2 2 3 2 4 2 2 3 4 4 3 3 6 )  e) \ud835\udc34= ( 0 2 2 1 1 3 3 3 1 3 3 3 2 5 5 3 )  f) \ud835\udc34= ( 0 2 2 1 1 3 3 5 1 3 3 5 5 3 3 3 )    5. Fie o stiv\u0103 ini\u021bial vid\u0103. Cu ajutorul subprogramelor Ad(x), respectiv El() este  ad\u0103ugat elementul x, respectiv \u0219ters un element din stiv\u0103. Suma elementelor din stiv\u0103  dup\u0103 executarea opera\u021biilor urm\u0103toare este:   Ad(3) Ad(7) Ad(5) El() El() Ad(8)  a) 3  b) 7  c) 10  d) 11  e) 12  f) 13", "sentences": ["147     end;  write(a);    a) poLItEHnICA  b) POliTehnica  c) POliTehnica  d) POliTehNICA  e) poliTEHNICA  f) poLItEHnica     4.", " Fie un tablou bidimensional A, cu 4 linii \u0219i 4 coloane numerotate de la 0 la 3 care con\u021bine  elemente de tip \u00eentreg \u0219i dou\u0103 variabile i \u0219i j de tip \u00eentreg.", "Valorile ce vor fi re\u021binute \u00een  tabloul bidimensional A dup\u0103 executarea urm\u0103toarelor instruc\u021biuni sunt:  Limbajul C++/C  i=3;  while(i>=0)   {    j=3;    while(j>=0)     {      if((i+j)%2==0)        A[i][j]=i+j;      else        if(i>j) A[i][j]=i;        else A[i][j]=j;      j--;     }    i--;   }  Limbajul Pascal  i:=3;  while i>=0 do   begin   j:=3;   while j>=0 do     begin     if (i+j) MOD 2 =0 then       A[i,j]:=i+j     else       if i>j then         A[i,j]:=i       else         A[i,j]:=j;     j:=j-1     end;   i:=i-1   end;    a) \ud835\udc34= ( 0 0 0 2 2 0 1 4 2 1 0 4 4 2 2 6 )  b) \ud835\udc34= ( 0 1 1 1 0 3 3 1 0 3 3 1 2 5 5 3 )  c) \ud835\udc34= ( 0 1 1 1 2 3 3 3 2 3 3 3 2 5 5 3 )  d) \ud835\udc34= ( 0 1 1 2 2 3 2 4 2 2 3 4 4 3 3 6 )  e) \ud835\udc34= ( 0 2 2 1 1 3 3 3 1 3 3 3 2 5 5 3 )  f) \ud835\udc34= ( 0 2 2 1 1 3 3 5 1 3 3 5 5 3 3 3 )    5.", "Fie o stiv\u0103 ini\u021bial vid\u0103.", "Cu ajutorul subprogramelor Ad(x), respectiv El() este  ad\u0103ugat elementul x, respectiv \u0219ters un element din stiv\u0103.", "Suma elementelor din stiv\u0103  dup\u0103 executarea opera\u021biilor urm\u0103toare este:   Ad(3) Ad(7) Ad(5) El() El() Ad(8)  a) 3  b) 7  c) 10  d) 11  e) 12  f) 13"], "page_sentence_count_spacy": 6}, {"page_number": 148, "page_char_count": 1512, "page_word_count": 472, "page_sentence_count_raw": 7, "page_token_count": 378.0, "text": "148      6. Se d\u0103 mul\u021bimea A={1,4,5,8,9}. Un algoritm genereaz\u0103 \u00een ordine cresc\u0103toare, toate  numerele naturale de n cifre, folosind cifre distincte din mul\u021bimea A, care nu au al\u0103turate  cifre de aceea\u0219i paritate. Dac\u0103 pentru n=4, primele patru solu\u021bii generate sunt: 1458,  1498, 1854, 1894, num\u0103rul de solu\u021bii pe care le va genera algoritmul este:  a) 12  b) 16  c) 20  d) 24  e) 28  f) 30    7. \u0218irul care poate reprezenta valorile gradelor nodurilor unui graf neorientat cu 6 noduri  este:  a)  \ud835\udfd0 \ud835\udfd3 \ud835\udfce \ud835\udfd0 \ud835\udfcf \ud835\udfd0  b)  \ud835\udfd0 \ud835\udfd0 \ud835\udfcf \ud835\udfcf \ud835\udfcf \ud835\udfd0  c)  \ud835\udfd0 \ud835\udfd0 \ud835\udfd5 \ud835\udfd0 \ud835\udfd0 \ud835\udfcf  d)  \ud835\udfd0 \ud835\udfd0 \ud835\udfce \ud835\udfce \ud835\udfd2 \ud835\udfd0  e)  \ud835\udfd0 \ud835\udfd1 \ud835\udfcf \ud835\udfcf \ud835\udfd0 \ud835\udfd0  f)  \ud835\udfd0 \ud835\udfd0 \ud835\udfd0 \ud835\udfcf \ud835\udfcf \ud835\udfd0    8. \u0218irul de valori care poate fi vectorul de ta\u021bi al unui arbore cu 8 noduri este:  a)  \ud835\udc7b= (\ud835\udfce \ud835\udfcf \ud835\udfd6 \ud835\udfd1 \ud835\udfd0 \ud835\udfd3 \ud835\udfd3 \ud835\udfd2)  b)  \ud835\udc7b= (\ud835\udfce \ud835\udfd1 \ud835\udfd5 \ud835\udfd0 \ud835\udfd2 \ud835\udfd3 \ud835\udfd6 \ud835\udfd1)  c)  \ud835\udc7b= (\ud835\udfce \ud835\udfcf \ud835\udfcf \ud835\udfd0 \ud835\udfd2 \ud835\udfd3 \ud835\udfd6 \ud835\udfd5)  d)  \ud835\udc7b= (\ud835\udfce \ud835\udfd3 \ud835\udfd5 \ud835\udfd1 \ud835\udfcf \ud835\udfd1 \ud835\udfcf \ud835\udfd0)  e)  \ud835\udc7b= (\ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfd0 \ud835\udfd2 \ud835\udfd4 \ud835\udfd1 \ud835\udfd1)  f)  \ud835\udc7b= (\ud835\udfd6 \ud835\udfd3 \ud835\udfd5 \ud835\udfd1 \ud835\udfcf \ud835\udfd1 \ud835\udfcf \ud835\udfd0)    9. \u0218tiind c\u0103 i, j, s \u0219i a sunt patru variabile de tip \u00eentreg, pentru orice valoare natural\u0103  nenul\u0103 a variabilei a, dup\u0103 executarea instruc\u021biunilor, valoarea afi\u0219at\u0103 corespunde  formulei matematice:  Limbajul C++/C  s=0;  for(i=1;i<=a;i++)    {     j=1;     while(j<=i)       {        s++;        j++;       }     j=i+1;     do       {        s++;        j++;       }while(j<=a);    }  cout<<s--; | printf(\"%d\", s--);  Limbajul Pascal  s:=0;  for i:=1 to a do  begin    j:=1;    while j<=i do    begin      s:=s+1;      j:=j+1    end;    j:=i+1;    repeat      s:=s+1;      j:=j+1;    until j>a;  end;  write(s);    a) a(a+1)  b) a2+1  c) a2  d) a2-1  e) a(a-1)  f) 2a2-1", "sentences": ["148      6.", "Se d\u0103 mul\u021bimea A={1,4,5,8,9}.", "Un algoritm genereaz\u0103 \u00een ordine cresc\u0103toare, toate  numerele naturale de n cifre, folosind cifre distincte din mul\u021bimea A, care nu au al\u0103turate  cifre de aceea\u0219i paritate.", "Dac\u0103 pentru n=4, primele patru solu\u021bii generate sunt: 1458,  1498, 1854, 1894, num\u0103rul de solu\u021bii pe care le va genera algoritmul este:  a) 12  b) 16  c) 20  d) 24  e) 28  f) 30    7.", "\u0218irul care poate reprezenta valorile gradelor nodurilor unui graf neorientat cu 6 noduri  este:  a)  \ud835\udfd0 \ud835\udfd3 \ud835\udfce \ud835\udfd0 \ud835\udfcf \ud835\udfd0  b)  \ud835\udfd0 \ud835\udfd0 \ud835\udfcf \ud835\udfcf \ud835\udfcf \ud835\udfd0  c)  \ud835\udfd0 \ud835\udfd0 \ud835\udfd5 \ud835\udfd0 \ud835\udfd0 \ud835\udfcf  d)  \ud835\udfd0 \ud835\udfd0 \ud835\udfce \ud835\udfce \ud835\udfd2 \ud835\udfd0  e)  \ud835\udfd0 \ud835\udfd1 \ud835\udfcf \ud835\udfcf \ud835\udfd0 \ud835\udfd0  f)  \ud835\udfd0 \ud835\udfd0 \ud835\udfd0 \ud835\udfcf \ud835\udfcf \ud835\udfd0    8.", "\u0218irul de valori care poate fi vectorul de ta\u021bi al unui arbore cu 8 noduri este:  a)  \ud835\udc7b= (\ud835\udfce \ud835\udfcf \ud835\udfd6 \ud835\udfd1 \ud835\udfd0 \ud835\udfd3 \ud835\udfd3 \ud835\udfd2)  b)  \ud835\udc7b= (\ud835\udfce \ud835\udfd1 \ud835\udfd5 \ud835\udfd0 \ud835\udfd2 \ud835\udfd3 \ud835\udfd6 \ud835\udfd1)  c)  \ud835\udc7b= (\ud835\udfce \ud835\udfcf \ud835\udfcf \ud835\udfd0 \ud835\udfd2 \ud835\udfd3 \ud835\udfd6 \ud835\udfd5)  d)  \ud835\udc7b= (\ud835\udfce \ud835\udfd3 \ud835\udfd5 \ud835\udfd1 \ud835\udfcf \ud835\udfd1 \ud835\udfcf \ud835\udfd0)  e)  \ud835\udc7b= (\ud835\udfce \ud835\udfcf \ud835\udfce \ud835\udfd0 \ud835\udfd2 \ud835\udfd4 \ud835\udfd1 \ud835\udfd1)  f)  \ud835\udc7b= (\ud835\udfd6 \ud835\udfd3 \ud835\udfd5 \ud835\udfd1 \ud835\udfcf \ud835\udfd1 \ud835\udfcf \ud835\udfd0)    9.", "\u0218tiind c\u0103 i, j, s \u0219i a sunt patru variabile de tip \u00eentreg, pentru orice valoare natural\u0103  nenul\u0103 a variabilei a, dup\u0103 executarea instruc\u021biunilor, valoarea afi\u0219at\u0103 corespunde  formulei matematice:  Limbajul C++/C  s=0;  for(i=1;i<=a;i++)    {     j=1;     while(j<=i)       {        s++;        j++;       }     j=i+1;     do       {        s++;        j++;       }while(j<=a);    }  cout<<s--; | printf(\"%d\", s--);  Limbajul Pascal  s:=0;  for i:=1 to a do  begin    j:=1;    while j<=i do    begin      s:=s+1;      j:=j+1    end;    j:=i+1;    repeat      s:=s+1;      j:=j+1;    until j>a;  end;  write(s);    a) a(a+1)  b) a2+1  c) a2  d) a2-1  e) a(a-1)  f) 2a2-1"], "page_sentence_count_spacy": 7}, {"page_number": 149, "page_char_count": 1085, "page_word_count": 254, "page_sentence_count_raw": 4, "page_token_count": 271.25, "text": "149    10. Subprogramul afis prime\u0219te ca parametru un tablou bidimensional v cu n linii \u0219i n  coloane, numerotate de la 1 la n, unde  \ud835\udc97= ( \ud835\udfce \ud835\udfcf \ud835\udfd2 \ud835\udfd3 \ud835\udfd0 \ud835\udfd1 \ud835\udfd4 \ud835\udfd5 \ud835\udfd6 \ud835\udfd7 \ud835\udfd0 \ud835\udfd1 \ud835\udfce \ud835\udfcf \ud835\udfd2 \ud835\udfd3 ), n=4 \u0219i k=2\u2219n.    Pentru valorile date,  afis(v,n,k) va afi\u0219a:  Limbajul C++/C  void afis(int v[100][100],int n,int k)  {int i;  if(k>1)   { for(i=n;i>=1;i--)      if(k-i<=n && k-i>0)         cout<<v[i][k-i]; | printf(\"%d\", v[i][k-i]);  afis(v,n,k-2);}  }    Limbajul Pascal  type matrice = array [1..100,1..100] of integer;  procedure afis(var v:matrice; n:integer; k:integer);  var i: integer;  begin  if k<>1 then  begin      for i:=n downto 1 do          if(k-i<=n) AND (k-i>0) then             write(v[i,k-i]);    afis(v,n,k-2)  end  end;  a) 08523075  b) 57032580  c) 02587035  d) 53078520  e) 35087250  f) 70358520    11. \u0218tiind c\u0103 subprogramul functie corespunde func\u021biei matematice f(x)=3\u2219x-1,  pentru orice x num\u0103r \u00eentreg, abc(t,c) va calcula:   Limbajul C++/C  int functie(int x)  {return 3*x-1;}    int abc(int t, int c)  { if(c==0) return t;   else    return abc(functie(t),c-1);}    Limbajul Pascal", "sentences": ["149    10.", "Subprogramul afis prime\u0219te ca parametru un tablou bidimensional v cu n linii \u0219i n  coloane, numerotate de la 1 la n, unde  \ud835\udc97= ( \ud835\udfce \ud835\udfcf \ud835\udfd2 \ud835\udfd3 \ud835\udfd0 \ud835\udfd1 \ud835\udfd4 \ud835\udfd5 \ud835\udfd6 \ud835\udfd7 \ud835\udfd0 \ud835\udfd1 \ud835\udfce \ud835\udfcf \ud835\udfd2 \ud835\udfd3 ), n=4 \u0219i k=2\u2219n.", "   Pentru valorile date,  afis(v,n,k) va afi\u0219a:  Limbajul C++/C  void afis(int v[100][100],int n,int k)  {int i;  if(k>1)   { for(i=n;i>=1;i--)      if(k-i<=n && k-i>0)         cout<<v[i][k-i]; | printf(\"%d\", v[i][k-i]);  afis(v,n,k-2);}  }    Limbajul Pascal  type matrice = array [1..100,1..100] of integer;  procedure afis(var v:matrice; n:integer; k:integer);  var i: integer;  begin  if k<>1 then  begin      for i:=n downto 1 do          if(k-i<=n) AND (k-i>0) then             write(v[i,k-i]);    afis(v,n,k-2)  end  end;  a) 08523075  b) 57032580  c) 02587035  d) 53078520  e) 35087250  f) 70358520    11.", "\u0218tiind c\u0103 subprogramul functie corespunde func\u021biei matematice f(x)=3\u2219x-1,  pentru orice x num\u0103r \u00eentreg, abc(t,c) va calcula:   Limbajul C++/C  int functie(int x)  {return 3*x-1;}    int abc(int t, int c)  { if(c==0) return t;   else    return abc(functie(t),c-1);}    Limbajul Pascal"], "page_sentence_count_spacy": 4}, {"page_number": 150, "page_char_count": 1078, "page_word_count": 270, "page_sentence_count_raw": 4, "page_token_count": 269.5, "text": "150    function functie(var x:integer):integer;  begin    functie:=3*x-1  end;    function abc(t,c:integer):integer;  begin   if c=0 then        abc:=t   else     abc:=abc(functie(t),c-1)   end;  a) \ud835\udc87(\ud835\udc95) \u2218\u2026 \u2218\ud835\udc87(\ud835\udc95) \u23df         \ud835\udc84\u2212\ud835\udfcf   b) \ud835\udc87(\ud835\udc95) + \u22ef+ \ud835\udc87(\ud835\udc95) \u23df                 \ud835\udc84\u2212\ud835\udfcf   c) \ud835\udc87(\ud835\udc95)\ud835\udc84  d) \ud835\udc84\u2217\ud835\udc87(\ud835\udc95)  e) (\ud835\udc84\u2212\ud835\udfcf) \u2217\ud835\udc87(\ud835\udc95)  f) \ud835\udc87(\ud835\udc95) \u2218\u2026 \u2218\ud835\udc87(\ud835\udc95) \u23df         \ud835\udc84     12. Dup\u0103 executarea urm\u0103toarelor instruc\u021biuni se va afi\u0219a:  Limbajul C++/C  char a[20][20];  int i;  strcpy(a[1],\"bacalaureat\");  strcpy(a[2],\"liceu\");  strcpy(a[3],\"examene\");  strcpy(a[4],\"politehnica\");  for(i=1;i<=4;i++)      cout<<a[i][2*i];  | printf(\"%d\", a[i][2*i]);  Limbajul Pascal  var a:array[1..20] of  string;      i:integer;  begin  a[1]:='bacalaureat';  a[2]:='liceu';  a[3]:='examene';  a[4]:='politehnica';  for i:=1 to 4 do   write(a[i,2*i+1])  end.    a) aenn  b) teen  c) cunc  d) cuei  e) bceh  f) ceen    13. Urm\u0103toarele instruc\u021biuni vor afi\u0219a:   Limbajul C++  int f1(int x, int &y)  {   x=x+2;   y=y-1;   return x+y;   x=x+1;  }  Limbajul C  int f1(int x, int *y)  {   x=x+2;   *y=*y-1;   return x+*y;   x=x+1;  }", "sentences": ["150    function functie(var x:integer):integer;  begin    functie:=3*x-1  end;    function abc(t,c:integer):integer;  begin   if c=0 then        abc:=t   else     abc:=abc(functie(t),c-1)   end;  a) \ud835\udc87(\ud835\udc95) \u2218\u2026 \u2218\ud835\udc87(\ud835\udc95) \u23df         \ud835\udc84\u2212\ud835\udfcf   b) \ud835\udc87(\ud835\udc95) + \u22ef+ \ud835\udc87(\ud835\udc95) \u23df                 \ud835\udc84\u2212\ud835\udfcf   c) \ud835\udc87(\ud835\udc95)\ud835\udc84  d) \ud835\udc84\u2217\ud835\udc87(\ud835\udc95)  e) (\ud835\udc84\u2212\ud835\udfcf) \u2217\ud835\udc87(\ud835\udc95)  f) \ud835\udc87(\ud835\udc95) \u2218\u2026 \u2218\ud835\udc87(\ud835\udc95) \u23df         \ud835\udc84     12.", "Dup\u0103 executarea urm\u0103toarelor instruc\u021biuni se va afi\u0219a:  Limbajul C++/C  char a[20][20];  int i;  strcpy(a[1],\"bacalaureat\");  strcpy(a[2],\"liceu\");  strcpy(a[3],\"examene\");  strcpy(a[4],\"politehnica\");  for(i=1;i<=4;i++)      cout<<a[i][2*i];  | printf(\"%d\", a[i][2*i]);  Limbajul Pascal  var a:array[1..20] of  string;      i:integer;  begin  a[1]:='bacalaureat';  a[2]:='liceu';  a[3]:='examene';  a[4]:='politehnica';  for i:=1 to 4 do   write(a[i,2*i+1])  end.", "   a) aenn  b) teen  c) cunc  d) cuei  e) bceh  f) ceen    13.", "Urm\u0103toarele instruc\u021biuni vor afi\u0219a:   Limbajul C++  int f1(int x, int &y)  {   x=x+2;   y=y-1;   return x+y;   x=x+1;  }  Limbajul C  int f1(int x, int *y)  {   x=x+2;   *y=*y-1;   return x+*y;   x=x+1;  }"], "page_sentence_count_spacy": 4}, {"page_number": 151, "page_char_count": 1003, "page_word_count": 235, "page_sentence_count_raw": 3, "page_token_count": 250.75, "text": "151    int main()  {  int n=3,m=6;  cout<<f1(f1(m,n),m);  cout<<\" \"<<m;  }  int main()  {  int n=3,m=6;  printf(\"%d \",  f1(f1(m,&n),&m));  printf(\"%d\", m);  }  Limbajul Pascal  function f1(x:integer; var y:integer):integer;  begin   x:=x+2;   y:=y-1;   f1:=x+y;   x:=x+1  end;  var m,n: integer;  begin  m:=6;  n:=3;  write(f1(f1(m,n),m),' ',m)  end.  a) 17 5  b) 17 6  c) 10 5  d) 10 6  e) 11 6  f) 10 7    14. Valorile care vor fi memorate \u00een tabloul bidimensional b, cu liniile \u0219i coloanele  numerotate de la 1 la n, dup\u0103 apelul  matrice(a,b,n,q), unde  \ud835\udc82= ( \ud835\udfd0 \ud835\udfd1 \ud835\udfd2 \ud835\udfd1 \ud835\udfd2 \ud835\udfd3 \ud835\udfd2 \ud835\udfd3 \ud835\udfd4 ), \ud835\udc83= \ud835\udc76\ud835\udfd1, n=3, q=2, sunt:  Limbajul C++/C  void matrice(int a[][100], int b[][100], int n, int q)  {int i,j,k;   if(q>1)    {     for(i=1;i<=n;i++)       for(j=1;j<=n;j++)         for(k=1;k<=n;k++)          b[i][j]=b[i][j]+a[i][k]*a[k][j];     matrice(a,b,n,q-1);    }  }    Limbajul Pascal  type matrix = array [1..100,1..100] of integer;  procedure matrice(a:matrix; b:matrix; n:integer;  q:integer);  var i,j,k: integer;", "sentences": ["151    int main()  {  int n=3,m=6;  cout<<f1(f1(m,n),m);  cout<<\" \"<<m;  }  int main()  {  int n=3,m=6;  printf(\"%d \",  f1(f1(m,&n),&m));  printf(\"%d\", m);  }  Limbajul Pascal  function f1(x:integer; var y:integer):integer;  begin   x:=x+2;   y:=y-1;   f1:=x+y;   x:=x+1  end;  var m,n: integer;  begin  m:=6;  n:=3;  write(f1(f1(m,n),m),' ',m)  end.", " a) 17 5  b) 17 6  c) 10 5  d) 10 6  e) 11 6  f) 10 7    14.", "Valorile care vor fi memorate \u00een tabloul bidimensional b, cu liniile \u0219i coloanele  numerotate de la 1 la n, dup\u0103 apelul  matrice(a,b,n,q), unde  \ud835\udc82= ( \ud835\udfd0 \ud835\udfd1 \ud835\udfd2 \ud835\udfd1 \ud835\udfd2 \ud835\udfd3 \ud835\udfd2 \ud835\udfd3 \ud835\udfd4 ), \ud835\udc83= \ud835\udc76\ud835\udfd1, n=3, q=2, sunt:  Limbajul C++/C  void matrice(int a[][100], int b[][100], int n, int q)  {int i,j,k;   if(q>1)    {     for(i=1;i<=n;i++)       for(j=1;j<=n;j++)         for(k=1;k<=n;k++)          b[i][j]=b[i][j]+a[i][k]*a[k][j];     matrice(a,b,n,q-1);    }  }    Limbajul Pascal  type matrix = array [1..100,1..100] of integer;  procedure matrice(a:matrix; b:matrix; n:integer;  q:integer);  var i,j,k: integer;"], "page_sentence_count_spacy": 3}, {"page_number": 152, "page_char_count": 991, "page_word_count": 307, "page_sentence_count_raw": 3, "page_token_count": 247.75, "text": "152    begin   if q>1 then   begin   for i:=1 to n do     for j:=1 to n do       for k:=1 to n do             b[i,j]:=b[i,j]+a[i,k]*a[k,j];     matrice(a,b,n,q-1)   end  end;  a) \ud835\udc83= ( \ud835\udfd0 \ud835\udfd1 \ud835\udfd2 \ud835\udfd1 \ud835\udfd2 \ud835\udfd3 \ud835\udfd2 \ud835\udfd3 \ud835\udfd4 )  b) \ud835\udc83= ( \ud835\udfd2\ud835\udfd5 \ud835\udfd1\ud835\udfd6 \ud835\udfd0\ud835\udfd7 \ud835\udfd4\ud835\udfd0 \ud835\udfd3\ud835\udfce \ud835\udfd1\ud835\udfd6 \ud835\udfd5\ud835\udfd5 \ud835\udfd4\ud835\udfd0 \ud835\udfd2\ud835\udfd5 )  c) \ud835\udc83= ( \ud835\udfd2 \ud835\udfd4 \ud835\udfd6 \ud835\udfd4 \ud835\udfd6 \ud835\udfcf\ud835\udfce \ud835\udfd6 \ud835\udfcf\ud835\udfce \ud835\udfcf\ud835\udfd0 )  d) \ud835\udc83= ( \ud835\udfd2 \ud835\udfd7 \ud835\udfcf\ud835\udfd4 \ud835\udfd7 \ud835\udfcf\ud835\udfd4 \ud835\udfd0\ud835\udfd3 \ud835\udfcf\ud835\udfd4 \ud835\udfd0\ud835\udfd3 \ud835\udfd1\ud835\udfd4 )  e) \ud835\udc83= ( \ud835\udfd0\ud835\udfd7 \ud835\udfd1\ud835\udfd6 \ud835\udfd2\ud835\udfd5 \ud835\udfd1\ud835\udfd6 \ud835\udfd3\ud835\udfce \ud835\udfd4\ud835\udfd0 \ud835\udfd2\ud835\udfd5 \ud835\udfd4\ud835\udfd0 \ud835\udfd5\ud835\udfd5 )  f) \ud835\udc83= ( \ud835\udfd5\ud835\udfd5 \ud835\udfd4\ud835\udfd0 \ud835\udfd2\ud835\udfd5 \ud835\udfd4\ud835\udfd0 \ud835\udfd3\ud835\udfce \ud835\udfd1\ud835\udfd6 \ud835\udfd2\ud835\udfd5 \ud835\udfd1\ud835\udfd6 \ud835\udfd0\ud835\udfd7 )    15. \u00cen urma execut\u0103rii programului de mai jos se afi\u0219eaz\u0103:  Limbajul C++  #include <iostream>  using namespace std;   void functie(int &a,int &b)  { b=3*b;    a=2*a;}   int main()  { int n=4;    functie(n,n);    cout<<n;}  Limbajul C  #include <stdio.h>  void functie(int *a,int *b)  {   *b=3*(*b);      *a=2*(*a);}  int main()  {   int n=4;      functie(&n,&n);      printf(\"%d\", n);  }  Limbajul Pascal  procedure functie (var a:integer; var b:integer);  begin   b:=3*b;   a:=2*a  end;    var n:integer;  begin    n:=4;    functie(n,n);    write(n)   end.    a) eroare  b) 4  c) 6  d) 12  e) 14  f) 24", "sentences": ["152    begin   if q>1 then   begin   for i:=1 to n do     for j:=1 to n do       for k:=1 to n do             b[i,j]:=b[i,j]+a[i,k]*a[k,j];     matrice(a,b,n,q-1)   end  end;  a) \ud835\udc83= ( \ud835\udfd0 \ud835\udfd1 \ud835\udfd2 \ud835\udfd1 \ud835\udfd2 \ud835\udfd3 \ud835\udfd2 \ud835\udfd3 \ud835\udfd4 )  b) \ud835\udc83= ( \ud835\udfd2\ud835\udfd5 \ud835\udfd1\ud835\udfd6 \ud835\udfd0\ud835\udfd7 \ud835\udfd4\ud835\udfd0 \ud835\udfd3\ud835\udfce \ud835\udfd1\ud835\udfd6 \ud835\udfd5\ud835\udfd5 \ud835\udfd4\ud835\udfd0 \ud835\udfd2\ud835\udfd5 )  c) \ud835\udc83= ( \ud835\udfd2 \ud835\udfd4 \ud835\udfd6 \ud835\udfd4 \ud835\udfd6 \ud835\udfcf\ud835\udfce \ud835\udfd6 \ud835\udfcf\ud835\udfce \ud835\udfcf\ud835\udfd0 )  d) \ud835\udc83= ( \ud835\udfd2 \ud835\udfd7 \ud835\udfcf\ud835\udfd4 \ud835\udfd7 \ud835\udfcf\ud835\udfd4 \ud835\udfd0\ud835\udfd3 \ud835\udfcf\ud835\udfd4 \ud835\udfd0\ud835\udfd3 \ud835\udfd1\ud835\udfd4 )  e) \ud835\udc83= ( \ud835\udfd0\ud835\udfd7 \ud835\udfd1\ud835\udfd6 \ud835\udfd2\ud835\udfd5 \ud835\udfd1\ud835\udfd6 \ud835\udfd3\ud835\udfce \ud835\udfd4\ud835\udfd0 \ud835\udfd2\ud835\udfd5 \ud835\udfd4\ud835\udfd0 \ud835\udfd5\ud835\udfd5 )  f) \ud835\udc83= ( \ud835\udfd5\ud835\udfd5 \ud835\udfd4\ud835\udfd0 \ud835\udfd2\ud835\udfd5 \ud835\udfd4\ud835\udfd0 \ud835\udfd3\ud835\udfce \ud835\udfd1\ud835\udfd6 \ud835\udfd2\ud835\udfd5 \ud835\udfd1\ud835\udfd6 \ud835\udfd0\ud835\udfd7 )    15.", "\u00cen urma execut\u0103rii programului de mai jos se afi\u0219eaz\u0103:  Limbajul C++  #include <iostream>  using namespace std;   void functie(int &a,int &b)  { b=3*b;    a=2*a;}   int main()  { int n=4;    functie(n,n);    cout<<n;}  Limbajul C  #include <stdio.h>  void functie(int *a,int *b)  {   *b=3*(*b);      *a=2*(*a);}  int main()  {   int n=4;      functie(&n,&n);      printf(\"%d\", n);  }  Limbajul Pascal  procedure functie (var a:integer; var b:integer);  begin   b:=3*b;   a:=2*a  end;    var n:integer;  begin    n:=4;    functie(n,n);    write(n)   end.", "   a) eroare  b) 4  c) 6  d) 12  e) 14  f) 24"], "page_sentence_count_spacy": 3}, {"page_number": 153, "page_char_count": 1751, "page_word_count": 547, "page_sentence_count_raw": 13, "page_token_count": 437.75, "text": "153    Varianta 27    1. Rezultatul expresiei de mai jos este:  Limbajul C++/C  16 / (-5 % 3) * 3  Limbajul Pascal  16 div (-5 mod 3) * 3  a) 48  b) -24  c) -48  d) -2  e) 2  f) 6    2. Expresia corespunz\u0103toare penultimei cifre a num\u0103rului natural av\u00e2nd cel pu\u021bin dou\u0103 cifre  re\u021binut de variabila \u00eentreag\u0103 n este:  Limbajul C++/C  a) n / 10 / 10  b) n / 10 % 10  c) n % 10 % 10  d) n % 10 / 10  e) n % 10 / 100  f) n / 100 % 10  Limbajul Pascal  a) n div 10 div 10  b) n div 10 mod 10  c) n mod 10 mod 10  d) n mod 10 div 10  e) n mod 10 div 100  f) n div 100 mod 10    3. Afirma\u021bia adev\u0103rat\u0103 \u00een privin\u021ba secven\u021bei de instruc\u021biuni de mai jos este:  Limbajul C++/C  d = 1;  while (d * d <= n)  {    if (n % d == 0)    {      d1 = d;      d2 = n / d;    }    d++;  }  Limbajul Pascal  d := 1;  while d * d <= n do    begin      if n mod d = 0 then        begin          d1 := d;          d2 := n div d        end;      d := d + 1    end  a) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r prim.  b) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine cubul unui num\u0103r prim.  c) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r impar.   d) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r par.  e) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine 0.  f) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r p\u0103trat perfect.    4. Secven\u021ba de instruc\u021biuni de mai jos ordoneaz\u0103 cresc\u0103tor cele n elemente ale tabloului  unidimensional v, \u00een care primul element este memorat pe pozi\u021bia 0, dac\u0103 punctele de  suspensie sunt \u00eenlocuite cu:   Limbajul C++/C  for (i = 0; i < n - 1; i++)  {    ...    {      if (v[j] > v[j+1])  Limbajul Pascal  for i := 0 to n - 2 do    begin      ...        begin          if v[j] > v[j+1] then", "sentences": ["153    Varianta 27    1.", "Rezultatul expresiei de mai jos este:  Limbajul C++/C  16 / (-5 % 3) * 3  Limbajul Pascal  16 div (-5 mod 3) * 3  a) 48  b) -24  c) -48  d) -2  e) 2  f) 6    2.", "Expresia corespunz\u0103toare penultimei cifre a num\u0103rului natural av\u00e2nd cel pu\u021bin dou\u0103 cifre  re\u021binut de variabila \u00eentreag\u0103 n este:  Limbajul C++/C  a) n / 10 / 10  b) n / 10 % 10  c) n % 10 % 10  d) n % 10 / 10  e) n % 10 / 100  f) n / 100 % 10  Limbajul Pascal  a) n div 10 div 10  b) n div 10 mod 10  c) n mod 10 mod 10  d) n mod 10 div 10  e) n mod 10 div 100  f) n div 100 mod 10    3.", "Afirma\u021bia adev\u0103rat\u0103 \u00een privin\u021ba secven\u021bei de instruc\u021biuni de mai jos este:  Limbajul C++/C  d = 1;  while (d * d <= n)  {    if (n % d == 0)    {      d1 = d;      d2 = n / d;    }    d++;  }  Limbajul Pascal  d := 1;  while d * d <= n do    begin      if n mod d = 0 then        begin          d1 := d;          d2 := n div d        end;      d := d + 1    end  a) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r prim.", " b) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine cubul unui num\u0103r prim.", " c) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r impar.", "  d) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r par.", " e) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine 0.", " f) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r p\u0103trat perfect.", "   4.", "Secven\u021ba de instruc\u021biuni de mai jos ordoneaz\u0103 cresc\u0103tor cele n elemente ale tabloului  unidimensional v, \u00een care primul element este memorat pe pozi\u021bia 0, dac\u0103 punctele de  suspensie sunt \u00eenlocuite cu:   Limbajul C++/C  for (i = 0; i < n - 1; i++)  {    ...    {      if (v[j] > v[j+1])  Limbajul Pascal  for i := 0 to n - 2 do    begin      ...        begin          if v[j] > v[j+1] then"], "page_sentence_count_spacy": 11}, {"page_number": 154, "page_char_count": 1704, "page_word_count": 578, "page_sentence_count_raw": 5, "page_token_count": 426.0, "text": "154        {        aux = v[j];        v[j] = v[j+1];        v[j+1] = aux;      }    }  }            begin              aux := v[j];              v[j] := v[j+1];              v[j+1] := aux            end        end    end  Limbajul C++/C  a) for (j = n-2; j >= i; j--)  b) for (j = 0; j <= i; j++)  c) for (j = n-i; j >= i; j--)  d) for (j = 1; j < i; j++)  e) for (j = n-1; j > i; j--)  f) for (j = 1; j <= i+1; j++)  Limbajul Pascal  a) for j := n-2 downto i do  b) for j := 0 to i do  c) for j := n-i downto i do  d) for j := 1 to i-1 do  e) for j := n-1 downto i+1 do  f) for j := 1 to i+1 do    5. Subprogramul f este definit mai jos. O condi\u021bie necesar\u0103 \u0219i suficient\u0103 pentru ca num\u0103rul  natural mai mare strict ca 1 re\u021binut de variabila n s\u0103 fie prim este:  Limbajul C++/C  int f(int d, int n)  {    do    {      d++;    }    while (n % d != 0);    return d;  }  Limbajul Pascal  function f(d, n: integer):   integer;  begin    repeat      d := d + 1;    until n mod d = 0;    f := d  end;  Limbajul C/C++  a) f(2, n) == n  b) f(2, n) == 2  c) f(1, n) == n  d) f(1, n) == 1  e) f(1, n - 1) == n  f) f(2, n - 1) == 2  Limbajul Pascal  a) f(2, n) = n  b) f(2, n) = 2  c) f(1, n) = n  d) f(1, n) = 1  e) f(1, n - 1) = n  f) f(2, n - 1) = 2    6. Num\u0103rul de muchii care trebuie ad\u0103ugate unui arbore cu 10 v\u00e2rfuri astfel \u00eenc\u00e2t acesta  s\u0103 devin\u0103 graf complet este:  a) 9  b) 10  c) 11  d) 35  e) 36  f) 37    7. Suma elementelor aflate pe diagonala principal\u0103 a matricei a, cu 5 linii \u0219i 5 coloane  numerotate de la 0 la 4, ale c\u0103rei elemente sunt actualizate \u00een secven\u021ba de instruc\u021biuni  de mai jos este:  Limbajul C++/C  n = 5;  for (i = 0; i < n; i++)  Limbajul Pascal  n := 5;  for i := 0 to n - 1 do", "sentences": ["154        {        aux = v[j];        v[j] = v[j+1];        v[j+1] = aux;      }    }  }            begin              aux := v[j];              v[j] := v[j+1];              v[j+1] := aux            end        end    end  Limbajul C++/C  a) for (j = n-2; j >= i; j--)  b) for (j = 0; j <= i; j++)  c) for (j = n-i; j >= i; j--)  d) for (j = 1; j < i; j++)  e) for (j = n-1; j > i; j--)  f) for (j = 1; j <= i+1; j++)  Limbajul Pascal  a) for j := n-2 downto i do  b) for j := 0 to i do  c) for j := n-i downto i do  d) for j := 1 to i-1 do  e) for j := n-1 downto i+1 do  f) for j := 1 to i+1 do    5.", "Subprogramul f este definit mai jos.", "O condi\u021bie necesar\u0103 \u0219i suficient\u0103 pentru ca num\u0103rul  natural mai mare strict ca 1 re\u021binut de variabila n s\u0103 fie prim este:  Limbajul C++/C  int f(int d, int n)  {    do    {      d++;    }    while (n % d !", "= 0);    return d;  }  Limbajul Pascal  function f(d, n: integer):   integer;  begin    repeat      d := d + 1;    until n mod d = 0;    f := d  end;  Limbajul C/C++  a) f(2, n) == n  b) f(2, n) == 2  c) f(1, n) == n  d) f(1, n) == 1  e) f(1, n - 1) == n  f) f(2, n - 1) == 2  Limbajul Pascal  a) f(2, n) = n  b) f(2, n) = 2  c) f(1, n) = n  d) f(1, n) = 1  e) f(1, n - 1) = n  f) f(2, n - 1) = 2    6.", "Num\u0103rul de muchii care trebuie ad\u0103ugate unui arbore cu 10 v\u00e2rfuri astfel \u00eenc\u00e2t acesta  s\u0103 devin\u0103 graf complet este:  a) 9  b) 10  c) 11  d) 35  e) 36  f) 37    7.", "Suma elementelor aflate pe diagonala principal\u0103 a matricei a, cu 5 linii \u0219i 5 coloane  numerotate de la 0 la 4, ale c\u0103rei elemente sunt actualizate \u00een secven\u021ba de instruc\u021biuni  de mai jos este:  Limbajul C++/C  n = 5;  for (i = 0; i < n; i++)  Limbajul Pascal  n := 5;  for i := 0 to n - 1 do"], "page_sentence_count_spacy": 6}, {"page_number": 155, "page_char_count": 1808, "page_word_count": 400, "page_sentence_count_raw": 14, "page_token_count": 452.0, "text": "155    {    for (j = 0; j < n; j++)    {      a[i][j] = (n - i) * n - j;    }  }    begin      for j := 0 to n - 1 do        begin          a[i,j] := (n-i)*n - j        end    end  a) 15  b) 20  c) 35  d) 55  e) 65  f) 70    8. O variant\u0103 care poate corespunde \u0219irului  gradelor interne ale v\u00e2rfurilor grafului  orientat al\u0103turat este:    a) (2,1,1,1,0)  b) (1,1,1,1,0)  c) (2,1,0,2,0)  d) (2,0,2,2,0)  e) (2,0,0,3,0)  f) (2,0,1,1,0)    9. Un algoritm Backtracking genereaz\u0103 ultimele dou\u0103 solu\u021bii pilo \u0219i poli, av\u00e2nd ca  date de intrare cuv\u00e2ntul poli. O variant\u0103 care poate reprezenta descrierea algoritmului  este:  a) Algoritmul genereaz\u0103 \u00een ordine invers lexicografic\u0103 anagramele cuv\u00e2ntului citit.  b) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele cuv\u00e2ntului citit.  c) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele cuv\u00e2ntului citit care nu au  vocale pe pozi\u021bii al\u0103turate.  d) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele cuv\u00e2ntului citit care nu au  consoane pe pozi\u021bii al\u0103turate.  e) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele cuv\u00e2ntului citit care nu au  vocale pe ultima pozi\u021bie.  f) Algoritmul genereaz\u0103 \u00een ordine invers lexicografic\u0103 anagramele cuv\u00e2ntului citit care  nu au consoane pe ultima pozi\u021bie.    10. Programul de mai jos afi\u0219eaz\u0103 pe ecran textul Poli 2020 dac\u0103 punctele de suspensie  sunt \u00eenlocuite cu:   Limbajul C++/C  #include <stdio.h>  #include <string.h>  int main()  {   char s[256], t[256];   strcpy(s,\"Politehnica 2020\");   ...   strcpy(s + 4, t);   puts(s);   return 0;  }  Limbajul Pascal  var s, t: string;    begin    s:='Politehnica 2020';    ...    s:=copy(s, 1, 4) + t;    writeln(s)  end.  Limbajul C++/C  a) strcpy(t, strchr(s, ' '));  b) strcpy(t, strcpy(s, ' '));  c) strcat(t, strchr(s, '2'));  d) strcpy(t, strchr(s, \" \"));", "sentences": ["155    {    for (j = 0; j < n; j++)    {      a[i][j] = (n - i) * n - j;    }  }    begin      for j := 0 to n - 1 do        begin          a[i,j] := (n-i)*n - j        end    end  a) 15  b) 20  c) 35  d) 55  e) 65  f) 70    8.", "O variant\u0103 care poate corespunde \u0219irului  gradelor interne ale v\u00e2rfurilor grafului  orientat al\u0103turat este:    a) (2,1,1,1,0)  b) (1,1,1,1,0)  c) (2,1,0,2,0)  d) (2,0,2,2,0)  e) (2,0,0,3,0)  f) (2,0,1,1,0)    9.", "Un algoritm Backtracking genereaz\u0103 ultimele dou\u0103 solu\u021bii pilo \u0219i poli, av\u00e2nd ca  date de intrare cuv\u00e2ntul poli.", "O variant\u0103 care poate reprezenta descrierea algoritmului  este:  a) Algoritmul genereaz\u0103 \u00een ordine invers lexicografic\u0103 anagramele cuv\u00e2ntului citit.", " b) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele cuv\u00e2ntului citit.", " c) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele cuv\u00e2ntului citit care nu au  vocale pe pozi\u021bii al\u0103turate.", " d) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele cuv\u00e2ntului citit care nu au  consoane pe pozi\u021bii al\u0103turate.", " e) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele cuv\u00e2ntului citit care nu au  vocale pe ultima pozi\u021bie.", " f) Algoritmul genereaz\u0103 \u00een ordine invers lexicografic\u0103 anagramele cuv\u00e2ntului citit care  nu au consoane pe ultima pozi\u021bie.", "   10.", "Programul de mai jos afi\u0219eaz\u0103 pe ecran textul Poli 2020 dac\u0103 punctele de suspensie  sunt \u00eenlocuite cu:   Limbajul C++/C  #include <stdio.h>  #include <string.h>  int main()  {   char s[256], t[256];   strcpy(s,\"Politehnica 2020\");   ...   strcpy(s + 4, t);   puts(s);   return 0;  }  Limbajul Pascal  var s, t: string;    begin    s:='Politehnica 2020';    ...    s:=copy(s, 1, 4) + t;    writeln(s)  end.", " Limbajul C++/C  a) strcpy(t, strchr(s, ' '));  b) strcpy(t, strcpy(s, ' '));  c) strcat(t, strchr(s, '2'));  d) strcpy(t, strchr(s, \" \"));"], "page_sentence_count_spacy": 12}, {"page_number": 156, "page_char_count": 1591, "page_word_count": 504, "page_sentence_count_raw": 7, "page_token_count": 397.75, "text": "156    e) strcat(t, strcpy(s, \"2\"));  f) strcpy(t, strchr(s, \"2\"));  Limbajul Pascal  a) t:=copy(s, pos(' ', s), 5);  b) t:=copy(s, copy(' ', s), 4);  c) t:=s + pos('2', s);  d) t:=copy(s, pos(\" \", s), 5);  e) t:=copy(s, copy(\"2\", s), 4);  f) t:=copy(s, pos(\"2\", s), 5);    11. Subprogramul f este definit mai jos. Valoarea returnat\u0103 la apelul f(24,34) este:  Limbajul C++/C  int f(int a, int b)  {    int r;    if (a >= b)    {      r = a;    }    else if (a % 10 == b % 10)    {      r = 2 + f(a + 1, b);    }    else if (a % 3 == b % 3)    {      r = 1 + f(a + 1, b - 1);    }    else    {      r = f(a, b - 2);    }    return r;  }  Limbajul Pascal  function f(a, b: integer):  integer;  var r: integer;  begin    if a >= b then      begin        r := a;      end    else     if a mod 10 = b mod 10 then      begin        r := 2 + f(a + 1, b)      end    else if a mod 3 = b mod 3  then      begin        r := 1 + f(a + 1, b - 1)      end    else      begin        r := f(a, b - 2)      end;    f := r  end;  a) 30  b) 31  c) 32  d) 33  e) 34  f) 35    12. Num\u0103rul maxim de muchii care pot fi  eliminate din graful neorientat al\u0103turat  astfel \u00eenc\u00e2t acesta s\u0103 con\u021bin\u0103 cel pu\u021bin trei  cicluri elementare distincte este:    a) 1  b) 6  c) 2  d) 4  e) 5  f) 3    13. Se genereaz\u0103 \u00een ordine lexicografic\u0103 vectorii de ta\u021bi corespunz\u0103tori tuturor arborilor cu  r\u0103d\u0103cin\u0103 av\u00e2nd exact 6 noduri. Prin \u00een\u0103l\u021bimea unui arbore cu r\u0103d\u0103cin\u0103 \u00een\u021belegem  num\u0103rul de muchii ale celui mai lung lan\u021b elementar care une\u0219te r\u0103d\u0103cina cu un alt  nod. A doua solu\u021bie corespunz\u0103toare unui arbore cu \u00een\u0103l\u021bimea 3 este:", "sentences": ["156    e) strcat(t, strcpy(s, \"2\"));  f) strcpy(t, strchr(s, \"2\"));  Limbajul Pascal  a) t:=copy(s, pos(' ', s), 5);  b) t:=copy(s, copy(' ', s), 4);  c) t:=s + pos('2', s);  d) t:=copy(s, pos(\" \", s), 5);  e) t:=copy(s, copy(\"2\", s), 4);  f) t:=copy(s, pos(\"2\", s), 5);    11.", "Subprogramul f este definit mai jos.", "Valoarea returnat\u0103 la apelul f(24,34) este:  Limbajul C++/C  int f(int a, int b)  {    int r;    if (a >= b)    {      r = a;    }    else if (a % 10 == b % 10)    {      r = 2 + f(a + 1, b);    }    else if (a % 3 == b % 3)    {      r = 1 + f(a + 1, b - 1);    }    else    {      r = f(a, b - 2);    }    return r;  }  Limbajul Pascal  function f(a, b: integer):  integer;  var r: integer;  begin    if a >= b then      begin        r := a;      end    else     if a mod 10 = b mod 10 then      begin        r := 2 + f(a + 1, b)      end    else if a mod 3 = b mod 3  then      begin        r := 1 + f(a + 1, b - 1)      end    else      begin        r := f(a, b - 2)      end;    f := r  end;  a) 30  b) 31  c) 32  d) 33  e) 34  f) 35    12.", "Num\u0103rul maxim de muchii care pot fi  eliminate din graful neorientat al\u0103turat  astfel \u00eenc\u00e2t acesta s\u0103 con\u021bin\u0103 cel pu\u021bin trei  cicluri elementare distincte este:    a) 1  b) 6  c) 2  d) 4  e) 5  f) 3    13.", "Se genereaz\u0103 \u00een ordine lexicografic\u0103 vectorii de ta\u021bi corespunz\u0103tori tuturor arborilor cu  r\u0103d\u0103cin\u0103 av\u00e2nd exact 6 noduri.", "Prin \u00een\u0103l\u021bimea unui arbore cu r\u0103d\u0103cin\u0103 \u00een\u021belegem  num\u0103rul de muchii ale celui mai lung lan\u021b elementar care une\u0219te r\u0103d\u0103cina cu un alt  nod.", "A doua solu\u021bie corespunz\u0103toare unui arbore cu \u00een\u0103l\u021bimea 3 este:"], "page_sentence_count_spacy": 7}, {"page_number": 157, "page_char_count": 1650, "page_word_count": 613, "page_sentence_count_raw": 6, "page_token_count": 412.5, "text": "157    a) 0 1 2 3 1 1  b) 0 1 1 1 2 5  c) 0 1 1 1 2 6  d) 0 1 1 1 3 5  e) 0 1 1 1 1 2  f) 0 1 1 1 4 5    14. Subprogramul rad de mai jos calculeaz\u0103 \u0219i returneaz\u0103 cel mai mic num\u0103r care ridicat  la p\u0103trat este mai mare sau egal cu num\u0103rul natural re\u021binut de x (partea \u00eentreag\u0103  superioar\u0103 a lui radical din x) dac\u0103 punctele de suspensie sunt \u00eenlocuite cu:  Limbajul C++/C  int rad(int s, int d, int x)  {    int rez, m;    if (s == d)    {      rez = s;    }    else    {      m = (s + d) / 2;      if (...)      {        rez = rad(s, m, x);      }      else      {        rez = rad(m + 1, d, x);      }    }    return rez;  }  Limbajul Pascal  function rad(s,d,x: integer)       :integer;  var m, rez: integer;  begin    if s = d then      begin        rez := s      end    else      begin        m := (s + d) div 2;        if ... then          begin            rez := rad(s, m, x)          end        else          begin            rez := rad(m+1,d, x)          end      end;    rad := rez  end;  Limbajul C++/C  a) m * m == x  b) m * m >= x  c) m * m <= x  d) m * m > x  e) m * m < x  f) m * m != x  Limbajul Pascal  a) m * m = x  b) m * m >= x  c) m * m <= x  d) m * m > x  e) m * m < x  f) m * m <> x    15. Fie un tablou unidimensional v care re\u021bine n numere naturale: v[0],v[1],\u2026,v[n- 1] \u0219i un num\u0103r \u00eentreg t. Secven\u021ba de instruc\u021biuni de mai jos are ca efect ob\u021binerea  lungimii maxime lmax a unei subsecven\u021be v[k], v[k+1], ... v[k+lmax-1]  av\u00e2nd suma elementelor mai mic\u0103 sau egal\u0103 cu t dac\u0103 punctele de suspensie sunt  \u00eenlocuite cu:  Limbajul C++/C            s = 0;    j = 0;    lmax = 0;  Limbajul Pascal    s := 0;    j := 0;    lmax := 0;", "sentences": ["157    a) 0 1 2 3 1 1  b) 0 1 1 1 2 5  c) 0 1 1 1 2 6  d) 0 1 1 1 3 5  e) 0 1 1 1 1 2  f) 0 1 1 1 4 5    14.", "Subprogramul rad de mai jos calculeaz\u0103 \u0219i returneaz\u0103 cel mai mic num\u0103r care ridicat  la p\u0103trat este mai mare sau egal cu num\u0103rul natural re\u021binut de x (partea \u00eentreag\u0103  superioar\u0103 a lui radical din x) dac\u0103 punctele de suspensie sunt \u00eenlocuite cu:  Limbajul C++/C  int rad(int s, int d, int x)  {    int rez, m;    if (s == d)    {      rez = s;    }    else    {      m = (s + d) / 2;      if (...)      {        rez = rad(s, m, x);      }      else      {        rez = rad(m + 1, d, x);      }    }    return rez;  }  Limbajul Pascal  function rad(s,d,x: integer)       :integer;  var m, rez: integer;  begin    if s = d then      begin        rez := s      end    else      begin        m := (s + d) div 2;        if ... then          begin            rez := rad(s, m, x)          end        else          begin            rez := rad(m+1,d, x)          end      end;    rad := rez  end;  Limbajul C++/C  a) m * m == x  b) m * m >= x  c) m * m <= x  d) m * m > x  e) m * m < x  f) m * m !", "= x  Limbajul Pascal  a) m * m = x  b) m * m >= x  c) m * m <= x  d) m * m > x  e) m * m < x  f) m * m <> x    15.", "Fie un tablou unidimensional v care re\u021bine n numere naturale: v[0],v[1],\u2026,v[n- 1] \u0219i un num\u0103r \u00eentreg t. Secven\u021ba de instruc\u021biuni de mai jos are ca efect ob\u021binerea  lungimii maxime lmax a unei subsecven\u021be v[k], v[k+1], ... v[k+lmax-1]  av\u00e2nd suma elementelor mai mic\u0103 sau egal\u0103 cu t dac\u0103 punctele de suspensie sunt  \u00eenlocuite cu:  Limbajul C++/C            s = 0;    j = 0;    lmax = 0;  Limbajul Pascal    s := 0;    j := 0;    lmax := 0;"], "page_sentence_count_spacy": 4}, {"page_number": 158, "page_char_count": 655, "page_word_count": 322, "page_sentence_count_raw": 3, "page_token_count": 163.75, "text": "158      for (i = 0; i < n; i++)     {      s += v[i];      while (j <= i && s > t)      {        ...        j++;      }      if (i - j + 1 > lmax)      {        lmax = i - j + 1;      }    }    for i := 0 to n-1 do      begin        s := s + v[i];        while(j<=i) and (s>t) do          begin            ...            j := j + 1          end;        if i - j + 1 > lmax then          begin            lmax := i - j + 1          end;      end;    Limbajul C++/C  a) s += v[j];  b) i--;  c) s -= v[i];  d) s -= v[j];  e) s += v[i];  f) i++;  Limbajul Pascal  a) s := s+v[j];  b) i := i-1;  c) s := s-v[i];  d) s := s-v[j];  e) s := s+v[i];  f) i := i+1;", "sentences": ["158      for (i = 0; i < n; i++)     {      s += v[i];      while (j <= i && s > t)      {        ...        j++;      }      if (i - j + 1 > lmax)      {        lmax = i - j + 1;      }    }    for i := 0 to n-1 do      begin        s := s + v[i];        while(j<=i) and (s>t) do          begin            ...            j := j + 1          end;        if i - j + 1 > lmax then          begin            lmax := i - j + 1          end;      end;    Limbajul C++/C  a) s += v[j];  b) i--;  c) s -= v[i];  d) s -= v[j];  e) s += v[i];  f) i++;  Limbajul Pascal  a) s := s+v[j];  b) i := i-1;  c) s := s-v[i];  d) s := s-v[j];  e) s := s+v[i];  f) i := i+1;"], "page_sentence_count_spacy": 1}, {"page_number": 159, "page_char_count": 1411, "page_word_count": 440, "page_sentence_count_raw": 6, "page_token_count": 352.75, "text": "159    Varianta 28    1. Expresia corespunz\u0103toare mediei aritmetice a patru numere reale memorate \u00een variabilele  a,b,c \u015fi d este:  a) a+b+c+d/4  b)(a+b+c+d)*1/2  c)(a+b+c+d)*0.4  d)(a+b+c+d)*0.25  e)(a+b+c+d)*4.0  f)(a+b+c+d)*1.4    2. \u00cen secven\u021bele de instruc\u021biuni S1 \u0219i S2 variabilele n \u0219i p sunt de tip \u00eentreg. Ob\u021binerea \u00een  variabila p a primei cifre a num\u0103rului re\u021binut ini\u021bial de n este realizat\u0103:  Limbajul C/C++  //S1  p = n;  while (p > 9)  {    p /= 10;  }  //S2  do  {    p = n % 10;    n /= 10;  }  while (n != 0);  Limbajul Pascal  {S1}  p := n;  while p > 9 do    begin      p := p div 10    end  {S2}  repeat    p := n mod 10;    n := n div 10  until n = 0;  a) doar de S1  b) doar de S2  c) at\u00e2t de S1, c\u00e2t \u0219i de S2  d) doar folosind o cu totul alt\u0103 secven\u021b\u0103  e) doar de S1, dac\u0103 n are o singur\u0103  cifr\u0103  f) doar de S2, dac\u0103 n are mai multe cifre    3. \u00cen urma execut\u0103rii secven\u021bei de instruc\u021biuni de mai jos variabila nr va re\u021bine num\u0103rul  divizorilor primi ai num\u0103rului natural nenul re\u021binut ini\u021bial de variabila n dac\u0103 punctele de  suspensie sunt \u00eenlocuite cu:  Limbajul C++/C  d = 2;  nr = 0;  while (n > 1)  {    p = 0;    while (...)    {      p = 1;      n /= d;    }    nr += p;    d++;  }  Limbajul Pascal  d := 2;  nr := 0;  while n > 1 do    begin      p := 0;      while ... do        begin          p := 1;          n := n div d        end;      nr := nr + p;      d := d + 1    end", "sentences": ["159    Varianta 28    1.", "Expresia corespunz\u0103toare mediei aritmetice a patru numere reale memorate \u00een variabilele  a,b,c \u015fi d este:  a) a+b+c+d/4  b)(a+b+c+d)*1/2  c)(a+b+c+d)*0.4  d)(a+b+c+d)*0.25  e)(a+b+c+d)*4.0  f)(a+b+c+d)*1.4    2.", "\u00cen secven\u021bele de instruc\u021biuni S1 \u0219i S2 variabilele n \u0219i p sunt de tip \u00eentreg.", "Ob\u021binerea \u00een  variabila p a primei cifre a num\u0103rului re\u021binut ini\u021bial de n este realizat\u0103:  Limbajul C/C++  //S1  p = n;  while (p > 9)  {    p /= 10;  }  //S2  do  {    p = n % 10;    n /= 10;  }  while (n !", "= 0);  Limbajul Pascal  {S1}  p := n;  while p > 9 do    begin      p := p div 10    end  {S2}  repeat    p := n mod 10;    n := n div 10  until n = 0;  a) doar de S1  b) doar de S2  c) at\u00e2t de S1, c\u00e2t \u0219i de S2  d) doar folosind o cu totul alt\u0103 secven\u021b\u0103  e) doar de S1, dac\u0103 n are o singur\u0103  cifr\u0103  f) doar de S2, dac\u0103 n are mai multe cifre    3.", "\u00cen urma execut\u0103rii secven\u021bei de instruc\u021biuni de mai jos variabila nr va re\u021bine num\u0103rul  divizorilor primi ai num\u0103rului natural nenul re\u021binut ini\u021bial de variabila n dac\u0103 punctele de  suspensie sunt \u00eenlocuite cu:  Limbajul C++/C  d = 2;  nr = 0;  while (n > 1)  {    p = 0;    while (...)    {      p = 1;      n /= d;    }    nr += p;    d++;  }  Limbajul Pascal  d := 2;  nr := 0;  while n > 1 do    begin      p := 0;      while ... do        begin          p := 1;          n := n div d        end;      nr := nr + p;      d := d + 1    end"], "page_sentence_count_spacy": 6}, {"page_number": 160, "page_char_count": 1640, "page_word_count": 511, "page_sentence_count_raw": 6, "page_token_count": 410.0, "text": "160      Limbajul C++/C  a) d*d<n  b) n<d  c) n>d  d) d+d<n  e) n%d!=0  f) n%d==0  Limbajul Pascal  a) d*d<n  b) n<d  c) n>d  d) d+d<n  e) n mod d<>0 f) n mod d=0    4. Vectorul v are n componente \u00eentregi, numerotate de la 0, ordonate cresc\u0103tor. Pentru ca \u00een  urma execut\u0103rii secven\u021bei de instruc\u021biuni de mai jos s\u0103 se insereze valoarea \u00eentreag\u0103 re\u021binut\u0103  de x \u00een vectorul v \u0219i acesta s\u0103 r\u0103m\u00e2n\u0103 ordonat, punctele de suspensie trebuie \u00eenlocuite cu:  Limbajul C++/C  i = n - 1;  while (i >= 0 && v[i] > x)  {    v[i+1] = v[i];    i--;  }  ...;  n++;  Limbajul Pascal  i := n - 1;  while (i>=0) and (v[i]>x) do    begin      v[i+1] := v[i];      i := i - 1;    end;  ...;  n := n + 1;  Limbajul C++/C  a) x = v[i+1]  b) v[i] = x  c) v[n] = x  d) v[i-1] = x  e) v[i+1] = x  f) v[n+1] = x  Limbajul Pascal  a) x := v[i+1]  b) v[i] := x  c) v[n] := x  d) v[i-1] := x  e) v[i+1] := x  f) v[n+1] := x    5. \u00cen urma execut\u0103rii secven\u021bei de instruc\u021biuni de mai jos suma elementelor pare ale matricei  a, cu 5 linii \u0219i 5 coloane numerotate de la 0 la 4 va fi:  Limbajul C/C++  n = 5;  for (i = 0; i < n; i++)  {    for (j = 0; j < n; j++)    {      a[i][j] = i - j + n;    }  }  Limbajul Pascal  n := 5;  for i := 0 to n - 1 do    begin      for j := 0 to n - 1 do        begin          a[i,j] := i - j + n        end;    end;  a) 20  b) 60  c) 62  d) 64  e) 61  f) 12    6. Subprogramul f este definit mai jos. Apelul care returneaz\u0103 valoarea 0 este:  Limbajul C++/C  int f(int n)  {    int r = 0;    while (r * r < n)    {      r++;  Limbajul Pascal  function f(n:integer):integer;  var r: integer;  begin    r := 0;    while r * r < n do      begin", "sentences": ["160      Limbajul C++/C  a) d*d<n  b) n<d  c) n>d  d) d+d<n  e) n%d!=0  f) n%d==0  Limbajul Pascal  a) d*d<n  b) n<d  c) n>d  d) d+d<n  e) n mod d<>0 f) n mod d=0    4.", "Vectorul v are n componente \u00eentregi, numerotate de la 0, ordonate cresc\u0103tor.", "Pentru ca \u00een  urma execut\u0103rii secven\u021bei de instruc\u021biuni de mai jos s\u0103 se insereze valoarea \u00eentreag\u0103 re\u021binut\u0103  de x \u00een vectorul v \u0219i acesta s\u0103 r\u0103m\u00e2n\u0103 ordonat, punctele de suspensie trebuie \u00eenlocuite cu:  Limbajul C++/C  i = n - 1;  while (i >= 0 && v[i] > x)  {    v[i+1] = v[i];    i--;  }  ...;  n++;  Limbajul Pascal  i := n - 1;  while (i>=0) and (v[i]>x) do    begin      v[i+1] := v[i];      i := i - 1;    end;  ...;  n := n + 1;  Limbajul C++/C  a) x = v[i+1]  b) v[i] = x  c) v[n] = x  d) v[i-1] = x  e) v[i+1] = x  f) v[n+1] = x  Limbajul Pascal  a) x := v[i+1]  b) v[i] := x  c) v[n] := x  d) v[i-1] := x  e) v[i+1] := x  f) v[n+1] := x    5.", "\u00cen urma execut\u0103rii secven\u021bei de instruc\u021biuni de mai jos suma elementelor pare ale matricei  a, cu 5 linii \u0219i 5 coloane numerotate de la 0 la 4 va fi:  Limbajul C/C++  n = 5;  for (i = 0; i < n; i++)  {    for (j = 0; j < n; j++)    {      a[i][j] = i - j + n;    }  }  Limbajul Pascal  n := 5;  for i := 0 to n - 1 do    begin      for j := 0 to n - 1 do        begin          a[i,j] := i - j + n        end;    end;  a) 20  b) 60  c) 62  d) 64  e) 61  f) 12    6.", "Subprogramul f este definit mai jos.", "Apelul care returneaz\u0103 valoarea 0 este:  Limbajul C++/C  int f(int n)  {    int r = 0;    while (r * r < n)    {      r++;  Limbajul Pascal  function f(n:integer):integer;  var r: integer;  begin    r := 0;    while r * r < n do      begin"], "page_sentence_count_spacy": 6}, {"page_number": 161, "page_char_count": 1548, "page_word_count": 465, "page_sentence_count_raw": 7, "page_token_count": 387.0, "text": "161      }    return r * r - n;  }        r := r + 1      end;    f := r*r - n  end;  a) f(23)  b) f(225)  c) f(17)  d) f(131)  e) f(122)  f) f(1000)    7. Un graf orientat tare conex are \u0219irul gradelor externe ale v\u00e2rfurilor sale (3,1,1,1).  Graful nu are arce cu extremit\u0103\u021bile identice (bucle). O variant\u0103 care poate reprezenta \u0219irul  gradelor interne ale v\u00e2rfurilor grafului este:   a) (6,0,0,0)  b) (2,1,3,2)  c) (2,2,2,0)  d) (1,1,2,2)  e) (1,1,1,2)  f) (0,0,1,5)    8. Num\u0103rul nodurilor terminale (frunze) ale arborelui cu r\u0103d\u0103cin\u0103 corespunz\u0103tor vectorului de  ta\u021bi (7,4,0,3,7,3,3,4) este:  a) 3  b) 7  c) 5  d) 0  e) 8  f) 4    9. Programul de mai jos afi\u0219eaz\u0103 num\u0103rul apari\u021biilor caracterului c \u00een cuv\u00e2ntul s dac\u0103 punctele  de suspensie sunt \u00eenlocuite cu:  Limbajul C++/C  #include <stdio.h>  #include <string.h>    int main()  {      char s[256], c, *p;      int nr;      scanf(\"%s %c\", s, &c);      p = strchr(s, c);      nr = 0;      while (p != NULL)      {          nr++;          ...;          p = strchr(s, c);      }      printf(\"%d\", nr);      return 0;  }  Limbajul Pascal  var s: string;      c: char;      p, nr: integer;    begin    readln(s);    readln(c);    p := pos(c, s);    nr := 0;    while p <> 0 do      begin        nr := nr + 1;        ...;        p := pos(c, s)      end;    writeln(nr)  end.  Limbajul C/C++  a) strcpy(p,p+1)  b) strcpy(p+1,p)  c) strcat(s,p+1)  d) p++  e) strcat(s,p)  f) p--  Limbajul Pascal  a) delete(s,p,1)  b) delete(p,s,1)  c) concat(s,p+1,1)  d) p := p + 1  e) concat(s,p,1)  f) p := p - 1", "sentences": ["161      }    return r * r - n;  }        r := r + 1      end;    f := r*r - n  end;  a) f(23)  b) f(225)  c) f(17)  d) f(131)  e) f(122)  f) f(1000)    7.", "Un graf orientat tare conex are \u0219irul gradelor externe ale v\u00e2rfurilor sale (3,1,1,1).", " Graful nu are arce cu extremit\u0103\u021bile identice (bucle).", "O variant\u0103 care poate reprezenta \u0219irul  gradelor interne ale v\u00e2rfurilor grafului este:   a) (6,0,0,0)  b) (2,1,3,2)  c) (2,2,2,0)  d) (1,1,2,2)  e) (1,1,1,2)  f) (0,0,1,5)    8.", "Num\u0103rul nodurilor terminale (frunze) ale arborelui cu r\u0103d\u0103cin\u0103 corespunz\u0103tor vectorului de  ta\u021bi (7,4,0,3,7,3,3,4) este:  a) 3  b) 7  c) 5  d) 0  e) 8  f) 4    9.", "Programul de mai jos afi\u0219eaz\u0103 num\u0103rul apari\u021biilor caracterului c \u00een cuv\u00e2ntul s dac\u0103 punctele  de suspensie sunt \u00eenlocuite cu:  Limbajul C++/C  #include <stdio.h>  #include <string.h>    int main()  {      char s[256], c, *p;      int nr;      scanf(\"%s %c\", s, &c);      p = strchr(s, c);      nr = 0;      while (p !", "= NULL)      {          nr++;          ...;          p = strchr(s, c);      }      printf(\"%d\", nr);      return 0;  }  Limbajul Pascal  var s: string;      c: char;      p, nr: integer;    begin    readln(s);    readln(c);    p := pos(c, s);    nr := 0;    while p <> 0 do      begin        nr := nr + 1;        ...;        p := pos(c, s)      end;    writeln(nr)  end.", " Limbajul C/C++  a) strcpy(p,p+1)  b) strcpy(p+1,p)  c) strcat(s,p+1)  d) p++  e) strcat(s,p)  f) p--  Limbajul Pascal  a) delete(s,p,1)  b) delete(p,s,1)  c) concat(s,p+1,1)  d) p := p + 1  e) concat(s,p,1)  f) p := p - 1"], "page_sentence_count_spacy": 8}, {"page_number": 162, "page_char_count": 2115, "page_word_count": 510, "page_sentence_count_raw": 16, "page_token_count": 528.75, "text": "162    10 .  Apelul s(3) al subprogramului s definit mai jos va afi\u0219a pe ecran:  Limbajul C++/C  void s(int n)  {    int i;    if (n > 0)    {      for (i = 0; i < n; i++)      {        printf(\"%d\", i);        s(i - 1);      }      printf(\"%d\", n);    }  }  Limbajul Pascal  procedure s(n: integer);  var i: integer;  begin    if n > 0 then      begin        for i := 0 to n-1 do          begin            write(i);            s(i-1)          end;        write(n)      end  end;  a) 012301  b) 012031  c) 00120013  d) 01203  e) 0120013  f) 012013    11 .  Rezolvarea problemei gener\u0103rii tuturor imaginilor func\u021biilor injective definite pe mul\u021bimea  {1,2,..,k} cu valori \u00een mul\u021bimea {1,2,..,n} prin metoda Backtracking necesit\u0103 ca  fiecare element ad\u0103ugat \u00een vectorul solu\u021bie s\u0103 respecte o condi\u021bie de compatibilitate cu cele  deja introduse. Aceea\u0219i condi\u021bie este respectat\u0103 \u00een cazul:  a) Gener\u0103rii tuturor submul\u021bimilor mul\u021bimii {1,2,...,n}.  b) Gener\u0103rii tuturor permut\u0103rilor mul\u021bimii {1,2,...,n}.  c) Gener\u0103rii produsului cartezian a k mul\u021bimi {1,2,...,n}.  d) Gener\u0103rii submul\u021bimilor av\u00e2nd k elemente ale mul\u021bimii {1,2,...,n}.  e) Gener\u0103rii tuturor parti\u021biilor mul\u021bimii {1,2,...,n}.  f) Gener\u0103rii submul\u021bimilor av\u00e2nd cel pu\u021bin k elemente ale mul\u021bimii {1,2,...,n}.    12 .  Fie G un graf neorientat cu 10 v\u00e2rfuri \u0219i 8 muchii. Afirma\u021bia fals\u0103 este:  a) G nu poate fi conex  b) G poate avea mai multe cicluri elementare  c) G nu poate fi hamiltonian  d) G nu poate fi eulerian  e) G poate avea v\u00e2rfuri izolate (de grad 0)  f) G poate avea v\u00e2rfuri terminale (de grad 1)    13 .  Un arbore cu r\u0103d\u0103cin\u0103 cu 12 noduri are proprietatea c\u0103 exact 3 dintre nodurile sale au c\u00e2te  3 fii. Prin \u00een\u0103l\u021bimea unui arbore cu r\u0103d\u0103cin\u0103 \u00een\u021belegem num\u0103rul de muchii ale celui mai  lung lan\u021b care une\u0219te r\u0103d\u0103cina cu un alt nod. \u00cen\u0103l\u021bimea maxim\u0103 a arborelui este:  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    14 .  Subprogramul mysort de mai jos ordoneaz\u0103 cresc\u0103tor componentele \u00eentregi ale vectorului  v (declarat astfel \u00eenc\u00e2t s\u0103 poat\u0103 re\u021bine cel mult 100 de elemente, numerotate de la 0 la n- 1) dac\u0103 punctele de suspensie sunt \u00eenlocuite cu:", "sentences": ["162    10 .", " Apelul s(3) al subprogramului s definit mai jos va afi\u0219a pe ecran:  Limbajul C++/C  void s(int n)  {    int i;    if (n > 0)    {      for (i = 0; i < n; i++)      {        printf(\"%d\", i);        s(i - 1);      }      printf(\"%d\", n);    }  }  Limbajul Pascal  procedure s(n: integer);  var i: integer;  begin    if n > 0 then      begin        for i := 0 to n-1 do          begin            write(i);            s(i-1)          end;        write(n)      end  end;  a) 012301  b) 012031  c) 00120013  d) 01203  e) 0120013  f) 012013    11 .", " Rezolvarea problemei gener\u0103rii tuturor imaginilor func\u021biilor injective definite pe mul\u021bimea  {1,2,..,k} cu valori \u00een mul\u021bimea {1,2,..,n} prin metoda Backtracking necesit\u0103 ca  fiecare element ad\u0103ugat \u00een vectorul solu\u021bie s\u0103 respecte o condi\u021bie de compatibilitate cu cele  deja introduse.", "Aceea\u0219i condi\u021bie este respectat\u0103 \u00een cazul:  a) Gener\u0103rii tuturor submul\u021bimilor mul\u021bimii {1,2,...,n}.", " b) Gener\u0103rii tuturor permut\u0103rilor mul\u021bimii {1,2,...,n}.", " c) Gener\u0103rii produsului cartezian a k mul\u021bimi {1,2,...,n}.", " d) Gener\u0103rii submul\u021bimilor av\u00e2nd k elemente ale mul\u021bimii {1,2,...,n}.", " e) Gener\u0103rii tuturor parti\u021biilor mul\u021bimii {1,2,...,n}.", " f) Gener\u0103rii submul\u021bimilor av\u00e2nd cel pu\u021bin k elemente ale mul\u021bimii {1,2,...,n}.", "   12 .", " Fie G un graf neorientat cu 10 v\u00e2rfuri \u0219i 8 muchii.", "Afirma\u021bia fals\u0103 este:  a) G nu poate fi conex  b) G poate avea mai multe cicluri elementare  c) G nu poate fi hamiltonian  d) G nu poate fi eulerian  e) G poate avea v\u00e2rfuri izolate (de grad 0)  f) G poate avea v\u00e2rfuri terminale (de grad 1)    13 .", " Un arbore cu r\u0103d\u0103cin\u0103 cu 12 noduri are proprietatea c\u0103 exact 3 dintre nodurile sale au c\u00e2te  3 fii.", "Prin \u00een\u0103l\u021bimea unui arbore cu r\u0103d\u0103cin\u0103 \u00een\u021belegem num\u0103rul de muchii ale celui mai  lung lan\u021b care une\u0219te r\u0103d\u0103cina cu un alt nod.", "\u00cen\u0103l\u021bimea maxim\u0103 a arborelui este:  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    14 .", " Subprogramul mysort de mai jos ordoneaz\u0103 cresc\u0103tor componentele \u00eentregi ale vectorului  v (declarat astfel \u00eenc\u00e2t s\u0103 poat\u0103 re\u021bine cel mult 100 de elemente, numerotate de la 0 la n- 1) dac\u0103 punctele de suspensie sunt \u00eenlocuite cu:"], "page_sentence_count_spacy": 16}, {"page_number": 163, "page_char_count": 1323, "page_word_count": 467, "page_sentence_count_raw": 3, "page_token_count": 330.75, "text": "163    Limbajul C++/C  void mysort(int n,int  v[100])  {    int aux;    if (n > 1)    {      mysort(n - 1, v);      ...    }  }  Limbajul Pascal  procedure mysort      (n:integer; var v:vector);  var aux:integer;  begin    if n>1 then      begin        mysort(n - 1, v);        ...      end  end;    Observa\u021bie: Tipul vector a fost declarat anterior:    type vector = array [0..99]   of integer;  Limbajul C++/C  a)   if (v[n-2] > v[n-1])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  b)   if (v[n-2] < v[n-1])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  c)   int i;  for (i=0; i+1<n; i++)  {    if (v[i] > v[i+1])    {      aux = v[i];      v[i] = v[i+1];      v[i+1] = aux;    }  }  d)   int i;  for (i=n-1; i-1>=0; i--)  {    if (v[i] > v[i-1])    {      aux = v[i];      v[i] = v[i-1];      v[i-1] = aux;    }  }  e)   if (v[n] > v[n+1])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  f)   if (v[n+1] < v[n])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  Limbajul Pascal  a)   if v[n-2] > v[n-1] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;  b)   if v[n-2] < v[n-1] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;", "sentences": ["163    Limbajul C++/C  void mysort(int n,int  v[100])  {    int aux;    if (n > 1)    {      mysort(n - 1, v);      ...    }  }  Limbajul Pascal  procedure mysort      (n:integer; var v:vector);  var aux:integer;  begin    if n>1 then      begin        mysort(n - 1, v);        ...      end  end;    Observa\u021bie: Tipul vector a fost declarat anterior:    type vector = array [0..99]   of integer;  Limbajul C++/C  a)   if (v[n-2] > v[n-1])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  b)   if (v[n-2] < v[n-1])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  c)   int i;  for (i=0; i+1<n; i++)  {    if (v[i] > v[i+1])    {      aux = v[i];      v[i] = v[i+1];      v[i+1] = aux;    }  }  d)   int i;  for (i=n-1; i-1>=0; i--)  {    if (v[i] > v[i-1])    {      aux = v[i];      v[i] = v[i-1];      v[i-1] = aux;    }  }  e)   if (v[n] > v[n+1])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  f)   if (v[n+1] < v[n])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  Limbajul Pascal  a)   if v[n-2] > v[n-1] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;  b)   if v[n-2] < v[n-1] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;"], "page_sentence_count_spacy": 1}, {"page_number": 164, "page_char_count": 1774, "page_word_count": 628, "page_sentence_count_raw": 5, "page_token_count": 443.5, "text": "164        mysort(n-1, v)    end      mysort(n-1, v)    end  c)   for i:=0 to n-2 do    begin      if v[i] > v[i+1] then        begin          aux := v[i];          v[i] := v[i+1];          v[i+1] := aux        end    end  d)   for i:=n-1 downto 0 do    begin      if v[i] > v[i-1] then        begin          aux := v[i];          v[i] := v[i-1];          v[i-1] := aux        end    end  e)   if v[n] > v[n+1] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;      mysort(n-1, v)    end  f)   if v[n+1] < v[n] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;      mysort(n-1, v)    end    15 .  Fie un vector v care re\u021bine cele n cifre (v[0], v[1],\u2026, v[n-1]) ale unui num\u0103r  natural X \u0219i un num\u0103r natural k (k<n). Secven\u021ba de instruc\u021biuni de mai jos \u00ee\u0219i propune s\u0103  construiasc\u0103 vectorul s, care s\u0103 re\u021bin\u0103 cifrele celui mai mare num\u0103r natural Y care poate fi  ob\u021binut din X prin eliminarea a exact k cifre, f\u0103r\u0103 a schimba ordinea \u00een care cifrele ap\u0103reau  \u00een X. De exemplu, dac\u0103 n=8, k=3, v=(5, 1, 3, 5, 4, 4, 6, 9), corespunz\u0103tor  lui X=51354469, secven\u021ba de cod ar trebui s\u0103 construiasc\u0103 s=(5, 5, 4, 6, 9),  corespunz\u0103tor lui Y=55469. Pentru a ob\u021bine rezultatul dorit punctele de suspensie trebuie  \u00eenlocuite cu:  Limbajul C++/C           m = 0;    for (i = 0; i < n; i++)    {      while (m>0 && k>0 &&...)      {        m--;        k--;      }      s[m++] = v[i];    }    m -= k;  Limbajul Pascal  m := 0;  for i := 0 to n - 1 do    begin      while (m>0)and(k>0)and(...)                      do        begin          m := m - 1;          k := k - 1;        end;      s[m] := v[i];      m := m + 1    end;  m := m - k;  a) v[i]>v[i-1]  b) v[i]>=s[m-1]  c) v[i]>s[m-1]  d) v[i]<v[i-1]  e) v[i]<s[m-1]  f) v[i]<v[i+1]", "sentences": ["164        mysort(n-1, v)    end      mysort(n-1, v)    end  c)   for i:=0 to n-2 do    begin      if v[i] > v[i+1] then        begin          aux := v[i];          v[i] := v[i+1];          v[i+1] := aux        end    end  d)   for i:=n-1 downto 0 do    begin      if v[i] > v[i-1] then        begin          aux := v[i];          v[i] := v[i-1];          v[i-1] := aux        end    end  e)   if v[n] > v[n+1] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;      mysort(n-1, v)    end  f)   if v[n+1] < v[n] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;      mysort(n-1, v)    end    15 .", " Fie un vector v care re\u021bine cele n cifre (v[0], v[1],\u2026, v[n-1]) ale unui num\u0103r  natural X \u0219i un num\u0103r natural k (k<n).", "Secven\u021ba de instruc\u021biuni de mai jos \u00ee\u0219i propune s\u0103  construiasc\u0103 vectorul s, care s\u0103 re\u021bin\u0103 cifrele celui mai mare num\u0103r natural Y care poate fi  ob\u021binut din X prin eliminarea a exact k cifre, f\u0103r\u0103 a schimba ordinea \u00een care cifrele ap\u0103reau  \u00een X. De exemplu, dac\u0103 n=8, k=3, v=(5, 1, 3, 5, 4, 4, 6, 9), corespunz\u0103tor  lui X=51354469, secven\u021ba de cod ar trebui s\u0103 construiasc\u0103 s=(5, 5, 4, 6, 9),  corespunz\u0103tor lui Y=55469.", "Pentru a ob\u021bine rezultatul dorit punctele de suspensie trebuie  \u00eenlocuite cu:  Limbajul C++/C           m = 0;    for (i = 0; i < n; i++)    {      while (m>0 && k>0 &&...)      {        m--;        k--;      }      s[m++] = v[i];    }    m -= k;  Limbajul Pascal  m := 0;  for i := 0 to n - 1 do    begin      while (m>0)and(k>0)and(...)                      do        begin          m := m - 1;          k := k - 1;        end;      s[m] := v[i];      m := m + 1    end;  m := m - k;  a) v[i]>v[i-1]  b) v[i]>=s[m-1]  c) v[i]>s[m-1]  d) v[i]<v[i-1]  e) v[i]<s[m-1]  f) v[i]<v[i+1]"], "page_sentence_count_spacy": 4}, {"page_number": 165, "page_char_count": 1797, "page_word_count": 410, "page_sentence_count_raw": 9, "page_token_count": 449.25, "text": "165    Varianta 29     1. R\u0103sturnatul tabloului unidimensional (2 4 1 3 7 0 5) este (5 0 7 3 1 4 2).   Num\u0103rul necesar de interschimb\u0103ri pentru a r\u0103sturna un tablou unidimensional cu n  (num\u0103r natural nenul, impar) elemente este:  a) 1  b) n/2+1  c) (n-1)/2  d) (n+1)/2  e) n/2-1  f) n    2. Dup\u0103 permutarea circular\u0103 spre st\u00e2nga cu 2 pozi\u021bii, tabloul unidimensional (18 91 1  15 102) devine:  a) (102 15 18 91 1)  b) (1 15 102 18 91)  c) (1 15 102 91 18)  d) (15 102 18 91 1)  e) (91 1 15 102 18)  f) (1 15 102)    3. \u00cen \u0219irurile de mai jos, elementul de pe pozi\u021bia k reprezint\u0103 r\u00e2ndul pe care este a\u0219ezat\u0103 a  k-a dam\u0103 (regin\u0103) pe o tabl\u0103 de \u0219ah, damele fiind a\u015fezate pe coloane distincte (dama 1  pe coloana 1, dama 2 pe coloana 2, \u015f.a.m.d.).  Pentru a a\u0219eza 4 dame (regine) pe o tabl\u0103 de \u0219ah 4x4, astfel \u00eenc\u00e2t acestea s\u0103 nu se atace  \u00eentre ele (dou\u0103 dame se atac\u0103 atunci c\u00e2nd se afl\u0103 pe aceea\u0219i linie, pe aceea\u0219i coloan\u0103 sau  pe aceea\u0219i diagonal\u0103), o solu\u021bie corect\u0103 este:  a) 4 3 2 1  b) 4 2 3 1  c) 3 1 4 2  d) 2 3 1 4  e) 2 1 3 4  f) 1 2 3 4    4. Pentru a sorta cresc\u0103tor tabloul unidimensional (10 24 9 11 33 7 15), folosind  BubbleSort, num\u0103rul de interschimb\u0103ri necesare este:  a) 9  b) 10  c) 11  d) 12  e) 13  f) 14    5. Cu ajutorul metodei backtracking se genereaz\u0103, \u00een ordine cresc\u0103toare, numere cu  propriet\u0103\u021bile:  -  au exact cinci cifre;  -  cifrele de pe pozi\u021bii consecutive sunt \u00een ordine strict cresc\u0103toare;  -  au cel mult dou\u0103 cifre al\u0103turate de aceea\u0219i paritate;  Exemplu de numere generate: 13469, 14589.  O secven\u021b\u0103 care con\u021bine cinci numere generate consecutiv este:  a) 45678 45679 45689 46789 56789  b) 34789 35678 35679 35689 45678  c) 34578 34569 34568 34567 26789  d) 13458 13459 13467 13478 13479  e) 13458 13459 13467 13468 13469  f) 26789 34567 34568 34569 34578", "sentences": ["165    Varianta 29     1.", "R\u0103sturnatul tabloului unidimensional (2 4 1 3 7 0 5) este (5 0 7 3 1 4 2).", "  Num\u0103rul necesar de interschimb\u0103ri pentru a r\u0103sturna un tablou unidimensional cu n  (num\u0103r natural nenul, impar) elemente este:  a) 1  b) n/2+1  c) (n-1)/2  d) (n+1)/2  e) n/2-1  f) n    2.", "Dup\u0103 permutarea circular\u0103 spre st\u00e2nga cu 2 pozi\u021bii, tabloul unidimensional (18 91 1  15 102) devine:  a) (102 15 18 91 1)  b) (1 15 102 18 91)  c) (1 15 102 91 18)  d) (15 102 18 91 1)  e) (91 1 15 102 18)  f) (1 15 102)    3.", "\u00cen \u0219irurile de mai jos, elementul de pe pozi\u021bia k reprezint\u0103 r\u00e2ndul pe care este a\u0219ezat\u0103 a  k-a dam\u0103 (regin\u0103) pe o tabl\u0103 de \u0219ah, damele fiind a\u015fezate pe coloane distincte (dama 1  pe coloana 1, dama 2 pe coloana 2, \u015f.a.m.d.).", " Pentru a a\u0219eza 4 dame (regine) pe o tabl\u0103 de \u0219ah 4x4, astfel \u00eenc\u00e2t acestea s\u0103 nu se atace  \u00eentre ele (dou\u0103 dame se atac\u0103 atunci c\u00e2nd se afl\u0103 pe aceea\u0219i linie, pe aceea\u0219i coloan\u0103 sau  pe aceea\u0219i diagonal\u0103), o solu\u021bie corect\u0103 este:  a) 4 3 2 1  b) 4 2 3 1  c) 3 1 4 2  d) 2 3 1 4  e) 2 1 3 4  f) 1 2 3 4    4.", "Pentru a sorta cresc\u0103tor tabloul unidimensional (10 24 9 11 33 7 15), folosind  BubbleSort, num\u0103rul de interschimb\u0103ri necesare este:  a) 9  b) 10  c) 11  d) 12  e) 13  f) 14    5.", "Cu ajutorul metodei backtracking se genereaz\u0103, \u00een ordine cresc\u0103toare, numere cu  propriet\u0103\u021bile:  -  au exact cinci cifre;  -  cifrele de pe pozi\u021bii consecutive sunt \u00een ordine strict cresc\u0103toare;  -  au cel mult dou\u0103 cifre al\u0103turate de aceea\u0219i paritate;  Exemplu de numere generate: 13469, 14589.", " O secven\u021b\u0103 care con\u021bine cinci numere generate consecutiv este:  a) 45678 45679 45689 46789 56789  b) 34789 35678 35679 35689 45678  c) 34578 34569 34568 34567 26789  d) 13458 13459 13467 13478 13479  e) 13458 13459 13467 13468 13469  f) 26789 34567 34568 34569 34578"], "page_sentence_count_spacy": 9}, {"page_number": 166, "page_char_count": 1094, "page_word_count": 351, "page_sentence_count_raw": 4, "page_token_count": 273.5, "text": "166    6. Pentru func\u021bia f definit\u0103 mai jos, valoarea returnat\u0103 de apelul f(2019,2347); este:  Limbajul C++/C  int f(int a, int b)  {      int cif;      if (a+b>0)      {          cif=a%10;          if (cif<b%10)              cif=b%10;          return f(a/10, b/10)*10+cif;      }      return 0;  }  Limbajul Pascal  function f(a,b: integer):integer;  var cif:integer;  begin      if (a+b>0) then      begin          cif:=a mod 10;          if (cif < b mod 10) then                  cif:=b mod 10;          f:=f(a div 10, b div 10)*10+cif      end      else         f:=0  end;  a) 349  b) 2017  c) 2349  d) 7102  e) 9432  f) 9743    7. Pentru tabloul unidimensional  (4, 6, 14, 25, 61, 73, 82, 87, 95, 96, 98) num\u0103rul  minim de elemente ale tabloului care trebuie verificate p\u00e2n\u0103 este g\u0103sit elementul 82 este:  a) 7  b) 6  c) 5  d) 3  e) 2  f) 1    8. \u00cen urma execut\u0103rii programului de mai jos, variabila k are valoarea:   Limbajul C++/C  #include <iostream>  int k=1;  int f(int n)  {      int k;  Limbajul Pascal   program p;  function f(n: integer):integer;  var k:integer;  begin    k:=k+2;", "sentences": ["166    6.", "Pentru func\u021bia f definit\u0103 mai jos, valoarea returnat\u0103 de apelul f(2019,2347); este:  Limbajul C++/C  int f(int a, int b)  {      int cif;      if (a+b>0)      {          cif=a%10;          if (cif<b%10)              cif=b%10;          return f(a/10, b/10)*10+cif;      }      return 0;  }  Limbajul Pascal  function f(a,b: integer):integer;  var cif:integer;  begin      if (a+b>0) then      begin          cif:=a mod 10;          if (cif < b mod 10) then                  cif:=b mod 10;          f:=f(a div 10, b div 10)*10+cif      end      else         f:=0  end;  a) 349  b) 2017  c) 2349  d) 7102  e) 9432  f) 9743    7.", "Pentru tabloul unidimensional  (4, 6, 14, 25, 61, 73, 82, 87, 95, 96, 98) num\u0103rul  minim de elemente ale tabloului care trebuie verificate p\u00e2n\u0103 este g\u0103sit elementul 82 este:  a) 7  b) 6  c) 5  d) 3  e) 2  f) 1    8.", "\u00cen urma execut\u0103rii programului de mai jos, variabila k are valoarea:   Limbajul C++/C  #include <iostream>  int k=1;  int f(int n)  {      int k;  Limbajul Pascal   program p;  function f(n: integer):integer;  var k:integer;  begin    k:=k+2;"], "page_sentence_count_spacy": 4}, {"page_number": 167, "page_char_count": 1588, "page_word_count": 374, "page_sentence_count_raw": 12, "page_token_count": 397.0, "text": "167        k=k+2;      return k;  }  int main()  {      k=f(k);      return 0;  }    f:=k  end;  var k:integer;  begin    k:=1;    k:=f(k)  end.  a) 0  b) 1  c) 2  d) 3  e) nedefinit\u0103  f) nicio valoare, programul are erori    9. Num\u0103rul elementelor care se g\u0103sesc strict deasupra diagonalei secundare a unui tablou  bidimensional cu 20 de linii \u0219i 20 de coloane este:  a) 180  b) 190  c) 200  d) 210  e) 380  f) 400    10. Problema Turnurile din Hanoi:  Se dau 3 tije. Pe prima tij\u0103 se g\u0103sesc discuri de diametre diferite, a\u015fezate \u00een ordinea  descresc\u0103toare a diametrelor privite de jos \u00een sus. Se cere s\u0103 se mute discurile de pe prima  tij\u0103 pe cea de-a doua, utiliz\u00e2nd ca tij\u0103 intermediar\u0103 cea de-a treia, respect\u00e2nd urm\u0103toarele  reguli:  \u25cf la fiecare pas se mut\u0103 un singur disc;  \u25cf nu este permis s\u0103 se a\u015feze un disc cu diametrul mai mare peste un disc cu  diametrul mai mic.  Num\u0103rul minim de mut\u0103ri necesare rezolv\u0103rii problemei Turnurile din Hanoi pentru 10  discuri este:  a) 99  b) 100  c) 1022  d) 1023  e) 1024  f) 1025    11. \u00centr-un graf orientat cu 56 de arce, \u00een care oricare arc are extremit\u0103\u021bi distincte \u015fi oricare  dou\u0103 arce difer\u0103 prin cel pu\u0163in una dintre extremit\u0103\u0163i, num\u0103rul minim de v\u00e2rfuri este:  a) 6  b) 7  c) 8  d) 28  e) 56  f) 112    12. Fie problema:  Se dau n-1 numere naturale distincte de la 1 la n (1<n<105). Se cere un algoritm care  s\u0103 determine num\u0103rul lips\u0103.  Fie algoritmii:  A1: Se verific\u0103 prin c\u00e2te o parcurgere prezen\u021ba fiec\u0103rui num\u0103r de la 1 la n \u00een \u0219ir.  A2: Num\u0103rul lips\u0103 este egal cu diferen\u021ba dintre [n\u00b7(n + 1 )/2] \u0219i suma numerelor  din \u0219ir.", "sentences": ["167        k=k+2;      return k;  }  int main()  {      k=f(k);      return 0;  }    f:=k  end;  var k:integer;  begin    k:=1;    k:=f(k)  end.", " a) 0  b) 1  c) 2  d) 3  e) nedefinit\u0103  f) nicio valoare, programul are erori    9.", "Num\u0103rul elementelor care se g\u0103sesc strict deasupra diagonalei secundare a unui tablou  bidimensional cu 20 de linii \u0219i 20 de coloane este:  a) 180  b) 190  c) 200  d) 210  e) 380  f) 400    10.", "Problema Turnurile din Hanoi:  Se dau 3 tije.", "Pe prima tij\u0103 se g\u0103sesc discuri de diametre diferite, a\u015fezate \u00een ordinea  descresc\u0103toare a diametrelor privite de jos \u00een sus.", "Se cere s\u0103 se mute discurile de pe prima  tij\u0103 pe cea de-a doua, utiliz\u00e2nd ca tij\u0103 intermediar\u0103 cea de-a treia, respect\u00e2nd urm\u0103toarele  reguli:  \u25cf la fiecare pas se mut\u0103 un singur disc;  \u25cf nu este permis s\u0103 se a\u015feze un disc cu diametrul mai mare peste un disc cu  diametrul mai mic.", " Num\u0103rul minim de mut\u0103ri necesare rezolv\u0103rii problemei Turnurile din Hanoi pentru 10  discuri este:  a) 99  b) 100  c) 1022  d) 1023  e) 1024  f) 1025    11.", "\u00centr-un graf orientat cu 56 de arce, \u00een care oricare arc are extremit\u0103\u021bi distincte \u015fi oricare  dou\u0103 arce difer\u0103 prin cel pu\u0163in una dintre extremit\u0103\u0163i, num\u0103rul minim de v\u00e2rfuri este:  a) 6  b) 7  c) 8  d) 28  e) 56  f) 112    12.", "Fie problema:  Se dau n-1 numere naturale distincte de la 1 la n (1<n<105).", "Se cere un algoritm care  s\u0103 determine num\u0103rul lips\u0103.", " Fie algoritmii:  A1: Se verific\u0103 prin c\u00e2te o parcurgere prezen\u021ba fiec\u0103rui num\u0103r de la 1 la n \u00een \u0219ir.", " A2: Num\u0103rul lips\u0103 este egal cu diferen\u021ba dintre [n\u00b7(n + 1 )/2] \u0219i suma numerelor  din \u0219ir."], "page_sentence_count_spacy": 12}, {"page_number": 168, "page_char_count": 1831, "page_word_count": 377, "page_sentence_count_raw": 14, "page_token_count": 457.75, "text": "168    A3: Se sorteaz\u0103 numerele \u0219i se determin\u0103 pentru ce valori consecutive \u00een \u0219irul sortat  diferen\u021ba este diferit\u0103 de 1.  A4: Se sorteaz\u0103 cresc\u0103tor numerele \u0219i se determin\u0103 prima valoare din \u0219irul sortat care este  diferit\u0103 de pozi\u021bia \u00een \u0219ir.  Este adev\u0103rat enun\u021bul:  a) Algoritmii A1 \u0219i A2 rezolv\u0103 problema pentru anumite date de intrare.  b) Algoritmul A2 este cel mai pu\u021bin eficient din punctul de vedere al timpului de  executare.  c) Algoritmul A4 este cel mai eficient din punctul de vedere al timpului de executare.  d) Algoritmul A4 rezolv\u0103 problema doar dac\u0103 num\u0103rul lips\u0103 este cel mai mare din \u0219ir.  e) Cel pu\u021bin unul dintre algoritmi nu rezolv\u0103 problema.  f) Doi dintre algoritmi nu difer\u0103 ca eficien\u021b\u0103 din punctul de vedere al timpului de  executare.    13. Fie enun\u021burile:  E1: orice graf neorientat conex G cu cel pu\u021bin 2 noduri, con\u021bine cel pu\u021bin un nod k care  poate fi eliminat (\u0219i muchiile incidente cu el) ob\u021bin\u00e2ndu-se un subgraf G\u2019 conex;  E2: un graf neorientat cu n (n>2) noduri \u0219i n muchii con\u021bine cel pu\u021bin un ciclu;  E3: orice arbore cu n (n>1) noduri con\u021bine cel pu\u021bin dou\u0103 noduri cu gradul 1.   Enun\u021burile adev\u0103rate sunt:  a) doar E1  b) doar E2  c) doar E1 \u0219i E2  d) doar E1 \u0219i E3  e) doar E2 \u0219i E3  f) E1, E2 \u0219i E3    14. \u00cen urma execut\u0103rii unui program pentru generarea permut\u0103rilor elementelor unui \u0219ir de  caractere ce con\u021bine duplicate, num\u0103rul de cuvinte distincte, anagrame ale cuv\u00e2ntului  \u201ccaracter\u201d, este:  a) 120  b) 2520  c) 5040  d) 10080  e) 20160  f) 40320    15. Fie urm\u0103toarele formule:  1.    \u0218tiind c\u0103 \ud835\udc39(1) = 1, \ud835\udc39(2) = 1, pentru a determina al n-lea (n>2) termen din \u0219irul lui  Fibonacci (1, 1, 2, 3, 5, 8, ...) se poate folosi:  a) niciuna dintre cele trei formule  b) doar formula 1  c) doar formula 2  d) doar formula 1 \u0219i formula 2  e) doar formula 3  f) toate cele trei formule", "sentences": ["168    A3: Se sorteaz\u0103 numerele \u0219i se determin\u0103 pentru ce valori consecutive \u00een \u0219irul sortat  diferen\u021ba este diferit\u0103 de 1.", " A4: Se sorteaz\u0103 cresc\u0103tor numerele \u0219i se determin\u0103 prima valoare din \u0219irul sortat care este  diferit\u0103 de pozi\u021bia \u00een \u0219ir.", " Este adev\u0103rat enun\u021bul:  a) Algoritmii A1 \u0219i A2 rezolv\u0103 problema pentru anumite date de intrare.", " b) Algoritmul A2 este cel mai pu\u021bin eficient din punctul de vedere al timpului de  executare.", " c) Algoritmul A4 este cel mai eficient din punctul de vedere al timpului de executare.", " d) Algoritmul A4 rezolv\u0103 problema doar dac\u0103 num\u0103rul lips\u0103 este cel mai mare din \u0219ir.", " e) Cel pu\u021bin unul dintre algoritmi nu rezolv\u0103 problema.", " f) Doi dintre algoritmi nu difer\u0103 ca eficien\u021b\u0103 din punctul de vedere al timpului de  executare.", "   13.", "Fie enun\u021burile:  E1: orice graf neorientat conex G cu cel pu\u021bin 2 noduri, con\u021bine cel pu\u021bin un nod k care  poate fi eliminat (\u0219i muchiile incidente cu el) ob\u021bin\u00e2ndu-se un subgraf G\u2019 conex;  E2: un graf neorientat cu n (n>2) noduri \u0219i n muchii con\u021bine cel pu\u021bin un ciclu;  E3: orice arbore cu n (n>1) noduri con\u021bine cel pu\u021bin dou\u0103 noduri cu gradul 1.", "  Enun\u021burile adev\u0103rate sunt:  a) doar E1  b) doar E2  c) doar E1 \u0219i E2  d) doar E1 \u0219i E3  e) doar E2 \u0219i E3  f) E1, E2 \u0219i E3    14.", "\u00cen urma execut\u0103rii unui program pentru generarea permut\u0103rilor elementelor unui \u0219ir de  caractere ce con\u021bine duplicate, num\u0103rul de cuvinte distincte, anagrame ale cuv\u00e2ntului  \u201ccaracter\u201d, este:  a) 120  b) 2520  c) 5040  d) 10080  e) 20160  f) 40320    15.", "Fie urm\u0103toarele formule:  1.", "   \u0218tiind c\u0103 \ud835\udc39(1) = 1, \ud835\udc39(2) = 1, pentru a determina al n-lea (n>2) termen din \u0219irul lui  Fibonacci (1, 1, 2, 3, 5, 8, ...) se poate folosi:  a) niciuna dintre cele trei formule  b) doar formula 1  c) doar formula 2  d) doar formula 1 \u0219i formula 2  e) doar formula 3  f) toate cele trei formule"], "page_sentence_count_spacy": 14}, {"page_number": 169, "page_char_count": 1930, "page_word_count": 407, "page_sentence_count_raw": 11, "page_token_count": 482.5, "text": "169      Varianta 30    1. R\u0103sturnatul tabloului unidimensional (2 4 1 3 7 0) este (0 7 3 1 4 2).  Num\u0103rul necesar de interschimb\u0103ri pentru a r\u0103sturna un tabloul unidimensional cu n  (num\u0103r natural nenul, par) elemente este:  a) 1  b) n/2-1  c) n/2  d) (n-1)/2  e) n/2+1  f) n    2. Pentru a permuta, eficient din punctul de vedere al memoriei utilizate, circular spre  dreapta cu k pozi\u021bii elementele unui tablou unidimensional cu n numere \u00eentregi (n, k  numere naturale nenule, k\u2264n) este necesar un spa\u021biu suplimentar de memorie de:  a) n\u2219k elemente  b) n elemente  c) k elemente  d) 0 elemente  e) 2\u2219n elemente  f) 2\u2219k elemente    3. Num\u0103rul solu\u021biilor de a\u0219ezare a 3 dame (regine) pe o tabl\u0103 de \u0219ah 3x3, astfel \u00eenc\u00e2t acestea  s\u0103 nu se atace \u00eentre ele (dou\u0103 dame se atac\u0103 atunci c\u00e2nd se afl\u0103 pe aceea\u0219i linie, pe aceea\u0219i  coloan\u0103 sau pe aceea\u0219i diagonal\u0103), este:  a) 5  b) 4  c) 3  d) 2  e) 1  f) 0    4. Un graf este memorat printr-o matrice de adiacen\u021b\u0103 cu x+5 linii \u0219i y+3 coloane. Valorile  lui x \u0219i respectiv y ar putea fi:  a) 5 3  b) 3 5  c) 1 4  d) 4 1  e) 2 2  f) 2 1    5. dc(a,b) reprezint\u0103 o func\u021bie care determin\u0103 cel mai mare divizor comun al numerelor  naturale a \u0219i b iar a mod b reprezint\u0103 restul \u00eemp\u0103r\u021birii num\u0103rului \u00eentreg a la num\u0103rul  \u00eentreg nenul b.  O formul\u0103 recursiv\u0103 pentru determinarea celui mai mare divizor comun a dou\u0103 numere x  \u0219i y este:  a) dc(x,y)=dc(x*y,y)  b) dc(x,y)=dc(x mod y,x)  c) dc(x,y)=dc(y,x*y)  d) dc(x,y)=dc(x,x mod y)  e) dc(x,y)=dc(y,x mod y) f) dc(x,y)=dc(x mod x,y mod y)    6. Fie un tablou unidimensional. Algoritmul de sortare rapid\u0103 (quick sort) \u00eemparte tabloul  \u00een:  a) 2 subtablouri, \u00eentotdeauna cu acela\u0219i num\u0103r de elemente  b) 2 subtablouri, nu \u00eentotdeauna cu acela\u0219i num\u0103r de elemente  c) 3 subtablouri, \u00eentotdeauna cu acela\u0219i num\u0103r de elemente  d) 3 subtablouri, nu \u00eentotdeauna cu acela\u0219i num\u0103r de elemente  e) 4 subtablouri, \u00eentotdeauna cu acela\u0219i num\u0103r de elemente", "sentences": ["169      Varianta 30    1.", "R\u0103sturnatul tabloului unidimensional (2 4 1 3 7 0) este (0 7 3 1 4 2).", " Num\u0103rul necesar de interschimb\u0103ri pentru a r\u0103sturna un tabloul unidimensional cu n  (num\u0103r natural nenul, par) elemente este:  a) 1  b) n/2-1  c) n/2  d) (n-1)/2  e) n/2+1  f) n    2.", "Pentru a permuta, eficient din punctul de vedere al memoriei utilizate, circular spre  dreapta cu k pozi\u021bii elementele unui tablou unidimensional cu n numere \u00eentregi (n, k  numere naturale nenule, k\u2264n) este necesar un spa\u021biu suplimentar de memorie de:  a) n\u2219k elemente  b) n elemente  c) k elemente  d) 0 elemente  e) 2\u2219n elemente  f) 2\u2219k elemente    3.", "Num\u0103rul solu\u021biilor de a\u0219ezare a 3 dame (regine) pe o tabl\u0103 de \u0219ah 3x3, astfel \u00eenc\u00e2t acestea  s\u0103 nu se atace \u00eentre ele (dou\u0103 dame se atac\u0103 atunci c\u00e2nd se afl\u0103 pe aceea\u0219i linie, pe aceea\u0219i  coloan\u0103 sau pe aceea\u0219i diagonal\u0103), este:  a) 5  b) 4  c) 3  d) 2  e) 1  f) 0    4.", "Un graf este memorat printr-o matrice de adiacen\u021b\u0103 cu x+5 linii \u0219i y+3 coloane.", "Valorile  lui x \u0219i respectiv y ar putea fi:  a) 5 3  b) 3 5  c) 1 4  d) 4 1  e) 2 2  f) 2 1    5.", "dc(a,b) reprezint\u0103 o func\u021bie care determin\u0103 cel mai mare divizor comun al numerelor  naturale a \u0219i b iar a mod b reprezint\u0103 restul \u00eemp\u0103r\u021birii num\u0103rului \u00eentreg a la num\u0103rul  \u00eentreg nenul b.  O formul\u0103 recursiv\u0103 pentru determinarea celui mai mare divizor comun a dou\u0103 numere x  \u0219i y este:  a) dc(x,y)=dc(x*y,y)  b) dc(x,y)=dc(x mod y,x)  c) dc(x,y)=dc(y,x*y)  d) dc(x,y)=dc(x,x mod y)  e) dc(x,y)=dc(y,x mod y) f) dc(x,y)=dc(x mod x,y mod y)    6.", "Fie un tablou unidimensional.", "Algoritmul de sortare rapid\u0103 (quick sort) \u00eemparte tabloul  \u00een:  a) 2 subtablouri, \u00eentotdeauna cu acela\u0219i num\u0103r de elemente  b) 2 subtablouri, nu \u00eentotdeauna cu acela\u0219i num\u0103r de elemente  c) 3 subtablouri, \u00eentotdeauna cu acela\u0219i num\u0103r de elemente  d) 3 subtablouri, nu \u00eentotdeauna cu acela\u0219i num\u0103r de elemente  e) 4 subtablouri, \u00eentotdeauna cu acela\u0219i num\u0103r de elemente"], "page_sentence_count_spacy": 10}, {"page_number": 170, "page_char_count": 1520, "page_word_count": 347, "page_sentence_count_raw": 10, "page_token_count": 380.0, "text": "170    f) 4 subtablouri, nu \u00eentotdeauna cu acela\u0219i num\u0103r de elemente    7. Fie \u0219irul de caractere tablou. R\u0103sturnatul acestui \u0219ir este uolbat.  Structura de date cea mai adecvat\u0103 \u00een care se poate memora un \u0219ir de caractere pentru a-l  folosi r\u0103sturnat este:  a) arbore  b) coad\u0103  c) graf orientat  d) o coad\u0103 \u0219i un graf orientat  e) stiv\u0103  f) o coad\u0103 \u0219i un graf neorientat    8. \u00cen programul de mai jos subprogramul f este definit incomplet.  Limbajul C++/C  void f(int n)  {  if(n!=0)  {   cout<<n;|printf(\"%d\",n);     ........  }  }  Limbajul Pascal  procedure f(n:integer);  begin  if (n<>0) then  begin  writeln(n);  ...........  end  end;  Instruc\u021biunea cu care se pot \u00eenlocui punctele de suspensie astfel \u00eenc\u00e2t dup\u0103 apelul f(n)  din programul principal executarea s\u0103 se \u00eencheie f\u0103r\u0103 niciun fel de eroare, indiferent de  valoarea \u00eentreag\u0103 a parametrului, este:  Limbajul C++/C  Limbajul Pascal  a) f(n-2);  b) f(n-1);  a) f(n-2)  b) f(n-1)  c) f(n%2);  d) f(n/2);  c) f(n mod 2)  d) f(n div 2)  e) f(n+2);  f) f(n*2);  e) f(n+2)  f) f(n*2)    9. Subprogramele f \u0219i s sunt definite mai jos.  Limbajul C++/C  int f(int x)  {  x=x+1;  return x;  }  int s(int x, int y)  {  return x+y;  }  Limbajul Pascal  function f(x: integer): integer;  begin       x:=x+1;       f:=x  end;  function s(x,y: integer): integer;  begin       s:=x+y  end;  \u00cen urma execut\u0103rii instruc\u021biunii   Limbajul C++/C  z=s(f(1),f(1));  Limbajul Pascal  z:=s(f(1),f(1));  variabila de tip \u00eentreg z are valoarea:  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5", "sentences": ["170    f) 4 subtablouri, nu \u00eentotdeauna cu acela\u0219i num\u0103r de elemente    7.", "Fie \u0219irul de caractere tablou.", "R\u0103sturnatul acestui \u0219ir este uolbat.", " Structura de date cea mai adecvat\u0103 \u00een care se poate memora un \u0219ir de caractere pentru a-l  folosi r\u0103sturnat este:  a) arbore  b) coad\u0103  c) graf orientat  d) o coad\u0103 \u0219i un graf orientat  e) stiv\u0103  f) o coad\u0103 \u0219i un graf neorientat    8.", "\u00cen programul de mai jos subprogramul f este definit incomplet.", " Limbajul C++/C  void f(int n)  {  if(n!=0)  {   cout<<n;|printf(\"%d\",n);     ........  }  }  Limbajul Pascal  procedure f(n:integer);  begin  if (n<>0) then  begin  writeln(n);  ...........  end  end;  Instruc\u021biunea cu care se pot \u00eenlocui punctele de suspensie astfel \u00eenc\u00e2t dup\u0103 apelul f(n)  din programul principal executarea s\u0103 se \u00eencheie f\u0103r\u0103 niciun fel de eroare, indiferent de  valoarea \u00eentreag\u0103 a parametrului, este:  Limbajul C++/C  Limbajul Pascal  a) f(n-2);  b) f(n-1);  a) f(n-2)  b) f(n-1)  c) f(n%2);  d) f(n/2);  c) f(n mod 2)  d) f(n div 2)  e) f(n+2);  f) f(n*2);  e) f(n+2)  f) f(n*2)    9.", "Subprogramele f \u0219i s sunt definite mai jos.", " Limbajul C++/C  int f(int x)  {  x=x+1;  return x;  }  int s(int x, int y)  {  return x+y;  }  Limbajul Pascal  function f(x: integer): integer;  begin       x:=x+1;       f:=x  end;  function s(x,y: integer): integer;  begin       s:=x+y  end;  \u00cen urma execut\u0103rii instruc\u021biunii   Limbajul C++/C  z=s(f(1),f(1));  Limbajul Pascal  z:=s(f(1),f(1));  variabila de tip \u00eentreg z are valoarea:  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5"], "page_sentence_count_spacy": 8}, {"page_number": 171, "page_char_count": 1746, "page_word_count": 381, "page_sentence_count_raw": 14, "page_token_count": 436.5, "text": "171      10. \u00cen mul\u021bimea de numere naturale de la 101 la 200 num\u0103rul celor care nu sunt divizibile  cu niciuna dintre valorile 2, 3 \u0219i 5 este:  a) 25  b) 26  c) 27  d) 28  e) 29  f) 30    11. \u00cen urma execut\u0103rii unui program pentru generarea permut\u0103rilor elementelor unui \u0219ir care  con\u021bine elemente care apar de mai multe ori, rezultatul permut\u0103rii elementelor \u0219irului de  caractere \u201cxx\u201d, este:  a) xx  b) xx, xx  c) x, x  d) x  e) x, xx  f) xx, x    12. Cu ajutorul metodei backtracking se genereaz\u0103, \u00een ordine cresc\u0103toare, numere naturale cu  propriet\u0103\u021bile:  -  au exact cinci cifre;  -  cifrele de pe pozi\u021bii consecutive sunt \u00een ordine strict cresc\u0103toare;  -  au cel mult dou\u0103 cifre al\u0103turate de aceea\u0219i paritate;  Exemplu de numere generate: 13469, 14589.  Fie urm\u0103toarele enun\u021buri:  1. se genereaz\u0103 cel mult 27 de numere cu prima cifr\u0103 2;  2. se genereaz\u0103 exact \u0219ase numere de forma \ud835\udc56\ud835\udc5d\ud835\udc5d\ud835\udc56\ud835\udc56, unde i este o cifr\u0103 impar\u0103 iar p  este o cifr\u0103 par\u0103;  3. exist\u0103 numere generate care s\u0103 aib\u0103 patru cifre de aceea\u0219i paritate;  4. cifrele 2 \u0219i 7 nu pot ap\u0103rea pe pozi\u021bii consecutive \u00een numerele generate;  5. \u00een numerele generate cifra 1 apare pe prima pozi\u021bie de exact acela\u0219i num\u0103r de ori  cum cifra 9 apare pe ultima pozi\u021bie.  Num\u0103rul de enun\u021buri adev\u0103rate este:  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    13. Num\u0103rul ciclurilor hamiltoniene distincte \u00eentr-un graf neorientat complet \ud835\udc3e\ud835\udc5b, cu \ud835\udc5b\u22653  noduri, este:  a) 2n(n-1)/2  b) 4n(n-1)/2  c) (n-1)!  d) (n-1)!/2  e) (n+1)!/2  f) n!/2    14. Un graf orientat este complet dac\u0103 oricare dou\u0103 v\u00e2rfuri distincte ale sale sunt adiacente.   Dac\u0103 num\u0103rul de grafuri orientate complete ce se pot ob\u021bine cu n v\u00e2rfuri este 59049,  valoarea lui n este:  a) 4  b) 5  c) 6  d) 7  e) 8  f) 9    Fie urm\u0103toarele rela\u021bii:", "sentences": ["171      10.", "\u00cen mul\u021bimea de numere naturale de la 101 la 200 num\u0103rul celor care nu sunt divizibile  cu niciuna dintre valorile 2, 3 \u0219i 5 este:  a) 25  b) 26  c) 27  d) 28  e) 29  f) 30    11.", "\u00cen urma execut\u0103rii unui program pentru generarea permut\u0103rilor elementelor unui \u0219ir care  con\u021bine elemente care apar de mai multe ori, rezultatul permut\u0103rii elementelor \u0219irului de  caractere \u201cxx\u201d, este:  a) xx  b) xx, xx  c) x, x  d) x  e) x, xx  f) xx, x    12.", "Cu ajutorul metodei backtracking se genereaz\u0103, \u00een ordine cresc\u0103toare, numere naturale cu  propriet\u0103\u021bile:  -  au exact cinci cifre;  -  cifrele de pe pozi\u021bii consecutive sunt \u00een ordine strict cresc\u0103toare;  -  au cel mult dou\u0103 cifre al\u0103turate de aceea\u0219i paritate;  Exemplu de numere generate: 13469, 14589.", " Fie urm\u0103toarele enun\u021buri:  1.", "se genereaz\u0103 cel mult 27 de numere cu prima cifr\u0103 2;  2.", "se genereaz\u0103 exact \u0219ase numere de forma \ud835\udc56\ud835\udc5d\ud835\udc5d\ud835\udc56\ud835\udc56, unde i este o cifr\u0103 impar\u0103 iar p  este o cifr\u0103 par\u0103;  3.", "exist\u0103 numere generate care s\u0103 aib\u0103 patru cifre de aceea\u0219i paritate;  4.", "cifrele 2 \u0219i 7 nu pot ap\u0103rea pe pozi\u021bii consecutive \u00een numerele generate;  5.", "\u00een numerele generate cifra 1 apare pe prima pozi\u021bie de exact acela\u0219i num\u0103r de ori  cum cifra 9 apare pe ultima pozi\u021bie.", " Num\u0103rul de enun\u021buri adev\u0103rate este:  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    13.", "Num\u0103rul ciclurilor hamiltoniene distincte \u00eentr-un graf neorientat complet \ud835\udc3e\ud835\udc5b, cu \ud835\udc5b\u22653  noduri, este:  a) 2n(n-1)/2  b) 4n(n-1)/2  c) (n-1)!", " d) (n-1)!/2  e) (n+1)!/2  f) n!/2    14.", "Un graf orientat este complet dac\u0103 oricare dou\u0103 v\u00e2rfuri distincte ale sale sunt adiacente.", "  Dac\u0103 num\u0103rul de grafuri orientate complete ce se pot ob\u021bine cu n v\u00e2rfuri este 59049,  valoarea lui n este:  a) 4  b) 5  c) 6  d) 7  e) 8  f) 9    Fie urm\u0103toarele rela\u021bii:"], "page_sentence_count_spacy": 15}, {"page_number": 172, "page_char_count": 581, "page_word_count": 159, "page_sentence_count_raw": 5, "page_token_count": 145.25, "text": "172    15. \ud835\udc381: \ud835\udc39 \ud835\udc5d(\ud835\udc5b) = \ud835\udc39(3 \u00b7 \ud835\udc5b);  \ud835\udc382: \ud835\udc39 \ud835\udc5d(\ud835\udc5b) = 4 \u00b7 \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22121) + \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22122), \ud835\udc5b\u22652, \ud835\udc39 \ud835\udc5d(0) = 0 \u0219i \ud835\udc39 \ud835\udc5d(1) = 2.  \ud835\udc383: \ud835\udc39 \ud835\udc5d(\ud835\udc5b) = \ud835\udc39( \ud835\udc5b+1 2 ) \u00b7 \ud835\udc39( \ud835\udc5b+1 2 ) + \ud835\udc39 \ud835\udc5d( \ud835\udc5b\u22121 2 ) \u00b7 \ud835\udc39 \ud835\udc5d( \ud835\udc5b\u22121 2 ) , \ud835\udc5b\u22651 \u0219i  \ud835\udc39 \ud835\udc5d(0) = 0.  unde: \ud835\udc39(\ud835\udc5b) este al n-lea termen din \u0219irul lui Fibonacci (1, 1, 2, 3, 5, 8, ...), iar \ud835\udc39 \ud835\udc5d(\ud835\udc5b) este  al n-lea termen par din \u0219irul lui Fibonacci (2, 8, 34, ...).  Pentru a determina al n-lea termen par din \u0219irul lui Fibonacci putem folosi:  a) doar  rela\u021bia \ud835\udc381  b) doar  rela\u021bia \ud835\udc382  c) doar  rela\u021biile \ud835\udc381 \u0219i \ud835\udc382  d) doar  rela\u021bia \ud835\udc383  e) doar  rela\u021biile \ud835\udc381 \u0219i \ud835\udc383  f) doar  rela\u021biile \ud835\udc382 \u0219i \ud835\udc383", "sentences": ["172    15.", "\ud835\udc381: \ud835\udc39 \ud835\udc5d(\ud835\udc5b) = \ud835\udc39(3 \u00b7 \ud835\udc5b);  \ud835\udc382: \ud835\udc39 \ud835\udc5d(\ud835\udc5b) = 4 \u00b7 \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22121) + \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22122), \ud835\udc5b\u22652, \ud835\udc39 \ud835\udc5d(0) = 0 \u0219i \ud835\udc39 \ud835\udc5d(1) = 2.", " \ud835\udc383: \ud835\udc39 \ud835\udc5d(\ud835\udc5b) = \ud835\udc39( \ud835\udc5b+1 2 ) \u00b7 \ud835\udc39( \ud835\udc5b+1 2 ) + \ud835\udc39 \ud835\udc5d( \ud835\udc5b\u22121 2 ) \u00b7 \ud835\udc39 \ud835\udc5d( \ud835\udc5b\u22121 2 ) , \ud835\udc5b\u22651 \u0219i  \ud835\udc39 \ud835\udc5d(0) = 0.", " unde: \ud835\udc39(\ud835\udc5b) este al n-lea termen din \u0219irul lui Fibonacci (1, 1, 2, 3, 5, 8, ...), iar \ud835\udc39 \ud835\udc5d(\ud835\udc5b) este  al n-lea termen par din \u0219irul lui Fibonacci (2, 8, 34, ...).", " Pentru a determina al n-lea termen par din \u0219irul lui Fibonacci putem folosi:  a) doar  rela\u021bia \ud835\udc381  b) doar  rela\u021bia \ud835\udc382  c) doar  rela\u021biile \ud835\udc381 \u0219i \ud835\udc382  d) doar  rela\u021bia \ud835\udc383  e) doar  rela\u021biile \ud835\udc381 \u0219i \ud835\udc383  f) doar  rela\u021biile \ud835\udc382 \u0219i \ud835\udc383"], "page_sentence_count_spacy": 5}, {"page_number": 173, "page_char_count": 1780, "page_word_count": 478, "page_sentence_count_raw": 9, "page_token_count": 445.0, "text": "173    Varianta 31    1.  Fie expresia:  Limbajul C++/C  Limbajul Pascal  2020 \u2013 n%2020 + n/2020    2020 - n mod 2020 + n div 2020  Indica\u021bi care este valoarea maxim\u0103 a expresiei  de mai sus \u0219tiind c\u0103 variabila \u00eentreag\u0103 n  memoreaz\u0103 un num\u0103r natural cu cel mult 4 cifre.    a) 0  b) 1  c) 2020  d) 2024  e) 2080  f) 4039    2.  Variabilele \u00eentregi x \u0219i y memoreaz\u0103 numere naturale. Preciza\u021bi ce se afi\u0219eaz\u0103 dup\u0103  executarea instruc\u021biunilor de mai jos.    Limbajul C++/C  Limbajul Pascal  for(x=0; x<=3; x++)   for(y=3; y>=x; y--)    if (y%3==2)     cout<<x+y; |printf(\"%d\",x+y);    for x :=0  to 3 do   for y :=3 downto  x do     if  y mod 3 = 2               then write(x+y);    a) 234  b) 5432  c) 22525  d) 54321  e) 654321  f) 6543210      3.  Variabilele i \u0219i j sunt de tip \u00eentreg, iar variabila a memoreaz\u0103 un tablou bidimensional  cu 10 linii \u0219i 10 coloane, av\u00e2nd ini\u021bial toate valorile elementelor egale cu zero. Suma  valorilor elementelor din tabloul a, dup\u0103 executarea instruc\u021biunilor de mai jos, este:  Limbajul C++/C  Limbajul Pascal  for(x=1; x<=6; x++)   for(y=1; y<=6; y++)         if (x%2==0)            a[x][y]=(x-1)%5;           else a[y][x]= y-1;    for x :=1 to 6 do    for y :=1 to  6 do      if x mod 2 = 0  then        a[x, y] := (x-1) mod 5         else a[y, x] := y-1;    a) 80  b) 72  c) 69  d) 55  e) 48  f) 42                    4.  \u0218irul de caractere afi\u0219at  dup\u0103  executarea instruc\u021biunilor de mai jos este:    Limbajul C++/C  Limbajul Pascal   var s: string[20];  s:='BUTONOMATICA';  delete(s,6,1);  s[1]:= chr(ord(s[1])-1);  delete(s,6,1);  write(s);  char s[20]=\u201dBUTONOMATICA\u201d;  strcpy(s+5,s+6);  s[0]=s[0]-1;  strcpy(s+5,s+6);  cout<<s; \u2502 printf(\"%s\",s);  a)  AUTONATICA  b)  AUTOMATICA  c)  AUTONTICA    d)  AUTOnATIC  e)  Auton  f)  butonatica", "sentences": ["173    Varianta 31    1.", " Fie expresia:  Limbajul C++/C  Limbajul Pascal  2020 \u2013 n%2020 + n/2020    2020 - n mod 2020 + n div 2020  Indica\u021bi care este valoarea maxim\u0103 a expresiei  de mai sus \u0219tiind c\u0103 variabila \u00eentreag\u0103 n  memoreaz\u0103 un num\u0103r natural cu cel mult 4 cifre.", "   a) 0  b) 1  c) 2020  d) 2024  e) 2080  f) 4039    2.", " Variabilele \u00eentregi x \u0219i y memoreaz\u0103 numere naturale.", "Preciza\u021bi ce se afi\u0219eaz\u0103 dup\u0103  executarea instruc\u021biunilor de mai jos.", "   Limbajul C++/C  Limbajul Pascal  for(x=0; x<=3; x++)   for(y=3; y>=x; y--)    if (y%3==2)     cout<<x+y; |printf(\"%d\",x+y);    for x :=0  to 3 do   for y :=3 downto  x do     if  y mod 3 = 2               then write(x+y);    a) 234  b) 5432  c) 22525  d) 54321  e) 654321  f) 6543210      3.", " Variabilele i \u0219i j sunt de tip \u00eentreg, iar variabila a memoreaz\u0103 un tablou bidimensional  cu 10 linii \u0219i 10 coloane, av\u00e2nd ini\u021bial toate valorile elementelor egale cu zero.", "Suma  valorilor elementelor din tabloul a, dup\u0103 executarea instruc\u021biunilor de mai jos, este:  Limbajul C++/C  Limbajul Pascal  for(x=1; x<=6; x++)   for(y=1; y<=6; y++)         if (x%2==0)            a[x][y]=(x-1)%5;           else a[y][x]= y-1;    for x :=1 to 6 do    for y :=1 to  6 do      if x mod 2 = 0  then        a[x, y] := (x-1) mod 5         else a[y, x] := y-1;    a) 80  b) 72  c) 69  d) 55  e) 48  f) 42                    4.", " \u0218irul de caractere afi\u0219at  dup\u0103  executarea instruc\u021biunilor de mai jos este:    Limbajul C++/C  Limbajul Pascal   var s: string[20];  s:='BUTONOMATICA';  delete(s,6,1);  s[1]:= chr(ord(s[1])-1);  delete(s,6,1);  write(s);  char s[20]=\u201dBUTONOMATICA\u201d;  strcpy(s+5,s+6);  s[0]=s[0]-1;  strcpy(s+5,s+6);  cout<<s; \u2502 printf(\"%s\",s);  a)  AUTONATICA  b)  AUTOMATICA  c)  AUTONTICA    d)  AUTOnATIC  e)  Auton  f)  butonatica"], "page_sentence_count_spacy": 9}, {"page_number": 174, "page_char_count": 2021, "page_word_count": 516, "page_sentence_count_raw": 10, "page_token_count": 505.25, "text": "174    5.  \u00cen secven\u021ba de instruc\u021biuni de mai jos, at\u00e2t variabila  I, c\u00e2t \u0219i variabila J memoreaz\u0103 \u00een  c\u00e2mpurile a \u0219i b numere reale reprezent\u00e2nd extremitatea st\u00e2ng\u0103, respectiv extremitatea  dreapt\u0103 a c\u00e2te unui interval deschis de numere reale(a,b), unde a<b.     Limbajul C++  Limbajul C  Limbajul Pascal  struct interval  { float a,b;};  interval I,J;    typedef struct  { float a,b;  }interval;  interval I,J;  type interval=record       a,b: real;          end;  var I,J: interval;  Indica\u021bi expresia care are valoarea 1 (C++/C),  respectiv true (Pascal) dac\u0103 \u0219i numai  dac\u0103 intersec\u021bia intervalelor memorate \u00een variabilele I \u0219i J este mul\u021bimea vid\u0103.  Limbajul C++/C  a) (I.a<J.a) && (I.b<J.b) && (I.a<J.b)          b) (I.b<=J.a) || (J.b<=I.a)          c) !(I.b>J.a) && !(J.b>I.a)          d) !(I.b>=J.a) || (J.b<I.a)          e) !(I.b>J.a) || (J.b<I.a)          f) !(I.b>J.a) && (J.b<=I.a)          Limbajul Pascal          a) (I.a<J.a) and (I.b<J.b) and (I.a<J.b)         b) (I.b<=J.a) or (J.b<=I.a)          c) not(I.b>J.a) and not(J.b>I.a)          d) not(I.b>=J.a) or (J.b<I.a)          e) not(I.b>J.a) or (J.b<I.a)          f) not(I.b>J.a) and (J.b<=I.a)              6.  Pentru determinarea \u00een ordine cresc\u0103toare a numerelor naturale av\u00e2nd exact 2 cifre  formate cu elemente din mul\u0163imea {0,1,2} se utilizeaz\u0103 un algoritm backtracking care  genereaz\u0103,  \u00een ordine,  numerele 10,11,12,20,21,22. Dac\u0103 se utilizeaz\u0103 acela\u015fi  algoritm pentru generarea numerelor naturale av\u00e2nd exact 3 cifre formate cu elemente  din mul\u0163imea {0,1,2}, preciza\u021bi c\u00e2te numere generate sunt pare.    a) 9  b) 12  c) 18  d) 27  e) 36  f) 40      7.  Subprogramul f este definit mai jos.  Limbajul C++/C    Limbajul Pascal   function f(n : integer) :  integer;  begin  if  (n=1) then f := 2            else                f:=n*(n+1)+f(n-1);  end;  int f(int n)  {   if (n==1) return 2;   else   return n*(n+1)+f(n-1);  }  Preciza\u021bi ce valoare returneaz\u0103 subprogramul la apelul f(20).    a) 440  b) 2660  c) 3080  d) 3542  e) 5660  f) 5690", "sentences": ["174    5.", " \u00cen secven\u021ba de instruc\u021biuni de mai jos, at\u00e2t variabila  I, c\u00e2t \u0219i variabila J memoreaz\u0103 \u00een  c\u00e2mpurile a \u0219i b numere reale reprezent\u00e2nd extremitatea st\u00e2ng\u0103, respectiv extremitatea  dreapt\u0103 a c\u00e2te unui interval deschis de numere reale(a,b), unde a<b.     Limbajul C++  Limbajul C  Limbajul Pascal  struct interval  { float a,b;};  interval I,J;    typedef struct  { float a,b;  }interval;  interval I,J;  type interval=record       a,b: real;          end;  var I,J: interval;  Indica\u021bi expresia care are valoarea 1 (C++/C),  respectiv true (Pascal) dac\u0103 \u0219i numai  dac\u0103 intersec\u021bia intervalelor memorate \u00een variabilele I \u0219i J este mul\u021bimea vid\u0103.", " Limbajul C++/C  a) (I.a<J.a) && (I.b<J.b) && (I.a<J.b)          b) (I.b<=J.a) || (J.b<=I.a)          c) !(", "I.b>J.a) && !(", "J.b>I.a)          d) !(", "I.b>=J.a) || (J.b<I.a)          e) !(", "I.b>J.a) || (J.b<I.a)          f) !(", "I.b>J.a) && (J.b<=I.a)          Limbajul Pascal          a) (I.a<J.a) and (I.b<J.b) and (I.a<J.b)         b) (I.b<=J.a) or (J.b<=I.a)          c) not(I.b>J.a) and not(J.b>I.a)          d) not(I.b>=J.a) or (J.b<I.a)          e) not(I.b>J.a) or (J.b<I.a)          f) not(I.b>J.a) and (J.b<=I.a)              6.", " Pentru determinarea \u00een ordine cresc\u0103toare a numerelor naturale av\u00e2nd exact 2 cifre  formate cu elemente din mul\u0163imea {0,1,2} se utilizeaz\u0103 un algoritm backtracking care  genereaz\u0103,  \u00een ordine,  numerele 10,11,12,20,21,22.", "Dac\u0103 se utilizeaz\u0103 acela\u015fi  algoritm pentru generarea numerelor naturale av\u00e2nd exact 3 cifre formate cu elemente  din mul\u0163imea {0,1,2}, preciza\u021bi c\u00e2te numere generate sunt pare.", "   a) 9  b) 12  c) 18  d) 27  e) 36  f) 40      7.", " Subprogramul f este definit mai jos.", " Limbajul C++/C    Limbajul Pascal   function f(n : integer) :  integer;  begin  if  (n=1) then f := 2            else                f:=n*(n+1)+f(n-1);  end;  int f(int n)  {   if (n==1) return 2;   else   return n*(n+1)+f(n-1);  }  Preciza\u021bi ce valoare returneaz\u0103 subprogramul la apelul f(20).", "   a) 440  b) 2660  c) 3080  d) 3542  e) 5660  f) 5690"], "page_sentence_count_spacy": 14}, {"page_number": 175, "page_char_count": 2112, "page_word_count": 509, "page_sentence_count_raw": 18, "page_token_count": 528.0, "text": "175        8.  Tabloul unidimensional A, cu 5 elemente av\u00e2nd valori distincte, memoreaz\u0103 cele mai  mici 5 numere naturale p\u0103trate perfecte. Tabloul  unidimensional B, cu 4 elemente av\u00e2nd  valori distincte, memoreaz\u0103 cele mai mici 4 numere naturale prime. Tablourile A \u0219i B  sunt sortate descresc\u0103tor. Se sorteaz\u0103 descresc\u0103tor prin interclasare cele dou\u0103 tablouri A  \u0219i B \u00een tabloul unidimensional C.  Preciza\u021bi care sunt elementele tabloului  C, dup\u0103  sortarea prin interclasare a  lui  A \u0219i B.    a) (16,9,7,5,4,3,2)  b) (16,9,7,5,4,3,2,1,0)  c) (16,9,7,5,4,3)    d) (16,9,7,5,4,3,1)  e) (16,9,7,5,4,3,2,1,1)  f) (16,9,7,5,4,2)      9.  Variabilele \u00eentregi a, b \u0219i c memoreaz\u0103 ini\u021bial valorile 19, 20, respectiv 21. Preciza\u021bi  care sunt valorile lui a, b, respectiv c dup\u0103  apelul f(a,b,c) pentru limbajele C++  \u0219i Pascal,  respectiv f(a,b,&c) pentru limbajul C.    Limbajul C++  Limbajul C  Limbajul Pascal   procedure f(a: integer;  b: integer; var c:  integer);  begin    a:= b mod c;    b:= a+1;    c:= a mod b;  end;  void f( int a,      int b, int &c)     {      a= b%c;      b= a+1;      c= a%b;  }  void f( int a,   int b, int *c)    {     a= b%(*c);     b= a+1;    *c= a%b;  }    a) 19 20 20  b) 19 20 21  c) 19 21 20      d) 20 20 0  e) 20 20 21  f) 20 20 22      10.  Se consider\u0103 un arbore cu r\u0103d\u0103cin\u0103 av\u00e2nd 1026 de noduri etichetate cu numerele  naturale  de  la  1  la  1026.  Toate  nodurile  arborelui  respect\u0103  rela\u021bia:  tata[x]=[x/2](tat\u0103l nodului x este partea \u00eentreag\u0103 din jum\u0103tatea lui x). Num\u0103rul  nodurilor din arbore care au cel mult un descendent direct(fiu) este:    a)  512  b)  513  c)  514  d)  518  e)  1023  f)  1026      11.  Un graf neorientat G cu 4 noduri, numerotate de la 1 la 4, are mul\u021bimea muchiilor  {[1,2],[2,3]}. Se construiesc toate subgrafurile distincte ale lui G av\u00e2nd zero  muchii. Dou\u0103 subgrafuri se consider\u0103 distincte dac\u0103 au mul\u021bimile nodurilor diferite.  Preciza\u021bi c\u00e2te astfel de subgrafuri distincte ale lui G s-au construit (se num\u0103r\u0103 numai  subgrafurile lui G \u00een care mul\u021bimea muchiilor este mul\u021bimea vid\u0103).    a)  4  b)  6  c)  9  d)  12  e)  13  f)  16", "sentences": ["175        8.", " Tabloul unidimensional A, cu 5 elemente av\u00e2nd valori distincte, memoreaz\u0103 cele mai  mici 5 numere naturale p\u0103trate perfecte.", "Tabloul  unidimensional B, cu 4 elemente av\u00e2nd  valori distincte, memoreaz\u0103 cele mai mici 4 numere naturale prime.", "Tablourile A \u0219i B  sunt sortate descresc\u0103tor.", "Se sorteaz\u0103 descresc\u0103tor prin interclasare cele dou\u0103 tablouri A  \u0219i B \u00een tabloul unidimensional C.  Preciza\u021bi care sunt elementele tabloului  C, dup\u0103  sortarea prin interclasare a  lui  A \u0219i B.    a) (16,9,7,5,4,3,2)  b) (16,9,7,5,4,3,2,1,0)  c) (16,9,7,5,4,3)    d) (16,9,7,5,4,3,1)  e) (16,9,7,5,4,3,2,1,1)  f) (16,9,7,5,4,2)      9.", " Variabilele \u00eentregi a, b \u0219i c memoreaz\u0103 ini\u021bial valorile 19, 20, respectiv 21.", "Preciza\u021bi  care sunt valorile lui a, b, respectiv c dup\u0103  apelul f(a,b,c) pentru limbajele C++  \u0219i Pascal,  respectiv f(a,b,&c) pentru limbajul C.    Limbajul C++  Limbajul C  Limbajul Pascal   procedure f(a: integer;  b: integer; var c:  integer);  begin    a:= b mod c;    b:= a+1;    c:= a mod b;  end;  void f( int a,      int b, int &c)     {      a= b%c;      b= a+1;      c= a%b;  }  void f( int a,   int b, int *c)    {     a= b%(*c);     b= a+1;    *c= a%b;  }    a) 19 20 20  b) 19 20 21  c) 19 21 20      d) 20 20 0  e) 20 20 21  f) 20 20 22      10.", " Se consider\u0103 un arbore cu r\u0103d\u0103cin\u0103 av\u00e2nd 1026 de noduri etichetate cu numerele  naturale  de  la  1  la  1026.", " Toate  nodurile  arborelui  respect\u0103  rela\u021bia:  tata[x]=[x/2](tat\u0103l nodului x este partea \u00eentreag\u0103 din jum\u0103tatea lui x).", "Num\u0103rul  nodurilor din arbore care au cel mult un descendent direct(fiu) este:    a)  512  b)  513  c)  514  d)  518  e)  1023  f)  1026      11.", " Un graf neorientat G cu 4 noduri, numerotate de la 1 la 4, are mul\u021bimea muchiilor  {[1,2],[2,3]}.", "Se construiesc toate subgrafurile distincte ale lui G av\u00e2nd zero  muchii.", "Dou\u0103 subgrafuri se consider\u0103 distincte dac\u0103 au mul\u021bimile nodurilor diferite.", " Preciza\u021bi c\u00e2te astfel de subgrafuri distincte ale lui G s-au construit (se num\u0103r\u0103 numai  subgrafurile lui G \u00een care mul\u021bimea muchiilor este mul\u021bimea vid\u0103).", "   a)  4  b)  6  c)  9  d)  12  e)  13  f)  16"], "page_sentence_count_spacy": 15}, {"page_number": 176, "page_char_count": 1796, "page_word_count": 386, "page_sentence_count_raw": 16, "page_token_count": 449.0, "text": "176    12.  Fie un num\u0103r natural nenul n. Dorim s\u0103 num\u0103r\u0103m \u00een c\u00e2te cifre consecutive de zero se  termin\u0103 produsul 1*2*3*...*n. Dac\u0103 trebuie s\u0103 calcul\u0103m acest num\u0103r de zerouri  consecutive cel mai eficient din punct de vedere al timpului de execu\u021bie, alegem s\u0103  utiliz\u0103m un algoritm bazat pe cea mai restrictiv\u0103 variant\u0103, av\u00e2nd complexitatea timp:    a) O(1), algoritm  bazat pe  o formul\u0103 matematic\u0103    b) O(logn), algoritm logaritmic    c) O(n), algoritm liniar  d) O(n2), algoritm p\u0103tratic  e) O(n3), algoritm cubic  f) O(2n), algoritm exponen\u021bial      13.  Se consider\u0103 graful orientat cu 4 v\u00e2rfuri, etichetate cu numere de la 1 la 4, av\u00e2nd  mul\u021bimea arcelor {(1,2),(3,2),(4,1),(4,2),(4,3)}. Indica\u021bi  num\u0103rul  minim de arce care trebuie ad\u0103ugate \u00een acest graf orientat astfel \u00eenc\u00e2t noul graf s\u0103 devin\u0103  tare conex.    a) 5  b) 4  c) 3  d) 2  e) 1  f) 0      14.  Preciza\u021bi c\u00e2te grafuri neorientate distincte, cu nodurile etichetate de la 1 la 8, se pot  construi, \u0219tiind c\u0103 \u00een fiecare graf construit se respect\u0103 simultan propriet\u0103\u021bile de mai jos:     1) Fiecare nod etichetat cu un num\u0103r prim este adiacent cu nodul 8.  2) Nu exist\u0103 nicio muchie [x,y] cu ambele extremit\u0103\u021bi x \u0219i y numere impare.    Dou\u0103 grafuri neorientate se consider\u0103 distincte dac\u0103 au matricele de adiacen\u021b\u0103 diferite.    a)  29  b)  217  c)  49  d)  228  e)  417  f)  256      15.  Tabloul unidimensional V are 33 de elemente, numerotate de la 1 la 33. Valorile  elementelor din V sunt numere naturale. Tabloul V con\u021bine, \u00eencep\u00e2nd cu indicele 1,  primii 33 de termeni ai \u0219irului de numere naturale: (0, 1, 4, 9, 61, 52, 63,  94, 46, 18, 1, ...). Deduce\u021bi regula de generalizare dup\u0103 care s-au construit  termenii \u0219irului \u0219i preciza\u021bi c\u00e2te elemente ale lui V  se termin\u0103 cu cifra 1.    a) 26  b) 17  c) 12  d) 9  e) 8  f) 4", "sentences": ["176    12.", " Fie un num\u0103r natural nenul n. Dorim s\u0103 num\u0103r\u0103m \u00een c\u00e2te cifre consecutive de zero se  termin\u0103 produsul 1*2*3*...*n.", "Dac\u0103 trebuie s\u0103 calcul\u0103m acest num\u0103r de zerouri  consecutive cel mai eficient din punct de vedere al timpului de execu\u021bie, alegem s\u0103  utiliz\u0103m un algoritm bazat pe cea mai restrictiv\u0103 variant\u0103, av\u00e2nd complexitatea timp:    a) O(1), algoritm  bazat pe  o formul\u0103 matematic\u0103    b) O(logn), algoritm logaritmic    c) O(n), algoritm liniar  d) O(n2), algoritm p\u0103tratic  e) O(n3), algoritm cubic  f) O(2n), algoritm exponen\u021bial      13.", " Se consider\u0103 graful orientat cu 4 v\u00e2rfuri, etichetate cu numere de la 1 la 4, av\u00e2nd  mul\u021bimea arcelor {(1,2),(3,2),(4,1),(4,2),(4,3)}.", "Indica\u021bi  num\u0103rul  minim de arce care trebuie ad\u0103ugate \u00een acest graf orientat astfel \u00eenc\u00e2t noul graf s\u0103 devin\u0103  tare conex.", "   a) 5  b) 4  c) 3  d) 2  e) 1  f) 0      14.", " Preciza\u021bi c\u00e2te grafuri neorientate distincte, cu nodurile etichetate de la 1 la 8, se pot  construi, \u0219tiind c\u0103 \u00een fiecare graf construit se respect\u0103 simultan propriet\u0103\u021bile de mai jos:     1) Fiecare nod etichetat cu un num\u0103r prim este adiacent cu nodul 8.", " 2) Nu exist\u0103 nicio muchie [x,y] cu ambele extremit\u0103\u021bi x \u0219i y numere impare.", "   Dou\u0103 grafuri neorientate se consider\u0103 distincte dac\u0103 au matricele de adiacen\u021b\u0103 diferite.", "   a)  29  b)  217  c)  49  d)  228  e)  417  f)  256      15.", " Tabloul unidimensional V are 33 de elemente, numerotate de la 1 la 33.", "Valorile  elementelor din V sunt numere naturale.", "Tabloul V con\u021bine, \u00eencep\u00e2nd cu indicele 1,  primii 33 de termeni ai \u0219irului de numere naturale: (0, 1, 4, 9, 61, 52, 63,  94, 46, 18, 1, ...).", "Deduce\u021bi regula de generalizare dup\u0103 care s-au construit  termenii \u0219irului \u0219i preciza\u021bi c\u00e2te elemente ale lui V  se termin\u0103 cu cifra 1.", "   a) 26  b) 17  c) 12  d) 9  e) 8  f) 4"], "page_sentence_count_spacy": 15}, {"page_number": 177, "page_char_count": 1938, "page_word_count": 451, "page_sentence_count_raw": 8, "page_token_count": 484.5, "text": "177    Varianta 32    1.  Variabila a memoreaz\u0103 un num\u0103r natural care nu este multiplu de 3. Expresia care are  totdeauna valoarea egal\u0103 cu o treime din a este:  Limbajul  C++/C  a) a/(3*2)/2  b) a/3+a/2  c) a/2/3+a/3/2  d) a/(2/3)/3  e) a/3*a/2  f) a/2/3*2  Limbajul  Pascal  a) a div (3*2) div 2  b) a div 3+a div 2  c) a div 2 div 3 +   a div 3 div 2  d) a div (2 div 3) div 3  e) a div 3 * a div 2  f) a div 2 div 3*2    2.  Variabilele a \u0219i b memoreaz\u0103 numere naturale nenule. Se consider\u0103 urm\u0103toarea  secven\u0163\u0103 de program:  Limbajul C++/C  for(i=a*b; i>=1; i--)   if(i%a==0 && i%b==0)         c=i;      cout<<c;| printf(\"%d\",c);  Limbajul Pascal  for i:=a*b downto 1 do  if i mod a=0 and i mod b=0 then c=i;  write(c);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate, variabila c are valoarea:  a) cel mai mic multiplu comun al numerelor a \u015fi b;  b) cel mai mare num\u0103r mai mic dec\u00e2t produsul numerelor a \u015fi b, care divide pe a \u015fi pe  b;  c) cel mai mic num\u0103r mai mare dec\u00e2t produsul numerelor a \u015fi b, care este divizibil cu  a \u015fi cu b;  d) cel mai mare divizor comun al numerelor a \u015fi b;  e) suma divizorilor numerelor a \u015fi b;  f) produsul divizorilor numerelor a \u015fi b.    3.  Variabila x re\u021bine un num\u0103r natural mai mic dec\u00e2t 19, iar i \u0219i y sunt variabile de tip  \u00eentreg. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  for(i=1;i<=9;i++)  if((x-i)>=0 && (x-i)<=9)  {    y=10*i+(x-i);    cout<<y<<' ';        |printf(\"%d \",y);  }  Limbajul Pascal  for i:=1 to 9 do  if (x-i)>=0 and (x-i)<=9 then    begin      y:=10*i+(x-i);      write(y,' ')    end;  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate, se afi\u015feaz\u0103:  a) numerele naturale de dou\u0103 cifre care au suma cifrelor egal\u0103 cu x;  b) numerele naturale care au suma cifrelor egal\u0103 cu x;  c) numere naturale mai mari dec\u00e2t 10 \u015fi mai mici dec\u00e2t x;  d) numere naturale cu cifre distincte, mai mici dec\u00e2t x;  e) numere naturale cu cifre distincte, mai mari dec\u00e2t x;", "sentences": ["177    Varianta 32    1.", " Variabila a memoreaz\u0103 un num\u0103r natural care nu este multiplu de 3.", "Expresia care are  totdeauna valoarea egal\u0103 cu o treime din a este:  Limbajul  C++/C  a) a/(3*2)/2  b) a/3+a/2  c) a/2/3+a/3/2  d) a/(2/3)/3  e) a/3*a/2  f) a/2/3*2  Limbajul  Pascal  a) a div (3*2) div 2  b) a div 3+a div 2  c) a div 2 div 3 +   a div 3 div 2  d) a div (2 div 3) div 3  e) a div 3 * a div 2  f) a div 2 div 3*2    2.", " Variabilele a \u0219i b memoreaz\u0103 numere naturale nenule.", "Se consider\u0103 urm\u0103toarea  secven\u0163\u0103 de program:  Limbajul C++/C  for(i=a*b; i>=1; i--)   if(i%a==0 && i%b==0)         c=i;      cout<<c;| printf(\"%d\",c);  Limbajul Pascal  for i:=a*b downto 1 do  if i mod a=0 and i mod b=0 then c=i;  write(c);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate, variabila c are valoarea:  a) cel mai mic multiplu comun al numerelor a \u015fi b;  b) cel mai mare num\u0103r mai mic dec\u00e2t produsul numerelor a \u015fi b, care divide pe a \u015fi pe  b;  c) cel mai mic num\u0103r mai mare dec\u00e2t produsul numerelor a \u015fi b, care este divizibil cu  a \u015fi cu b;  d) cel mai mare divizor comun al numerelor a \u015fi b;  e) suma divizorilor numerelor a \u015fi b;  f) produsul divizorilor numerelor a \u015fi b.    3.", " Variabila x re\u021bine un num\u0103r natural mai mic dec\u00e2t 19, iar i \u0219i y sunt variabile de tip  \u00eentreg.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  for(i=1;i<=9;i++)  if((x-i)>=0 && (x-i)<=9)  {    y=10*i+(x-i);    cout<<y<<' ';        |printf(\"%d \",y);  }  Limbajul Pascal  for i:=1 to 9 do  if (x-i)>=0 and (x-i)<=9 then    begin      y:=10*i+(x-i);      write(y,' ')    end;  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate, se afi\u015feaz\u0103:  a) numerele naturale de dou\u0103 cifre care au suma cifrelor egal\u0103 cu x;  b) numerele naturale care au suma cifrelor egal\u0103 cu x;  c) numere naturale mai mari dec\u00e2t 10 \u015fi mai mici dec\u00e2t x;  d) numere naturale cu cifre distincte, mai mici dec\u00e2t x;  e) numere naturale cu cifre distincte, mai mari dec\u00e2t x;"], "page_sentence_count_spacy": 7}, {"page_number": 178, "page_char_count": 1820, "page_word_count": 407, "page_sentence_count_raw": 12, "page_token_count": 455.0, "text": "178    f) numerele naturale de cel pu\u0163in dou\u0103 cifre care au suma cifrelor egal\u0103 cu x.    4.  Variabila x memoreaz\u0103 notele ob\u0163inute de un elev la cele trei probe de Bacalaureat, note  cu dou\u0103 zecimale. Declararea corect\u0103 a variabilei x este:  Limbajul  C++/C  a) char x[2];  b) int x;  c) float x;  d) float x[3];  e) int x[2];  f) float x[2][3];  Limbajul  Pascal  a) var x:string[2];  b) var x:byte;  c) var x:real;  d) var x:array[1..3]of real;  e) var x:array[1..2]of  byte;  f) var x:array[1..2,1..3]of  real;    5.  \u00centr-un graf neorientat, cu 10 noduri, fiecare nod are gradul 2. Num\u0103rul maxim de  componente conexe din care poate fi format graful este:    a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    6.  Pentru a calcula cel mai mare divizor comun pentru numerele naturale nenule a \u015fi b, se  consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  while(a!=b)if(a>b)a=a-b;  else b=b-a;  Limbajul Pascal  while a<>b do if a>b then a:=a-b  else b:=b-a;  Algoritmul este:    a) eficient  b) ineficient c) incorect  sintactic  d) incorect  semantic  e) gre\u015fit  f) infinit    7.  Se consider\u0103 graful neorientat G cu 5 noduri, reprezentat  prin matricea de adiacen\u0163\u0103 al\u0103turat\u0103.     Afirma\u0163ia adev\u0103rat\u0103 este:  0 1 0 0 1  1 0 1 1 1  0 1 0 1 0  0 1 1 0 0  1 1 0 0 0    a) Graful G con\u0163ine dou\u0103 componente conexe;  b) Orice subgraf a lui G format din 3 noduri este arbore;  c) Graful G este hamiltonian;  d) Graful G este eulerian;  e) Graful G este arbore;  f) Graful G nu este eulerian.    8.  Variabilele n \u0219i i memoreaz\u0103 numere naturale \u00eentregi. \u00cen urm\u0103toarea secven\u0163\u0103 de  program, v este un tablou unidimensional cu n elemente:  Limbajul C++/C  i=0;  while(i<n)     v[i++]=i*i*i;  Limbajul Pascal  i:=1;  while i<=n do   begin    v[i]:=i*i*i;inc(i)  end;  Num\u0103rul de repet\u0103ri ale secven\u0163ei de instruc\u0163iuni din while este:", "sentences": ["178    f) numerele naturale de cel pu\u0163in dou\u0103 cifre care au suma cifrelor egal\u0103 cu x.    4.", " Variabila x memoreaz\u0103 notele ob\u0163inute de un elev la cele trei probe de Bacalaureat, note  cu dou\u0103 zecimale.", "Declararea corect\u0103 a variabilei x este:  Limbajul  C++/C  a) char x[2];  b) int x;  c) float x;  d) float x[3];  e) int x[2];  f) float x[2][3];  Limbajul  Pascal  a) var x:string[2];  b) var x:byte;  c) var x:real;  d) var x:array[1..3]of real;  e) var x:array[1..2]of  byte;  f) var x:array[1..2,1..3]of  real;    5.", " \u00centr-un graf neorientat, cu 10 noduri, fiecare nod are gradul 2.", "Num\u0103rul maxim de  componente conexe din care poate fi format graful este:    a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    6.", " Pentru a calcula cel mai mare divizor comun pentru numerele naturale nenule a \u015fi b, se  consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  while(a!=b)if(a>b)a=a-b;  else b=b-a;  Limbajul Pascal  while a<>b do if a>b then a:=a-b  else b:=b-a;  Algoritmul este:    a) eficient  b) ineficient c) incorect  sintactic  d) incorect  semantic  e) gre\u015fit  f) infinit    7.", " Se consider\u0103 graful neorientat G cu 5 noduri, reprezentat  prin matricea de adiacen\u0163\u0103 al\u0103turat\u0103.", "    Afirma\u0163ia adev\u0103rat\u0103 este:  0 1 0 0 1  1 0 1 1 1  0 1 0 1 0  0 1 1 0 0  1 1 0 0 0    a) Graful G con\u0163ine dou\u0103 componente conexe;  b) Orice subgraf a lui G format din 3 noduri este arbore;  c) Graful G este hamiltonian;  d) Graful G este eulerian;  e) Graful G este arbore;  f) Graful G nu este eulerian.", "   8.", " Variabilele n \u0219i i memoreaz\u0103 numere naturale \u00eentregi.", "\u00cen urm\u0103toarea secven\u0163\u0103 de  program, v este un tablou unidimensional cu n elemente:  Limbajul C++/C  i=0;  while(i<n)     v[i++]=i*i*i;  Limbajul Pascal  i:=1;  while i<=n do   begin    v[i]:=i*i*i;inc(i)  end;  Num\u0103rul de repet\u0103ri ale secven\u0163ei de instruc\u0163iuni din while este:"], "page_sentence_count_spacy": 11}, {"page_number": 179, "page_char_count": 2306, "page_word_count": 516, "page_sentence_count_raw": 12, "page_token_count": 576.5, "text": "179      a) n+1   b) n-1  c) n   d) 0  e) 1  f) 3*n    9.  Un elev folose\u015fte metoda backtracking pentru a genera submul\u0163imile mul\u0163imii  {1,2,5,6,9}.  Num\u0103rul de submul\u0163imi generate, care obligatoriu con\u0163in elementul 2  \u015fi nu con\u0163in elementul 6, este?    a) 16  b) 8   c) 7  d) 6  e) 4  f) 2    10. Subprogramul f, cu parametrii a \u015fi b numere \u00eentregi (a<b), returneaz\u0103 num\u0103rul de  numere pare din intervalul [a,b]. Expresia care are valoarea 1 (C++/C) / True  (Pascal), pentru orice numere a \u015fi b care nu au aceea\u015fi paritate este:  Limbajul  C++/C  a) f(a,b)== f(a,b+1)  b) f(a,b)==(b-a)/2  c) f(a,b)==(b-a+1)/2  d) f(a,b)== b-a  e) f(a,b)== b-a+1  f)  f(a,b)== (b-a-1)/2  Limbajul  Pascal  a) f(a,b)= f(a,b+1)  b) f(a,b)=(b-a) div 2  c) f(a,b)= (b-a+1) div 2  d) f(a,b)= b-a  e) f(a,b)= b-a+1  f) f(a,b)= (b-a-1) div 2    11. Se consider\u0103 un arbore, care are r\u0103d\u0103cina pe nivelul 1 \u015fi orice nod de pe nivelul i are  exact i+1 descenden\u0163i direc\u0163i, cu excep\u0163ia nodurilor de pe nivelul 4 care sunt noduri  terminale. Num\u0103rul de frunze ale arborelui este:    a) 120  b) 30  c) 24  d) 8  e) 6  f) 4    12. Se consider\u0103 urm\u0103torul subprogram:  Limbajul C++  void f(int x,int *y)  {     y=x+y;     x=x+y;   }  Limbajul C  void f(int x, int &y)  {     *y=x+*y;     x=x+*y;   }  Limbajul Pascal  procedure f(x:integer;var  y:integer);  begin  y:=x+y;  x:=x+y  end;  Dac\u0103 valoarea variabilei a \u00eenainte de apel este 2, care este valoarea sa dup\u0103 apelul:  Limbajul C++: f(a,a)  Limbajul C: f(a,&a)  Limbajul Pascal: f(a,a)    a) 12  b) 10  c) 8  d) 6  e) 4  f) 2    13. Subprogramul f, cu doi parametri \u00eentregi x \u015fi y, returneaz\u0103 valoarea celui mai mare  divizor comun al numerelor x \u015fi y. Expresia prin care se calculeaz\u0103 cel mai mare  divizor comun al numerelor x, y \u015fi z este:  a) f(x,y)+f(y,z)  b) f(x,y,z)  c) f(x,y)*z  d) f(x,y)*f(y,z)  e) f(x*y,z)  f) f(f(x,y),z)    14. Pentru variabilele \u00eentregi x \u015fi y, subprogramul mic(x,y) \u00eentoarce cel mai mic num\u0103r  dintre x \u015fi y, subprogramul mare(x,y) \u00eentoarce cel mai mare num\u0103r dintre x \u015fi y,  iar subprogramul p(x,y) \u00eentoarce valoarea puterii lui x cu exponent y. Pentru ca u \u015fi  v s\u0103 fie cel mai mare divizor comun, respectiv cel mai mic multiplu comun al numerelor  \ud835\udfd4\ud835\udc99 \u015fi \ud835\udfd4\ud835\udc9a, atunci subprogramele f1, f2, f3 \u015fi f4 din instruc\u0163iunile:  Limbajul C++/C  Limbajul Pascal", "sentences": ["179      a) n+1   b) n-1  c) n   d) 0  e) 1  f) 3*n    9.", " Un elev folose\u015fte metoda backtracking pentru a genera submul\u0163imile mul\u0163imii  {1,2,5,6,9}.", " Num\u0103rul de submul\u0163imi generate, care obligatoriu con\u0163in elementul 2  \u015fi nu con\u0163in elementul 6, este?", "   a) 16  b) 8   c) 7  d) 6  e) 4  f) 2    10.", "Subprogramul f, cu parametrii a \u015fi b numere \u00eentregi (a<b), returneaz\u0103 num\u0103rul de  numere pare din intervalul [a,b].", "Expresia care are valoarea 1 (C++/C) / True  (Pascal), pentru orice numere a \u015fi b care nu au aceea\u015fi paritate este:  Limbajul  C++/C  a) f(a,b)== f(a,b+1)  b) f(a,b)==(b-a)/2  c) f(a,b)==(b-a+1)/2  d) f(a,b)== b-a  e) f(a,b)== b-a+1  f)  f(a,b)== (b-a-1)/2  Limbajul  Pascal  a) f(a,b)= f(a,b+1)  b) f(a,b)=(b-a) div 2  c) f(a,b)= (b-a+1) div 2  d) f(a,b)= b-a  e) f(a,b)= b-a+1  f) f(a,b)= (b-a-1) div 2    11.", "Se consider\u0103 un arbore, care are r\u0103d\u0103cina pe nivelul 1 \u015fi orice nod de pe nivelul i are  exact i+1 descenden\u0163i direc\u0163i, cu excep\u0163ia nodurilor de pe nivelul 4 care sunt noduri  terminale.", "Num\u0103rul de frunze ale arborelui este:    a) 120  b) 30  c) 24  d) 8  e) 6  f) 4    12.", "Se consider\u0103 urm\u0103torul subprogram:  Limbajul C++  void f(int x,int *y)  {     y=x+y;     x=x+y;   }  Limbajul C  void f(int x, int &y)  {     *y=x+*y;     x=x+*y;   }  Limbajul Pascal  procedure f(x:integer;var  y:integer);  begin  y:=x+y;  x:=x+y  end;  Dac\u0103 valoarea variabilei a \u00eenainte de apel este 2, care este valoarea sa dup\u0103 apelul:  Limbajul C++: f(a,a)  Limbajul C: f(a,&a)  Limbajul Pascal: f(a,a)    a) 12  b) 10  c) 8  d) 6  e) 4  f) 2    13.", "Subprogramul f, cu doi parametri \u00eentregi x \u015fi y, returneaz\u0103 valoarea celui mai mare  divizor comun al numerelor x \u015fi y. Expresia prin care se calculeaz\u0103 cel mai mare  divizor comun al numerelor x, y \u015fi z este:  a) f(x,y)+f(y,z)  b) f(x,y,z)  c) f(x,y)*z  d) f(x,y)*f(y,z)  e) f(x*y,z)  f) f(f(x,y),z)    14.", "Pentru variabilele \u00eentregi x \u015fi y, subprogramul mic(x,y) \u00eentoarce cel mai mic num\u0103r  dintre x \u015fi y, subprogramul mare(x,y) \u00eentoarce cel mai mare num\u0103r dintre x \u015fi y,  iar subprogramul p(x,y) \u00eentoarce valoarea puterii lui x cu exponent y. Pentru ca u \u015fi  v s\u0103 fie cel mai mare divizor comun, respectiv cel mai mic multiplu comun al numerelor  \ud835\udfd4\ud835\udc99 \u015fi \ud835\udfd4\ud835\udc9a, atunci subprogramele f1, f2, f3 \u015fi f4 din instruc\u0163iunile:  Limbajul C++/C  Limbajul Pascal"], "page_sentence_count_spacy": 11}, {"page_number": 180, "page_char_count": 584, "page_word_count": 126, "page_sentence_count_raw": 3, "page_token_count": 146.0, "text": "180    u = p(2,f1(x,y))*p(3,f2(x,y));   v = p(2,f3(x,y))*p(3,f4(x,y));  u:= p(2,f1(x,y))*p(3,f2(x,y));   v:= p(2,f3(x,y))*p(3,f4(x,y));  sunt, respectiv:    a) mic, mic, mare, mare;  b) mic, mare, mic, mare;  c) mare, mare, mic, mic;  d) mare, mic, mare, mic;  e) mare, mic, mic, mare;  f) mic, mare, mare, mic.     15. Num\u0103rul de cicluri hamiltoniene distincte \u00eentr-un graf neorientat complet cu n noduri  (n\u22653) este (dou\u0103 cicluri se consider\u0103 distincte dac\u0103 difer\u0103 prin cel pu\u0163in o muchie):    a)  \ud835\udc8f(\ud835\udc8f\u2212\ud835\udfcf) \ud835\udfd0   b)  (\ud835\udc8f\u2212\ud835\udfcf)! \ud835\udfd0   c)  (\ud835\udc8f\u2212\ud835\udfd0)(\ud835\udc8f\u2212\ud835\udfcf) \ud835\udfd0  d) \ud835\udc8f\u2212\ud835\udfd0  e)   (\ud835\udc8f+\ud835\udfcf)! \ud835\udfd0   f)  (\ud835\udc8f+\ud835\udfd0)(\ud835\udc8f+\ud835\udfcf) \ud835\udfd0", "sentences": ["180    u = p(2,f1(x,y))*p(3,f2(x,y));   v = p(2,f3(x,y))*p(3,f4(x,y));  u:= p(2,f1(x,y))*p(3,f2(x,y));   v:= p(2,f3(x,y))*p(3,f4(x,y));  sunt, respectiv:    a) mic, mic, mare, mare;  b) mic, mare, mic, mare;  c) mare, mare, mic, mic;  d) mare, mic, mare, mic;  e) mare, mic, mic, mare;  f) mic, mare, mare, mic.", "    15.", "Num\u0103rul de cicluri hamiltoniene distincte \u00eentr-un graf neorientat complet cu n noduri  (n\u22653) este (dou\u0103 cicluri se consider\u0103 distincte dac\u0103 difer\u0103 prin cel pu\u0163in o muchie):    a)  \ud835\udc8f(\ud835\udc8f\u2212\ud835\udfcf) \ud835\udfd0   b)  (\ud835\udc8f\u2212\ud835\udfcf)!", "\ud835\udfd0   c)  (\ud835\udc8f\u2212\ud835\udfd0)(\ud835\udc8f\u2212\ud835\udfcf) \ud835\udfd0  d) \ud835\udc8f\u2212\ud835\udfd0  e)   (\ud835\udc8f+\ud835\udfcf)!", "\ud835\udfd0   f)  (\ud835\udc8f+\ud835\udfd0)(\ud835\udc8f+\ud835\udfcf) \ud835\udfd0"], "page_sentence_count_spacy": 5}, {"page_number": 181, "page_char_count": 1985, "page_word_count": 519, "page_sentence_count_raw": 14, "page_token_count": 496.25, "text": "181    Varianta 33    1. Variabilele x \u0219i y memoreaz\u0103 numere reale. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C    y=x;x=x*x;    if(x<y) cout<<\"DA\";            |printf(\"DA\");  Limbajul Pascal    y:=x;x:=x*x;    if x<y then write('DA');    Executarea secven\u021bei de program al\u0103turate afi\u015feaz\u0103 DA pentru valori ini\u0163iale ale lui x:    a) strict pozitive subunitare;    b) strict pozitive supraunitare;  c) strict negative subunitare;  d) strict negative supraunitare;  e) strict pozitive;  f) strict negative.    2. Variabilele n \u015fi k memoreaz\u0103 numere naturale nenule. Expresia prin care se poate calcula  cel mai mare num\u0103r natural divizibil cu k, num\u0103r care s\u0103 fie mai mic sau egal cu n este:   Limbajul  C++/C    a) Nu exist\u0103 formul\u0103.  b) (k*n) / k    c) n%k + n/k  d) (k+n) / k    e) n \u2013 n/k  f) n \u2013 n%k  Limbajul  Pascal    a) Nu exist\u0103 formul\u0103.  b) (k * n) div k    c) n mod k + n div k  d) (k + n) div k    e) n \u2013 n div k  f) n - n mod k    3. Variabilele n \u015fi i memoreaz\u0103 numere naturale nenule. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:    Limbajul C++   for(i=1;i<=5;i++)     n=n*i;   cout<<n;  Limbajul C    for(i=1;i<=5;i++)       n=n*i;    printf(\"%d\",n);  Limbajul Pascal    for i:=1 to 5 do       n:=n*i;    write(y);  Valoarea ini\u0163ial\u0103 a variabilei n pentru care executarea secven\u021bei de program al\u0103turate  afi\u015feaz\u0103 360 este:    a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    4. Variabilele a \u015fi b memoreaz\u0103 numere naturale nenule. Se consider\u0103 urm\u0103toarea secven\u0163\u0103  de program:  Limbajul C++/C     a=0;b=...;      while (b<10)      {          a=a+b; b++;      }      cout<<a; | printf(\"%d\",a);  Limbajul Pascal    a:=0;b:=...;    while b<10 do      begin          a:=a+b;b:=b+1      end;    write(a);  Valoarea care poate \u00eenlocui punctele de suspensie din secven\u0163a al\u0103turat\u0103, astfel \u00eenc\u00e2t  valoarea afi\u015fat\u0103 s\u0103 fie 35 este:    a) 2  b) 3  c) 4   d) 5  e) 6  f) 7    5. Un graf neorientat are gradele v\u00e2rfurilor: 2, 3, 3, 2, 4. Num\u0103rul de muchii ale  grafului este:", "sentences": ["181    Varianta 33    1.", "Variabilele x \u0219i y memoreaz\u0103 numere reale.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C    y=x;x=x*x;    if(x<y) cout<<\"DA\";            |printf(\"DA\");  Limbajul Pascal    y:=x;x:=x*x;    if x<y then write('DA');    Executarea secven\u021bei de program al\u0103turate afi\u015feaz\u0103 DA pentru valori ini\u0163iale ale lui x:    a) strict pozitive subunitare;    b) strict pozitive supraunitare;  c) strict negative subunitare;  d) strict negative supraunitare;  e) strict pozitive;  f) strict negative.", "   2.", "Variabilele n \u015fi k memoreaz\u0103 numere naturale nenule.", "Expresia prin care se poate calcula  cel mai mare num\u0103r natural divizibil cu k, num\u0103r care s\u0103 fie mai mic sau egal cu n este:   Limbajul  C++/C    a) Nu exist\u0103 formul\u0103.", " b) (k*n) / k    c) n%k + n/k  d) (k+n) / k    e) n \u2013 n/k  f) n \u2013 n%k  Limbajul  Pascal    a) Nu exist\u0103 formul\u0103.", " b) (k * n) div k    c) n mod k + n div k  d) (k + n) div k    e) n \u2013 n div k  f) n - n mod k    3.", "Variabilele n \u015fi i memoreaz\u0103 numere naturale nenule.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:    Limbajul C++   for(i=1;i<=5;i++)     n=n*i;   cout<<n;  Limbajul C    for(i=1;i<=5;i++)       n=n*i;    printf(\"%d\",n);  Limbajul Pascal    for i:=1 to 5 do       n:=n*i;    write(y);  Valoarea ini\u0163ial\u0103 a variabilei n pentru care executarea secven\u021bei de program al\u0103turate  afi\u015feaz\u0103 360 este:    a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    4.", "Variabilele a \u015fi b memoreaz\u0103 numere naturale nenule.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103  de program:  Limbajul C++/C     a=0;b=...;      while (b<10)      {          a=a+b; b++;      }      cout<<a; | printf(\"%d\",a);  Limbajul Pascal    a:=0;b:=...;    while b<10 do      begin          a:=a+b;b:=b+1      end;    write(a);  Valoarea care poate \u00eenlocui punctele de suspensie din secven\u0163a al\u0103turat\u0103, astfel \u00eenc\u00e2t  valoarea afi\u015fat\u0103 s\u0103 fie 35 este:    a) 2  b) 3  c) 4   d) 5  e) 6  f) 7    5.", "Un graf neorientat are gradele v\u00e2rfurilor: 2, 3, 3, 2, 4.", "Num\u0103rul de muchii ale  grafului este:"], "page_sentence_count_spacy": 14}, {"page_number": 182, "page_char_count": 2270, "page_word_count": 522, "page_sentence_count_raw": 16, "page_token_count": 567.5, "text": "182      a) 5  b) 6   c) 7  d) 8  e) 9  f) 10    6. Variabilele i \u015fi j memoreaz\u0103 numere naturale nenule. Se consider\u0103 urm\u0103toarea secven\u0163\u0103  de program:  Limbajul C++/C    for(i=0; i<=9; i++)       for(j=0; j<=9; j++)         a[i][j]=(2*i+3*j)%10;  Limbajul Pascal    for i:=0 to 9 do          j:=0 to 9 do              a[i][j]:=(2*i+3*j)%10;  Suma elementelor de pe diagonala principal\u0103 a tabloului bidimensional constuit este:    a) 10  b) 25  c) 50  d) 45   e) 46  f) 100    7. Num\u0103rul maxim de compar\u0103ri pentru ordonarea descresc\u0103toare a valorilor celor 100 de  componente ale tabloului unidimensional v, ordonare realizat\u0103 prin metoda bulelor, este:     a) 100  b) 4950  c) 9701  d) 9900  e) 9999  f) 10000    8. Subprogramul f(a,b) returneaz\u0103 media aritmetic\u0103 a numerelor reale a \u015fi b. Pentru a, b,  c \u015fi d numere reale, instruc\u0163iunea care atribuie variabilei a suma dintre media aritmetic\u0103 a  numerelor b \u015fi c \u015fi media aritmetic\u0103 a numerelor c \u015fi d este:  Limbajul  C++/C    a) a= f(b,f(c,d);  b) a=f(f(b,c),d);    c) a=(b+c+d)/2;  d) a=f(b,c)+f(b,d);    e) a=f(b,d)+c;  f) a=(f(b,c)+f(b,d))/2;  Limbajul  Pascal    a) a:= f(b,f(c,d);  b) a:=f(f(b,c),d);    c) a:=(b+c+d)/2;  d) a:=f(b,c)+f(b,d);    e) a:=f(b,d)+c;  f) a:=(f(b,c)+f(b,d))/2;    9. Se consider\u0103 un graf neorientat G, cu 5 noduri,  reprezentat prin matricea de adiacen\u0163\u0103 al\u0103turat\u0103.     Afirma\u0163ia adev\u0103rat\u0103 este:  0 1 0 0 1  1 0 1 1 1  0 1 0 1 0  0 1 1 0 0  1 1 0 0 0    a) G este graf hamiltonian \u015fi graf eulerian;  b) G este graf hamiltonian, dar nu este graf eulerian;  c) G nu este graf hamiltonian, dar este graf eulerian;  d) G nu este graf hamiltonian, nici graf eulerian;  e) G este graf hamiltonian;  f) Toate afirma\u0163iile de mai sus sunt false.    10. Pentru a determina toate modalit\u0103\u0163ile de a scrie pe 9 ca sum\u0103 de numere naturale nenule  distincte (abstrac\u0163ie f\u0103c\u00e2nd de ordinea termenilor), un elev folose\u015fte metoda backtracking  gener\u00e2nd, \u00een aceast\u0103 ordine, toate solu\u0163iile: 1+2+6, 1+3+5, 1+8, 2+3+4, 2+7, 3+6  \u015fi 4+5. Aplic\u00e2nd exact aceea\u015fi metod\u0103, el determin\u0103 solu\u0163iile pentru scrierea lui 12.  Num\u0103rul solu\u0163ii de forma 3+... este:    a) 0  b) 1  c) 2  d) 4  e) 6  f) 7    11. Fie G un arbore cu n (n>1) noduri \u015fi d1\u2265 d2\u2265 d3\u2265... dn\u22651 gradele nodurilor sale.   Afirma\u0163ia adev\u0103rat\u0103 este:", "sentences": ["182      a) 5  b) 6   c) 7  d) 8  e) 9  f) 10    6.", "Variabilele i \u015fi j memoreaz\u0103 numere naturale nenule.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103  de program:  Limbajul C++/C    for(i=0; i<=9; i++)       for(j=0; j<=9; j++)         a[i][j]=(2*i+3*j)%10;  Limbajul Pascal    for i:=0 to 9 do          j:=0 to 9 do              a[i][j]:=(2*i+3*j)%10;  Suma elementelor de pe diagonala principal\u0103 a tabloului bidimensional constuit este:    a) 10  b) 25  c) 50  d) 45   e) 46  f) 100    7.", "Num\u0103rul maxim de compar\u0103ri pentru ordonarea descresc\u0103toare a valorilor celor 100 de  componente ale tabloului unidimensional v, ordonare realizat\u0103 prin metoda bulelor, este:     a) 100  b) 4950  c) 9701  d) 9900  e) 9999  f) 10000    8.", "Subprogramul f(a,b) returneaz\u0103 media aritmetic\u0103 a numerelor reale a \u015fi b. Pentru a, b,  c \u015fi d numere reale, instruc\u0163iunea care atribuie variabilei a suma dintre media aritmetic\u0103 a  numerelor b \u015fi c \u015fi media aritmetic\u0103 a numerelor c \u015fi d este:  Limbajul  C++/C    a) a= f(b,f(c,d);  b) a=f(f(b,c),d);    c) a=(b+c+d)/2;  d) a=f(b,c)+f(b,d);    e) a=f(b,d)+c;  f) a=(f(b,c)+f(b,d))/2;  Limbajul  Pascal    a) a:= f(b,f(c,d);  b) a:=f(f(b,c),d);    c) a:=(b+c+d)/2;  d) a:=f(b,c)+f(b,d);    e) a:=f(b,d)+c;  f) a:=(f(b,c)+f(b,d))/2;    9.", "Se consider\u0103 un graf neorientat G, cu 5 noduri,  reprezentat prin matricea de adiacen\u0163\u0103 al\u0103turat\u0103.", "    Afirma\u0163ia adev\u0103rat\u0103 este:  0 1 0 0 1  1 0 1 1 1  0 1 0 1 0  0 1 1 0 0  1 1 0 0 0    a) G este graf hamiltonian \u015fi graf eulerian;  b) G este graf hamiltonian, dar nu este graf eulerian;  c) G nu este graf hamiltonian, dar este graf eulerian;  d) G nu este graf hamiltonian, nici graf eulerian;  e) G este graf hamiltonian;  f) Toate afirma\u0163iile de mai sus sunt false.", "   10.", "Pentru a determina toate modalit\u0103\u0163ile de a scrie pe 9 ca sum\u0103 de numere naturale nenule  distincte (abstrac\u0163ie f\u0103c\u00e2nd de ordinea termenilor), un elev folose\u015fte metoda backtracking  gener\u00e2nd, \u00een aceast\u0103 ordine, toate solu\u0163iile: 1+2+6, 1+3+5, 1+8, 2+3+4, 2+7, 3+6  \u015fi 4+5.", "Aplic\u00e2nd exact aceea\u015fi metod\u0103, el determin\u0103 solu\u0163iile pentru scrierea lui 12.", " Num\u0103rul solu\u0163ii de forma 3+... este:    a) 0  b) 1  c) 2  d) 4  e) 6  f) 7    11.", "Fie G un arbore cu n (n>1) noduri \u015fi d1\u2265 d2\u2265 d3\u2265... dn\u22651 gradele nodurilor sale.", "  Afirma\u0163ia adev\u0103rat\u0103 este:"], "page_sentence_count_spacy": 13}, {"page_number": 183, "page_char_count": 1119, "page_word_count": 279, "page_sentence_count_raw": 9, "page_token_count": 279.75, "text": "183    a) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udc27 \ud835\udc22=\ud835\udfcf \ud835\udfd0\ud835\udc27\u2212\ud835\udfd0  b) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udfd0\ud835\udc27\u2212\ud835\udfcf \ud835\udc8f \ud835\udc8a=\ud835\udfcf   c) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udc8f \ud835\udc8a=\ud835\udfcf \ud835\udfd0\ud835\udc27  d) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udfd0\ud835\udc27+ \ud835\udfcf \ud835\udc8f \ud835\udc8a=\ud835\udfcf   e) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udc27 \ud835\udc22=\ud835\udfcf \ud835\udfd0\ud835\udc27 +  \ud835\udfd0  f) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udc27 \ud835\udc27 \ud835\udc22=\ud835\udfcf     12. Func\u0163iea f prime\u015fte dou\u0103 valori \u00eentregi prin intermediul a doi parametri \u015fi returneaz\u0103 suma  tuturor cifrelor celor dou\u0103 numere. De exemplu, f(173,608)returneaz\u0103 25. Apelul  func\u0163iei f care determin\u0103 suma cifrelor unui num\u0103r \u00eentreg n este:    a) f(1,1)  b) f(n,0)  c) f(n,1)  d) f(n,n)  e) f(1,n)  f) f(n,n-1)    13. \u00centr-o coad\u0103, ini\u021bial vid\u0103, la fiecare pas k se introduc 3k valori \u015fi se extrag k+2 valori.   Dup\u0103 executarea primilor 9 pa\u0219i, \u00een coad\u0103 se afl\u0103 un num\u0103r de elemente egal cu:    a) 9  b) 36  c) 72  d) 75  e) 79  f) 172    14. Se consider\u0103 un graf neorientat conex cu n noduri \u015fi m muchii. Pentru a ob\u0163ine exact 2  componente conexe, num\u0103rul minim de muchii care trebuie eliminate este egal cu:  a) gradul minim din graf  b) gradul maxim din graf  c) m-1  d) n-1  e)  \ud835\udc26(\ud835\udc26\u2212\ud835\udfcf) \ud835\udfd0     f) \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   \u2212 \ud835\udc26    15. Num\u0103rul de elemente nule ale matricei de adiacen\u021b\u0103 asociat\u0103 unui arbore cu n noduri  este:    a) n2  b) n2+1  c) n(n-1)+n  d) n2-n-2  e) n(n-1)-n  f) n2-2n+2", "sentences": ["183    a) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udc27 \ud835\udc22=\ud835\udfcf \ud835\udfd0\ud835\udc27\u2212\ud835\udfd0  b) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udfd0\ud835\udc27\u2212\ud835\udfcf \ud835\udc8f \ud835\udc8a=\ud835\udfcf   c) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udc8f \ud835\udc8a=\ud835\udfcf \ud835\udfd0\ud835\udc27  d) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udfd0\ud835\udc27+ \ud835\udfcf \ud835\udc8f \ud835\udc8a=\ud835\udfcf   e) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udc27 \ud835\udc22=\ud835\udfcf \ud835\udfd0\ud835\udc27 +  \ud835\udfd0  f) \u2211 \ud835\udc1d\ud835\udc22= \ud835\udc27 \ud835\udc27 \ud835\udc22=\ud835\udfcf     12.", "Func\u0163iea f prime\u015fte dou\u0103 valori \u00eentregi prin intermediul a doi parametri \u015fi returneaz\u0103 suma  tuturor cifrelor celor dou\u0103 numere.", "De exemplu, f(173,608)returneaz\u0103 25.", "Apelul  func\u0163iei f care determin\u0103 suma cifrelor unui num\u0103r \u00eentreg n este:    a) f(1,1)  b) f(n,0)  c) f(n,1)  d) f(n,n)  e) f(1,n)  f) f(n,n-1)    13.", "\u00centr-o coad\u0103, ini\u021bial vid\u0103, la fiecare pas k se introduc 3k valori \u015fi se extrag k+2 valori.", "  Dup\u0103 executarea primilor 9 pa\u0219i, \u00een coad\u0103 se afl\u0103 un num\u0103r de elemente egal cu:    a) 9  b) 36  c) 72  d) 75  e) 79  f) 172    14.", "Se consider\u0103 un graf neorientat conex cu n noduri \u015fi m muchii.", "Pentru a ob\u0163ine exact 2  componente conexe, num\u0103rul minim de muchii care trebuie eliminate este egal cu:  a) gradul minim din graf  b) gradul maxim din graf  c) m-1  d) n-1  e)  \ud835\udc26(\ud835\udc26\u2212\ud835\udfcf) \ud835\udfd0     f) \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   \u2212 \ud835\udc26    15.", "Num\u0103rul de elemente nule ale matricei de adiacen\u021b\u0103 asociat\u0103 unui arbore cu n noduri  este:    a) n2  b) n2+1  c) n(n-1)+n  d) n2-n-2  e) n(n-1)-n  f) n2-2n+2"], "page_sentence_count_spacy": 9}, {"page_number": 184, "page_char_count": 1996, "page_word_count": 486, "page_sentence_count_raw": 10, "page_token_count": 499.0, "text": "184    Varianta 34    1. Variabila n memoreaz\u0103 un num\u0103r natural. Expresia care este egal\u0103 cu 0 dac\u0103 \u015fi numai dac\u0103  n este un num\u0103r nedivizibil cu 3 este:  Limbajul  C++/C  a) (1-n%3)*(2-n%3)  b) (2-n%3)%2  c) (1-n%3)+(2-n%3)  d)  (1-n%3)%2  e) (1-n%3)-(2-n%3)  f) (2-n%3)-(1-n%3)  Limbajul  Pascal  a)  (1 - n mod 3)*      (2 - n mod 3)  b) (2 - n mod 3) mod 2  c)  (1- n mod 3)+      (2 - n mod 3)  d) (1 - n mod 3) mod 2  e) (1-n mod 3)-      (2-n mod 3)  f) (2-n mod 3)-(1-n mod 3)    2. Variabia a memoreaz\u0103 numere reale ne\u00eentregi, a>0 \u015fi variabia c memoreaz\u0103 numere naturale.  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C   do   { c=floor(a);     a=(a-c)*10;   }while(floor(a)==0);   cout<<floor(a);      |printf(\"%d\",floor(a));  Limbajul Pascal  repeat          c:=int(a);          a:=(a-c)*10;    until int(a)>0;    write(floor(a));  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) prima zecimal\u0103 a lui a;  b) ultima zecimal\u0103 a lui a;  c) prima zecimal\u0103 nenul\u0103 a lui a;  d) ultima zecimal\u0103 nenul\u0103 a lui a;  e) a doua zecimal\u0103 a lui a;  f) a doua zecimal\u0103 nenul\u0103 a lui a.    3. Variabilele a \u015fi b memoreaz\u0103 numere naturale nenule. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C   b=0;   for(a=0; a<=9; a++)     if(a%4==2 || a%4==3) b=b+a;     else b++;   cout<<b;|printf(\"%d\",b);  Limbajul Pascal   b:=0;   for a:=0 to 9 do     if a mod 4=2 or a mod 4=3 b:=b+a     else b:=b+1;   write(b);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) 22  b) 23  c) 24  d) 25  e) 26  f) 27    4. Variabilele x,y \u015fi z au valori aleatoare \u00een mul\u0163imea {1,2,3}.   Se consider\u0103 urm\u0103toarele instruc\u0163iuni:  Limbajul C++/C   u = (x==y) || (y==z);   v = ((x!=y) && (y!=z));  Limbajul Pascal    u := (x=y) or (y=z);    v :=((x<>y) and (y<>z));  Afirma\u0163ia adev\u0103rat\u0103 este:  a) u \u015fi v sunt egale pentru orice x,y,z  b) exist\u0103 x,y,z pentru care u este diferit de v  c) u \u015fi v sunt diferite pentru orice x,y,z d) u \u015fi v sunt egale numai dac\u0103 x=y=z=1", "sentences": ["184    Varianta 34    1.", "Variabila n memoreaz\u0103 un num\u0103r natural.", "Expresia care este egal\u0103 cu 0 dac\u0103 \u015fi numai dac\u0103  n este un num\u0103r nedivizibil cu 3 este:  Limbajul  C++/C  a) (1-n%3)*(2-n%3)  b) (2-n%3)%2  c) (1-n%3)+(2-n%3)  d)  (1-n%3)%2  e) (1-n%3)-(2-n%3)  f) (2-n%3)-(1-n%3)  Limbajul  Pascal  a)  (1 - n mod 3)*      (2 - n mod 3)  b) (2 - n mod 3) mod 2  c)  (1- n mod 3)+      (2 - n mod 3)  d) (1 - n mod 3) mod 2  e) (1-n mod 3)-      (2-n mod 3)  f) (2-n mod 3)-(1-n mod 3)    2.", "Variabia a memoreaz\u0103 numere reale ne\u00eentregi, a>0 \u015fi variabia c memoreaz\u0103 numere naturale.", " Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C   do   { c=floor(a);     a=(a-c)*10;   }while(floor(a)==0);   cout<<floor(a);      |printf(\"%d\",floor(a));  Limbajul Pascal  repeat          c:=int(a);          a:=(a-c)*10;    until int(a)>0;    write(floor(a));  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) prima zecimal\u0103 a lui a;  b) ultima zecimal\u0103 a lui a;  c) prima zecimal\u0103 nenul\u0103 a lui a;  d) ultima zecimal\u0103 nenul\u0103 a lui a;  e) a doua zecimal\u0103 a lui a;  f) a doua zecimal\u0103 nenul\u0103 a lui a.    3.", "Variabilele a \u015fi b memoreaz\u0103 numere naturale nenule.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C   b=0;   for(a=0; a<=9; a++)     if(a%4==2 || a%4==3) b=b+a;     else b++;   cout<<b;|printf(\"%d\",b);  Limbajul Pascal   b:=0;   for a:=0 to 9 do     if a mod 4=2 or a mod 4=3 b:=b+a     else b:=b+1;   write(b);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) 22  b) 23  c) 24  d) 25  e) 26  f) 27    4.", "Variabilele x,y \u015fi z au valori aleatoare \u00een mul\u0163imea {1,2,3}.", "  Se consider\u0103 urm\u0103toarele instruc\u0163iuni:  Limbajul C++/C   u = (x==y) || (y==z);   v = ((x!=y) && (y!=z));  Limbajul Pascal    u := (x=y) or (y=z);    v :=((x<>y) and (y<>z));  Afirma\u0163ia adev\u0103rat\u0103 este:  a) u \u015fi v sunt egale pentru orice x,y,z  b) exist\u0103 x,y,z pentru care u este diferit de v  c) u \u015fi v sunt diferite pentru orice x,y,z d) u \u015fi v sunt egale numai dac\u0103 x=y=z=1"], "page_sentence_count_spacy": 9}, {"page_number": 185, "page_char_count": 2154, "page_word_count": 454, "page_sentence_count_raw": 17, "page_token_count": 538.5, "text": "185      e) u \u015fi v sunt egale numai dac\u0103 y = 1  f) u \u015fi v sunt egale numai dac\u0103 x+y+z=3    5. Num\u0103rul minim de noduri dintr-un graf neorientat cu 12 muchii, f\u0103r\u0103 noduri izolate, graf  format din exact 3 componente conexe este:    a) 7  b) 8  c) 9  d) 10  e) 11  f) 12    6. Se consider\u0103 tabloul unidimensional v cu n elemente (n num\u0103r natural, n\u22652). Subprogramul  f(v,i,j) inverseaz\u0103 ordinea elementelor aflate pe pozi\u0163iile i, i+i, ..., j-1, j  (1\u2264i<j\u2264n). Secven\u0163a de program care inverseaz\u0103, \u00een v, doar v[i] \u015fi v[j] este:  a) f(v,i,j); f(v,i+1,j-1);  b) f(v,i,j); f(v,i-1,j+1);  c) f(v,i,j); f(v,i+1,j+1);  d) f(v,i+1,j-1); f(v,i,j);  e) f(v,i+1,j+1); f(v,i,j);  f) f(v,i,j);f(v,i+1,j-1);     7. Se consider\u0103 un arbore. Referitor la un lan\u0163 elementar care une\u015fte dou\u0103 noduri distincte a \u015fi  b, afirma\u0163ia adev\u0103rat\u0103 este:  a) Este unic, dac\u0103 \u015fi numai dac\u0103 a sau b este  frunz\u0103.  b) Sigur con\u0163ine r\u0103d\u0103cina arborelui.  c) Este unic, oricare ar fi a \u015fi b.  d) Nu poate trece prin r\u0103d\u0103cina arborelui.  e) Este unic, dac\u0103 \u015fi numai dac\u0103 a sau b este  r\u0103d\u0103cin\u0103.  f) Nu este unic oricare ar fi a \u015fi b.    8. Variabilele a,b,c memoreaz\u0103 numere naturale nenule. Instruc\u0163iunea   Limbajul C++/C: c=b-b%a | Limbajul Pascal: c:=b-b mod a   atribuie variabilei c o valoare care reprezint\u0103:  a) cel mai mic num\u0103r natural mai mare sau egal cu a \u015fi care este divizibil cu b;  b) cel mai mic num\u0103r natural mai mare sau egal cu b \u015fi care este divizibil cu a;  c) cel mai mic num\u0103r natural mai mare sau egal cu b \u015fi care este nedivizibil cu a;  d) cel mai mare num\u0103r natural mai mic sau egal cu b \u015fi care este divizibil cu a;  e) cel mai mare num\u0103r natural mai mic sau egal cu a \u015fi care este divizibil cu b;  f) cel mai mare num\u0103r natural mai mic sau egal cu a \u015fi care este nedivizibil cu b.    9. Se consider\u0103 subprogramul f1:  Limbajul C++/C  void f1(int a[50][50],int n, int m)  {int i,j;  for(i=1;i<=n-1;i++)     for(j=i+1;j<=n;j++)       if(a[i][2]>a[j][2])f2(a,n,m,i,j);}  Limbajul Pascal  procedure f1(var a:array[1..5.,1..50] of integer;n,m:integer);  var i,j:integer;  begin   for i:=1 to n-1 do      for j:=i+1 to n do           if a[i][2]>a[j][2]f2(a,n,m,i,j)  end;", "sentences": ["185      e) u \u015fi v sunt egale numai dac\u0103 y = 1  f) u \u015fi v sunt egale numai dac\u0103 x+y+z=3    5.", "Num\u0103rul minim de noduri dintr-un graf neorientat cu 12 muchii, f\u0103r\u0103 noduri izolate, graf  format din exact 3 componente conexe este:    a) 7  b) 8  c) 9  d) 10  e) 11  f) 12    6.", "Se consider\u0103 tabloul unidimensional v cu n elemente (n num\u0103r natural, n\u22652).", "Subprogramul  f(v,i,j) inverseaz\u0103 ordinea elementelor aflate pe pozi\u0163iile i, i+i, ..., j-1, j  (1\u2264i<j\u2264n).", "Secven\u0163a de program care inverseaz\u0103, \u00een v, doar v[i] \u015fi v[j] este:  a) f(v,i,j); f(v,i+1,j-1);  b) f(v,i,j); f(v,i-1,j+1);  c) f(v,i,j); f(v,i+1,j+1);  d) f(v,i+1,j-1); f(v,i,j);  e) f(v,i+1,j+1); f(v,i,j);  f) f(v,i,j);f(v,i+1,j-1);     7.", "Se consider\u0103 un arbore.", "Referitor la un lan\u0163 elementar care une\u015fte dou\u0103 noduri distincte a \u015fi  b, afirma\u0163ia adev\u0103rat\u0103 este:  a) Este unic, dac\u0103 \u015fi numai dac\u0103 a sau b este  frunz\u0103.", " b) Sigur con\u0163ine r\u0103d\u0103cina arborelui.", " c) Este unic, oricare ar fi a \u015fi b.  d) Nu poate trece prin r\u0103d\u0103cina arborelui.", " e) Este unic, dac\u0103 \u015fi numai dac\u0103 a sau b este  r\u0103d\u0103cin\u0103.", " f) Nu este unic oricare ar fi a \u015fi b.    8.", "Variabilele a,b,c memoreaz\u0103 numere naturale nenule.", "Instruc\u0163iunea   Limbajul C++/C: c=b-b%a | Limbajul Pascal: c:=b-b mod a   atribuie variabilei c o valoare care reprezint\u0103:  a) cel mai mic num\u0103r natural mai mare sau egal cu a \u015fi care este divizibil cu b;  b) cel mai mic num\u0103r natural mai mare sau egal cu b \u015fi care este divizibil cu a;  c) cel mai mic num\u0103r natural mai mare sau egal cu b \u015fi care este nedivizibil cu a;  d) cel mai mare num\u0103r natural mai mic sau egal cu b \u015fi care este divizibil cu a;  e) cel mai mare num\u0103r natural mai mic sau egal cu a \u015fi care este divizibil cu b;  f) cel mai mare num\u0103r natural mai mic sau egal cu a \u015fi care este nedivizibil cu b.    9.", "Se consider\u0103 subprogramul f1:  Limbajul C++/C  void f1(int a[50][50],int n, int m)  {int i,j;  for(i=1;i<=n-1;i++)     for(j=i+1;j<=n;j++)       if(a[i][2]>a[j][2])f2(a,n,m,i,j);}  Limbajul Pascal  procedure f1(var a:array[1..5.,1..50] of integer;n,m:integer);  var i,j:integer;  begin   for i:=1 to n-1 do      for j:=i+1 to n do           if a[i][2]>a[j][2]f2(a,n,m,i,j)  end;"], "page_sentence_count_spacy": 14}, {"page_number": 186, "page_char_count": 2336, "page_word_count": 537, "page_sentence_count_raw": 10, "page_token_count": 584.0, "text": "186    Subprogramul f2 realizeaz\u0103 interschimbarea elementelor liniilor i \u015fi j ale tabloului  transmis prin parametrul a, care are n linii \u015fi m coloane. Numerotarea liniilor \u015fi a coloanelor  \u00eencepe de la 1.   Pentru a ordona cresc\u0103tor numerele de pe a doua coloan\u0103 a tabloului a, num\u0103rul de apeluri  ale subprogramului f2 necesar este:  a) cel pu\u0163in  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   b) cel mult  \ud835\udc26(\ud835\udc26\u2212\ud835\udfcf) \ud835\udfd0   c) exact  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   d) cel mult  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   e) cel pu\u0163in  \ud835\udc26(\ud835\udc26\u2212\ud835\udfcf) \ud835\udfd0   f) exact  \ud835\udc26(\ud835\udc26\u2212\ud835\udfcf) \ud835\udfd0     10. Generarea tuturor tablourilor bidimensionale de ordin n, cu elemente 6 \u015fi 9, cu proprietatea  c\u0103 pe fiecare linie \u015fi pe fiecare coloan\u0103 exist\u0103 un singur element egal cu 9, se poate realiza  utiliz\u00e2nd metoda backtracking. Algoritmul utilizat este echivalent cu algoritmul de  generare a:  a) aranjamentelor  b) combin\u0103rilor    c) permut\u0103rilor    d) produsului cartezian  e) submul\u0163imilor  f) problemei celor n dame    11.   Se consider\u0103 urm\u0103torul subprogram:    Limbajul C++  void f(char a, char &b)  {char x=a;a=b;b=x;}    Limbajul C   void f(char a, char *b)   {char x=a;a=*b;*b=x;}     Limbajul Pascal   procedure f(a:char;var  b:char);   var x:char;   begin     x:=a;a:=b;b:=x   end;  Dac\u0103, \u00eenainte de apel, a='a'\u015fi b='b', dup\u0103 executarea secven\u021bei de program al\u0103turate se  afi\u015feaz\u0103:    Limbajul C++  f(a,b);  cout<<a<<' '<<b;  Limbajul C   f(a,&b);    printf(\"%c %c\",a,b)  Limbajul Pascal   f(a,b);    write(a,' ',b);    a) a a  b) b b  c) b a  d) a b  e) aa  f) bb    12. Numim graf complementar al unui graf neorintat G1 graful neorientat G2 cu aceea\u015fi  mul\u0163ime a nodurilor ca \u015fi G1 \u015fi cu proprietatea c\u0103 dou\u0103 noduri sunt adiacente \u00een G2 dac\u0103 \u015fi  numai dac\u0103 nu sunt adiacente \u00een G1. Dac\u0103 G1 are n noduri \u015fi m muchii, num\u0103rul de muchii  pentru G2 este:  a) minim  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0  - m  b) exact  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0  - m  c) maxim  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   - m  d) minim n-m  e) exact n-m  f) maxim n-m    13. Subprogramul f(a,b) returneaz\u0103 cel mai mare divizor prim al num\u0103rului natural a,  divizor mai mic sau egal cu b (a\u22653, 2\u2264b\u2264a). Expresia care are valoarea 1 (C++/C) /  True (Pascal), dac\u0103 \u015fi numai dac\u0103 a este un num\u0103r prim este:  Limbajul  C++/C  a) f(a,a-1)== 2  b) f(a,a)== 2  c) f(a,a)== a  d) f(a,a/2)== a/2  e) f(a,a)== 1  f) f(a,a)== a/2  Limbajul  Pascal:  a) f(a,a-1)= 2  b) f(a,a)= 2  c) f(a,a)= a  d) f(a,a div 2)=        a div 2  e) f(a,a)= 1  f) f(a,a)= a div 2", "sentences": ["186    Subprogramul f2 realizeaz\u0103 interschimbarea elementelor liniilor i \u015fi j ale tabloului  transmis prin parametrul a, care are n linii \u015fi m coloane.", "Numerotarea liniilor \u015fi a coloanelor  \u00eencepe de la 1.", "  Pentru a ordona cresc\u0103tor numerele de pe a doua coloan\u0103 a tabloului a, num\u0103rul de apeluri  ale subprogramului f2 necesar este:  a) cel pu\u0163in  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   b) cel mult  \ud835\udc26(\ud835\udc26\u2212\ud835\udfcf) \ud835\udfd0   c) exact  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   d) cel mult  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   e) cel pu\u0163in  \ud835\udc26(\ud835\udc26\u2212\ud835\udfcf) \ud835\udfd0   f) exact  \ud835\udc26(\ud835\udc26\u2212\ud835\udfcf) \ud835\udfd0     10.", "Generarea tuturor tablourilor bidimensionale de ordin n, cu elemente 6 \u015fi 9, cu proprietatea  c\u0103 pe fiecare linie \u015fi pe fiecare coloan\u0103 exist\u0103 un singur element egal cu 9, se poate realiza  utiliz\u00e2nd metoda backtracking.", "Algoritmul utilizat este echivalent cu algoritmul de  generare a:  a) aranjamentelor  b) combin\u0103rilor    c) permut\u0103rilor    d) produsului cartezian  e) submul\u0163imilor  f) problemei celor n dame    11.", "  Se consider\u0103 urm\u0103torul subprogram:    Limbajul C++  void f(char a, char &b)  {char x=a;a=b;b=x;}    Limbajul C   void f(char a, char *b)   {char x=a;a=*b;*b=x;}     Limbajul Pascal   procedure f(a:char;var  b:char);   var x:char;   begin     x:=a;a:=b;b:=x   end;  Dac\u0103, \u00eenainte de apel, a='a'\u015fi b='b', dup\u0103 executarea secven\u021bei de program al\u0103turate se  afi\u015feaz\u0103:    Limbajul C++  f(a,b);  cout<<a<<' '<<b;  Limbajul C   f(a,&b);    printf(\"%c %c\",a,b)  Limbajul Pascal   f(a,b);    write(a,' ',b);    a) a a  b) b b  c) b a  d) a b  e) aa  f) bb    12.", "Numim graf complementar al unui graf neorintat G1 graful neorientat G2 cu aceea\u015fi  mul\u0163ime a nodurilor ca \u015fi G1 \u015fi cu proprietatea c\u0103 dou\u0103 noduri sunt adiacente \u00een G2 dac\u0103 \u015fi  numai dac\u0103 nu sunt adiacente \u00een G1.", "Dac\u0103 G1 are n noduri \u015fi m muchii, num\u0103rul de muchii  pentru G2 este:  a) minim  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0  - m  b) exact  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0  - m  c) maxim  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0   - m  d) minim n-m  e) exact n-m  f) maxim n-m    13.", "Subprogramul f(a,b) returneaz\u0103 cel mai mare divizor prim al num\u0103rului natural a,  divizor mai mic sau egal cu b (a\u22653, 2\u2264b\u2264a).", "Expresia care are valoarea 1 (C++/C) /  True (Pascal), dac\u0103 \u015fi numai dac\u0103 a este un num\u0103r prim este:  Limbajul  C++/C  a) f(a,a-1)== 2  b) f(a,a)== 2  c) f(a,a)== a  d) f(a,a/2)== a/2  e) f(a,a)== 1  f) f(a,a)== a/2  Limbajul  Pascal:  a) f(a,a-1)= 2  b) f(a,a)= 2  c) f(a,a)= a  d) f(a,a div 2)=        a div 2  e) f(a,a)= 1  f) f(a,a)= a div 2"], "page_sentence_count_spacy": 10}, {"page_number": 187, "page_char_count": 582, "page_word_count": 121, "page_sentence_count_raw": 5, "page_token_count": 145.5, "text": "187      14. Fie G un graf orientat, cu n noduri \u015fi m arce. Dac\u0103 S1 \u015fi S2 reprezint\u0103 suma gradelor  interioare, respectiv exterioare ale grafului G, afirma\u0163ia fals\u0103 este:  a) S1=S2  b) S1+S2=2m  c) dac\u0103 G este graf complet, atunci S1+S2=n(n-1)  d) S1\u2264S2  e) S1\u2265S2  f) dac\u0103 G este graf complet, atunci S1+S2=m(m-1)    15. Un arbore binar este un arbore cu r\u0103d\u0103cin\u0103 \u00een care fiecare nod are cel mult 2 descenden\u0163i  direc\u0163i (fii). Un arbore binar complet cu n noduri are un num\u0103r de niveluri egal cu:  a) [log2n]-1  b) [log2n]  c) [log2n]+1  d) [log2(n-1)]  e) [log2(n+1)]  f) [log2n]-1", "sentences": ["187      14.", "Fie G un graf orientat, cu n noduri \u015fi m arce.", "Dac\u0103 S1 \u015fi S2 reprezint\u0103 suma gradelor  interioare, respectiv exterioare ale grafului G, afirma\u0163ia fals\u0103 este:  a) S1=S2  b) S1+S2=2m  c) dac\u0103 G este graf complet, atunci S1+S2=n(n-1)  d) S1\u2264S2  e) S1\u2265S2  f) dac\u0103 G este graf complet, atunci S1+S2=m(m-1)    15.", "Un arbore binar este un arbore cu r\u0103d\u0103cin\u0103 \u00een care fiecare nod are cel mult 2 descenden\u0163i  direc\u0163i (fii).", "Un arbore binar complet cu n noduri are un num\u0103r de niveluri egal cu:  a) [log2n]-1  b) [log2n]  c) [log2n]+1  d) [log2(n-1)]  e) [log2(n+1)]  f) [log2n]-1"], "page_sentence_count_spacy": 5}, {"page_number": 188, "page_char_count": 1916, "page_word_count": 528, "page_sentence_count_raw": 9, "page_token_count": 479.0, "text": "188    Varianta 35    1.  Variabilele n \u015fi c memoreaz\u0103 numere naturale nenule. Instruc\u0163iunea care insereaz\u0103 cifra c  \u00een fa\u0163a ultimei cifre a lui n este:  Limbajul  C++/C  a) n=(n%10*10+c)*10+n/10;  b) n=(n/10*10+c)*10+n%10;  c) n=(n/10+c)*10+n%10;  d) n=n/10+c+n%10;  e) n= n/10*10+c*10+n%10;  f) n=(n%10+c)*10+n/10;  Limbajul  Pascal  a) n:=(n mod10*10+c)*10        +n div 10;  b) n:=(n div 10*10+c)*10        +n mod 10;  c) n:=(n div 10+c)*10        +n mod 10;  d) n:=n div 10+c+n mod 10;  e) n:= n div 10*10+c*10        +n mod 10;  f) n:=(n mod 10+c)*10+n div 10;    2.  Variabilele a \u015fi b memoreaz\u0103 numere naturale. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C      b=2;      for(a=5; a<=10; a++)      {          a=a+b;          b=a+b;      }      cout<<a+b; |printf(\"%d\",a+b);  Limbajul Pascal      b:=2;      for a:= 5 to 10 do      begin          a:=a+b;          b:=a+b      end;      write(a+b);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:    a) 18  b) 26  c) 28  d) 44  e) 48  f) 52    3.  Variabilele i,j \u015fi k memoreaz\u0103 numere naturale. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C  for(i=1;i<=10;i++)  { for(j=1;j<=i;j++)           cout<<j; |printf(\"%d\",j);     for(k=9;k>0;k--)            cout<<k; |printf(\"%d\",k);   }  Limbajul Pascal   for i:=1 to 10 do     begin      for j:=1 to i do write(j);      for k:=9 downto 1 do           write(k)     end;  Num\u0103rul de execu\u0163ii ale instruc\u0163iunii care afi\u015feaz\u0103 valoarea variabilei k este:    a) 495  b) 90  c ) 60  d) 55  e) 10  f) 9    4.  Pentru un graf neorientat cu 9 muchii \u015fi 12 noduri, num\u0103rul minim de componente  conexe este:    a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    5.  Algoritmul lui Euclid este utilizat pentru:   a) calculul num\u0103rului de multipli ai unui num\u0103r natural;  b) descompunerea \u00een factori primi a unui num\u0103r natural;  c) calculul celui mai mare divizor comun a dou\u0103 numere naturale;", "sentences": ["188    Varianta 35    1.", " Variabilele n \u015fi c memoreaz\u0103 numere naturale nenule.", "Instruc\u0163iunea care insereaz\u0103 cifra c  \u00een fa\u0163a ultimei cifre a lui n este:  Limbajul  C++/C  a) n=(n%10*10+c)*10+n/10;  b) n=(n/10*10+c)*10+n%10;  c) n=(n/10+c)*10+n%10;  d) n=n/10+c+n%10;  e) n= n/10*10+c*10+n%10;  f) n=(n%10+c)*10+n/10;  Limbajul  Pascal  a) n:=(n mod10*10+c)*10        +n div 10;  b) n:=(n div 10*10+c)*10        +n mod 10;  c) n:=(n div 10+c)*10        +n mod 10;  d) n:=n div 10+c+n mod 10;  e) n:= n div 10*10+c*10        +n mod 10;  f) n:=(n mod 10+c)*10+n div 10;    2.", " Variabilele a \u015fi b memoreaz\u0103 numere naturale.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C      b=2;      for(a=5; a<=10; a++)      {          a=a+b;          b=a+b;      }      cout<<a+b; |printf(\"%d\",a+b);  Limbajul Pascal      b:=2;      for a:= 5 to 10 do      begin          a:=a+b;          b:=a+b      end;      write(a+b);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:    a) 18  b) 26  c) 28  d) 44  e) 48  f) 52    3.", " Variabilele i,j \u015fi k memoreaz\u0103 numere naturale.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C  for(i=1;i<=10;i++)  { for(j=1;j<=i;j++)           cout<<j; |printf(\"%d\",j);     for(k=9;k>0;k--)            cout<<k; |printf(\"%d\",k);   }  Limbajul Pascal   for i:=1 to 10 do     begin      for j:=1 to i do write(j);      for k:=9 downto 1 do           write(k)     end;  Num\u0103rul de execu\u0163ii ale instruc\u0163iunii care afi\u015feaz\u0103 valoarea variabilei k este:    a) 495  b) 90  c ) 60  d) 55  e) 10  f) 9    4.", " Pentru un graf neorientat cu 9 muchii \u015fi 12 noduri, num\u0103rul minim de componente  conexe este:    a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    5.", " Algoritmul lui Euclid este utilizat pentru:   a) calculul num\u0103rului de multipli ai unui num\u0103r natural;  b) descompunerea \u00een factori primi a unui num\u0103r natural;  c) calculul celui mai mare divizor comun a dou\u0103 numere naturale;"], "page_sentence_count_spacy": 9}, {"page_number": 189, "page_char_count": 2321, "page_word_count": 464, "page_sentence_count_raw": 12, "page_token_count": 580.25, "text": "189    d) calculul num\u0103rului de divizori ai unui num\u0103r natural;  e) suma divizorilor unui num\u0103r natural;  f) suma divizorilor proprii ai unui num\u0103r natural.    6.  Variabilele x,y,z,s \u015fi p memoreaz\u0103 numere reale. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C  if(x>y) if(y>z) if(z>x)  s=x+y+z; else p=x*y*z;  Limbajul Pascal    if x>y then if y>z then if z>x then    s:=x+y+z else p:=x*y*z;  Secven\u0163a de program echivalent\u0103 cu ea, care s\u0103 con\u0163in\u0103 o singur\u0103 instruc\u0163iune de decizie,  este:  Limbajul  C++/C  a) if(x>y || y>z)s=x+y+z; b) if(x>y && y>z)s=x+y+z;  c) if(x>y && y>z)s=x+y+z; d) if(x>y && y>z)p=x*y*z;  e) if(x>y && y>z)s=x+y+z;   else p=p*y*z;  f) if(x>y || y>z)p=x*y*z;  Limbajul  Pascal  a) if(x>y)or(y>z)then        s:=x+y+z;  b) if(x>y)and(y>z)then s:=x+y+z;  c) if(x>y)and(y>z)then        s:=x+y+z;  d) if(x>y)and(y>z)then p:=x*y*z;  e) if(x>y)and(y>z)then        s:=x+y+z   else p:=p*y*z;  f) if(x>y)or(y>z)then p:=x*y*z;    7.  Num\u0103rul de interschimb\u0103ri care se efectueaz\u0103 \u00een cazul sort\u0103rii descresc\u0103toare a \u015firului de  numere consecutive 0,1,2,3,...,8,9,10 prin metoda bulelor este:    a) 0  b) 10  c) 11  d) 45  e) 55  f) 121    8.  Fie a un tablou bidimensional cu 45 linii (numerotate de la 1 la 45) \u015fi 45 coloane  (numerotate de la 1 la 45). Expresia care calculeaz\u0103 num\u0103rul de ordine al elementului de  pe linia i \u015fi coloana j (a c\u00e2ta valoare este acesta, pornind din col\u0163ul din s\u00e2nga sus, de la  prima spre ultima linie, pe fiecare linie elementele num\u0103r\u00e2ndu-se de la st\u00e2nga la dreapta)  este:  a) i*45+j-1  b) (i-1)*45+j  c) (j-1)*45+i  d) j*45+i-1  e) (i+1)*45+j  f) (j+1)*45+i    9.  Se consider\u0103 algoritmul care determin\u0103 toate permut\u0103rile distincte de n obiecte  (numerotate de la 1 la n), \u00een care pe orice pozi\u0163ie de rang par se afl\u0103 o valoare par\u0103. De  exemplu, pentru n=5, primele trei permut\u0103ri generate \u00een ordine lexicografic\u0103 sunt:  (1,2,3,4,5), (1,2,5,4,3), (1,4,3,2,5).   Pentru n=4, num\u0103rul total de astfel de permut\u0103ri este:    a) 12  b) 10  c) 8  d) 7  e) 6  f) 4      10. Subprogramul f prime\u015fte prin parametrii a \u015fi b dou\u0103 valori \u00eentregi (a\u2264b) \u015fi returneaz\u0103  num\u0103rul de numere prime din intervalul \u00eenchis [a,b]. Expresia care are valoarea 1  (C++/C) / True (Pascal), numai dac\u0103 valoarea \u00eentreag\u0103 x (x>5) este num\u0103r prim este:  a) f(x-1,x)==f(x,x+1)  b) f(x,x)==1", "sentences": ["189    d) calculul num\u0103rului de divizori ai unui num\u0103r natural;  e) suma divizorilor unui num\u0103r natural;  f) suma divizorilor proprii ai unui num\u0103r natural.", "   6.", " Variabilele x,y,z,s \u015fi p memoreaz\u0103 numere reale.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C  if(x>y) if(y>z) if(z>x)  s=x+y+z; else p=x*y*z;  Limbajul Pascal    if x>y then if y>z then if z>x then    s:=x+y+z else p:=x*y*z;  Secven\u0163a de program echivalent\u0103 cu ea, care s\u0103 con\u0163in\u0103 o singur\u0103 instruc\u0163iune de decizie,  este:  Limbajul  C++/C  a) if(x>y || y>z)s=x+y+z; b) if(x>y && y>z)s=x+y+z;  c) if(x>y && y>z)s=x+y+z; d) if(x>y && y>z)p=x*y*z;  e) if(x>y && y>z)s=x+y+z;   else p=p*y*z;  f) if(x>y || y>z)p=x*y*z;  Limbajul  Pascal  a) if(x>y)or(y>z)then        s:=x+y+z;  b) if(x>y)and(y>z)then s:=x+y+z;  c) if(x>y)and(y>z)then        s:=x+y+z;  d) if(x>y)and(y>z)then p:=x*y*z;  e) if(x>y)and(y>z)then        s:=x+y+z   else p:=p*y*z;  f) if(x>y)or(y>z)then p:=x*y*z;    7.", " Num\u0103rul de interschimb\u0103ri care se efectueaz\u0103 \u00een cazul sort\u0103rii descresc\u0103toare a \u015firului de  numere consecutive 0,1,2,3,...,8,9,10 prin metoda bulelor este:    a) 0  b) 10  c) 11  d) 45  e) 55  f) 121    8.", " Fie a un tablou bidimensional cu 45 linii (numerotate de la 1 la 45) \u015fi 45 coloane  (numerotate de la 1 la 45).", "Expresia care calculeaz\u0103 num\u0103rul de ordine al elementului de  pe linia i \u015fi coloana j (a c\u00e2ta valoare este acesta, pornind din col\u0163ul din s\u00e2nga sus, de la  prima spre ultima linie, pe fiecare linie elementele num\u0103r\u00e2ndu-se de la st\u00e2nga la dreapta)  este:  a) i*45+j-1  b) (i-1)*45+j  c) (j-1)*45+i  d) j*45+i-1  e) (i+1)*45+j  f) (j+1)*45+i    9.", " Se consider\u0103 algoritmul care determin\u0103 toate permut\u0103rile distincte de n obiecte  (numerotate de la 1 la n), \u00een care pe orice pozi\u0163ie de rang par se afl\u0103 o valoare par\u0103.", "De  exemplu, pentru n=5, primele trei permut\u0103ri generate \u00een ordine lexicografic\u0103 sunt:  (1,2,3,4,5), (1,2,5,4,3), (1,4,3,2,5).", "  Pentru n=4, num\u0103rul total de astfel de permut\u0103ri este:    a) 12  b) 10  c) 8  d) 7  e) 6  f) 4      10.", "Subprogramul f prime\u015fte prin parametrii a \u015fi b dou\u0103 valori \u00eentregi (a\u2264b) \u015fi returneaz\u0103  num\u0103rul de numere prime din intervalul \u00eenchis [a,b].", "Expresia care are valoarea 1  (C++/C) / True (Pascal), numai dac\u0103 valoarea \u00eentreag\u0103 x (x>5) este num\u0103r prim este:  a) f(x-1,x)==f(x,x+1)  b) f(x,x)==1"], "page_sentence_count_spacy": 12}, {"page_number": 190, "page_char_count": 2130, "page_word_count": 475, "page_sentence_count_raw": 8, "page_token_count": 532.5, "text": "190    Limbajul  C++/C  c) f(2,x)!=f(2,x-1)  d) f(2,x)!=f(2,x+1)  e) f(2,x)==f(2,x-1)  f) f(2,x)==f(2,x+1)  Limbajul  Pascal  a) f(x-1,x)=f(x,x+1)  b) f(x,x)=1  c) f(2,x)<>f(2,x-1)  d) f(2,x)<>f(2,x+1)  e) f(2,x)=f(2,x-1)  f) f(2,x)=f(2,x+1)    11. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:    Limbajul C++  int a,b;  void f(int x,int &y)  {int b=x;y+=b;x=y;}  int main()  { a=20;b=23;    f(a,b);    cout<<a<<' '<<b;    return 0;  }  Limbajul C   int a,b;   void f(int x,int *y)     {int b=x;*y=*y+b;x=*y;}   int main()   { a=20;b=23;     f(a,&b);     printf(\"%d %d\",a,b);     return 0;   }   Limbajul Pascal   var a,b:integer;   procedure    f(x:integer; var  y:integer);   var b:integer;   begin  b:=x;y:=y+b;x:=y  end;   begin    a:=20;b:=23;    f(a,b);write(a,' ',b)   end.    \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:    a) 43 43  b) 23 23  c) 20 23  d) 23 43 e) 20 43  f) 23 20    12. Num\u0103rul minim de muchii care trebuie ad\u0103ugate grafului din figura al\u0103turat\u0103, astfel \u00eenc\u00e2t  acesta s\u0103 devin\u0103 eulerian este:      a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    13. Subprogramul minim returneaz\u0103 cifra minim\u0103 a unui num\u0103r natural. Pentru o variabil\u0103 x,  ce memoreaz\u0103 o valoare natural\u0103 de cel mult 2 cifre, subprogramul este apelat \u00eentr-o  secven\u0163\u0103 de forma Limbajul C++/C:         if(minim(x)+minim(x*x*x))==0)nr++;   Limbajul Pascal:          if minim(x)+minim(x*x*x)=0 then nr:=nr+1;   Varianta pentru un antet corect al subprogramului este:  Limbajul C++/C  Limbajul Pascal  a) int minim(long u)   a) function minim(u:longint):integer;  b) int minim(long x*x*x)   b) function minim(x*x*x:longint)    :integer;  c) int minim(int x, int y)    c) function minim(x,y:integer)    :integer;    d) void minim(long u)   d) procedure minim(u:longint);  e) void minim(int x, int y)  e) procedure minim(x,y:longint);  f) void minim(long x*x*x)   f) procedure minim(x*x*x:longint);    14. Un arbore binar este un arbore cu r\u0103d\u0103cin\u0103 \u00een care fiecare nod are cel mult 2 descenden\u0163i  direc\u0163i (fii).  Un arbore binar complet, cu h niveluri, are un num\u0103r de noduri egal cu:    a) 2h  b) 2h+1  c) 2h-1  d) 2h-1  e) 2h  f) 2h+1", "sentences": ["190    Limbajul  C++/C  c) f(2,x)!=f(2,x-1)  d) f(2,x)!=f(2,x+1)  e) f(2,x)==f(2,x-1)  f) f(2,x)==f(2,x+1)  Limbajul  Pascal  a) f(x-1,x)=f(x,x+1)  b) f(x,x)=1  c) f(2,x)<>f(2,x-1)  d) f(2,x)<>f(2,x+1)  e) f(2,x)=f(2,x-1)  f) f(2,x)=f(2,x+1)    11.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:    Limbajul C++  int a,b;  void f(int x,int &y)  {int b=x;y+=b;x=y;}  int main()  { a=20;b=23;    f(a,b);    cout<<a<<' '<<b;    return 0;  }  Limbajul C   int a,b;   void f(int x,int *y)     {int b=x;*y=*y+b;x=*y;}   int main()   { a=20;b=23;     f(a,&b);     printf(\"%d %d\",a,b);     return 0;   }   Limbajul Pascal   var a,b:integer;   procedure    f(x:integer; var  y:integer);   var b:integer;   begin  b:=x;y:=y+b;x:=y  end;   begin    a:=20;b:=23;    f(a,b);write(a,' ',b)   end.", "   \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:    a) 43 43  b) 23 23  c) 20 23  d) 23 43 e) 20 43  f) 23 20    12.", "Num\u0103rul minim de muchii care trebuie ad\u0103ugate grafului din figura al\u0103turat\u0103, astfel \u00eenc\u00e2t  acesta s\u0103 devin\u0103 eulerian este:      a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    13.", "Subprogramul minim returneaz\u0103 cifra minim\u0103 a unui num\u0103r natural.", "Pentru o variabil\u0103 x,  ce memoreaz\u0103 o valoare natural\u0103 de cel mult 2 cifre, subprogramul este apelat \u00eentr-o  secven\u0163\u0103 de forma Limbajul C++/C:         if(minim(x)+minim(x*x*x))==0)nr++;   Limbajul Pascal:          if minim(x)+minim(x*x*x)=0 then nr:=nr+1;   Varianta pentru un antet corect al subprogramului este:  Limbajul C++/C  Limbajul Pascal  a) int minim(long u)   a) function minim(u:longint):integer;  b) int minim(long x*x*x)   b) function minim(x*x*x:longint)    :integer;  c) int minim(int x, int y)    c) function minim(x,y:integer)    :integer;    d) void minim(long u)   d) procedure minim(u:longint);  e) void minim(int x, int y)  e) procedure minim(x,y:longint);  f) void minim(long x*x*x)   f) procedure minim(x*x*x:longint);    14.", "Un arbore binar este un arbore cu r\u0103d\u0103cin\u0103 \u00een care fiecare nod are cel mult 2 descenden\u0163i  direc\u0163i (fii).", " Un arbore binar complet, cu h niveluri, are un num\u0103r de noduri egal cu:    a) 2h  b) 2h+1  c) 2h-1  d) 2h-1  e) 2h  f) 2h+1"], "page_sentence_count_spacy": 8}, {"page_number": 191, "page_char_count": 210, "page_word_count": 64, "page_sentence_count_raw": 3, "page_token_count": 52.5, "text": "191      15. Fie G un graf neorientat, cu n noduri \u015fi p componente conexe.   Num\u0103rul maxim de muchii este:  a)  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0     b)  (\ud835\udc27\u2212\ud835\udc29)(\ud835\udc27\u2212\ud835\udc29+\ud835\udfcf) \ud835\udfd0  c)  \ud835\udc27(\ud835\udc27+\ud835\udfcf) \ud835\udfd0   d)  (\ud835\udc27+\ud835\udc29)(\ud835\udc27+\ud835\udc29+\ud835\udfcf) \ud835\udfd0     e)  \ud835\udc29(\ud835\udc29\u2212\ud835\udfcf) \ud835\udfd0   f)  \ud835\udc29(\ud835\udc29+\ud835\udfcf) \ud835\udfd0", "sentences": ["191      15.", "Fie G un graf neorientat, cu n noduri \u015fi p componente conexe.", "  Num\u0103rul maxim de muchii este:  a)  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0     b)  (\ud835\udc27\u2212\ud835\udc29)(\ud835\udc27\u2212\ud835\udc29+\ud835\udfcf) \ud835\udfd0  c)  \ud835\udc27(\ud835\udc27+\ud835\udfcf) \ud835\udfd0   d)  (\ud835\udc27+\ud835\udc29)(\ud835\udc27+\ud835\udc29+\ud835\udfcf) \ud835\udfd0     e)  \ud835\udc29(\ud835\udc29\u2212\ud835\udfcf) \ud835\udfd0   f)  \ud835\udc29(\ud835\udc29+\ud835\udfcf) \ud835\udfd0"], "page_sentence_count_spacy": 3}, {"page_number": 192, "page_char_count": 1872, "page_word_count": 432, "page_sentence_count_raw": 8, "page_token_count": 468.0, "text": "192    Varianta 36    1.  Variabilele x \u0219i y memoreaz\u0103 numere \u00eentregi. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:   Limbajul   C++/C  x=2020/7;  y=123%10*3/8;  cout<<x<<' '<<y  |printf(\"%d  %d\",x,y);  Limbajul  Pascal  x:=2020 div 7;  y:=123 mod 10*3 div 8;  write(x,' ',y);    Dup\u0103 executarea secven\u021be de program al\u0103turate, variabilele x \u0219i y au valorile:    a) 66 0  b) 66 1  c) 202 0  d) 202 1  e) 288 0  f) 288 1    2.    Se consider\u0103 urm\u0103toarea expresie:  Limbajul C++/C:  (x==y)==(y==z)  Limbajul Pascal : (x=y)=(y=z)  Expresia dat\u0103 are valoarea 0(C++/C)/False(Pascal) dac\u0103 \u0219i numai dac\u0103 cele trei  variabile \u00eentregi x, y \u0219i z sunt:  a) toate trei egale  b) neini\u021bializate  Limbajul C++/C  Limbajul Pascal  c)(x==y && y!=z)||(x!=y && y==z) c)(x=y and y<>z)or     (x<>y and y=z)  d)(x==y && y!=z)&&(x!=y &&  y==z)  d)(x=y and y<>z)and     (x<>y and y=z)  e)(x==y || y!=z)||(x!=y || y==z) e)(x=y or y<>z)or     (x<>y or y=z)  f) (x==y || y!=z)&&(x!=y ||  y==z)  f) (x=y or y<>z)and   (x<>y or y=z)        3.  Variabilele de tip \u00eentreg x \u0219i y, ini\u021bial egale, memoreaz\u0103 valoarea 100. Se consider\u0103  urm\u0103toarea secven\u0163\u0103 de program:    Limbajul C++/C  Limbajul Pascal    if(x>y) x=10*y-8*x;     else y=10*x-8*y;  if x>y then x:=10*y-8*x     else y:=10*x-8*y;    \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate, diferen\u021ba absolut\u0103 dintre valorile  celor dou\u0103 variabile este:    a) -200  b) -100  c) 0  d) 1  e) 100  f) 200    4.  Se consider\u0103 urm\u0103toarele dou\u0103 secven\u021be:  Limbajul C++/C  Limbajul Pascal  while \u2026\u2026  {   a=a-1;   cout<<\"20\";  }  do  { cout<<\"20\";    a--;  }while(a>=1);  while \u2026\u2026 do  begin    a:=a-1;    write('20');  end;  repeat    write('20');    a:=a-1;  until a<1;  Variabila de tip \u00eentreg a are ini\u021bial valoarea 21. Cele dou\u0103 secven\u0163e sunt echivalente  dac\u0103 punctele de suspensie se \u00eenlocuiesc cu:    a) a=0  b) a>0  c) a>=1  d) a>1  e) a<=1  f) a<1", "sentences": ["192    Varianta 36    1.", " Variabilele x \u0219i y memoreaz\u0103 numere \u00eentregi.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:   Limbajul   C++/C  x=2020/7;  y=123%10*3/8;  cout<<x<<' '<<y  |printf(\"%d  %d\",x,y);  Limbajul  Pascal  x:=2020 div 7;  y:=123 mod 10*3 div 8;  write(x,' ',y);    Dup\u0103 executarea secven\u021be de program al\u0103turate, variabilele x \u0219i y au valorile:    a) 66 0  b) 66 1  c) 202 0  d) 202 1  e) 288 0  f) 288 1    2.", "   Se consider\u0103 urm\u0103toarea expresie:  Limbajul C++/C:  (x==y)==(y==z)  Limbajul Pascal : (x=y)=(y=z)  Expresia dat\u0103 are valoarea 0(C++/C)/False(Pascal) dac\u0103 \u0219i numai dac\u0103 cele trei  variabile \u00eentregi x, y \u0219i z sunt:  a) toate trei egale  b) neini\u021bializate  Limbajul C++/C  Limbajul Pascal  c)(x==y && y!=z)||(x!=y && y==z) c)(x=y and y<>z)or     (x<>y and y=z)  d)(x==y && y!=z)&&(x!=y &&  y==z)  d)(x=y and y<>z)and     (x<>y and y=z)  e)(x==y || y!=z)||(x!=y || y==z) e)(x=y or y<>z)or     (x<>y or y=z)  f) (x==y || y!=z)&&(x!=y ||  y==z)  f) (x=y or y<>z)and   (x<>y or y=z)        3.", " Variabilele de tip \u00eentreg x \u0219i y, ini\u021bial egale, memoreaz\u0103 valoarea 100.", "Se consider\u0103  urm\u0103toarea secven\u0163\u0103 de program:    Limbajul C++/C  Limbajul Pascal    if(x>y) x=10*y-8*x;     else y=10*x-8*y;  if x>y then x:=10*y-8*x     else y:=10*x-8*y;    \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate, diferen\u021ba absolut\u0103 dintre valorile  celor dou\u0103 variabile este:    a) -200  b) -100  c) 0  d) 1  e) 100  f) 200    4.", " Se consider\u0103 urm\u0103toarele dou\u0103 secven\u021be:  Limbajul C++/C  Limbajul Pascal  while \u2026\u2026  {   a=a-1;   cout<<\"20\";  }  do  { cout<<\"20\";    a--;  }while(a>=1);  while \u2026\u2026 do  begin    a:=a-1;    write('20');  end;  repeat    write('20');    a:=a-1;  until a<1;  Variabila de tip \u00eentreg a are ini\u021bial valoarea 21.", "Cele dou\u0103 secven\u0163e sunt echivalente  dac\u0103 punctele de suspensie se \u00eenlocuiesc cu:    a) a=0  b) a>0  c) a>=1  d) a>1  e) a<=1  f) a<1"], "page_sentence_count_spacy": 8}, {"page_number": 193, "page_char_count": 2044, "page_word_count": 480, "page_sentence_count_raw": 14, "page_token_count": 511.0, "text": "193    5.  Se consider\u0103 urm\u0103torul subprogram:    Limbajul C++/C  int f(int x)  {      if(x) return 2*f(x-1);      else return 3;  }  Limbajul Pascal  function f(x:integer):integer;  begin      if x<>0 then f:=2*f(x-1);      else f:=3  end;    Valoarea returnat\u0103 de apelul f(5) pentru func\u0163ia al\u0103turat\u0103 este:    a) 3  b) 13  c) 48  d) 96  e) 144  f) 162    6.  Concatenarea a dou\u0103 \u0219iruri de caractere se poate realiza cu func\u0163ia predefinit\u0103:  Limbajul  C++/C  a)  strconcat  b)  strcmp  c) strlen d) strcat e)  strst r  f) strlwr  Limbajul  Pascal  a) paste  b) copy  c) length d) concat e) str  f) pos    7.  Se consider\u0103 un graf neorientat cu nodurile numerotate de la 1 la 5 \u0219i muchiile  [1,2],[1,5], [2,3],[2,4],[2,5],[3,4],[4,5]. Num\u0103rul lan\u021burilor distincte  de lungime 3 de la nodul 1 la 4 este:    a) 3  b) 4  c) 5  d) 6  e) 7  f) 8    8.  Se consider\u0103 un arbore cu r\u0103d\u0103cin\u0103, cu 2020 noduri. Num\u0103rul minim de frunze pe care  \u00eel poate avea arborele este:    a) 0  b) 1  c) 2  d) 1010  e) 2019  f) 2020    9.  Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate numerele, de cel mult trei cifre,  formate cu cifre distincte, care au suma cifrelor egal\u0103 cu 7 \u0219i nu sunt divizibile cu 10.  Astfel, se genereaz\u0103 \u00een aceast\u0103 ordine numerele: 106, 124, 142, 16, 205, \u2026. Folosind  accea\u0219i metod\u0103 se genereaz\u0103 toate numerele naturale cu cifre distincte, care au suma  cifrelor egal\u0103 cu 9 \u0219i nu sunt divizible cu 5. Al \u0219aselea num\u0103r generat este:    a) 135  b) 153  c) 162  d) 207  e) 216  f) 234    10. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program \u00een care toate variabilele sunt numere  \u00eentregi:  Limbajul C++/C  Limbajul Pascal  for (i=0;i<= 2020;i++)   {  =i+1;a[i]=t;t--; }  for i:=0 to 2020 do   begin    t:=i+1;a[i]:=t;dec(t); end;    Suma elementelor tabloului a este:    a) 2020  b) 2021  c) 4040  d) 4041  e) 2041210 f) 2043231    11. Folosind metoda bulelor tabloul unidimensional (5,6,10,20,1)este ordonat  cresc\u0103tor:(1,5,6,10,20). Num\u0103rul de parcurgeri necesare pentru a ordona cresc\u0103tor  tabloul este:    a) 9  b) 8  c) 7  d) 6  e) 5  f) 4", "sentences": ["193    5.", " Se consider\u0103 urm\u0103torul subprogram:    Limbajul C++/C  int f(int x)  {      if(x) return 2*f(x-1);      else return 3;  }  Limbajul Pascal  function f(x:integer):integer;  begin      if x<>0 then f:=2*f(x-1);      else f:=3  end;    Valoarea returnat\u0103 de apelul f(5) pentru func\u0163ia al\u0103turat\u0103 este:    a) 3  b) 13  c) 48  d) 96  e) 144  f) 162    6.", " Concatenarea a dou\u0103 \u0219iruri de caractere se poate realiza cu func\u0163ia predefinit\u0103:  Limbajul  C++/C  a)  strconcat  b)  strcmp  c) strlen d) strcat e)  strst r  f) strlwr  Limbajul  Pascal  a) paste  b) copy  c) length d) concat e) str  f) pos    7.", " Se consider\u0103 un graf neorientat cu nodurile numerotate de la 1 la 5 \u0219i muchiile  [1,2],[1,5], [2,3],[2,4],[2,5],[3,4],[4,5].", "Num\u0103rul lan\u021burilor distincte  de lungime 3 de la nodul 1 la 4 este:    a) 3  b) 4  c) 5  d) 6  e) 7  f) 8    8.", " Se consider\u0103 un arbore cu r\u0103d\u0103cin\u0103, cu 2020 noduri.", "Num\u0103rul minim de frunze pe care  \u00eel poate avea arborele este:    a) 0  b) 1  c) 2  d) 1010  e) 2019  f) 2020    9.", " Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate numerele, de cel mult trei cifre,  formate cu cifre distincte, care au suma cifrelor egal\u0103 cu 7 \u0219i nu sunt divizibile cu 10.", " Astfel, se genereaz\u0103 \u00een aceast\u0103 ordine numerele: 106, 124, 142, 16, 205, \u2026.", "Folosind  accea\u0219i metod\u0103 se genereaz\u0103 toate numerele naturale cu cifre distincte, care au suma  cifrelor egal\u0103 cu 9 \u0219i nu sunt divizible cu 5.", "Al \u0219aselea num\u0103r generat este:    a) 135  b) 153  c) 162  d) 207  e) 216  f) 234    10.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program \u00een care toate variabilele sunt numere  \u00eentregi:  Limbajul C++/C  Limbajul Pascal  for (i=0;i<= 2020;i++)   {  =i+1;a[i]=t;t--; }  for i:=0 to 2020 do   begin    t:=i+1;a[i]:=t;dec(t); end;    Suma elementelor tabloului a este:    a) 2020  b) 2021  c) 4040  d) 4041  e) 2041210 f) 2043231    11.", "Folosind metoda bulelor tabloul unidimensional (5,6,10,20,1)este ordonat  cresc\u0103tor:(1,5,6,10,20).", "Num\u0103rul de parcurgeri necesare pentru a ordona cresc\u0103tor  tabloul este:    a) 9  b) 8  c) 7  d) 6  e) 5  f) 4"], "page_sentence_count_spacy": 14}, {"page_number": 194, "page_char_count": 2008, "page_word_count": 633, "page_sentence_count_raw": 7, "page_token_count": 502.0, "text": "194    12. Un num\u0103r \ud835\udc1a\ud835\udc1b\ud835\udc1c \u0305\u0305\u0305\u0305\u0305 se nume\u015fte excep\u021bional dac\u0103 b=ac. Mul\u021bimea numerelor excep\u021bionale  con\u021bine un num\u0103r de valori egal cu:    a) 36  b) 29  c) 26  d) 15  e) 6  f) 5      13. Se consider\u0103 urm\u0103torul subprogram:  Limbajul   C++/C  void f(int n)  {   int i;   if(n>0) for(i=1;i<=n;i++)   { f(n-2);      cout<<i<<' ';       |printf(\"%d \",i);   }  }  Limbajul Pascal  procedure f (n:integer);  var i:integer;  begin  if n>0 then    for i:=1 to n do     begin     f(n-2);write(i,' ')     end  end;    Valoarea lui n pentru care sunt afi\u0219ate valorile 1 1 1 2 1 3 la apelul f(n) este:    a) 12  b) 9  c) 6  d) 5  e) 4  f) 3    14. Variabila a memoreaz\u0103 elementele unui tablou bidimensional  cu 5 linii \u015fi 5 coloane, numerotate de la 1 la 5, iar celelalte  variabile sunt de tip \u00eentreg. Specifica\u0163i care va fi con\u0163inutul  variabilei a \u00een urma execut\u0103rii secven\u0163ei de program date, dac\u0103  tabloul bidimensional are ini\u021bial con\u021binutul al\u0103turat:  1  2  3  4  5   1  2  3  4  5  1  2  3  4  5  1  2  3  4  5  1  2  3  4  5  Limbajul C++/C  Limbajul Pascal  for(i=1; i<=n; i++)  if(i<=n/2)   for(j=1;j<=i;j++)  {aux=a[i][j];    a[i][j]=a[i][n-j+1];   a[i][n-j+1]=aux;   }   else    for(j=1;j<=n-i+1;j++)  { aux=a[i][j];    a[i][j]=a[i][n-j+1];    a[i][n-j+1]=aux;  }  for i:=1 to n do   if i<=n div 2 then for j:=1 to i do    begin      aux:=a[i,j]; a[i,j]:=a[i,n-j+1];        a[i,n-j+1]:=aux;    end   else for j:=1 to n-i+1 do     begin      aux:=a[i,j]; a[i,j]:=a[i,n-j+1];       a[i,n-j+1]:=aux;     end;    a)   5 4 3 2 1  5 2 3 4 1  5 2 3 4 1  5 2 3 4 1  5 4 3 2 1  b)  5 4 3 2 1  1 2 3 4 5  1 2 3 4 5  1 2 3 4 5  5 4 3 2 1  c)   5 2 3 4 1   5 4 3 2 1  5 4 3 2 1  5 4 3 2 1  5 2 3 4 1  d)  1 2 5 4 3  1 2 5 4 3  1 2 5 4 3  1 2 5 4 3  1 2 5 4 3  e)   1 2 3 5 4  1 2 3 5 4  1 2 3 5 4  1 2 3 5 4  1 2 3 5 4  f)   1 2 3 4 5  1 2 3 4 5  1 2 3 4 5  1 2 3 4 5  1 2 3 4 5    15. Se consider\u0103 urm\u0103torul subprogram:  Limbajul C++/C  Limbajul Pascal  int T(int n)  {   function T(n:integer):integer;  var o,m,c:integer;", "sentences": ["194    12.", "Un num\u0103r \ud835\udc1a\ud835\udc1b\ud835\udc1c \u0305\u0305\u0305\u0305\u0305 se nume\u015fte excep\u021bional dac\u0103 b=ac.", "Mul\u021bimea numerelor excep\u021bionale  con\u021bine un num\u0103r de valori egal cu:    a) 36  b) 29  c) 26  d) 15  e) 6  f) 5      13.", "Se consider\u0103 urm\u0103torul subprogram:  Limbajul   C++/C  void f(int n)  {   int i;   if(n>0) for(i=1;i<=n;i++)   { f(n-2);      cout<<i<<' ';       |printf(\"%d \",i);   }  }  Limbajul Pascal  procedure f (n:integer);  var i:integer;  begin  if n>0 then    for i:=1 to n do     begin     f(n-2);write(i,' ')     end  end;    Valoarea lui n pentru care sunt afi\u0219ate valorile 1 1 1 2 1 3 la apelul f(n) este:    a) 12  b) 9  c) 6  d) 5  e) 4  f) 3    14.", "Variabila a memoreaz\u0103 elementele unui tablou bidimensional  cu 5 linii \u015fi 5 coloane, numerotate de la 1 la 5, iar celelalte  variabile sunt de tip \u00eentreg.", "Specifica\u0163i care va fi con\u0163inutul  variabilei a \u00een urma execut\u0103rii secven\u0163ei de program date, dac\u0103  tabloul bidimensional are ini\u021bial con\u021binutul al\u0103turat:  1  2  3  4  5   1  2  3  4  5  1  2  3  4  5  1  2  3  4  5  1  2  3  4  5  Limbajul C++/C  Limbajul Pascal  for(i=1; i<=n; i++)  if(i<=n/2)   for(j=1;j<=i;j++)  {aux=a[i][j];    a[i][j]=a[i][n-j+1];   a[i][n-j+1]=aux;   }   else    for(j=1;j<=n-i+1;j++)  { aux=a[i][j];    a[i][j]=a[i][n-j+1];    a[i][n-j+1]=aux;  }  for i:=1 to n do   if i<=n div 2 then for j:=1 to i do    begin      aux:=a[i,j]; a[i,j]:=a[i,n-j+1];        a[i,n-j+1]:=aux;    end   else for j:=1 to n-i+1 do     begin      aux:=a[i,j]; a[i,j]:=a[i,n-j+1];       a[i,n-j+1]:=aux;     end;    a)   5 4 3 2 1  5 2 3 4 1  5 2 3 4 1  5 2 3 4 1  5 4 3 2 1  b)  5 4 3 2 1  1 2 3 4 5  1 2 3 4 5  1 2 3 4 5  5 4 3 2 1  c)   5 2 3 4 1   5 4 3 2 1  5 4 3 2 1  5 4 3 2 1  5 2 3 4 1  d)  1 2 5 4 3  1 2 5 4 3  1 2 5 4 3  1 2 5 4 3  1 2 5 4 3  e)   1 2 3 5 4  1 2 3 5 4  1 2 3 5 4  1 2 3 5 4  1 2 3 5 4  f)   1 2 3 4 5  1 2 3 4 5  1 2 3 4 5  1 2 3 4 5  1 2 3 4 5    15.", "Se consider\u0103 urm\u0103torul subprogram:  Limbajul C++/C  Limbajul Pascal  int T(int n)  {   function T(n:integer):integer;  var o,m,c:integer;"], "page_sentence_count_spacy": 7}, {"page_number": 195, "page_char_count": 659, "page_word_count": 266, "page_sentence_count_raw": 1, "page_token_count": 164.75, "text": "195       int o,m=n,c=1;     o=n;     while(o>9)     {  c=c*10;        o=o/10;     }     o=n%c*10+n/c;     while(o!=n)      {        if(m<o) m=o;        o=o%c*10+o/c;      }      return m;  }  begin      m:=n; c:=1;o:=n;      while(o>9) do        begin            c:=c*10; o:=o div 10;          end;      o:=n mod c*10+n div c;      while o<>n do          begin            if m<o then m:=o;            o:=o mod c*10 + o div c;          end;       T:=m;   end;  \u0218tiind c\u0103 parametrul formal n este un num\u0103r natural format din 3 cifre, subprogramul T  poate returna un num\u0103r de valori cu cifra sutelor 9 egal cu:    a) 100  b) 200  c) 225  d) 252  e) 260  f) 261", "sentences": ["195       int o,m=n,c=1;     o=n;     while(o>9)     {  c=c*10;        o=o/10;     }     o=n%c*10+n/c;     while(o!=n)      {        if(m<o) m=o;        o=o%c*10+o/c;      }      return m;  }  begin      m:=n; c:=1;o:=n;      while(o>9) do        begin            c:=c*10; o:=o div 10;          end;      o:=n mod c*10+n div c;      while o<>n do          begin            if m<o then m:=o;            o:=o mod c*10 + o div c;          end;       T:=m;   end;  \u0218tiind c\u0103 parametrul formal n este un num\u0103r natural format din 3 cifre, subprogramul T  poate returna un num\u0103r de valori cu cifra sutelor 9 egal cu:    a) 100  b) 200  c) 225  d) 252  e) 260  f) 261"], "page_sentence_count_spacy": 1}, {"page_number": 196, "page_char_count": 1963, "page_word_count": 596, "page_sentence_count_raw": 9, "page_token_count": 490.75, "text": "196    Varianta 37    1. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  char c='7';  float a= c- '9';   cout<<a; | printf(\"%.0f\",a);      var c:char; a:real;      c:='7';      a:=ord(c)- ord('9');      write(a:1:0);  Valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate este:    a) 79  b) -2  c) 2.0  d) 2  e) \u201979\u2019  f) -16    2. Se consider\u0103 urm\u0103toarea list\u0103 de descenden\u021bi asociat\u0103 unui arbore cu r\u0103d\u0103cin\u0103 cu 8 noduri:               1: 4,7,6,2                2: -                3: 4,6,5,2,7,8,1                4: -                5: -                6: -                7: 2                8: 7,2,4,1,6  Varianta care reprezint\u0103 vectorul de ta\u0163i asociat acestui arbore este:  a) 2 3 8 1 3 1 8 0  b) 8 7 0 1 8 1 1 3  c) 8 7 0 1 3 1 1 3   d) 0 3 1 8 3 1 1 1     e) 8 7 8 1 3 1 1 0  f)  0 7 8 3 1 3 3 1    3. \u00cen matricea de adiacen\u021b\u0103 asociat\u0103 unui graf neorientat cu n noduri, num\u0103rul de cifre de 1  aflate sub diagonala principal\u0103 este egal cu n*(n-1)/2. Num\u0103rul de muchii ce trebuie  ad\u0103ugate la acest graf astfel \u00eenc\u00e2t acesta s\u0103 devin\u0103 complet este:    a) n-1  b) n  c) 1  d) (n-1)/2  e) n/2  f) 0    4. Se consider\u0103 un graf neorientat cu 3675 de noduri \u0219i 10589 muchii. Gradul maxim pe care  \u00eel poate avea un nod din reprezentarea grafului ce con\u021bine un num\u0103r maxim de noduri izolate  este:    a) 147  b) 148  c) 146  d) 3666  e) 3674  f) 145    5. \u015eirul de caractere s ce desemneaz\u0103 o propozi\u021bie cu exact 11 cuvinte formate doar din litere  mici, mari \u0219i separate prin c\u00e2te un spa\u021biu. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  int n;  char s[100], *p, c[100];  strcpy(s,s+(strchr(s,' ')-s));  p=strtok(s,\" \");  while (p && n)      {   p=strtok(NULL,\" \");          strcpy(c, p);          n--;          }   var s,c,p:string[100];n:integer;   delete(s,1,pos(' ',s));   while n<>0 do      begin       delete(s,1,pos(' ',s));       c:=copy(s,1,pos(' ',s)-1);       n:=n-1      end;", "sentences": ["196    Varianta 37    1.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  char c='7';  float a= c- '9';   cout<<a; | printf(\"%.0f\",a);      var c:char; a:real;      c:='7';      a:=ord(c)- ord('9');      write(a:1:0);  Valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate este:    a) 79  b) -2  c) 2.0  d) 2  e) \u201979\u2019  f) -16    2.", "Se consider\u0103 urm\u0103toarea list\u0103 de descenden\u021bi asociat\u0103 unui arbore cu r\u0103d\u0103cin\u0103 cu 8 noduri:               1: 4,7,6,2                2: -                3: 4,6,5,2,7,8,1                4: -                5: -                6: -                7: 2                8: 7,2,4,1,6  Varianta care reprezint\u0103 vectorul de ta\u0163i asociat acestui arbore este:  a) 2 3 8 1 3 1 8 0  b) 8 7 0 1 8 1 1 3  c) 8 7 0 1 3 1 1 3   d) 0 3 1 8 3 1 1 1     e) 8 7 8 1 3 1 1 0  f)  0 7 8 3 1 3 3 1    3.", "\u00cen matricea de adiacen\u021b\u0103 asociat\u0103 unui graf neorientat cu n noduri, num\u0103rul de cifre de 1  aflate sub diagonala principal\u0103 este egal cu n*(n-1)/2.", "Num\u0103rul de muchii ce trebuie  ad\u0103ugate la acest graf astfel \u00eenc\u00e2t acesta s\u0103 devin\u0103 complet este:    a) n-1  b) n  c) 1  d) (n-1)/2  e) n/2  f) 0    4.", "Se consider\u0103 un graf neorientat cu 3675 de noduri \u0219i 10589 muchii.", "Gradul maxim pe care  \u00eel poate avea un nod din reprezentarea grafului ce con\u021bine un num\u0103r maxim de noduri izolate  este:    a) 147  b) 148  c) 146  d) 3666  e) 3674  f) 145    5.", "\u015eirul de caractere s ce desemneaz\u0103 o propozi\u021bie cu exact 11 cuvinte formate doar din litere  mici, mari \u0219i separate prin c\u00e2te un spa\u021biu.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  int n;  char s[100], *p, c[100];  strcpy(s,s+(strchr(s,' ')-s));  p=strtok(s,\" \");  while (p && n)      {   p=strtok(NULL,\" \");          strcpy(c, p);          n--;          }   var s,c,p:string[100];n:integer;   delete(s,1,pos(' ',s));   while n<>0 do      begin       delete(s,1,pos(' ',s));       c:=copy(s,1,pos(' ',s)-1);       n:=n-1      end;"], "page_sentence_count_spacy": 9}, {"page_number": 197, "page_char_count": 2277, "page_word_count": 541, "page_sentence_count_raw": 7, "page_token_count": 569.25, "text": "197    Pentru a memora \u00een variabila c cuv\u00e2ntul din mijloc, valoarea atribuit\u0103 variabilei n este:    a) 11  b) 6  c) 5  d) 7  e) 3  f) 4      6. Se consider\u0103 \u0219irul: 1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,  5,6, 7... \u015fi urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  int n,k,s=0;  cin>>n; | scanf(\"%d\",&n);  k=1;  while(s<n)      { s=s+k;k++;}   var n,k,s:integer;   read(n); k:=1; s:=0;   while s<n do        begin           s:=s+k; inc(k)        end;  Expresia care determin\u0103 termenul de pe o anumit\u0103 pozi\u021bie n dat\u0103 de la tastatur\u0103, dac\u0103  numerotarea termenilor pleac\u0103 de la valoarea 1 este:    a) s-(k-n)+1 b) k-s+n-1 c) k-s+n  d) k+s-n  e) n-k  f) k+n    7. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal    int i, j, n, a[10][10];    cin>>n; |scanf(\"%d\",&n);  for (i=1;i<=n;i++)   for (j=1;j<=n-i+1;j++)     {       a[i][j]=i+j;       a[n-j+1][n+1-i]=i+j;     }   var a: array [1..10, 1..10] of integer;      i, j, n: byte;   read(n);   for i:=1 to n do       for j:=1 to n-i+1 do         begin              a[i][j]:= i+j;              a[n-j+1][n+1-i]:=i+j         end;    \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se ob\u0163ine:  a) un tablou bidimensional cu elementele simetrice fa\u021b\u0103 de diagonala principal\u0103 dar nu \u015fi  fa\u0163\u0103 de diagonala secundar\u0103;  b) un tablou bidimensional cu elementele simetrice fa\u021b\u0103 de diagonala secundar\u0103 dar nu \u015fi  fa\u0163\u0103 de diagonala principal\u0103;  c) un tablou bidimensional cu elementele simetrice at\u00e2t fa\u021b\u0103 de diagonala principal\u0103 c\u00e2t \u015fi  fa\u0163\u0103 de diagonala secundar\u0103;  d) un tablou bidimensional cu elementele identice pe coloane;  e) un tablou bidimensional cu elementele identice pe linii;  f) un tablou bidimensional cu toate elementele egale \u00eentre ele.      8. Variabilele a,b,i \u0219i d memoreaz\u0103 numere naturale. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C  Limbajul Pascal  for(i=a*b;i>=b;i--)      if(i%a==0 && i%b==0)               d=i;  cout<<d; | printf(\"%d\",d);   for i:= a*b downto b do     if i mod a=0 and i mod b=0 then           d:=i;   write(d);  Valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate reprezint\u0103:  a) cel mai mare divizor comun  b) num\u0103rul de multiplii comuni  c) cel mai mic multiplu comun  d) num\u0103rul de divizori comuni", "sentences": ["197    Pentru a memora \u00een variabila c cuv\u00e2ntul din mijloc, valoarea atribuit\u0103 variabilei n este:    a) 11  b) 6  c) 5  d) 7  e) 3  f) 4      6.", "Se consider\u0103 \u0219irul: 1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,  5,6, 7... \u015fi urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  int n,k,s=0;  cin>>n; | scanf(\"%d\",&n);  k=1;  while(s<n)      { s=s+k;k++;}   var n,k,s:integer;   read(n); k:=1; s:=0;   while s<n do        begin           s:=s+k; inc(k)        end;  Expresia care determin\u0103 termenul de pe o anumit\u0103 pozi\u021bie n dat\u0103 de la tastatur\u0103, dac\u0103  numerotarea termenilor pleac\u0103 de la valoarea 1 este:    a) s-(k-n)+1 b) k-s+n-1 c) k-s+n  d) k+s-n  e) n-k  f) k+n    7.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal    int i, j, n, a[10][10];    cin>>n; |scanf(\"%d\",&n);  for (i=1;i<=n;i++)   for (j=1;j<=n-i+1;j++)     {       a[i][j]=i+j;       a[n-j+1][n+1-i]=i+j;     }   var a: array [1..10, 1..10] of integer;      i, j, n: byte;   read(n);   for i:=1 to n do       for j:=1 to n-i+1 do         begin              a[i][j]:= i+j;              a[n-j+1][n+1-i]:=i+j         end;    \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se ob\u0163ine:  a) un tablou bidimensional cu elementele simetrice fa\u021b\u0103 de diagonala principal\u0103 dar nu \u015fi  fa\u0163\u0103 de diagonala secundar\u0103;  b) un tablou bidimensional cu elementele simetrice fa\u021b\u0103 de diagonala secundar\u0103 dar nu \u015fi  fa\u0163\u0103 de diagonala principal\u0103;  c) un tablou bidimensional cu elementele simetrice at\u00e2t fa\u021b\u0103 de diagonala principal\u0103 c\u00e2t \u015fi  fa\u0163\u0103 de diagonala secundar\u0103;  d) un tablou bidimensional cu elementele identice pe coloane;  e) un tablou bidimensional cu elementele identice pe linii;  f) un tablou bidimensional cu toate elementele egale \u00eentre ele.", "     8.", "Variabilele a,b,i \u0219i d memoreaz\u0103 numere naturale.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C  Limbajul Pascal  for(i=a*b;i>=b;i--)      if(i%a==0 && i%b==0)               d=i;  cout<<d; | printf(\"%d\",d);   for i:= a*b downto b do     if i mod a=0 and i mod b=0 then           d:=i;   write(d);  Valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate reprezint\u0103:  a) cel mai mare divizor comun  b) num\u0103rul de multiplii comuni  c) cel mai mic multiplu comun  d) num\u0103rul de divizori comuni"], "page_sentence_count_spacy": 6}, {"page_number": 198, "page_char_count": 2209, "page_word_count": 562, "page_sentence_count_raw": 6, "page_token_count": 552.25, "text": "198    e) cel mai mare multiplu comun  f) num\u0103rul de divizori al produsulu a*b    9. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbaju Pascal  int a,i,c;  cin>>a; | scanf(\"%d\",&a);  c=0;  for (i=1;i<=a;i++)       if (i%5==0)          {  int j=i;             while (j%5==0)             { c++; j=j/5; }          }   cout<<c; | printf(\"%d\",c);   var a,i,c,j:integer;   read(a); c:=0;   for i:=1 to a do    if i mod 5=0 then      begin        j:=i;        while j mod 5=0 do            begin               c:=c+1; j:=j div 5             end      end;   write(c);  Valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate reprezint\u0103:  a) factorialul num\u0103rului a;  b) num\u0103rul cifrelor cu valoarea 0 de la sf\u00e2r\u0219itul factorialului num\u0103rului a;  c) puterea lui 5 din factorialul num\u0103rului a;  d) at\u00e2t puterea lui 5 din factorialul num\u0103rului a, c\u00e2t \u0219i num\u0103rul cifrelor cu valoarea 0 de  la sf\u00e2r\u0219itul acestui factorial;  e) num\u0103rul de elemente divizibile cu 5 mai mici decat a;  f) num\u0103rul de elemente divizibile cu 10 mai mici decat a.      10.   Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  struct oras {      char strada[101];      unsigned nr,cod_postal;  };  struct colet {      char destinatar[51];      struct oras adresa;  };  struct colet v[100];   type oras= record         strada: string[101];         nr, cod_postal: word       end;       colet= record         destinatar: string[50];         adresa: oras       end;   var v: array [1..101] of colet;  Varianta care reprezint\u0103 o accesare corect\u0103 a unei litere din numele unei str\u0103zi  corespunz\u0103toare unui colet transmis de o anumit\u0103 firm\u0103 de curierat este:  a) v[5].adresa.oras[1]  b) v[5].adresa[1].strada      c) v[5].adresa.strada[1]  d) v.colet.strada[5]  e) adresa.v[5].strada[1]  f) v.strada[1].adresa      11.   Fi\u015fierul examen.txt con\u0163ine pe prima linie a sa valoarea unui num\u0103r natural n mai mic  dec\u00e2t 100, iar pe urm\u0103toarea linie n valori \u00eentregi separate prin c\u00e2te un spa\u0163iu. Se consider\u0103  urm\u0103toarea secven\u0163\u0103 de program:   Limbajul C++/C  Limbajul Pascal    ifstream f(\"examen.txt\"); |  FILE *f; f= fopen(\"examen.txt\",\"r\");   var f,g:text; n,i:byte;   v: array [1..100] of integer;", "sentences": ["198    e) cel mai mare multiplu comun  f) num\u0103rul de divizori al produsulu a*b    9.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbaju Pascal  int a,i,c;  cin>>a; | scanf(\"%d\",&a);  c=0;  for (i=1;i<=a;i++)       if (i%5==0)          {  int j=i;             while (j%5==0)             { c++; j=j/5; }          }   cout<<c; | printf(\"%d\",c);   var a,i,c,j:integer;   read(a); c:=0;   for i:=1 to a do    if i mod 5=0 then      begin        j:=i;        while j mod 5=0 do            begin               c:=c+1; j:=j div 5             end      end;   write(c);  Valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate reprezint\u0103:  a) factorialul num\u0103rului a;  b) num\u0103rul cifrelor cu valoarea 0 de la sf\u00e2r\u0219itul factorialului num\u0103rului a;  c) puterea lui 5 din factorialul num\u0103rului a;  d) at\u00e2t puterea lui 5 din factorialul num\u0103rului a, c\u00e2t \u0219i num\u0103rul cifrelor cu valoarea 0 de  la sf\u00e2r\u0219itul acestui factorial;  e) num\u0103rul de elemente divizibile cu 5 mai mici decat a;  f) num\u0103rul de elemente divizibile cu 10 mai mici decat a.      10.", "  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  struct oras {      char strada[101];      unsigned nr,cod_postal;  };  struct colet {      char destinatar[51];      struct oras adresa;  };  struct colet v[100];   type oras= record         strada: string[101];         nr, cod_postal: word       end;       colet= record         destinatar: string[50];         adresa: oras       end;   var v: array [1..101] of colet;  Varianta care reprezint\u0103 o accesare corect\u0103 a unei litere din numele unei str\u0103zi  corespunz\u0103toare unui colet transmis de o anumit\u0103 firm\u0103 de curierat este:  a) v[5].adresa.oras[1]  b) v[5].adresa[1].strada      c) v[5].adresa.strada[1]  d) v.colet.strada[5]  e) adresa.v[5].strada[1]  f) v.strada[1].adresa      11.", "  Fi\u015fierul examen.txt con\u0163ine pe prima linie a sa valoarea unui num\u0103r natural n mai mic  dec\u00e2t 100, iar pe urm\u0103toarea linie n valori \u00eentregi separate prin c\u00e2te un spa\u0163iu.", "Se consider\u0103  urm\u0103toarea secven\u0163\u0103 de program:   Limbajul C++/C  Limbajul Pascal    ifstream f(\"examen.txt\"); |  FILE *f; f= fopen(\"examen.txt\",\"r\");   var f,g:text; n,i:byte;   v: array [1..100] of integer;"], "page_sentence_count_spacy": 5}, {"page_number": 199, "page_char_count": 2215, "page_word_count": 518, "page_sentence_count_raw": 6, "page_token_count": 553.75, "text": "199     int n, i, v[100];       f>>n; |fscanf(f,\"%d\",&n);   for (i=1;i<=n;i++) f>>v[i];                   |fscanf(f,\"%d\",&v[i]);   f.close();|fclose(f);   ifstream g(\"examen.txt\"); |  FILE *g; g= fopen(\"examen.txt\",\"r\");  for (i=2;i<=n;i++) g>>v[i];               |fscanf(g,\"%d\",&v[i]);   g.close();   | fclose(g);  cout<<v[n]; |printf(\"%d\",v[n]);    assign(f,'examen.txt');   reset(f);   readln(f,n);   for i:= 1 to n do       read(f,v[i]);   close(f);    assign(g,'examen.txt');   reset(g);   for i:= 2 to n do       read(g,v[i]);   close(g); write(v[n]);    Valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate reprezint\u0103:  a) prima valoare din fi\u0219ier;  b) penultima valoare din fi\u0219ier;  c) antepenultima valoare din fi\u0219ier;  d) ultima valoare din fi\u0219ier;  e) num\u0103rul de valori din fi\u0219ier;  f) a doua valoare din fi\u0219ier.    12.   Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  unsigned n;  int c;  float f(int n)  { if (n)      { c++; return (n%10+ f(n/10));}    else return 0;  }   var n:word; c:integer;   function f(n: integer): real;   begin    if n<>0 then         begin        inc(c);        f:= n mod 10+ f(n div 10)      end      else f:= 0   end;  Apelul corect al func\u021biei care returneaz\u0103 media aritmetic\u0103 a cifrelor num\u0103rului natural n este:    a) f(n)/c  b) f(c)  c) f(n/c)  d) f(n)  e) f(c)/n  f) f(c/n)    13.   Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal    char s[101]=\"Sebastian  Nicholas\", p[50]=\"bytes to mb\";           strcpy(s+ (strchr(s,'a')+1 -s),  s+ strlen(s)-1);  s[3]++;  strncpy(s+3,p,2);  cout<<s<<endl;     |printf(\"%s\\n\",s);    var s, p: string[100];          s:='Sebastian Nicholas';   p:='bytes to mb';   delete(s,pos('a',s)     + 2,length(s)-1);   s[4]:=chr(ord(s[4])-1);   delete(s, length(s)-1,2);   s:=s+ p[1]+ p[2];   writeln(s);    \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:    a) Sebyy  b) Sebabby c) Nicholas d) Sebaty  e) Sebby  f) Seba    14.  Variabila n memoreaz\u0103 un num\u0103r natural \u015fi variabila a memoreaz\u0103 un tablou  bidimensional p\u0103tratic cu n linii \u015fi n coloane numerotate de la 1 la n. Se consider\u0103  urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal", "sentences": ["199     int n, i, v[100];       f>>n; |fscanf(f,\"%d\",&n);   for (i=1;i<=n;i++) f>>v[i];                   |fscanf(f,\"%d\",&v[i]);   f.close();|fclose(f);   ifstream g(\"examen.txt\"); |  FILE *g; g= fopen(\"examen.txt\",\"r\");  for (i=2;i<=n;i++) g>>v[i];               |fscanf(g,\"%d\",&v[i]);   g.close();   | fclose(g);  cout<<v[n]; |printf(\"%d\",v[n]);    assign(f,'examen.txt');   reset(f);   readln(f,n);   for i:= 1 to n do       read(f,v[i]);   close(f);    assign(g,'examen.txt');   reset(g);   for i:= 2 to n do       read(g,v[i]);   close(g); write(v[n]);    Valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate reprezint\u0103:  a) prima valoare din fi\u0219ier;  b) penultima valoare din fi\u0219ier;  c) antepenultima valoare din fi\u0219ier;  d) ultima valoare din fi\u0219ier;  e) num\u0103rul de valori din fi\u0219ier;  f) a doua valoare din fi\u0219ier.", "   12.", "  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  unsigned n;  int c;  float f(int n)  { if (n)      { c++; return (n%10+ f(n/10));}    else return 0;  }   var n:word; c:integer;   function f(n: integer): real;   begin    if n<>0 then         begin        inc(c);        f:= n mod 10+ f(n div 10)      end      else f:= 0   end;  Apelul corect al func\u021biei care returneaz\u0103 media aritmetic\u0103 a cifrelor num\u0103rului natural n este:    a) f(n)/c  b) f(c)  c) f(n/c)  d) f(n)  e) f(c)/n  f) f(c/n)    13.", "  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal    char s[101]=\"Sebastian  Nicholas\", p[50]=\"bytes to mb\";           strcpy(s+ (strchr(s,'a')+1 -s),  s+ strlen(s)-1);  s[3]++;  strncpy(s+3,p,2);  cout<<s<<endl;     |printf(\"%s\\n\",s);    var s, p: string[100];          s:='Sebastian Nicholas';   p:='bytes to mb';   delete(s,pos('a',s)     + 2,length(s)-1);   s[4]:=chr(ord(s[4])-1);   delete(s, length(s)-1,2);   s:=s+ p[1]+ p[2];   writeln(s);    \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:    a) Sebyy  b) Sebabby c) Nicholas d) Sebaty  e) Sebby  f) Seba    14.", " Variabila n memoreaz\u0103 un num\u0103r natural \u015fi variabila a memoreaz\u0103 un tablou  bidimensional p\u0103tratic cu n linii \u015fi n coloane numerotate de la 1 la n. Se consider\u0103  urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal"], "page_sentence_count_spacy": 5}, {"page_number": 200, "page_char_count": 2557, "page_word_count": 605, "page_sentence_count_raw": 8, "page_token_count": 639.25, "text": "200      for (k=1;k<=n/2+1;k++){   for (j=k;j<=n-k+1;j++)    cout<<a[k][j]<<' ';       | printf(\"%d \",a[k][j]);       for (i=k+1;i<=n-k+1;i++)    cout<<a[i][n-k+1]<<' ';      |printf(\"%d \",a[i][n-k+1]);    for (j=n-k;j>=k;j--)    cout<<a[n-k+1][j]<<' ';      | printf(\"%d \",a[n-k+1][j]);    for (i=n-k;i>k;i--)    cout<<a[i][k]<<' ';       |printf(\"%d \",a[i][k]);      }     for k:= 1 to n div 2+ 1  do   begin    for j:=k to n-k+1 do      write(a[k,j], ' ');    for i:=k+1 to n-k+1 do      write(a[i,n-k+1],' ');    for j:=n-k downto k do      write(a[n-k+1][j],' ');    for i:=n-k downto k+1 do      write(a[i,k],' ');   end;    \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se vor afi\u015fa:  a) elementele tabloului pe coloane, de la ultima la prima coloan\u0103;  b) elementele tabloului \u00een spiral\u0103;  c) elementele tabloului pe linii, de la prima la ultima linie;  d) elementele tabloului pe diagonale;  e) elementele tabloului aflate pe coloane impare;  f) elementele tabloului ce nu se afl\u0103 pe vreuna din cele dou\u0103 diagonale.      15. Nicholas are la Informatic\u0103 un num\u0103r de m note stocate \u00een tabloul unidimensional note, iar  \u00een variabila teza este trecut rezultatul ob\u021binut de el la lucrarea de sf\u00e2r\u0219it de semestru. Se  \u0219tie c\u0103 media se \u00eencheie cu un num\u0103r de n note (m<n), iar Nicholas dore\u0219te sa ob\u021bin\u0103 media  final\u0103 x.   Folosind metoda backtracking, Nicholas a creat un program care \u00eei genereaz\u0103 \u00een tabloul  unidimensional note, \u00een continuarea celor m note existente, restul de m-n note necesare  \u00eencheierii mediei. S-a notat cu k pozi\u021bia pe care se genereaz\u0103 pe r\u00e2nd restul notelor.  \u00cen rezolvarea programului s-a utilizat func\u021bia medie al c\u0103rei apel calculeaz\u0103 media curent\u0103.  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  float note[10], teza;  int n,m,k,as,ev,i,x;  float medie(float note[10],int m)  {   float s=0;      for (i=1;i<= m;i++)          s=s+note[i];      return (3*s+m*teza)/(4*m);  }  valid(float note[10],int k,int ev)  | void valid(float note[10],  int k,int *ev)  void  {          ev=1; |*ev=1;             if (k>m+1)        if (note[k]< note[k-1])          ev=0; |*ev=0;         if (k==n)          if (...)   type sir= array [1..11] of byte;   var note: sir;      m,n,teza,k,i x:word;      as,ev:boolean;   function  medie(note:sir;m:word):real;   var s:word;   begin    s:=0;    for i:=1 to m do s:=s+note[i];    medie:=(3*s+m*teza)/(4*m)   end;   procedure valid( note:sir;k word;var  ev:boolean);   begin     ev:=true;     if k>m+1 then        if note[k]< note[k-1] then           ev:=false;", "sentences": ["200      for (k=1;k<=n/2+1;k++){   for (j=k;j<=n-k+1;j++)    cout<<a[k][j]<<' ';       | printf(\"%d \",a[k][j]);       for (i=k+1;i<=n-k+1;i++)    cout<<a[i][n-k+1]<<' ';      |printf(\"%d \",a[i][n-k+1]);    for (j=n-k;j>=k;j--)    cout<<a[n-k+1][j]<<' ';      | printf(\"%d \",a[n-k+1][j]);    for (i=n-k;i>k;i--)    cout<<a[i][k]<<' ';       |printf(\"%d \",a[i][k]);      }     for k:= 1 to n div 2+ 1  do   begin    for j:=k to n-k+1 do      write(a[k,j], ' ');    for i:=k+1 to n-k+1 do      write(a[i,n-k+1],' ');    for j:=n-k downto k do      write(a[n-k+1][j],' ');    for i:=n-k downto k+1 do      write(a[i,k],' ');   end;    \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se vor afi\u015fa:  a) elementele tabloului pe coloane, de la ultima la prima coloan\u0103;  b) elementele tabloului \u00een spiral\u0103;  c) elementele tabloului pe linii, de la prima la ultima linie;  d) elementele tabloului pe diagonale;  e) elementele tabloului aflate pe coloane impare;  f) elementele tabloului ce nu se afl\u0103 pe vreuna din cele dou\u0103 diagonale.", "     15.", "Nicholas are la Informatic\u0103 un num\u0103r de m note stocate \u00een tabloul unidimensional note, iar  \u00een variabila teza este trecut rezultatul ob\u021binut de el la lucrarea de sf\u00e2r\u0219it de semestru.", "Se  \u0219tie c\u0103 media se \u00eencheie cu un num\u0103r de n note (m<n), iar Nicholas dore\u0219te sa ob\u021bin\u0103 media  final\u0103 x.   Folosind metoda backtracking, Nicholas a creat un program care \u00eei genereaz\u0103 \u00een tabloul  unidimensional note, \u00een continuarea celor m note existente, restul de m-n note necesare  \u00eencheierii mediei.", "S-a notat cu k pozi\u021bia pe care se genereaz\u0103 pe r\u00e2nd restul notelor.", " \u00cen rezolvarea programului s-a utilizat func\u021bia medie al c\u0103rei apel calculeaz\u0103 media curent\u0103.", " Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  float note[10], teza;  int n,m,k,as,ev,i,x;  float medie(float note[10],int m)  {   float s=0;      for (i=1;i<= m;i++)          s=s+note[i];      return (3*s+m*teza)/(4*m);  }  valid(float note[10],int k,int ev)  | void valid(float note[10],  int k,int *ev)  void  {          ev=1; |*ev=1;             if (k>m+1)        if (note[k]< note[k-1])          ev=0; |*ev=0;         if (k==n)          if (...)   type sir= array [1..11] of byte;   var note: sir;      m,n,teza,k,i x:word;      as,ev:boolean;   function  medie(note:sir;m:word):real;   var s:word;   begin    s:=0;    for i:=1 to m do s:=s+note[i];    medie:=(3*s+m*teza)/(4*m)   end;   procedure valid( note:sir;k word;var  ev:boolean);   begin     ev:=true;     if k>m+1 then        if note[k]< note[k-1] then           ev:=false;"], "page_sentence_count_spacy": 7}, {"page_number": 201, "page_char_count": 1009, "page_word_count": 178, "page_sentence_count_raw": 2, "page_token_count": 252.25, "text": "201              ev=0; |*ev=0;   }     if k=n then        if ... then ev:=false   end;    Pentru ca programul s\u0103 genereze toate combina\u021biile de note de care Nicholas are nevoie  pentru a ob\u021bine media dorit\u0103, expresia corespunz\u0103toare punctelor de suspensie din secven\u0163a  de program este:  a) Limbajul C++/C: medie(note,n)!=x;      Limbajul Pascal:  medie(note,n)<>x  b) Limbajul C++/C: medie(note,n)<=(x-0.5) && medie(note,n)>(x+0.5)      Limbajul Pascal: medie(note,n)<=(x-0.5) and medie(note,n)>(x+0.5)  c) Limbajul C++/C: medie(note,n)<(x-0.5) || medie(note,n)>(x+ 0.5)      Limbajul Pascal: medie(note,n)<(x-0.5) or medie(note,n)>(x+ 0.5)  d) Limbajul C++/C: medie(note,n)>=(x-0.5) && medie(note,n)<=(x+0.5)      Limbajul Pascal:  medie(note,n)>=(x-0.5) and medie(note,n)<=(x+0.5)  e) Limbajul C++/C: medie(note,n)<(x-0.5) || medie(note,n)>=(x+0.5)      Limbajul Pascal: medie(note,n)<(x-0.5) or medie(note,n)>=(x+0.5)    f) Limbajul C++/C:  medie(note,n)>(m-n)         Limbajul Pascal: medie(note,n)>(m-n)", "sentences": ["201              ev=0; |*ev=0;   }     if k=n then        if ... then ev:=false   end;    Pentru ca programul s\u0103 genereze toate combina\u021biile de note de care Nicholas are nevoie  pentru a ob\u021bine media dorit\u0103, expresia corespunz\u0103toare punctelor de suspensie din secven\u0163a  de program este:  a) Limbajul C++/C: medie(note,n)!=x;      Limbajul Pascal:  medie(note,n)<>x  b) Limbajul C++/C: medie(note,n)<=(x-0.5) && medie(note,n)>(x+0.5)      Limbajul Pascal: medie(note,n)<=(x-0.5) and medie(note,n)>(x+0.5)  c) Limbajul C++/C: medie(note,n)<(x-0.5) || medie(note,n)>(x+ 0.5)      Limbajul Pascal: medie(note,n)<(x-0.5) or medie(note,n)>(x+ 0.5)  d) Limbajul C++/C: medie(note,n)>=(x-0.5) && medie(note,n)<=(x+0.5)      Limbajul Pascal:  medie(note,n)>=(x-0.5) and medie(note,n)<=(x+0.5)  e) Limbajul C++/C: medie(note,n)<(x-0.5) || medie(note,n)>=(x+0.5)      Limbajul Pascal: medie(note,n)<(x-0.5) or medie(note,n)>=(x+0.5)    f) Limbajul C++/C:  medie(note,n)>(m-n)         Limbajul Pascal: medie(note,n)>(m-n)"], "page_sentence_count_spacy": 1}, {"page_number": 202, "page_char_count": 2090, "page_word_count": 581, "page_sentence_count_raw": 12, "page_token_count": 522.5, "text": "202    Varianta 38    1. Se consider\u0103 A, o mul\u021bime de numere naturale. Cardinalul minim al acestei mul\u021bimi, dac\u0103 o  parti\u021bion\u0103m \u00een 5 parti\u021bii, iar numerele de elemente ale acestor parti\u021bii reprezint\u0103 termeni  impari diferi\u0163i ai \u0219irului lui Fibonacci este:    a) 12  b) 43  c) 20  d) 55  e) 6  f) 43    2. Se consider\u0103 un arbore cu r\u0103dacin\u0103 av\u00e2nd urm\u0103toarele caracteristici:            - num\u0103rul de noduri este 12;            - \u00een\u0103l\u021bimea este 4;            - num\u0103rul de frunze este 6;            - lungimea celui mai lung lan\u021b elementar este egal\u0103 cu 6;                      - num\u0103rul de noduri de grad 1 este 7.     Un posibil vector de ta\u0163i asociat acestui arbore ar putea fi:   a) 8 9 5 1 8 5 1 0 4 5 1 4  b) 9 6 10 1 0 9 1 6 5 1 2 10  c) 4 1 8 0 1 2 5 1 5 12 2 5  d) 0 1 1 1 2 5 5 4 6 5 4 4  e) 7 6 5 7 0 1 5 3 7 3 8 11  f) 12 4 6 0 1 2 12 2 1 7 6 4    3. Se consider\u0103 o parol\u0103 de \u0219ase caractere, nu neap\u0103rat distincte, format\u0103 doar din litere mici  \u015fi mari ale alfabetului englez (52 de caractere) \u0219i cifre. Num\u0103rul minim, respectiv maxim de  \u00eencerc\u0103ri pentru a identifica respectiva parol\u0103 este:     a) 6  62  b) 1   662  c) 1   661  d) 1   626  e) 6   62    f) 6   52    4.       Num\u0103rul de muchii care trebuie mutate din graful neorientat  hamiltonian al\u0103turat astfel \u00eenc\u00e2t acesta s\u0103 devina eulerian, dar s\u0103  r\u0103m\u00e2n\u0103 \u0219i hamiltonian este:    a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    5.  Variabilele a \u0219i d memoreaz\u0103 numere naturale. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C  Limbajul Pascal  cin>>a;| scanf(\"%d\",&a);  d=0;  for (i=-a;i<=a;i++)          if (a%i==0) d++;   read(a);   d:=0;   for i:=-a to a do         if a mod i=0 then d:=d+1;  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate valoarea variabilei d este:  a) num\u0103rul de divizori pozitivi ai lui a; b) num\u0103rul de divizori pozitivi \u0219i negativi ai lui a;  c) num\u0103rul de divizori negativi ai lui a;  d) cel mai mare divizor al lui a;  e) num\u0103rul de divizori proprii ai lui a; f) valoarea variabilei d nu va putea fi calculat\u0103.    6. Fi\u0219ierul date.in con\u021bine urm\u0103toarele numere:   10  1 2 3 4 5 6 7 8 9 10", "sentences": ["202    Varianta 38    1.", "Se consider\u0103 A, o mul\u021bime de numere naturale.", "Cardinalul minim al acestei mul\u021bimi, dac\u0103 o  parti\u021bion\u0103m \u00een 5 parti\u021bii, iar numerele de elemente ale acestor parti\u021bii reprezint\u0103 termeni  impari diferi\u0163i ai \u0219irului lui Fibonacci este:    a) 12  b) 43  c) 20  d) 55  e) 6  f) 43    2.", "Se consider\u0103 un arbore cu r\u0103dacin\u0103 av\u00e2nd urm\u0103toarele caracteristici:            - num\u0103rul de noduri este 12;            - \u00een\u0103l\u021bimea este 4;            - num\u0103rul de frunze este 6;            - lungimea celui mai lung lan\u021b elementar este egal\u0103 cu 6;                      - num\u0103rul de noduri de grad 1 este 7.", "    Un posibil vector de ta\u0163i asociat acestui arbore ar putea fi:   a) 8 9 5 1 8 5 1 0 4 5 1 4  b) 9 6 10 1 0 9 1 6 5 1 2 10  c) 4 1 8 0 1 2 5 1 5 12 2 5  d) 0 1 1 1 2 5 5 4 6 5 4 4  e) 7 6 5 7 0 1 5 3 7 3 8 11  f) 12 4 6 0 1 2 12 2 1 7 6 4    3.", "Se consider\u0103 o parol\u0103 de \u0219ase caractere, nu neap\u0103rat distincte, format\u0103 doar din litere mici  \u015fi mari ale alfabetului englez (52 de caractere) \u0219i cifre.", "Num\u0103rul minim, respectiv maxim de  \u00eencerc\u0103ri pentru a identifica respectiva parol\u0103 este:     a) 6  62  b) 1   662  c) 1   661  d) 1   626  e) 6   62    f) 6   52    4.", "      Num\u0103rul de muchii care trebuie mutate din graful neorientat  hamiltonian al\u0103turat astfel \u00eenc\u00e2t acesta s\u0103 devina eulerian, dar s\u0103  r\u0103m\u00e2n\u0103 \u0219i hamiltonian este:    a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    5.", " Variabilele a \u0219i d memoreaz\u0103 numere naturale.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de  program:  Limbajul C++/C  Limbajul Pascal  cin>>a;| scanf(\"%d\",&a);  d=0;  for (i=-a;i<=a;i++)          if (a%i==0) d++;   read(a);   d:=0;   for i:=-a to a do         if a mod i=0 then d:=d+1;  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate valoarea variabilei d este:  a) num\u0103rul de divizori pozitivi ai lui a; b) num\u0103rul de divizori pozitivi \u0219i negativi ai lui a;  c) num\u0103rul de divizori negativi ai lui a;  d) cel mai mare divizor al lui a;  e) num\u0103rul de divizori proprii ai lui a; f) valoarea variabilei d nu va putea fi calculat\u0103.", "   6.", "Fi\u0219ierul date.in con\u021bine urm\u0103toarele numere:   10  1 2 3 4 5 6 7 8 9 10"], "page_sentence_count_spacy": 12}, {"page_number": 203, "page_char_count": 2133, "page_word_count": 621, "page_sentence_count_raw": 5, "page_token_count": 533.25, "text": "203    Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program \u00een care tabloul unidimensional v a fost  declarat parametru global:  Limbajul C++/C  Limbajul Pascal    int i, n, v[100];  ifstream f(\"date.in\");|  FILE *f,*g; f=fopen(\"date.in\",\"r\");    f>>n; | fscanf(f,\"%d\",&n);  for (i=1;i<=n;i=i+2)     f>>v[i]; | fscanf(f,\"%d\",&v[i]);  f.close();|fclose(f);  ofstream g(\"date.in\"); |  g=fopen(\"date.in\",\"w\");   g<<v[8];| fprintf(g,\"%d\",v[8]);  g.close();|fclose(g);   var f:text; i,n:byte;   v:array [1..100] of integer;     assign(f,'date.in');reset(f);   readln(f,n);   for i:= 1 to n do      if i mod 2<>0then         read(f,v[i]);   close(f);rewrite(f);   write(f,v[8]);   close(f);    Con\u021binutul fi\u0219ierului dup\u0103 executarea secven\u021bei de program al\u0103turate este:    a) 8  b) o valoare rezidual\u0103  c) 1  d) 8 9 10  e) 10  f) 0    7. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  typedef int sir[5];  sir v[100];int i,j;       for (i=1;i<=4;i++)   for (j=1;j<=3;j++) v[i][j]=i+j;  for (i=1;i<=4;i++)   for (j=1;j<=3;j++)     if (j==3)  cout<<v[i][j]<<endl;          |printf(\"%d\\n\",v[i][j]);                    else  cout<<v[i][j]<<' ';            |printf(\"%d \",v[i][j]);   type sir=array [1..5] of  integer;   var v:array [1..100] of sir;      i,j:integer;         for i:=1 to 4 do    for j:=1 to 3 do v[i][j]:=i+j;   for i:=1 to 4 do    for j:=1 to 3 do      if j=3 then writeln(v[i][j])      else write(v[i][j],' ');  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:    a)    1 2 3 4 5 6   7 8 9 10 11 12  b)     2 3 4 5   3 4 5 6    4 5 6 7   5 6 7 8  c)     2 3 4 5    3 4 5 6   4 5 6 7  d)     2 3 4   3 4 5   4 5 6   5 6 7  e)      3 4 5   4 5 6   5 6 7   6 7 8  f)      2 3   4 5   6 7   8 9    8. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  void f(int k,int p)  {  if (k*p>=0)    if (p!=0)    { ...                         cout<<k<<\"* \"<<p<<\"= \";    cout <<k*p<<endl;    |printf(\"%d* %d=%d\\n\",k,p,k*p);         }   procedure f(k,p:integer);   begin   if k*p>=0 then    begin     if p<>0 then      begin        ...       writeln(k,'* ',p,'= ',k*p)      end", "sentences": ["203    Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program \u00een care tabloul unidimensional v a fost  declarat parametru global:  Limbajul C++/C  Limbajul Pascal    int i, n, v[100];  ifstream f(\"date.in\");|  FILE *f,*g; f=fopen(\"date.in\",\"r\");    f>>n; | fscanf(f,\"%d\",&n);  for (i=1;i<=n;i=i+2)     f>>v[i]; | fscanf(f,\"%d\",&v[i]);  f.close();|fclose(f);  ofstream g(\"date.in\"); |  g=fopen(\"date.in\",\"w\");   g<<v[8];| fprintf(g,\"%d\",v[8]);  g.close();|fclose(g);   var f:text; i,n:byte;   v:array [1..100] of integer;     assign(f,'date.in');reset(f);   readln(f,n);   for i:= 1 to n do      if i mod 2<>0then         read(f,v[i]);   close(f);rewrite(f);   write(f,v[8]);   close(f);    Con\u021binutul fi\u0219ierului dup\u0103 executarea secven\u021bei de program al\u0103turate este:    a) 8  b) o valoare rezidual\u0103  c) 1  d) 8 9 10  e) 10  f) 0    7.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  typedef int sir[5];  sir v[100];int i,j;       for (i=1;i<=4;i++)   for (j=1;j<=3;j++) v[i][j]=i+j;  for (i=1;i<=4;i++)   for (j=1;j<=3;j++)     if (j==3)  cout<<v[i][j]<<endl;          |printf(\"%d\\n\",v[i][j]);                    else  cout<<v[i][j]<<' ';            |printf(\"%d \",v[i][j]);   type sir=array [1..5] of  integer;   var v:array [1..100] of sir;      i,j:integer;         for i:=1 to 4 do    for j:=1 to 3 do v[i][j]:=i+j;   for i:=1 to 4 do    for j:=1 to 3 do      if j=3 then writeln(v[i][j])      else write(v[i][j],' ');  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:    a)    1 2 3 4 5 6   7 8 9 10 11 12  b)     2 3 4 5   3 4 5 6    4 5 6 7   5 6 7 8  c)     2 3 4 5    3 4 5 6   4 5 6 7  d)     2 3 4   3 4 5   4 5 6   5 6 7  e)      3 4 5   4 5 6   5 6 7   6 7 8  f)      2 3   4 5   6 7   8 9    8.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  void f(int k,int p)  {  if (k*p>=0)    if (p!=0)    { ...                         cout<<k<<\"* \"<<p<<\"= \";    cout <<k*p<<endl;    |printf(\"%d* %d=%d\\n\",k,p,k*p);         }   procedure f(k,p:integer);   begin   if k*p>=0 then    begin     if p<>0 then      begin        ...       writeln(k,'* ',p,'= ',k*p)      end"], "page_sentence_count_spacy": 3}, {"page_number": 204, "page_char_count": 2203, "page_word_count": 498, "page_sentence_count_raw": 10, "page_token_count": 550.75, "text": "204     else f(k-1,10);       }     else f(k-1,10);    end   end;  Pentru a ob\u021bine afi\u0219area tablei \u00eenmul\u021birii de la 0 la 10 \u00een urma apelului f(10,10), apelul  corespunz\u0103tor punctelor de suspensie din secven\u021ba de program al\u0103turat\u0103 este:    a) f(k,p)  b) f(10,p) c) f(k,1)  d) f(k-1,p-1) e) f(k,p-1) f) f(k-1,p)    9. Variabila s memoreaz\u0103 un \u015fir de caractere. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  char s[101], cuv[5]=\"test\";  while (strstr(s,cuv))   strcpy(s+(strstr(s,cuv)-s),    s+(strstr(s,cuv)-s+strlen(cuv)));   var s:string[101];   cuv:string[5];   cuv:='test';   while pos(cuv,s)<>0 do    delete(s,pos(cuv, s)  ,length(cuv));  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se realizeaz\u0103:  a) eliminarea tuturor sub\u015firurilor test;  b) eliminarea ultimului sub\u015fir test;  c) dublarea tuturor sub\u015firurilor test;  d) eliminarea primului sub\u015fir test;  e) dublarea ultimei apari\u0163ii a sub\u015firului test; f) dublarea primei apari\u0163ii a sub\u015firului  test.    10. Variabilele m,n,i,j,p,s \u0219i k memoreaz\u0103 numere naturale. Tablourile bidimensionale  An*m (n linii \u015fi m coloane), Bm*p (m linii \u015fi p coloane) memoreaz\u0103 numere naturale.  Numerotarea liniilor \u015fi a coloanelor \u00eencepe cu valoarea 1.  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  for (i=1;i<=n;i++)   for (j=1;j<=p;j++)   {    s=0;    for (k=1;k<=m;k++)           s=s+A[i][k]*B[k][j];    cout<<s<<' ';      | printf(\"%d \",s);    if (j==p)             cout<<endl;      |printf(\"\\n\");   }   for i:=1 to n do     for j:=1 to p do       begin           s:=0;           for k:=1 to m do               s:=s+A[i][k]*B[k][j];           write(s,' ');           if j=p then                   writeln        end;  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) tabloul bidimensional sum\u0103 dintre A \u015fi B;  b) transpusa tabloului bidimensional A;  c) tabloul bidimensional produs dintre A \u015fi B;  d) tabloul bidimensional diferen\u021b\u0103 dintre A \u015fi B;  e) suma elementelor de pe ambele diagonale ale celor dou\u0103 tablouri bidimensionale;  f) produsul elementelor de pe ambele diagonale ale celor dou\u0103 tablouri bidimensionale.    11. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:", "sentences": ["204     else f(k-1,10);       }     else f(k-1,10);    end   end;  Pentru a ob\u021bine afi\u0219area tablei \u00eenmul\u021birii de la 0 la 10 \u00een urma apelului f(10,10), apelul  corespunz\u0103tor punctelor de suspensie din secven\u021ba de program al\u0103turat\u0103 este:    a) f(k,p)  b) f(10,p) c) f(k,1)  d) f(k-1,p-1) e) f(k,p-1) f) f(k-1,p)    9.", "Variabila s memoreaz\u0103 un \u015fir de caractere.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  char s[101], cuv[5]=\"test\";  while (strstr(s,cuv))   strcpy(s+(strstr(s,cuv)-s),    s+(strstr(s,cuv)-s+strlen(cuv)));   var s:string[101];   cuv:string[5];   cuv:='test';   while pos(cuv,s)<>0 do    delete(s,pos(cuv, s)  ,length(cuv));  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se realizeaz\u0103:  a) eliminarea tuturor sub\u015firurilor test;  b) eliminarea ultimului sub\u015fir test;  c) dublarea tuturor sub\u015firurilor test;  d) eliminarea primului sub\u015fir test;  e) dublarea ultimei apari\u0163ii a sub\u015firului test; f) dublarea primei apari\u0163ii a sub\u015firului  test.", "   10.", "Variabilele m,n,i,j,p,s \u0219i k memoreaz\u0103 numere naturale.", "Tablourile bidimensionale  An*m (n linii \u015fi m coloane), Bm*p (m linii \u015fi p coloane) memoreaz\u0103 numere naturale.", " Numerotarea liniilor \u015fi a coloanelor \u00eencepe cu valoarea 1.", " Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  for (i=1;i<=n;i++)   for (j=1;j<=p;j++)   {    s=0;    for (k=1;k<=m;k++)           s=s+A[i][k]*B[k][j];    cout<<s<<' ';      | printf(\"%d \",s);    if (j==p)             cout<<endl;      |printf(\"\\n\");   }   for i:=1 to n do     for j:=1 to p do       begin           s:=0;           for k:=1 to m do               s:=s+A[i][k]*B[k][j];           write(s,' ');           if j=p then                   writeln        end;  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) tabloul bidimensional sum\u0103 dintre A \u015fi B;  b) transpusa tabloului bidimensional A;  c) tabloul bidimensional produs dintre A \u015fi B;  d) tabloul bidimensional diferen\u021b\u0103 dintre A \u015fi B;  e) suma elementelor de pe ambele diagonale ale celor dou\u0103 tablouri bidimensionale;  f) produsul elementelor de pe ambele diagonale ale celor dou\u0103 tablouri bidimensionale.", "   11.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:"], "page_sentence_count_spacy": 10}, {"page_number": 205, "page_char_count": 1981, "page_word_count": 503, "page_sentence_count_raw": 5, "page_token_count": 495.25, "text": "205    Limbajul C++/C  Limbajul Pascal    char c;  for(c='m';c<='r';c++)  cout<<char(c- 5);    |printf(\"%c\",c-5);      var c:char;     for c:= 'm' to 'r' do         write(chr(ord(c)- 5));    \u015eirul de caractere afi\u0219at \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate este:    a) 104 b) mnopqr  c) abcdef  d) 109 e) hijklm f) 104105106107108109    12.    Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul  Pascal  char s[101];int k, p, c;  cin.getline(s,101); |gets(s);   k=0;p=strlen(s)-1;  while (k!=strlen(s))      {   c=s[k]+s[p];          s[k]=c-s[k];          s[p]=c-s[k];          k++;p--;      }   cout<<s; |printf(\"%s\",s);   var s: string[100]; k,p,c: integer;  readln(s);  k:=1;p:=length(s);  while (k<= length(s)) do          begin             c:=ord(s[k])+ord(s[p]);             s[k]:=chr(c-ord(s[k]));             s[p]:=chr(c-ord(s[k]));             k:=k+1;p:=p-1          end;  write(s);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) \u0219irul de caractere dat de la tastatur\u0103;  b) \u0219irul de caractere dat de la tastatur\u0103, r\u0103sturnat;  c) \u0219irul de caractere far\u0103 cele de pe pozi\u021biile k \u0219i p;  d) sub\u015firul de caractere aflate \u00eentre pozi\u0163iile k \u015fi p;  e) toate caracterele din \u015firul s care nu se afl\u0103 \u00eentre pozi\u0163iile k \u015fi p;  f) primul \u015fi ultimul caracter din s.    13.   Fi\u0219ierul date.in con\u0163ine informa\u0163ii despre trei elevi. Pentru fiecare elev sunt precizate  urm\u0103toarele: numele; cinci note \u015fi teza pentru o anumit\u0103 materie:  Ana  7 5 8 3 6  6  Sebby  10 9 10 9 10  10  Dan  9 8 9 9 7  9  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  ifstream f(\"date.in\");|  FILE *f; f= fopen(\"date.in\",\"r\");  struct materie  {   char nume[51];  unsigned note[6];      float teza;  } clasa[30];  float s;int i,j;      type sir=array [1..6] of byte;       materie= record          nume: string[50];          note: sir; teza: real        end;   var clasa:array [1..30] of  materie;    s:real; i,j:integer; f:text;", "sentences": ["205    Limbajul C++/C  Limbajul Pascal    char c;  for(c='m';c<='r';c++)  cout<<char(c- 5);    |printf(\"%c\",c-5);      var c:char;     for c:= 'm' to 'r' do         write(chr(ord(c)- 5));    \u015eirul de caractere afi\u0219at \u00een urma execut\u0103rii secven\u021bei de program al\u0103turate este:    a) 104 b) mnopqr  c) abcdef  d) 109 e) hijklm f) 104105106107108109    12.", "   Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul  Pascal  char s[101];int k, p, c;  cin.getline(s,101); |gets(s);   k=0;p=strlen(s)-1;  while (k!=strlen(s))      {   c=s[k]+s[p];          s[k]=c-s[k];          s[p]=c-s[k];          k++;p--;      }   cout<<s; |printf(\"%s\",s);   var s: string[100]; k,p,c: integer;  readln(s);  k:=1;p:=length(s);  while (k<= length(s)) do          begin             c:=ord(s[k])+ord(s[p]);             s[k]:=chr(c-ord(s[k]));             s[p]:=chr(c-ord(s[k]));             k:=k+1;p:=p-1          end;  write(s);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) \u0219irul de caractere dat de la tastatur\u0103;  b) \u0219irul de caractere dat de la tastatur\u0103, r\u0103sturnat;  c) \u0219irul de caractere far\u0103 cele de pe pozi\u021biile k \u0219i p;  d) sub\u015firul de caractere aflate \u00eentre pozi\u0163iile k \u015fi p;  e) toate caracterele din \u015firul s care nu se afl\u0103 \u00eentre pozi\u0163iile k \u015fi p;  f) primul \u015fi ultimul caracter din s.    13.", "  Fi\u0219ierul date.in con\u0163ine informa\u0163ii despre trei elevi.", "Pentru fiecare elev sunt precizate  urm\u0103toarele: numele; cinci note \u015fi teza pentru o anumit\u0103 materie:  Ana  7 5 8 3 6  6  Sebby  10 9 10 9 10  10  Dan  9 8 9 9 7  9  Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  ifstream f(\"date.in\");|  FILE *f; f= fopen(\"date.in\",\"r\");  struct materie  {   char nume[51];  unsigned note[6];      float teza;  } clasa[30];  float s;int i,j;      type sir=array [1..6] of byte;       materie= record          nume: string[50];          note: sir; teza: real        end;   var clasa:array [1..30] of  materie;    s:real; i,j:integer; f:text;"], "page_sentence_count_spacy": 4}, {"page_number": 206, "page_char_count": 2210, "page_word_count": 535, "page_sentence_count_raw": 6, "page_token_count": 552.5, "text": "206    s=0;  for (j=1;j<=3;j++)  { f>>clasa[j].nume; |     fscanf(f,\"%s\",clasa[j].nume);    for (i=1;i<= 5;i++)       {  f>>clasa[j].note[i]; |      fscanf(f,\"%d\",&clasa[j].note[i]);          s=s+clasa[j].note[i];       }           f>>clasa[j].teza; |       fscanf(f,\"%f\",&clasa[j].teza);  }   s=s-71;   cout<<(3*s+5*clasa[2].teza)/20; |  printf(\"%f\",(3*s  +5*clasa[2].teza)/20);   f.close();|fclose(f);             assign(f,'date.in');reset(f);     s:=0;     for j:=1 to 3 do         begin          readln(f,clasa[j].nume);          for i:=1 to 5 do           begin            read(f,clasa[j].note[i]);            s:=s+clasa[j].note[i]           end;          readln(f,clasa[j].teza)         end;     s:=s-71;     write((3*s+5*clasa[2].teza)/20);     close(f);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) media celor trei elevi la respectiva materie; b) suma mediilor celor trei elevi;  c) media lui Dan la respectiva materie;  d) media lui Sebby la respectiva materie;  e) cea mai mare medie dintre cele trei;  f) cea mai mic\u0103 medie dintre cele trei.    14.   Se consider\u0103 o parol\u0103 cu n caractere ce este alc\u0103tuit\u0103 din cifre dispuse \u00een progresie  aritmetic\u0103. Folosind metoda backtracking se genereaz\u0103 \u0219iruri de numere de lungime n p\u00e2n\u0103  la depistarea parolei respective. Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  void valid(int parola[10],int k,int &ev) |  void valid(int parola[10], int k, int *ev)  {    ev= 1; |*ev= 1;            if (k>2)          if (...)             ev= 0; |*ev= 0;   }  Limbajul Pascal  type sir= array [1..10] of integer;   procedure valid( parola: sir; k: word; var ev: boolean);   begin     ev:= true;     if k>2 then        if ... then  ev:= false   end;  Expresia corespunz\u0103toare punctelor de suspensie din secven\u0163a de program al\u0103turat\u0103 pentru  ca cifra de pe pozi\u021bia k(k>2)s\u0103 fie considerat\u0103 valid\u0103 \u0219i prin urmare variabila ev s\u0103  primeasc\u0103 valoarea 1(C++/C)/True(Pascal) este:  Limbajul C++/C  a) parola[k] - parola[k-1] != parola[2] - parola[1]  b) parola[k] - parola[k-1] != parola[k+1]- parola[k]  c) parola[k] <> parola[k-1]  d) parola[k] - parola[k-1] >= parola[2] - parola[1]  e) parola[k+1] - parola[k] != parola[2] - parola[1]", "sentences": ["206    s=0;  for (j=1;j<=3;j++)  { f>>clasa[j].nume; |     fscanf(f,\"%s\",clasa[j].nume);    for (i=1;i<= 5;i++)       {  f>>clasa[j].note[i]; |      fscanf(f,\"%d\",&clasa[j].note[i]);          s=s+clasa[j].note[i];       }           f>>clasa[j].teza; |       fscanf(f,\"%f\",&clasa[j].teza);  }   s=s-71;   cout<<(3*s+5*clasa[2].teza)/20; |  printf(\"%f\",(3*s  +5*clasa[2].teza)/20);   f.close();|fclose(f);             assign(f,'date.in');reset(f);     s:=0;     for j:=1 to 3 do         begin          readln(f,clasa[j].nume);          for i:=1 to 5 do           begin            read(f,clasa[j].note[i]);            s:=s+clasa[j].note[i]           end;          readln(f,clasa[j].teza)         end;     s:=s-71;     write((3*s+5*clasa[2].teza)/20);     close(f);  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se afi\u015feaz\u0103:  a) media celor trei elevi la respectiva materie; b) suma mediilor celor trei elevi;  c) media lui Dan la respectiva materie;  d) media lui Sebby la respectiva materie;  e) cea mai mare medie dintre cele trei;  f) cea mai mic\u0103 medie dintre cele trei.", "   14.", "  Se consider\u0103 o parol\u0103 cu n caractere ce este alc\u0103tuit\u0103 din cifre dispuse \u00een progresie  aritmetic\u0103.", "Folosind metoda backtracking se genereaz\u0103 \u0219iruri de numere de lungime n p\u00e2n\u0103  la depistarea parolei respective.", "Se consider\u0103 urm\u0103toarea secven\u0163\u0103 de program:  Limbajul C++/C  void valid(int parola[10],int k,int &ev) |  void valid(int parola[10], int k, int *ev)  {    ev= 1; |*ev= 1;            if (k>2)          if (...)             ev= 0; |*ev= 0;   }  Limbajul Pascal  type sir= array [1..10] of integer;   procedure valid( parola: sir; k: word; var ev: boolean);   begin     ev:= true;     if k>2 then        if ... then  ev:= false   end;  Expresia corespunz\u0103toare punctelor de suspensie din secven\u0163a de program al\u0103turat\u0103 pentru  ca cifra de pe pozi\u021bia k(k>2)s\u0103 fie considerat\u0103 valid\u0103 \u0219i prin urmare variabila ev s\u0103  primeasc\u0103 valoarea 1(C++/C)/True(Pascal) este:  Limbajul C++/C  a) parola[k] - parola[k-1] !", "= parola[2] - parola[1]  b) parola[k] - parola[k-1] !", "= parola[k+1]- parola[k]  c) parola[k] <> parola[k-1]  d) parola[k] - parola[k-1] >= parola[2] - parola[1]  e) parola[k+1] - parola[k] !", "= parola[2] - parola[1]"], "page_sentence_count_spacy": 8}, {"page_number": 207, "page_char_count": 1352, "page_word_count": 229, "page_sentence_count_raw": 3, "page_token_count": 338.0, "text": "207    f) parola[k] == parola[2] - parola[1]  Limbajul Pascal  a) parola[k] - parola[k-1] <> parola[2] - parola[1]  b) parola[k] - parola[k-1] <> parola[k+1]- parola[k]  c) parola[k] != parola[k-1]  d) parola[k] - parola[k-1] >= parola[2] - parola[1]  e) parola[k+1] - parola[k]<> parola[2] - parola[1]  f) parola[k] = parola[2] - parola[1]    15.  Variabilele n(n\u22652)\u0219i i memoreaz\u0103 numere naturale \u015fi tablou bidimensional p\u0103tratic a (n  linii \u015fi n coloane) are valori din mul\u0163imea {1,2,3,4,5}. Se consider\u0103 urm\u0103toarea  secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  for (i=n;i>= 1;i--)   if (i!=n-i+1)  {   a[i][n-i+1]=a[i][n- i+1]+a[i][i];   a[i][i]=a[i][n-i+1]-a[i][i];   a[i][n-i+1]=a[i][n-i+1]- a[i][i];   }  for i:=n downto 1 do   if i<>n-i+1 then   begin   a[i,n-i+1]:= a[i,n-i+1]+a[i,i];   a[i,i]:= a[i,n-i+1]-a[i,i];   a[i,n-i+1]:=a[i,n-i+1]-a[i,i]   end;  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se realizeaz\u0103:  a) interschimbarea elementelor de pe linia i \u0219i coloana n-i+1;  b) egalarea valorilor de pe cele dou\u0103 diagonale;  c) interschimbarea elementelor de pe cele dou\u0103 diagonale;  d) \u00eenlocuirea elementelor de pe diagonala principal\u0103 cu cele de pe diagonala secundar\u0103;  e) interschimbarea elementelor de pe coloana i \u0219i linia n-i+1;  f) \u00eenlocuirea elementelor de pe diagonala secundar\u0103 cu cele de pe diagonala principal\u0103.", "sentences": ["207    f) parola[k] == parola[2] - parola[1]  Limbajul Pascal  a) parola[k] - parola[k-1] <> parola[2] - parola[1]  b) parola[k] - parola[k-1] <> parola[k+1]- parola[k]  c) parola[k] !", "= parola[k-1]  d) parola[k] - parola[k-1] >= parola[2] - parola[1]  e) parola[k+1] - parola[k]<> parola[2] - parola[1]  f) parola[k] = parola[2] - parola[1]    15.", " Variabilele n(n\u22652)\u0219i i memoreaz\u0103 numere naturale \u015fi tablou bidimensional p\u0103tratic a (n  linii \u015fi n coloane) are valori din mul\u0163imea {1,2,3,4,5}.", "Se consider\u0103 urm\u0103toarea  secven\u0163\u0103 de program:  Limbajul C++/C  Limbajul Pascal  for (i=n;i>= 1;i--)   if (i!=n-i+1)  {   a[i][n-i+1]=a[i][n- i+1]+a[i][i];   a[i][i]=a[i][n-i+1]-a[i][i];   a[i][n-i+1]=a[i][n-i+1]- a[i][i];   }  for i:=n downto 1 do   if i<>n-i+1 then   begin   a[i,n-i+1]:= a[i,n-i+1]+a[i,i];   a[i,i]:= a[i,n-i+1]-a[i,i];   a[i,n-i+1]:=a[i,n-i+1]-a[i,i]   end;  \u00cen urma execut\u0103rii secven\u021bei de program al\u0103turate se realizeaz\u0103:  a) interschimbarea elementelor de pe linia i \u0219i coloana n-i+1;  b) egalarea valorilor de pe cele dou\u0103 diagonale;  c) interschimbarea elementelor de pe cele dou\u0103 diagonale;  d) \u00eenlocuirea elementelor de pe diagonala principal\u0103 cu cele de pe diagonala secundar\u0103;  e) interschimbarea elementelor de pe coloana i \u0219i linia n-i+1;  f) \u00eenlocuirea elementelor de pe diagonala secundar\u0103 cu cele de pe diagonala principal\u0103."], "page_sentence_count_spacy": 4}, {"page_number": 208, "page_char_count": 1633, "page_word_count": 374, "page_sentence_count_raw": 9, "page_token_count": 408.25, "text": "208      Varianta 39  1. Fie un \u0219ir alc\u0103tuit din 100 de elemente numere naturale (componentele \u0219irului se citesc  de la tastatur\u0103 prin intermediul variabilei \u00eentregi a). Urm\u0103toarea secven\u021b\u0103 de cod  determin\u0103, \u00een variabila \u00eentreag\u0103 nr, num\u0103rul tuturor elementelor din \u0219ir care memoreaz\u0103  un num\u0103r alc\u0103tuit din cel pu\u021bin dou\u0103 cifre. Stabili\u021bi expresiile care pot \u00eenlocui punctele de  suspensie.  Limbajul C++/C  nr=100;  for(i=1;i<=100;i++)  {cin>>a; | scanf(\"%d\",&a);  if(9>=\u2026)         nr=\u2026+nr;}  Limbajul Pascal  nr:=100;  for i:=1 to 100 do begin    readln(a);    if  9>=\u2026  then         nr:=\u2026+nr;   end;  a) a \u0219i i  b) a \u0219i \u2013i  c) a \u0219i -1  d) a \u0219i 1  e) a \u0219i a  f) a \u0219i -a    2. Variabila i memoreaz\u0103 un num\u0103r \u00eentreg, iar s memoreaz\u0103 un \u0219ir alc\u0103tuit din cel mult 20  de caractere. Rezultatul ob\u021binut, \u00een urma rul\u0103rii secven\u021bei de ma jos, este:  Limbajul C++/C  strcpy(s,\"VAPOARE\");  i=0;  while(i<strlen(s)-1)  {if(strchr(\"AEIOU\",s[i])!=0)      { s[i]=s[i]+1;        strcpy(s+i+1,s+i+2);      }  i++;}  cout<<s; | printf(\"%s\",s);  Limbajul Pascal  s:='VAPOARE' ;  i:=1;  while i<= length(s)-1 do  begin  if pos(s[i],'AEIOU')<>0 then   begin    s[i]:=succ(s[i]);    delete(s,i+1,1);   end;  i:=i+1;  end;  write(s);  a) VARE  b) VBPOR  c) VBPRF  d) VBPRO  e) VBPRE  f) VPRBO    3. Dup\u0103 execu\u021bia urm\u0103toarei secven\u021be, stabili\u021bi num\u0103rul elementelor cu valoarea 9 din tabloul  unidimensional a.  Limbajul C++/C  int a[] = {0, 1, 2, 3, 0, 4,  5, 6};   int i = 0, x = 9;   do{      a[i++] = x;     }  while(i<6&&a[i]);  Limbajul Pascal   type vector=array[1..8] of  integer;  var   a:vector = (0,1,2,3,0,4,  5,6);       i,x:integer;  begin", "sentences": ["208      Varianta 39  1.", "Fie un \u0219ir alc\u0103tuit din 100 de elemente numere naturale (componentele \u0219irului se citesc  de la tastatur\u0103 prin intermediul variabilei \u00eentregi a).", "Urm\u0103toarea secven\u021b\u0103 de cod  determin\u0103, \u00een variabila \u00eentreag\u0103 nr, num\u0103rul tuturor elementelor din \u0219ir care memoreaz\u0103  un num\u0103r alc\u0103tuit din cel pu\u021bin dou\u0103 cifre.", "Stabili\u021bi expresiile care pot \u00eenlocui punctele de  suspensie.", " Limbajul C++/C  nr=100;  for(i=1;i<=100;i++)  {cin>>a; | scanf(\"%d\",&a);  if(9>=\u2026)         nr=\u2026+nr;}  Limbajul Pascal  nr:=100;  for i:=1 to 100 do begin    readln(a);    if  9>=\u2026  then         nr:=\u2026+nr;   end;  a) a \u0219i i  b) a \u0219i \u2013i  c) a \u0219i -1  d) a \u0219i 1  e) a \u0219i a  f) a \u0219i -a    2.", "Variabila i memoreaz\u0103 un num\u0103r \u00eentreg, iar s memoreaz\u0103 un \u0219ir alc\u0103tuit din cel mult 20  de caractere.", "Rezultatul ob\u021binut, \u00een urma rul\u0103rii secven\u021bei de ma jos, este:  Limbajul C++/C  strcpy(s,\"VAPOARE\");  i=0;  while(i<strlen(s)-1)  {if(strchr(\"AEIOU\",s[i])!=0)      { s[i]=s[i]+1;        strcpy(s+i+1,s+i+2);      }  i++;}  cout<<s; | printf(\"%s\",s);  Limbajul Pascal  s:='VAPOARE' ;  i:=1;  while i<= length(s)-1 do  begin  if pos(s[i],'AEIOU')<>0 then   begin    s[i]:=succ(s[i]);    delete(s,i+1,1);   end;  i:=i+1;  end;  write(s);  a) VARE  b) VBPOR  c) VBPRF  d) VBPRO  e) VBPRE  f) VPRBO    3.", "Dup\u0103 execu\u021bia urm\u0103toarei secven\u021be, stabili\u021bi num\u0103rul elementelor cu valoarea 9 din tabloul  unidimensional a.  Limbajul C++/C  int a[] = {0, 1, 2, 3, 0, 4,  5, 6};   int i = 0, x = 9;   do{      a[i++] = x;     }  while(i<6&&a[i]);  Limbajul Pascal   type vector=array[1..8] of  integer;  var   a:vector = (0,1,2,3,0,4,  5,6);       i,x:integer;  begin"], "page_sentence_count_spacy": 8}, {"page_number": 209, "page_char_count": 1966, "page_word_count": 420, "page_sentence_count_raw": 11, "page_token_count": 491.5, "text": "209       i := 1;   x := 9;      repeat    a[i]:= x; i:=i+1;     until (i>6) or (a[i]=0);  end.  a) niciunul  b) unul  c) dou\u0103  d) trei  e) patru  f) cinci    4. \u00cen vederea sort\u0103rii cresc\u0103toare a unui \u0219ir de valori \u00eentregi, folosind metoda bulelor (bubble  sort), un program cite\u0219te valorile urm\u0103toare 2,40,17,1,51,34,20,63 \u0219i le  memoreaz\u0103 \u00eentr-un tablou unidimensional. Dup\u0103 c\u00e2te parcurgeri ale \u0219irului, valoarea 40  ajunge pe locul final \u00een tabloul unidimensional sortat cresc\u0103tor?  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    5. \u00centr-un tablou bidimensional de dimensiuni nxn, av\u00e2nd liniile \u0219i coloanele numerotate  de la 1 la n, condi\u0163ia pentru ca elementul de pe linia i \u0219i coloana j s\u0103 fie situat deasupra  diagonalei principale \u0219i deasupra diagonalei secundare este:  Limbajul C++/C  a)  (i<=j)&&(i+j<n )   b)  (i<j)&&(i+j<n+1 )  c)  (i<n)&&(i+j<n- 1)  d)  (i<j)||(i+j<n+ 1)  e)  (i<=j)&&(i+j<=n +1)  f)  i<n+j  Limbajul Pascal   a)  (i<=j)AND(i+j <n)  b)  (i<j)AND(i+j<n+1 )  c)  (i<n)AND(i+j<n- 1)  d)  (i<j)OR(i+j<n +1)  e)  (i<=j)AND(i+j<=n +1)  f)  i<n+j    6. Se consider\u0103 un graf neorientat cu 8 noduri \u015fi 28 de muchii. Indica\u0163i num\u0103rul minim de  muchii care pot fi eliminate, astfel \u00eenc\u00e2t graful par\u0163ial ob\u0163inut s\u0103 con\u021bin\u0103 dou\u0103 componente  conexe, cu cel pu\u0163in dou\u0103 noduri fiecare.  a) 4  b) 6  c) 8  d) 10  e) 12  f) 16    7. Variabilele x, y \u0219i z sunt de tip \u00eentreg \u0219i memoreaz\u0103 numere naturale din intervalul  [1,103]. Indica\u021bi o expresie care are valoarea 1 \u00een C++/C sau valoarea TRUE \u00een Pascal,  dac\u0103 \u0219i numai dac\u0103 valoarea variabilei x este strict mai mare dec\u00e2t valoarea oric\u0103reia dintre  variabilele y \u0219i z.  Limbajul C++/C  a)  x*y>y*z && x*z>y*z  b)  x*z>x*y && y*z>y*x  c)  y*z>x*z && y*x>z*x  d)  y*z>y*x && y*z>z*x  e)    x*y>y*z || x*z>y*z  f)   y*z>y*x || y*z>z*x  Limbajul Pascal   a)  (x*y>y*z)AND(x*z>y*z)  b)  (x*z>x*y)AND(y*z>y*x)  c)  (y*z>x*z)AND(y*x>z*x)  d)  (y*z>y*x)AND(y*z>z*x)  e)  (x*y>y*z)OR(x*z>y*z)  f)  (y*z>y*x)OR(y*z>z*x)", "sentences": ["209       i := 1;   x := 9;      repeat    a[i]:= x; i:=i+1;     until (i>6) or (a[i]=0);  end.", " a) niciunul  b) unul  c) dou\u0103  d) trei  e) patru  f) cinci    4.", "\u00cen vederea sort\u0103rii cresc\u0103toare a unui \u0219ir de valori \u00eentregi, folosind metoda bulelor (bubble  sort), un program cite\u0219te valorile urm\u0103toare 2,40,17,1,51,34,20,63 \u0219i le  memoreaz\u0103 \u00eentr-un tablou unidimensional.", "Dup\u0103 c\u00e2te parcurgeri ale \u0219irului, valoarea 40  ajunge pe locul final \u00een tabloul unidimensional sortat cresc\u0103tor?", " a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    5.", "\u00centr-un tablou bidimensional de dimensiuni nxn, av\u00e2nd liniile \u0219i coloanele numerotate  de la 1 la n, condi\u0163ia pentru ca elementul de pe linia i \u0219i coloana j s\u0103 fie situat deasupra  diagonalei principale \u0219i deasupra diagonalei secundare este:  Limbajul C++/C  a)  (i<=j)&&(i+j<n )   b)  (i<j)&&(i+j<n+1 )  c)  (i<n)&&(i+j<n- 1)  d)  (i<j)||(i+j<n+ 1)  e)  (i<=j)&&(i+j<=n +1)  f)  i<n+j  Limbajul Pascal   a)  (i<=j)AND(i+j <n)  b)  (i<j)AND(i+j<n+1 )  c)  (i<n)AND(i+j<n- 1)  d)  (i<j)OR(i+j<n +1)  e)  (i<=j)AND(i+j<=n +1)  f)  i<n+j    6.", "Se consider\u0103 un graf neorientat cu 8 noduri \u015fi 28 de muchii.", "Indica\u0163i num\u0103rul minim de  muchii care pot fi eliminate, astfel \u00eenc\u00e2t graful par\u0163ial ob\u0163inut s\u0103 con\u021bin\u0103 dou\u0103 componente  conexe, cu cel pu\u0163in dou\u0103 noduri fiecare.", " a) 4  b) 6  c) 8  d) 10  e) 12  f) 16    7.", "Variabilele x, y \u0219i z sunt de tip \u00eentreg \u0219i memoreaz\u0103 numere naturale din intervalul  [1,103].", "Indica\u021bi o expresie care are valoarea 1 \u00een C++/C sau valoarea TRUE \u00een Pascal,  dac\u0103 \u0219i numai dac\u0103 valoarea variabilei x este strict mai mare dec\u00e2t valoarea oric\u0103reia dintre  variabilele y \u0219i z.  Limbajul C++/C  a)  x*y>y*z && x*z>y*z  b)  x*z>x*y && y*z>y*x  c)  y*z>x*z && y*x>z*x  d)  y*z>y*x && y*z>z*x  e)    x*y>y*z || x*z>y*z  f)   y*z>y*x || y*z>z*x  Limbajul Pascal   a)  (x*y>y*z)AND(x*z>y*z)  b)  (x*z>x*y)AND(y*z>y*x)  c)  (y*z>x*z)AND(y*x>z*x)  d)  (y*z>y*x)AND(y*z>z*x)  e)  (x*y>y*z)OR(x*z>y*z)  f)  (y*z>y*x)OR(y*z>z*x)"], "page_sentence_count_spacy": 11}, {"page_number": 210, "page_char_count": 1709, "page_word_count": 431, "page_sentence_count_raw": 8, "page_token_count": 427.25, "text": "210    8. O variabil\u0103 \u00eentreag\u0103 x con\u021bine cel mai mic num\u0103r natural nenul, multiplu de 36, divizibil  cu toate numerele prime mai mici dec\u00e2t 10. Indica\u021bi o expresie care are valoarea 1 \u00een  C++/C sau valoarea TRUE \u00een Pascal.  Limbajul C++/C  a)  (x<1000)&&(x % 27 ==  0)  b)  (x>1000)&&((x*x*x) % 1000==0)  c)  ((x*x)/16) % 2 == 0    d)  (x % 100 == 0)||(x/100==0)  e)  (x%9 == 0)&&(x%25 ==  0)  f)  (x!=1260)||(x<1200)  Limbajul Pascal   a)  (x<1000)AND(x MOD  27=0)  b)  (x>1000)AND((x*x*x) MOD  1000=0)  c)  ((x*x) DIV 16) MOD 2=0  d)  (x MOD 100=0)OR(x DIV 100=0)  e)  (x MOD 9=0)AND(x MOD  25=0)  f)  (x<>1260) OR (x<1200)     9. \u0218tiind c\u0103 variabila n re\u021bine un num\u0103r \u00eentreg strict pozitiv, indica\u021bi semnifica\u021bia valorii  variabilei \u00eentregi x dup\u0103 execu\u021bia urm\u0103toarei secven\u021be:  Limbajul C++/C   x=1;   while(n>1)  {   n=n/2; x++;   }   cout<<x; |  printf(\"%d\",x);  Limbajul Pascal   x:=1;   while n>1 do    begin      n:=n div 2;      x:=x+1;     end;  write(x);  a)  suma puterilor din descompunerea \u00een  factori primi a num\u0103rului n  b) puterea la care apare 2 \u00een  descompunerea \u00een factori primi a  num\u0103rului n  c) num\u0103rul divizorilor pozitivi ai lui n  d) [log 2 n]-1  e) [log 2 n]  f) [log 2 n]+1   Nota\u021bie: [a] partea \u00eentreag\u0103 a numarului real a     10. Fie f \u0219i g dou\u0103 subprograme av\u00e2nd urm\u0103toarele defini\u021bii. Preciza\u021bi valoarea returnat\u0103 de  apelul g(6).  Limbajul C++/C   int f(int x){     if (x%2==0)   return f(x/2);       else return x;               }   int g(int x){     if(x<1) return 1;       else return f(x*g(x-1));               }  Limbajul Pascal   function  f(x:integer):integer;  begin   if x mod 2=0     then f:=f(x div 2)     else f:= x;   end;  function  g(x:integer):integer;  begin", "sentences": ["210    8.", "O variabil\u0103 \u00eentreag\u0103 x con\u021bine cel mai mic num\u0103r natural nenul, multiplu de 36, divizibil  cu toate numerele prime mai mici dec\u00e2t 10.", "Indica\u021bi o expresie care are valoarea 1 \u00een  C++/C sau valoarea TRUE \u00een Pascal.", " Limbajul C++/C  a)  (x<1000)&&(x % 27 ==  0)  b)  (x>1000)&&((x*x*x) % 1000==0)  c)  ((x*x)/16) % 2 == 0    d)  (x % 100 == 0)||(x/100==0)  e)  (x%9 == 0)&&(x%25 ==  0)  f)  (x!=1260)||(x<1200)  Limbajul Pascal   a)  (x<1000)AND(x MOD  27=0)  b)  (x>1000)AND((x*x*x) MOD  1000=0)  c)  ((x*x) DIV 16) MOD 2=0  d)  (x MOD 100=0)OR(x DIV 100=0)  e)  (x MOD 9=0)AND(x MOD  25=0)  f)  (x<>1260) OR (x<1200)     9.", "\u0218tiind c\u0103 variabila n re\u021bine un num\u0103r \u00eentreg strict pozitiv, indica\u021bi semnifica\u021bia valorii  variabilei \u00eentregi x dup\u0103 execu\u021bia urm\u0103toarei secven\u021be:  Limbajul C++/C   x=1;   while(n>1)  {   n=n/2; x++;   }   cout<<x; |  printf(\"%d\",x);  Limbajul Pascal   x:=1;   while n>1 do    begin      n:=n div 2;      x:=x+1;     end;  write(x);  a)  suma puterilor din descompunerea \u00een  factori primi a num\u0103rului n  b) puterea la care apare 2 \u00een  descompunerea \u00een factori primi a  num\u0103rului n  c) num\u0103rul divizorilor pozitivi ai lui n  d) [log 2 n]-1  e) [log 2 n]  f) [log 2 n]+1   Nota\u021bie: [a] partea \u00eentreag\u0103 a numarului real a     10.", "Fie f \u0219i g dou\u0103 subprograme av\u00e2nd urm\u0103toarele defini\u021bii.", "Preciza\u021bi valoarea returnat\u0103 de  apelul g(6).", " Limbajul C++/C   int f(int x){     if (x%2==0)   return f(x/2);       else return x;               }   int g(int x){     if(x<1) return 1;       else return f(x*g(x-1));               }  Limbajul Pascal   function  f(x:integer):integer;  begin   if x mod 2=0     then f:=f(x div 2)     else f:= x;   end;  function  g(x:integer):integer;  begin"], "page_sentence_count_spacy": 8}, {"page_number": 211, "page_char_count": 1822, "page_word_count": 447, "page_sentence_count_raw": 9, "page_token_count": 455.5, "text": "211     if x<1 then g:=1      else g:=f(x*g(x-1));   end;  a) 3  b) 9  c) 30  d) 45  e) 210  f) 315    11. Un graf neorientat este eulerian dac\u0103:  a)  este conex \u0219i con\u021bine cel pu\u021bin un ciclu  elementar  b)  este conex \u0219i nu con\u021bine cicluri  c)  este conex \u0219i suma elementelor de pe  fiecare coloan\u0103 a matricei de adiacen\u021b\u0103 este  num\u0103r par  d)  matricea de adiacen\u021b\u0103 este  simetric\u0103 fa\u021b\u0103 de diagonala principal\u0103  e)  con\u021bine cel pu\u021bin un ciclu hamiltonian  f)  con\u021bine un singur ciclu  elementar    12. \u00cen urma execut\u0103rii urm\u0103torului program, valorile afi\u0219ate pe ecran sunt:  Limbajul C++  #include <iostream>  using namespace std;  int x,y;  void g(int &a,  int &b)  {a=a+5; b=b+a;}  int main()  {x=1; y=2;   g(y,x);  cout<<x<<\" \"<<y;  cout<<\" \";  g(y,x);  cout<<x<<\" \"<<y;  return 0;}  Limbajul C  #include <stdio.h>  int x,y;  void g(int *a,  int *b)  {*a=*a+5;   *b=*b+*a;}  int main()  { x=1; y=2;  g(&y,&x);  printf(\"%d %d\",x,y);  printf(\" \");  g(&y,&x);  printf(\"%d %d\",x,y);  return 0;}  Limbajul Pascal  var x,y:integer;  procedure g(var   a,b: integer);  begin a:=a+5;  b:=b+a; end;  begin  x:=1; y:=2;  g(y,x);  write(x,\u2019 \u2019,y);  write(\u2019 \u2019);  g(y,x);  write(x,\u2019 \u2019,y);  end.  a)  8  7  20  12  b)  8  7  12  20  c)  7  8  12  20  d)  7  8  20  12  e)  12  20  7  8  f)  12  20  8  7    13. Preciza\u021bi num\u0103rul de \u0219iruri distincte formate din exact o liter\u0103 A, dou\u0103  litere B, trei litere  C \u0219i patru litere D.  a) 2500  b) 3600  c) 7560  d) 10300  e) 12600  f) 151200    14. Fie arborele cu 8 noduri \u0219i cu muchiile [1,2], [1,3], [1,4], [4,5], [6,4],  [1,8], [4,7]. C\u00e2\u021bi vectori de ta\u021bi distinc\u021bi se pot construi pentru acest  arbore? Doi vectori de ta\u021bi sunt distinc\u021bi dac\u0103 exist\u0103 cel pu\u021bin o pozi\u021bie pentru care  elementele din respectivele pozi\u021bii sunt distincte.  a)  7  b)  8  c)  28  d)  36  e)  8 !  f)  40320", "sentences": ["211     if x<1 then g:=1      else g:=f(x*g(x-1));   end;  a) 3  b) 9  c) 30  d) 45  e) 210  f) 315    11.", "Un graf neorientat este eulerian dac\u0103:  a)  este conex \u0219i con\u021bine cel pu\u021bin un ciclu  elementar  b)  este conex \u0219i nu con\u021bine cicluri  c)  este conex \u0219i suma elementelor de pe  fiecare coloan\u0103 a matricei de adiacen\u021b\u0103 este  num\u0103r par  d)  matricea de adiacen\u021b\u0103 este  simetric\u0103 fa\u021b\u0103 de diagonala principal\u0103  e)  con\u021bine cel pu\u021bin un ciclu hamiltonian  f)  con\u021bine un singur ciclu  elementar    12.", "\u00cen urma execut\u0103rii urm\u0103torului program, valorile afi\u0219ate pe ecran sunt:  Limbajul C++  #include <iostream>  using namespace std;  int x,y;  void g(int &a,  int &b)  {a=a+5; b=b+a;}  int main()  {x=1; y=2;   g(y,x);  cout<<x<<\" \"<<y;  cout<<\" \";  g(y,x);  cout<<x<<\" \"<<y;  return 0;}  Limbajul C  #include <stdio.h>  int x,y;  void g(int *a,  int *b)  {*a=*a+5;   *b=*b+*a;}  int main()  { x=1; y=2;  g(&y,&x);  printf(\"%d %d\",x,y);  printf(\" \");  g(&y,&x);  printf(\"%d %d\",x,y);  return 0;}  Limbajul Pascal  var x,y:integer;  procedure g(var   a,b: integer);  begin a:=a+5;  b:=b+a; end;  begin  x:=1; y:=2;  g(y,x);  write(x,\u2019 \u2019,y);  write(\u2019 \u2019);  g(y,x);  write(x,\u2019 \u2019,y);  end.", " a)  8  7  20  12  b)  8  7  12  20  c)  7  8  12  20  d)  7  8  20  12  e)  12  20  7  8  f)  12  20  8  7    13.", "Preciza\u021bi num\u0103rul de \u0219iruri distincte formate din exact o liter\u0103 A, dou\u0103  litere B, trei litere  C \u0219i patru litere D.  a) 2500  b) 3600  c) 7560  d) 10300  e) 12600  f) 151200    14.", "Fie arborele cu 8 noduri \u0219i cu muchiile [1,2], [1,3], [1,4], [4,5], [6,4],  [1,8], [4,7].", "C\u00e2\u021bi vectori de ta\u021bi distinc\u021bi se pot construi pentru acest  arbore?", "Doi vectori de ta\u021bi sunt distinc\u021bi dac\u0103 exist\u0103 cel pu\u021bin o pozi\u021bie pentru care  elementele din respectivele pozi\u021bii sunt distincte.", " a)  7  b)  8  c)  28  d)  36  e)  8 !", " f)  40320"], "page_sentence_count_spacy": 10}, {"page_number": 212, "page_char_count": 870, "page_word_count": 200, "page_sentence_count_raw": 2, "page_token_count": 217.5, "text": "212    15. Stabili\u021bi rezultatul execu\u021biei secven\u021bei de mai jos, unde variabilele x \u0219i b re\u021bin numere  naturale cunoscute (1\u2264x\u22641000, 1<b\u226410), iar s este o variabil\u0103 \u00eentreag\u0103:  Limbajul C++/C   s=0;  while (x>0)    {  s=s+ x % b;  x=x / b;   }  if (s % (b-1)==0)  cout<<\"da\"; | printf(\"da\");    else   cout<<\"nu\"; | printf(\"nu\");  Limbajul Pascal   s:=0;  while x>0 do    begin  s:=s+ x mod b;  x:=x div b;   end;  if  s mod (b-1)=0 then      write('da')  else write('nu');  a)  verific\u0103 dac\u0103 suma cifrelor reprezent\u0103rii  \u00een baza b-1 a num\u0103rului x este divizibil\u0103 cu b- 1  b)  verific\u0103 dac\u0103 num\u0103rul x este  divizibil cu b-1  c)  verific\u0103 dac\u0103 suma cifrelor reprezent\u0103rii  \u00een baza b a num\u0103rului x este divizibil\u0103 cu b  d)  verific\u0103 dac\u0103 num\u0103rul x este  divizibil cu b  e)  verific\u0103 dac\u0103 suma cifrelor lui x este  divizibil\u0103 cu b-1  f)  niciuna dintre variantele  anterioare", "sentences": ["212    15.", "Stabili\u021bi rezultatul execu\u021biei secven\u021bei de mai jos, unde variabilele x \u0219i b re\u021bin numere  naturale cunoscute (1\u2264x\u22641000, 1<b\u226410), iar s este o variabil\u0103 \u00eentreag\u0103:  Limbajul C++/C   s=0;  while (x>0)    {  s=s+ x % b;  x=x / b;   }  if (s % (b-1)==0)  cout<<\"da\"; | printf(\"da\");    else   cout<<\"nu\"; | printf(\"nu\");  Limbajul Pascal   s:=0;  while x>0 do    begin  s:=s+ x mod b;  x:=x div b;   end;  if  s mod (b-1)=0 then      write('da')  else write('nu');  a)  verific\u0103 dac\u0103 suma cifrelor reprezent\u0103rii  \u00een baza b-1 a num\u0103rului x este divizibil\u0103 cu b- 1  b)  verific\u0103 dac\u0103 num\u0103rul x este  divizibil cu b-1  c)  verific\u0103 dac\u0103 suma cifrelor reprezent\u0103rii  \u00een baza b a num\u0103rului x este divizibil\u0103 cu b  d)  verific\u0103 dac\u0103 num\u0103rul x este  divizibil cu b  e)  verific\u0103 dac\u0103 suma cifrelor lui x este  divizibil\u0103 cu b-1  f)  niciuna dintre variantele  anterioare"], "page_sentence_count_spacy": 2}, {"page_number": 213, "page_char_count": 1840, "page_word_count": 412, "page_sentence_count_raw": 11, "page_token_count": 460.0, "text": "213    Varianta 40  1. Se consider\u0103 subprogramul f av\u00e2nd defini\u0163ia urm\u0103toare. Stabili\u021bi valoarea variabilei n de  tip \u00eentreg \u0219tiind c\u0103, la apelul f(n), subprogramul returneaz\u0103 valoarea 2014?  Limbajul C++/C  int f(int x)  { if (x>=5)       return f(x-1)+x;    return 2*x;  }  Limbajul Pascal  function f(x:integer):integer;   begin      if  x<5  then f:=2*x         else f:=f(x-1)+x;   end;  a) 16  b) 30  c) 62  d) 63  e) 88  f) 100    2. \u00cen urm\u0103toarea secven\u0163\u0103 de program, variabilele k, i \u015fi j sunt de tip \u00eentreg, iar variabila  A memoreaz\u0103 un tablou bidimensional cu 7 linii \u015fi 7 coloane (numerotate de la 1 la 7) cu  elemente de tip \u00eentreg. Preciza\u021bi care este cea mai mare valoare memorat\u0103 \u00een matricea A  la finalul execut\u0103rii secven\u021bei?  Limbajul C++/C  k=1;  for(i=1;i<=7;i++)   for(j=1;j<=7;j++)    { A[i][j]=k++;      A[i][8-j]=k;}    Limbajul Pascal  k:=1;  for i:=1 to 7 do   for j:=1 to 7 do    begin     A[i][j]:=k; k:=k+1;     A[i][8-j]:=k;    end;  a) 0  b) 7  c) 10  d) 37  e) 50  f) 51    3. Se consider\u0103 urm\u0103toarea secven\u021b\u0103 de cod. Identifica\u021bi ce se va afi\u0219a dac\u0103 de la tastatur\u0103 se  vor introduce, \u00een ordine, \u0219irurile de caractere  student, carte \u0219i birou:  Limbajul C++/C  char a[256], b[256]; int i;  strcpy(b, \"\");  for(i=0;i<3;i++)  {cin>>a;  |  scanf(\"%s\",a);  strcat(b, a+i);  }  cout<<b; |  printf(\"%s\",b);  Limbajul Pascal  var  a,b:string; i:integer;  begin  b:=\u2019\u2019;  for  i:=0 to 2 do  begin  readln(a);  b:=b+copy(a,i+1,length(a));  end;  write(b);  end.  a)  scb  b)  studencartbiro c)  studentarterou  d)  studentcartbir e)    tudenartiro  f)  tudentrteou    4. Se consider\u0103 definite trei variabile \u00eentregi x, y \u0219i z \u0219i urm\u0103toarele dou\u0103 expresii. Stabili\u021bi  afirma\u021bia adev\u0103rat\u0103.  Limbajul C++/C  p=!((x == y)&&(x == z));  q=(x!=y)||(x!=z);  Limbajul Pascal  p:=NOT((x = y)AND(x = z));  q:=(x <> y)OR(x <>z);", "sentences": ["213    Varianta 40  1.", "Se consider\u0103 subprogramul f av\u00e2nd defini\u0163ia urm\u0103toare.", "Stabili\u021bi valoarea variabilei n de  tip \u00eentreg \u0219tiind c\u0103, la apelul f(n), subprogramul returneaz\u0103 valoarea 2014?", " Limbajul C++/C  int f(int x)  { if (x>=5)       return f(x-1)+x;    return 2*x;  }  Limbajul Pascal  function f(x:integer):integer;   begin      if  x<5  then f:=2*x         else f:=f(x-1)+x;   end;  a) 16  b) 30  c) 62  d) 63  e) 88  f) 100    2.", "\u00cen urm\u0103toarea secven\u0163\u0103 de program, variabilele k, i \u015fi j sunt de tip \u00eentreg, iar variabila  A memoreaz\u0103 un tablou bidimensional cu 7 linii \u015fi 7 coloane (numerotate de la 1 la 7) cu  elemente de tip \u00eentreg.", "Preciza\u021bi care este cea mai mare valoare memorat\u0103 \u00een matricea A  la finalul execut\u0103rii secven\u021bei?", " Limbajul C++/C  k=1;  for(i=1;i<=7;i++)   for(j=1;j<=7;j++)    { A[i][j]=k++;      A[i][8-j]=k;}    Limbajul Pascal  k:=1;  for i:=1 to 7 do   for j:=1 to 7 do    begin     A[i][j]:=k; k:=k+1;     A[i][8-j]:=k;    end;  a) 0  b) 7  c) 10  d) 37  e) 50  f) 51    3.", "Se consider\u0103 urm\u0103toarea secven\u021b\u0103 de cod.", "Identifica\u021bi ce se va afi\u0219a dac\u0103 de la tastatur\u0103 se  vor introduce, \u00een ordine, \u0219irurile de caractere  student, carte \u0219i birou:  Limbajul C++/C  char a[256], b[256]; int i;  strcpy(b, \"\");  for(i=0;i<3;i++)  {cin>>a;  |  scanf(\"%s\",a);  strcat(b, a+i);  }  cout<<b; |  printf(\"%s\",b);  Limbajul Pascal  var  a,b:string; i:integer;  begin  b:=\u2019\u2019;  for  i:=0 to 2 do  begin  readln(a);  b:=b+copy(a,i+1,length(a));  end;  write(b);  end.", " a)  scb  b)  studencartbiro c)  studentarterou  d)  studentcartbir e)    tudenartiro  f)  tudentrteou    4.", "Se consider\u0103 definite trei variabile \u00eentregi x, y \u0219i z \u0219i urm\u0103toarele dou\u0103 expresii.", "Stabili\u021bi  afirma\u021bia adev\u0103rat\u0103.", " Limbajul C++/C  p=!((x == y)&&(x == z));  q=(x!=y)||(x!=z);  Limbajul Pascal  p:=NOT((x = y)AND(x = z));  q:=(x <> y)OR(x <>z);"], "page_sentence_count_spacy": 13}, {"page_number": 214, "page_char_count": 1850, "page_word_count": 453, "page_sentence_count_raw": 13, "page_token_count": 462.5, "text": "214    a)  p egal cu q dac\u0103 \u0219i numai dac\u0103 x  egal cu y  b)  p egal cu q dac\u0103 \u0219i numai dac\u0103 x  egal cu z  c)  oricare ar fi x, y, z  p este  diferit de q  d)  oricare ar fi x, y, z  p este egal  cu q  e)  exist\u0103 x, y, z astfel \u00eenc\u00e2t p  diferit de q  f)  niciuna dintre variantele anterioare    5. Subprogramul f prime\u015fte prin intermediul parametrului n un num\u0103r natural \u015fi returneaz\u0103  num\u0103rul maxim de cifre consecutive situate pe pozi\u021bii al\u0103turate \u00een scrierea num\u0103rului n.  De exemplu, la apelul f(23523455) subprogramul returneaz\u0103 num\u0103rul 4. Determina\u021bi  num\u0103rul de valori distincte n cu exact 4 cifre pentru care expresia f(n) are valoarea 3.  a)  63  b)  121 c)  130 d)  152 e)  160 f)  181    6. Un tip de date \u00eentreg pe n bi\u021bi (n>1, num\u0103r natural) va putea re\u021bine valori \u00eentregi din  intervalul:  a)  [-2n-1, 2n-1-1] b)  [-2n, 2n -1]  c)  [-2n, 2n ]  d)  [0, 2n-1]  e)  [0, 2n]  f)  [0, 2n-1-1]    7. Preciza\u021bi valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program:  Limbajul C++/C  int i, p=16;  while(1)  { if (i=5) break;   p+=i;  i+=2; }   cout<<p; | printf(\u201d%d\u201d,p);  Limbajul Pascal  var  i, p:integer;  begin  p:=16; i:=1;   while TRUE do    begin       if i=1  then  break;        p:=p+i;       i:=i+2;     end;    write(p);  end.  a)  10  b)  16  c)  17  d)  20  e)  24  f)  instruc\u021biunea while  ruleaz\u0103 la infinit    8. Se consider\u0103 un tablou unidimensional a \u00een care elementele sunt, \u00een ordine:  1,3,5,7,10,16,21 . Pentru a afla pozi\u021bia pe care se afl\u0103 valoarea x=10 \u00een tablou, se  aplic\u0103 metoda c\u0103ut\u0103rii binare. Identifica\u021bi succesiunea corect\u0103 de elemente a c\u0103ror valoare  se compar\u0103 cu valoarea x.  a)  21,16,10  b)  7,16,10  c)  1,3,5,7,10  d)  5,7,10  e)  7,10  f)  10    9. Un tablou bidimensional cu 8 linii, format doar din elemente 0 \u0219i 1, are urm\u0103toarele  propriet\u0103\u021bi:  Prima linie con\u021bine un singur element cu valoarea 1;", "sentences": ["214    a)  p egal cu q dac\u0103 \u0219i numai dac\u0103 x  egal cu y  b)  p egal cu q dac\u0103 \u0219i numai dac\u0103 x  egal cu z  c)  oricare ar fi x, y, z  p este  diferit de q  d)  oricare ar fi x, y, z  p este egal  cu q  e)  exist\u0103 x, y, z astfel \u00eenc\u00e2t p  diferit de q  f)  niciuna dintre variantele anterioare    5.", "Subprogramul f prime\u015fte prin intermediul parametrului n un num\u0103r natural \u015fi returneaz\u0103  num\u0103rul maxim de cifre consecutive situate pe pozi\u021bii al\u0103turate \u00een scrierea num\u0103rului n.  De exemplu, la apelul f(23523455) subprogramul returneaz\u0103 num\u0103rul 4.", "Determina\u021bi  num\u0103rul de valori distincte n cu exact 4 cifre pentru care expresia f(n) are valoarea 3.", " a)  63  b)  121 c)  130 d)  152 e)  160 f)  181    6.", "Un tip de date \u00eentreg pe n bi\u021bi (n>1, num\u0103r natural) va putea re\u021bine valori \u00eentregi din  intervalul:  a)  [-2n-1, 2n-1-1] b)  [-2n, 2n -1]  c)  [-2n, 2n ]  d)  [0, 2n-1]  e)  [0, 2n]  f)  [0, 2n-1-1]    7.", "Preciza\u021bi valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program:  Limbajul C++/C  int i, p=16;  while(1)  { if (i=5) break;   p+=i;  i+=2; }   cout<<p; | printf(\u201d%d\u201d,p);  Limbajul Pascal  var  i, p:integer;  begin  p:=16; i:=1;   while TRUE do    begin       if i=1  then  break;        p:=p+i;       i:=i+2;     end;    write(p);  end.", " a)  10  b)  16  c)  17  d)  20  e)  24  f)  instruc\u021biunea while  ruleaz\u0103 la infinit    8.", "Se consider\u0103 un tablou unidimensional a \u00een care elementele sunt, \u00een ordine:  1,3,5,7,10,16,21 .", "Pentru a afla pozi\u021bia pe care se afl\u0103 valoarea x=10 \u00een tablou, se  aplic\u0103 metoda c\u0103ut\u0103rii binare.", "Identifica\u021bi succesiunea corect\u0103 de elemente a c\u0103ror valoare  se compar\u0103 cu valoarea x.  a)  21,16,10  b)  7,16,10  c)  1,3,5,7,10  d)  5,7,10  e)  7,10  f)  10    9.", "Un tablou bidimensional cu 8 linii, format doar din elemente 0 \u0219i 1, are urm\u0103toarele  propriet\u0103\u021bi:  Prima linie con\u021bine un singur element cu valoarea 1;"], "page_sentence_count_spacy": 11}, {"page_number": 215, "page_char_count": 2113, "page_word_count": 491, "page_sentence_count_raw": 21, "page_token_count": 528.25, "text": "215    Linia j con\u021bine de dou\u0103 ori mai multe valori nenule dec\u00e2t linia j-1, 2\u2264j\u22648;  Ultima linie con\u021bine un singur element cu valoare 0.  Determina\u021bi num\u0103rul total de elemente cu valoare 0 din tabloul bidimensional.  a)  528  b)  600  c)  688  d)  769  e)  777  f)  Nu exist\u0103 un tablou bidimensional cu aceste propriet\u0103\u021bi    10. Tabloul unidimensional A con\u0163ine, \u00eencep\u00e2nd cu indicele 1,  elementele: (1, 2, 2,  212, 12212, 21212212, 1221221212212,...). Stabili\u021bi num\u0103rul de cifre de  2 con\u021binute de cel de-al 15-lea element al tabloului?  a)  377  b)  391  c)  400  d)  520  e)  588  f)  610    11. Matricea de adiacen\u0163\u0103 asociat\u0103 unui graf neorientat cu 17 noduri are 40 elemente nenule.  Num\u0103rul maxim de componente conexe \u00een graf este:  a)  9  b)  10  c)  11  d)  12  e)  13  f)  14    12. Fie un num\u0103r a care apar\u021bine intervalului [410,681]. Pentru a verifica dac\u0103 a este  prim, num\u0103rul minim de numere care trebuie testate pentru a fi divizori ai lui a este:  a)  10  b)  13  c)  25  d)  205  e)  339  f)  640    13. Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate permut\u0103rile mul\u021bimii {1, 2, 3, 4,  5} \u00een ordine lexicografic\u0103. Primele cinci solu\u021bii generate sunt 12345, 12354,  12435, 12453, 12534. Spunem c\u0103 o permutare p a mul\u021bimii {1, 2, 3, 4, 5}  are num\u0103rul de ordine k, dac\u0103 este a k-a permutare generat\u0103 astfel. Permutarea 12354  are num\u0103rul de ordine 2, iar permutarea 12534 are num\u0103rul de ordine 5. Preciza\u021bi  num\u0103rul de ordine al permut\u0103rii 51423.  a)  98  b)  99  c)  100  d)  101  e)  110  f)  111    14. Variabilele m \u0219i n re\u021bin valori numere natural nenule. Preciza\u021bi ce execut\u0103 secven\u021ba de cod  de mai jos, unde c, d \u0219i x sunt variabile \u00eentregi.  Limbajul C++/C  c=m; d=n;  while (c!=d)  if (c>d) c=c-d;    else d=d-c;  x=m*n/c;  cout<<x;| printf(\"%d\",x);  Limbajul Pascal  c:=m; d:=n;  while c<>d do  if c>d then  c:=c-d    else d:=d-c;  x:=m*n div c;  write(x);  A. Calculeaz\u0103 \u0219i afi\u0219eaz\u0103 cel mai mic multiplu comun al numerelor natuale nenule m  \u0219i n  B. Dac\u0103 m=9 si n=12, atunci afi\u0219eaz\u0103 x=36  C. Dac\u0103 m=11 si n=6, atunci afi\u0219eaz\u0103 x=17  a)  A  b)  A,B  c)  A,B,C  d)  B  e)  B,C  f)     C", "sentences": ["215    Linia j con\u021bine de dou\u0103 ori mai multe valori nenule dec\u00e2t linia j-1, 2\u2264j\u22648;  Ultima linie con\u021bine un singur element cu valoare 0.", " Determina\u021bi num\u0103rul total de elemente cu valoare 0 din tabloul bidimensional.", " a)  528  b)  600  c)  688  d)  769  e)  777  f)  Nu exist\u0103 un tablou bidimensional cu aceste propriet\u0103\u021bi    10.", "Tabloul unidimensional A con\u0163ine, \u00eencep\u00e2nd cu indicele 1,  elementele: (1, 2, 2,  212, 12212, 21212212, 1221221212212,...).", "Stabili\u021bi num\u0103rul de cifre de  2 con\u021binute de cel de-al 15-lea element al tabloului?", " a)  377  b)  391  c)  400  d)  520  e)  588  f)  610    11.", "Matricea de adiacen\u0163\u0103 asociat\u0103 unui graf neorientat cu 17 noduri are 40 elemente nenule.", " Num\u0103rul maxim de componente conexe \u00een graf este:  a)  9  b)  10  c)  11  d)  12  e)  13  f)  14    12.", "Fie un num\u0103r a care apar\u021bine intervalului [410,681].", "Pentru a verifica dac\u0103 a este  prim, num\u0103rul minim de numere care trebuie testate pentru a fi divizori ai lui a este:  a)  10  b)  13  c)  25  d)  205  e)  339  f)  640    13.", "Utiliz\u00e2nd metoda backtracking se genereaz\u0103 toate permut\u0103rile mul\u021bimii {1, 2, 3, 4,  5} \u00een ordine lexicografic\u0103.", "Primele cinci solu\u021bii generate sunt 12345, 12354,  12435, 12453, 12534.", "Spunem c\u0103 o permutare p a mul\u021bimii {1, 2, 3, 4, 5}  are num\u0103rul de ordine k, dac\u0103 este a k-a permutare generat\u0103 astfel.", "Permutarea 12354  are num\u0103rul de ordine 2, iar permutarea 12534 are num\u0103rul de ordine 5.", "Preciza\u021bi  num\u0103rul de ordine al permut\u0103rii 51423.", " a)  98  b)  99  c)  100  d)  101  e)  110  f)  111    14.", "Variabilele m \u0219i n re\u021bin valori numere natural nenule.", "Preciza\u021bi ce execut\u0103 secven\u021ba de cod  de mai jos, unde c, d \u0219i x sunt variabile \u00eentregi.", " Limbajul C++/C  c=m; d=n;  while (c!=d)  if (c>d) c=c-d;    else d=d-c;  x=m*n/c;  cout<<x;| printf(\"%d\",x);  Limbajul Pascal  c:=m; d:=n;  while c<>d do  if c>d then  c:=c-d    else d:=d-c;  x:=m*n div c;  write(x);  A. Calculeaz\u0103 \u0219i afi\u0219eaz\u0103 cel mai mic multiplu comun al numerelor natuale nenule m  \u0219i n  B. Dac\u0103 m=9 si n=12, atunci afi\u0219eaz\u0103 x=36  C. Dac\u0103 m=11 si n=6, atunci afi\u0219eaz\u0103 x=17  a)  A  b)  A,B  c)  A,B,C  d)  B  e)  B,C  f)     C"], "page_sentence_count_spacy": 19}, {"page_number": 216, "page_char_count": 231, "page_word_count": 64, "page_sentence_count_raw": 3, "page_token_count": 57.75, "text": "216      15. Determina\u021bi  num\u0103rul  de  grafuri  neorientate  cu  mul\u0163imea  nodurilor  {1,2,3,4,5,6,7,8} \u00een care, at\u00e2t nodurile 2 \u0219i 3, c\u00e2t \u0219i nodurile 2 \u0219i 4 sunt  neadiacente.  a)  44  b)  410  c)  223  d)  224-2  e)  225  f)  413", "sentences": ["216      15.", "Determina\u021bi  num\u0103rul  de  grafuri  neorientate  cu  mul\u0163imea  nodurilor  {1,2,3,4,5,6,7,8} \u00een care, at\u00e2t nodurile 2 \u0219i 3, c\u00e2t \u0219i nodurile 2 \u0219i 4 sunt  neadiacente.", " a)  44  b)  410  c)  223  d)  224-2  e)  225  f)  413"], "page_sentence_count_spacy": 3}, {"page_number": 217, "page_char_count": 1922, "page_word_count": 493, "page_sentence_count_raw": 10, "page_token_count": 480.5, "text": "217    Varianta 41  1. Numim graf complementar al unui graf neorientat G graful neorientat G1 cu aceea\u015fi  mul\u0163ime a nodurilor ca \u015fi G \u015fi cu proprietatea c\u0103 dou\u0103 noduri sunt adiacente \u00een G1 dac\u0103 \u015fi  numai dac\u0103 nu sunt adiacente \u00een G. Dac\u0103 G are n noduri \u015fi m muchii, c\u00e2te muchii are G1?  a)exact n(n-1)/2\u2013m  b) exact n-m  c) exact (n-1)/2  d)minimum n(n-1)/2\u2013m  e) minimum n-m f) maximum n(n-1)/2\u2013m    2. Cu ce expresie trebuie completat\u0103 secven\u021ba lips\u0103 (marcat\u0103 prin\u2026) din func\u021bia urm\u0103toare  pentru ca f(x,2) s\u0103 aib\u0103 ca rezultat suma exponen\u021bilor factorilor primi ce intr\u0103 \u00een  descompunerea lui x?  Limbajul C++/C  int f(int x, int d)  {    if(\u2026) return 1;   if(x%d==0) return 1+f(x/d,  d);  return f(x, d+1);  }  Limbajul Pascal  function f(x,  d:integer):integer;  begin   if \u2026  then f:=1   else   if x mod d=0      then f:= 1+f(x div d, d)   else f:=f(x, d+1);    end;  a) x==1  (Limbajul C++/C)  a) x=1   (Limbajul Pascal )  b) x==0  (Limbajul C++/C)  b) x=0   (Limbajul Pascal)  c) x<d/2  d) x<d  e) x>d   f) x<=d    3. Instruc\u021biunea care afi\u015feaz\u0103 cea mai din st\u00e2nga pozi\u0163ie unde se afl\u0103 valoarea \u00eentreag\u0103 x, sau  afi\u015feaz\u0103 \u20131, dac\u0103 x nu apare \u00een tabloul unidimensional a cu n elemente numere \u00eentregi,  este:  Limbajul C++/C  1.  for(i=0;i<n&&a[i]==x;i++)      if (i<n) cout<<i; |               printf(\"%d\",i);        else cout<<-1; |              printf(\"-1\");  2.  for(i=0;i<n&&a[i]!=x;i++);     if (i==n) cout<<i;                |printf(\"%d\",i);      else cout<<-1; |            printf(\"-1\");  3.  for(i=0;i<n&&a[i]==x;i++)    if (i==n) cout<<i; |                printf(\"%d\",i);    else cout<<-1; |  Limbajul Pascal   1.i:=0;  while (i<n)and(a[i]=x) do  begin    if(i<n) then write(i)        else write(-1);       i:=i+1; end;  2. i:=0;  while (i<n) and (a[i]<>x) do    i:=i+1;  if i=n then write(i)      else write(-1);      3. i:=0;  while (i<n) and (a[i]=x) do  begin    if  i=n then write(i)    else write(-1) ;", "sentences": ["217    Varianta 41  1.", "Numim graf complementar al unui graf neorientat G graful neorientat G1 cu aceea\u015fi  mul\u0163ime a nodurilor ca \u015fi G \u015fi cu proprietatea c\u0103 dou\u0103 noduri sunt adiacente \u00een G1 dac\u0103 \u015fi  numai dac\u0103 nu sunt adiacente \u00een G. Dac\u0103 G are n noduri \u015fi m muchii, c\u00e2te muchii are G1?", " a)exact n(n-1)/2\u2013m  b) exact n-m  c) exact (n-1)/2  d)minimum n(n-1)/2\u2013m  e) minimum n-m f) maximum n(n-1)/2\u2013m    2.", "Cu ce expresie trebuie completat\u0103 secven\u021ba lips\u0103 (marcat\u0103 prin\u2026) din func\u021bia urm\u0103toare  pentru ca f(x,2) s\u0103 aib\u0103 ca rezultat suma exponen\u021bilor factorilor primi ce intr\u0103 \u00een  descompunerea lui x?", " Limbajul C++/C  int f(int x, int d)  {    if(\u2026) return 1;   if(x%d==0) return 1+f(x/d,  d);  return f(x, d+1);  }  Limbajul Pascal  function f(x,  d:integer):integer;  begin   if \u2026  then f:=1   else   if x mod d=0      then f:= 1+f(x div d, d)   else f:=f(x, d+1);    end;  a) x==1  (Limbajul C++/C)  a) x=1   (Limbajul Pascal )  b) x==0  (Limbajul C++/C)  b) x=0   (Limbajul Pascal)  c) x<d/2  d) x<d  e) x>d   f) x<=d    3.", "Instruc\u021biunea care afi\u015feaz\u0103 cea mai din st\u00e2nga pozi\u0163ie unde se afl\u0103 valoarea \u00eentreag\u0103 x, sau  afi\u015feaz\u0103 \u20131, dac\u0103 x nu apare \u00een tabloul unidimensional a cu n elemente numere \u00eentregi,  este:  Limbajul C++/C  1.", " for(i=0;i<n&&a[i]==x;i++)      if (i<n) cout<<i; |               printf(\"%d\",i);        else cout<<-1; |              printf(\"-1\");  2.", " for(i=0;i<n&&a[i]!=x;i++);     if (i==n) cout<<i;                |printf(\"%d\",i);      else cout<<-1; |            printf(\"-1\");  3.", " for(i=0;i<n&&a[i]==x;i++)    if (i==n) cout<<i; |                printf(\"%d\",i);    else cout<<-1; |  Limbajul Pascal   1.i:=0;  while (i<n)and(a[i]=x) do  begin    if(i<n) then write(i)        else write(-1);       i:=i+1; end;  2.", "i:=0;  while (i<n) and (a[i]<>x) do    i:=i+1;  if i=n then write(i)      else write(-1);      3.", "i:=0;  while (i<n) and (a[i]=x) do  begin    if  i=n then write(i)    else write(-1) ;"], "page_sentence_count_spacy": 11}, {"page_number": 218, "page_char_count": 1448, "page_word_count": 404, "page_sentence_count_raw": 11, "page_token_count": 362.0, "text": "218           printf(\"-1\");    4.  for(i=0;i<n&&a[i]!=x;i++);      if (i<n) cout<<i; |                   printf(\"%d\",i);        else cout<<-1; |             printf(\"-1\");  5.  for(i=0;i==n&&a[i]!=x;i++);       if (i==n) cout<<i; |  printf(\"%d\",i);  else cout<<-1; |   printf(\"-1\");    6. for (i=0;i<n;i++)    if (a[i]==x)cout<<i;|                printf(\"%d\",i);    else cout<<-1; |printf(\"- 1\");    i:=i+1; end;    4. i:=0;    while (i<n) and (a[i]<>x)  do  i:=i+1;    if  i < n then write( i)         else write(-1);      5. i:=0;  while (i=n) and (a[i]<>x) do    i:=i+1;  if  i=n then write(i)   else write(-1) ;      6. for i: = 0 to n-1 do    if a[i] = x then write(i)  else write(-1) ;    a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    4. Apelul F(7) returneaz\u0103:    Limbajul C++/C  int F(int N)  { if (N==0) return 1;   return F(N-1) + F(N-1);  }      Limbajul Pascal   function F(N:integer):integer;  begin   if  N=0 then  F:= 1        else F:= F(N-1) + F(N-1);   end;  a) 60 b) 64  c) 120  d) 128  e) 240  f) 256    5. Se consider\u0103 un \u0219ir de caractere s. Stabili\u021bi rezultatul afi\u0219\u0103rii pe ecran, \u00een urma execut\u0103rii  urm\u0103toarei secven\u021be de program:  Limbajul C++/C  char  s[15]=\"ABCDEFG\",*p,x[15];  p=s;  p+=4;  strcpy(x,s+2);  strcat(x,p);  cout<<x; | printf(\"%s\",x);  Limbajul Pascal   var s,p,x:string;   begin  s:= 'ABCDEFG';p:=s;  p:=copy(p,5,length(s));  x:=copy(s,3,length(s));  x:=x+p;  write(x);  end.  a)  ABCEFG  b)  BCDEFGDEFG  c)  CDEFGEFG", "sentences": ["218           printf(\"-1\");    4.", " for(i=0;i<n&&a[i]!=x;i++);      if (i<n) cout<<i; |                   printf(\"%d\",i);        else cout<<-1; |             printf(\"-1\");  5.", " for(i=0;i==n&&a[i]!=x;i++);       if (i==n) cout<<i; |  printf(\"%d\",i);  else cout<<-1; |   printf(\"-1\");    6.", "for (i=0;i<n;i++)    if (a[i]==x)cout<<i;|                printf(\"%d\",i);    else cout<<-1; |printf(\"- 1\");    i:=i+1; end;    4.", "i:=0;    while (i<n) and (a[i]<>x)  do  i:=i+1;    if  i < n then write( i)         else write(-1);      5.", "i:=0;  while (i=n) and (a[i]<>x) do    i:=i+1;  if  i=n then write(i)   else write(-1) ;      6.", "for i: = 0 to n-1 do    if a[i] = x then write(i)  else write(-1) ;    a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    4.", "Apelul F(7) returneaz\u0103:    Limbajul C++/C  int F(int N)  { if (N==0) return 1;   return F(N-1) + F(N-1);  }      Limbajul Pascal   function F(N:integer):integer;  begin   if  N=0 then  F:= 1        else F:= F(N-1) + F(N-1);   end;  a) 60 b) 64  c) 120  d) 128  e) 240  f) 256    5.", "Se consider\u0103 un \u0219ir de caractere s. Stabili\u021bi rezultatul afi\u0219\u0103rii pe ecran, \u00een urma execut\u0103rii  urm\u0103toarei secven\u021be de program:  Limbajul C++/C  char  s[15]=\"ABCDEFG\",*p,x[15];  p=s;  p+=4;  strcpy(x,s+2);  strcat(x,p);  cout<<x; | printf(\"%s\",x);  Limbajul Pascal   var s,p,x:string;   begin  s:= 'ABCDEFG';p:=s;  p:=copy(p,5,length(s));  x:=copy(s,3,length(s));  x:=x+p;  write(x);  end.", " a)  ABCEFG  b)  BCDEFGDEFG  c)  CDEFGEFG"], "page_sentence_count_spacy": 10}, {"page_number": 219, "page_char_count": 1817, "page_word_count": 426, "page_sentence_count_raw": 8, "page_token_count": 454.25, "text": "219    d)  CDEFGABCD  e)  DEFGDEFG  f)  EFGEFG      6. Preciza\u021bi care dintre urm\u0103toarele expresii are valoarea 1|TRUE dac\u0103 \u0219i numai dac\u0103  num\u0103rul natural n este divizibil cu 3 \u0219i are ultima cifr\u0103 4 sau 6.  Limbajul C++/C  A.n/3==0&&(n%10==4||n%10==6)    B.n%3==0 &&(n%10==4 ||  n%10==6)    C.(n%3==0 && n%10==4)||  (n%3==0 && n%10==6)    D.(n%3==0 && n%10==4) ||  n%10==6  Limbajul Pascal   A.(n DIV 3=0)AND((n MOD  10=4) OR (n MOD 10=6))  B.(n MOD 3=0)AND((n MOD  10=4) OR (n MOD 10=6))    C.((n MOD 3=0)AND(n MOD  10=4)) OR((n MOD 3=0)AND(n  MOD 10=6))  D.((n MOD 3=0)AND(n MOD  10=4)) OR (n MOD 10=6)    a)  A  b) B  c) A,B   d) B,C  e) B,D  f) D    7. Se genereaz\u0103 \u00een ordine lexicografic\u0103 toate tripletele vocal\u0103-consoan\u0103-vocal\u0103 formate cu  literele mari A,B,C,D,E: ABA,ABE, ACA, ACE, ADA, ADE, EBA, EBE,  ECA, ECE, EDA, EDE. Dac\u0103 se genereaz\u0103, folosind aceea\u0219i metod\u0103 \u0219i acelea\u0219i litere,  toate tripletele consoan\u0103-vocal\u0103-consoan\u0103, stabili\u021bi care dintre urm\u0103toarele variante este o  secven\u021b\u0103 de triplete generate unul imediat dup\u0103 cel\u0103lalt:  a)  ACE ADA ADE  d) CEA CEB CEC  b) BEC BED CAB  e) DAC DAB DEB           c)  BEC CEC DEC  f)  DAD DAC DAB      8. Se consider\u0103 numerele naturale m \u0219i n (0 \u2264 m \u2264 10, 0 \u2264 n \u2264 10) \u0219i subprogramul  Ack(m,n), care calculeaz\u0103 valoarea func\u021biei Ackermann pentru valorile m \u0219i n.  Preciza\u021bi num\u0103rul de apeluri recursive ale subprogramului Ack pentru valorile m=1 \u0219i  n=2, Ack(1,2).  Limbajul C++/C   int  Ack(int m, int n)  {if(m==0)    return n+1;   else   if(m>0 && n==0)        return Ack(m-1,1);      else  return Ack(m-1,Ack(m,n- 1));  }    Limbajul Pascal   Function  Ack(m,n:integer):integer;  begin   if m=0 then      Ack:=n+1   else     if (m>0)AND(n=0)then        Ack:=Ack(m-1,1)     else        Ack:=Ack(m-1,Ack(m,n-1));  end;   a) de 5 ori  b) de 6 ori  c) de 7 ori", "sentences": ["219    d)  CDEFGABCD  e)  DEFGDEFG  f)  EFGEFG      6.", "Preciza\u021bi care dintre urm\u0103toarele expresii are valoarea 1|TRUE dac\u0103 \u0219i numai dac\u0103  num\u0103rul natural n este divizibil cu 3 \u0219i are ultima cifr\u0103 4 sau 6.", " Limbajul C++/C  A.n/3==0&&(n%10==4||n%10==6)    B.n%3==0 &&(n%10==4 ||  n%10==6)    C.(n%3==0 && n%10==4)||  (n%3==0 && n%10==6)    D.(n%3==0 && n%10==4) ||  n%10==6  Limbajul Pascal   A.(n DIV 3=0)AND((n MOD  10=4) OR (n MOD 10=6))  B.(n MOD 3=0)AND((n MOD  10=4) OR (n MOD 10=6))    C.((n MOD 3=0)AND(n MOD  10=4)) OR((n MOD 3=0)AND(n  MOD 10=6))  D.((n MOD 3=0)AND(n MOD  10=4)) OR (n MOD 10=6)    a)  A  b) B  c) A,B   d) B,C  e) B,D  f) D    7.", "Se genereaz\u0103 \u00een ordine lexicografic\u0103 toate tripletele vocal\u0103-consoan\u0103-vocal\u0103 formate cu  literele mari A,B,C,D,E: ABA,ABE, ACA, ACE, ADA, ADE, EBA, EBE,  ECA, ECE, EDA, EDE.", "Dac\u0103 se genereaz\u0103, folosind aceea\u0219i metod\u0103 \u0219i acelea\u0219i litere,  toate tripletele consoan\u0103-vocal\u0103-consoan\u0103, stabili\u021bi care dintre urm\u0103toarele variante este o  secven\u021b\u0103 de triplete generate unul imediat dup\u0103 cel\u0103lalt:  a)  ACE ADA ADE  d) CEA CEB CEC  b) BEC BED CAB  e) DAC DAB DEB           c)  BEC CEC DEC  f)  DAD DAC DAB      8.", "Se consider\u0103 numerele naturale m \u0219i n (0 \u2264 m \u2264 10, 0 \u2264 n \u2264 10) \u0219i subprogramul  Ack(m,n), care calculeaz\u0103 valoarea func\u021biei Ackermann pentru valorile m \u0219i n.  Preciza\u021bi num\u0103rul de apeluri recursive ale subprogramului Ack pentru valorile m=1 \u0219i  n=2, Ack(1,2).", " Limbajul C++/C   int  Ack(int m, int n)  {if(m==0)    return n+1;   else   if(m>0 && n==0)        return Ack(m-1,1);      else  return Ack(m-1,Ack(m,n- 1));  }    Limbajul Pascal   Function  Ack(m,n:integer):integer;  begin   if m=0 then      Ack:=n+1   else     if (m>0)AND(n=0)then        Ack:=Ack(m-1,1)     else        Ack:=Ack(m-1,Ack(m,n-1));  end;   a) de 5 ori  b) de 6 ori  c) de 7 ori"], "page_sentence_count_spacy": 7}, {"page_number": 220, "page_char_count": 1921, "page_word_count": 470, "page_sentence_count_raw": 9, "page_token_count": 480.25, "text": "220    d) de 8 ori  e) de 9 ori  f) de 10 ori     9. Un arbore cu r\u0103d\u0103cin\u0103 are 359 de noduri numerotate de la 1 la 359. Dac\u0103 vectorul de ta\u021bi  al acestui arbore (vector notat cu t) are proprietatea c\u0103 t[i]= [ \ud835\udc8a \ud835\udfd0], pentru orice i de la  1 la 359, unde [x] reprezint\u0103 partea \u00eentreag\u0103 a num\u0103rului x, atunci num\u0103rul de noduri  care au exact un descendent direct \u00een acest arbore este:     a) 178  d) 3  b) 9  e) 1  c)4  f)0         10. Fie A un tablou unidimensional cu n elemente \u0219i subprogramul Swap care realizeaz\u0103  interschimbarea valorilor pe care le prime\u0219te. Atunci urm\u0103toarea secven\u021b\u0103 de cod sorteaz\u0103  descresc\u0103tor tabloul A. C\u00e2te apeluri ale subrogramului Swap vor fi f\u0103cute dac\u0103 ini\u021bial  A[i]=i pentru i=1,2, \u2026, n?  Limbajul C++/C  for (j=1;j<=n\u20131;j++)  for (k=1;k<=n\u2013j;k++)      if (A[k]<A[k+1])         Swap(A[k],A[k+1]);                Limbajul Pascal  for  j:=1 to  n\u20131 do    for  k:=1 to  n\u2013j do       if  A[k]<A[k+1] then         Swap(A[k],A[k+1]);  a) n/2  d) n(n-1)  b) n  e) n(n-1)/2          c) n-1   f) n*n    11. Care dintre urm\u0103toarele grafuri neorientate este un graf eulerian, dar nu este  hamiltonian? Grafurile sunt precizate prin n num\u0103rul de noduri \u0219i mul\u021bimea U a  muchiilor.  a)n=3,U={[1,2],[1,3],[2,3]}  b)n=4,U={[1,2],[1,3],[2,3],[1 ,4], [2,4],[3,4]}  c)n=5,U={[1,3],[1,4],[3,4],  [2,4],[4,5],[2,5]}  d) N=6,U={[1,2],[2,3],[3,4],  [5,4],[6,5],[2,6]}  e) N=6,U={[1,2],[2,3],[3,4],  [5,4],[6,5],[1,6]}  f) nici unul din grafurile  anterioare    12. Care este instruc\u021biunea echivalent\u0103 cu instruc\u021biunea de mai jos care s\u0103 con\u021bin\u0103 o singur\u0103  instruc\u021biune if, unde x, y \u0219i z sunt variabile care re\u021bin valori \u00eentregi:  Limbajul C++/C                        Limbajul Pascal    if(x>y)     if(y>z)        if(z>x) s=x+y+z;           else p=x*y*z;  if x>y then     if y>z then        if z>x then s:=x+y+z           else p:=x*y*z;  Limbajul C++/C  a) if(x>y && y>z)  b) if(x>y && y>z)  c) if(x>y || y>z)", "sentences": ["220    d) de 8 ori  e) de 9 ori  f) de 10 ori     9.", "Un arbore cu r\u0103d\u0103cin\u0103 are 359 de noduri numerotate de la 1 la 359.", "Dac\u0103 vectorul de ta\u021bi  al acestui arbore (vector notat cu t) are proprietatea c\u0103 t[i]= [ \ud835\udc8a \ud835\udfd0], pentru orice i de la  1 la 359, unde [x] reprezint\u0103 partea \u00eentreag\u0103 a num\u0103rului x, atunci num\u0103rul de noduri  care au exact un descendent direct \u00een acest arbore este:     a) 178  d) 3  b) 9  e) 1  c)4  f)0         10.", "Fie A un tablou unidimensional cu n elemente \u0219i subprogramul Swap care realizeaz\u0103  interschimbarea valorilor pe care le prime\u0219te.", "Atunci urm\u0103toarea secven\u021b\u0103 de cod sorteaz\u0103  descresc\u0103tor tabloul A. C\u00e2te apeluri ale subrogramului Swap vor fi f\u0103cute dac\u0103 ini\u021bial  A[i]=i pentru i=1,2, \u2026, n?", " Limbajul C++/C  for (j=1;j<=n\u20131;j++)  for (k=1;k<=n\u2013j;k++)      if (A[k]<A[k+1])         Swap(A[k],A[k+1]);                Limbajul Pascal  for  j:=1 to  n\u20131 do    for  k:=1 to  n\u2013j do       if  A[k]<A[k+1] then         Swap(A[k],A[k+1]);  a) n/2  d) n(n-1)  b) n  e) n(n-1)/2          c) n-1   f) n*n    11.", "Care dintre urm\u0103toarele grafuri neorientate este un graf eulerian, dar nu este  hamiltonian?", "Grafurile sunt precizate prin n num\u0103rul de noduri \u0219i mul\u021bimea U a  muchiilor.", " a)n=3,U={[1,2],[1,3],[2,3]}  b)n=4,U={[1,2],[1,3],[2,3],[1 ,4], [2,4],[3,4]}  c)n=5,U={[1,3],[1,4],[3,4],  [2,4],[4,5],[2,5]}  d) N=6,U={[1,2],[2,3],[3,4],  [5,4],[6,5],[2,6]}  e) N=6,U={[1,2],[2,3],[3,4],  [5,4],[6,5],[1,6]}  f) nici unul din grafurile  anterioare    12.", "Care este instruc\u021biunea echivalent\u0103 cu instruc\u021biunea de mai jos care s\u0103 con\u021bin\u0103 o singur\u0103  instruc\u021biune if, unde x, y \u0219i z sunt variabile care re\u021bin valori \u00eentregi:  Limbajul C++/C                        Limbajul Pascal    if(x>y)     if(y>z)        if(z>x) s=x+y+z;           else p=x*y*z;  if x>y then     if y>z then        if z>x then s:=x+y+z           else p:=x*y*z;  Limbajul C++/C  a) if(x>y && y>z)  b) if(x>y && y>z)  c) if(x>y || y>z)"], "page_sentence_count_spacy": 10}, {"page_number": 221, "page_char_count": 1690, "page_word_count": 471, "page_sentence_count_raw": 8, "page_token_count": 422.5, "text": "221          s=x+y+z;     else p=x*y*z;        p=x*y*z;          s=x+y+z;    d) if(x>y && y>z)         s=x+y+z;    e) if(!(x>y)&& y>z)         s=x+y+z;     else p=x*y*z;  f)if(!(x>y&&y>z))         s=x+y+z;    else p=x*y*z;  Limbajul Pascal  a)  if (x>y)AND (y>z)    then s:=x+y+z      else  p:=x*y*z;  b)   if (x>y)AND(y>z)       then p:=x*y*z;  c)   if (x>y)OR(y>z)     then   s:=x+y+z;  d)   if (x>y)AND(y>z)      then  s:=x+y+z;  e)  if not(x>y)AND (y>z)    then s:=x+y+z     else p:=x*y*z;    f)   if not((x>y)AND  (y>z))    then s:=x+y+z     else p:=x*y*z;    13. Dac\u0103 se dore\u015fte c\u0103utarea unui num\u0103r \u00eentr-un \u015fir ordonat de 1000 de elemente, folosind  algoritmul c\u0103ut\u0103rii binare, atunci num\u0103rul maxim al pa\u015filor efectua\u0163i (compara\u021bii) va fi:  a) cuprins \u00eentre 1  \u0219i 6  b) cuprins \u00eentre 7 \u0219i  12  c) cuprins \u00eentre  13 \u0219i 18  d) Cuprins \u00eentre  450 \u015fi 500        e) exact 500  f) cuprins \u00eentre  999 \u0219i 1001    14. Preciza\u021bi care dintre urm\u0103toarele subprograme calculeaz\u0103 corect cifra de control a unui  num\u0103r natural asociat x (Cifra de control a unui num\u0103r natural se determin\u0103 calcul\u00e2nd  suma cifrelor num\u0103rului, apoi suma cifrelor sumei \u0219i a\u0219a mai departe p\u00e2n\u0103 c\u00e2nd suma  ob\u021binut\u0103 reprezint\u0103 un num\u0103r cu o singur\u0103 cifr\u0103).  Limbajul C++/C  A.    int Control(int x)    {int s;     if (x>9){      s=x%10+Control(x/10);      if(s<10)return s;        else          return Control(s);       }  else return x;  }          B.    int Control(int x)  Limbajul Pascal  A.   function    Control(x:integer): integer;  var s:integer;  begin  if x>9 then  begin  s:=x mod 10+Control(x div 10);  if s<10  then Control:=s  else   Control:=Control(s);       end   else Control:=x;  end;      B.  function", "sentences": ["221          s=x+y+z;     else p=x*y*z;        p=x*y*z;          s=x+y+z;    d) if(x>y && y>z)         s=x+y+z;    e) if(!(x>y)&& y>z)         s=x+y+z;     else p=x*y*z;  f)if(!(x>y&&y>z))         s=x+y+z;    else p=x*y*z;  Limbajul Pascal  a)  if (x>y)AND (y>z)    then s:=x+y+z      else  p:=x*y*z;  b)   if (x>y)AND(y>z)       then p:=x*y*z;  c)   if (x>y)OR(y>z)     then   s:=x+y+z;  d)   if (x>y)AND(y>z)      then  s:=x+y+z;  e)  if not(x>y)AND (y>z)    then s:=x+y+z     else p:=x*y*z;    f)   if not((x>y)AND  (y>z))    then s:=x+y+z     else p:=x*y*z;    13.", "Dac\u0103 se dore\u015fte c\u0103utarea unui num\u0103r \u00eentr-un \u015fir ordonat de 1000 de elemente, folosind  algoritmul c\u0103ut\u0103rii binare, atunci num\u0103rul maxim al pa\u015filor efectua\u0163i (compara\u021bii) va fi:  a) cuprins \u00eentre 1  \u0219i 6  b) cuprins \u00eentre 7 \u0219i  12  c) cuprins \u00eentre  13 \u0219i 18  d) Cuprins \u00eentre  450 \u015fi 500        e) exact 500  f) cuprins \u00eentre  999 \u0219i 1001    14.", "Preciza\u021bi care dintre urm\u0103toarele subprograme calculeaz\u0103 corect cifra de control a unui  num\u0103r natural asociat x (Cifra de control a unui num\u0103r natural se determin\u0103 calcul\u00e2nd  suma cifrelor num\u0103rului, apoi suma cifrelor sumei \u0219i a\u0219a mai departe p\u00e2n\u0103 c\u00e2nd suma  ob\u021binut\u0103 reprezint\u0103 un num\u0103r cu o singur\u0103 cifr\u0103).", " Limbajul C++/C  A.    int Control(int x)    {int s;     if (x>9){      s=x%10+Control(x/10);      if(s<10)return s;        else          return Control(s);       }  else return x;  }          B.    int Control(int x)  Limbajul Pascal  A.   function    Control(x:integer): integer;  var s:integer;  begin  if x>9 then  begin  s:=x mod 10+Control(x div 10);  if s<10  then Control:=s  else   Control:=Control(s);       end   else Control:=x;  end;      B.  function"], "page_sentence_count_spacy": 4}, {"page_number": 222, "page_char_count": 1071, "page_word_count": 342, "page_sentence_count_raw": 5, "page_token_count": 267.75, "text": "222      {int s;      if (x>9){       s=x%10+Control(x/10);       if(s < 10)        return s;       else   return Control(s);       }  return s;  }          C.    int Control(int x)    {int s;     if (x >10)     s=x%10+Control(x/10);             return x;      }  Control(x:integer):integer;    var s:integer;    begin     if x>9 then      begin        s:=x mod 10 +            Control(x div 10);  if s<10  then   Control:=s  else      Control:=Control(s);      end;     Control:=s;    end;    C.  function  Control(x:integer):integer;  var s:integer;     begin      if x>10 then s:=x mod 10  +Control(x div 10);  Control:=x     end;  a) A  d) B,C  b) A,B  e) C  c) B  f) niciunul     15. Fie G un graf  neorientat conex, cu mul\u021bimea de v\u00e2rfuri V, av\u00e2nd propriet\u0103\u021bile: (1) fiecare  v\u00e2rf are cel mult 3 vecini \u0219i (2) exist\u0103 un v\u00e2rf u\u03f5V astfel \u00eenc\u00e2t pentru orice v\u03f5V avem  d(u;v)\u22645, unde d(u;v) reprezint\u0103 lungimea celui mai scurt drum dintre v\u00e2rfurile u  \u0219i v (ca num\u0103r de muchii). Care este num\u0103rul maxim de v\u00e2rfuri din G?    a)  46  d) 100  b)  64  e) 150  c) 94  f) 194", "sentences": ["222      {int s;      if (x>9){       s=x%10+Control(x/10);       if(s < 10)        return s;       else   return Control(s);       }  return s;  }          C.    int Control(int x)    {int s;     if (x >10)     s=x%10+Control(x/10);             return x;      }  Control(x:integer):integer;    var s:integer;    begin     if x>9 then      begin        s:=x mod 10 +            Control(x div 10);  if s<10  then   Control:=s  else      Control:=Control(s);      end;     Control:=s;    end;    C.  function  Control(x:integer):integer;  var s:integer;     begin      if x>10 then s:=x mod 10  +Control(x div 10);  Control:=x     end;  a) A  d) B,C  b) A,B  e) C  c) B  f) niciunul     15.", "Fie G un graf  neorientat conex, cu mul\u021bimea de v\u00e2rfuri V, av\u00e2nd propriet\u0103\u021bile: (1) fiecare  v\u00e2rf are cel mult 3 vecini \u0219i (2) exist\u0103 un v\u00e2rf u\u03f5V astfel \u00eenc\u00e2t pentru orice v\u03f5V avem  d(u;v)\u22645, unde d(u;v) reprezint\u0103 lungimea celui mai scurt drum dintre v\u00e2rfurile u  \u0219i v (ca num\u0103r de muchii).", "Care este num\u0103rul maxim de v\u00e2rfuri din G?", "   a)  46  d) 100  b)  64  e) 150  c) 94  f) 194"], "page_sentence_count_spacy": 4}, {"page_number": 223, "page_char_count": 1512, "page_word_count": 362, "page_sentence_count_raw": 5, "page_token_count": 378.0, "text": "223    Varianta 42  1. Preciza\u021bi valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program:  Limbajul C++/C  int v[8] =  {2,4,1,3,11,5,1,3};  int ex(int n, int m)  {   if (n==m)    return v[n]%2;  else    return ex(n, (n + m) /  2) + ex((n + m)/2 + 1, m);  }  int main()  {cout<< ex(0,7); |  printf(\"%d\",ex(0,7));   return 0;}  Limbajul Pascal  var v:array[0..7] of integer  =(2,4,1,3,11,5,1,3);  function   ex(n, m:integer):integer;  begin  if n=m   then ex:=v[n] mod 2   else     ex:= ex(n, (n+m) div 2) +       ex((n + m) div 2 + 1, m);  end;  begin    write(ex(0,7));  end.  a) 2  b) 3  c) 5  d) 6  e)7  f) 9    2. Se consider\u0103 un \u0219ir de caractere a care con\u021bine cel pu\u021bin o majuscul\u0103. Care dintre cele trei  secven\u021be S1), S2)\u0219i S3) de mai jos afi\u0219eaz\u0103 prima liter\u0103 mare din \u0219ir?  Limbajul C++/C  //S1  i = 0;  while (a[i]&&(a[i]<'A'||a[i]  >'Z'))    i++;  cout<< a[i];   | printf(\"%c\",a[i]);    //S2)  i=0;  do { i++;} while (a[i] &&  !(a[i]>='A'&& a[i]<= 'Z'));  cout<<a[i];   | printf(\"%c\",a[i]);    //S3)  for(i=0;a[i]&& a[i]>='A'&&  a[i]<='Z';i++)  cout<<a[i];   | printf(\"%c\",a[i]);    Limbajul Pascal  //S1  i:= 1;  while (i<=length(a)) and ((a[i]  <'A') or (a[i] >'Z')) do i:=i+1;  write(a[i]);      //S2)  i:=1;  repeat  i:=i+1;   until not((i<=length(a))and  ((a[i]<'A') or (a[i] >'Z')));  write(a[i]);    //S3  i:= 1;  while (i<=length(a))and  ((a[i]>='A') and (a[i] <='Z')) do   begin     write(a[i]);     i:=i+1  end;  a) Numai S1  d) S2 \u015fi S3  b) Numai S2  e) Numai S3  c) S1 \u015fi S2   f) Nici una", "sentences": ["223    Varianta 42  1.", "Preciza\u021bi valoarea afi\u0219at\u0103 \u00een urma execut\u0103rii secven\u021bei de program:  Limbajul C++/C  int v[8] =  {2,4,1,3,11,5,1,3};  int ex(int n, int m)  {   if (n==m)    return v[n]%2;  else    return ex(n, (n + m) /  2) + ex((n + m)/2 + 1, m);  }  int main()  {cout<< ex(0,7); |  printf(\"%d\",ex(0,7));   return 0;}  Limbajul Pascal  var v:array[0..7] of integer  =(2,4,1,3,11,5,1,3);  function   ex(n, m:integer):integer;  begin  if n=m   then ex:=v[n] mod 2   else     ex:= ex(n, (n+m) div 2) +       ex((n + m) div 2 + 1, m);  end;  begin    write(ex(0,7));  end.", " a) 2  b) 3  c) 5  d) 6  e)7  f) 9    2.", "Se consider\u0103 un \u0219ir de caractere a care con\u021bine cel pu\u021bin o majuscul\u0103.", "Care dintre cele trei  secven\u021be S1), S2)\u0219i S3) de mai jos afi\u0219eaz\u0103 prima liter\u0103 mare din \u0219ir?", " Limbajul C++/C  //S1  i = 0;  while (a[i]&&(a[i]<'A'||a[i]  >'Z'))    i++;  cout<< a[i];   | printf(\"%c\",a[i]);    //S2)  i=0;  do { i++;} while (a[i] &&  !(", "a[i]>='A'&& a[i]<= 'Z'));  cout<<a[i];   | printf(\"%c\",a[i]);    //S3)  for(i=0;a[i]&& a[i]>='A'&&  a[i]<='Z';i++)  cout<<a[i];   | printf(\"%c\",a[i]);    Limbajul Pascal  //S1  i:= 1;  while (i<=length(a)) and ((a[i]  <'A') or (a[i] >'Z')) do i:=i+1;  write(a[i]);      //S2)  i:=1;  repeat  i:=i+1;   until not((i<=length(a))and  ((a[i]<'A') or (a[i] >'Z')));  write(a[i]);    //S3  i:= 1;  while (i<=length(a))and  ((a[i]>='A') and (a[i] <='Z')) do   begin     write(a[i]);     i:=i+1  end;  a) Numai S1  d) S2 \u015fi S3  b) Numai S2  e) Numai S3  c) S1 \u015fi S2   f) Nici una"], "page_sentence_count_spacy": 7}, {"page_number": 224, "page_char_count": 1477, "page_word_count": 397, "page_sentence_count_raw": 8, "page_token_count": 369.25, "text": "224    3. Ce se va afi\u015fa \u00een urma execut\u0103rii secven\u0163ei de program al\u0103turate?       Limbajul C++/C  char s[]=\"UN11DOI22TREI33\";  int i=0;  while(s[i]!='\\0')     if(s[i]=='1')  {s[i+1]='+';i+=2;}     else     if(s[i]=='2')  {s[i+1]='=';i+=2;}     else     if(s[i]=='3')  {strcpy(s+i,s+i+1);i++;}     else strcpy(s+i,s+i+1);  cout<<s; | printf(\"%s\",s);    Limbajul Pascal  var s:string;i:integer;  begin  s:= \u2018UN11DOI22TREI33\u2019 ;  i:=1 ;  while i<=length(s)  do  if s[i]='1' then begin          s[i+1]:= '+' ;                  i:=i+2         end    else if s[i]='2' then begin         s[i+1]:='=';              i:=i+2        end    else if s[i]='3' then begin               delete(s,i,1);       i:=i+1       end  else delete(s,i,1);  write(s);  end.  a) UN+DOI=TREI  b) UN+DOI=3        c) 1+2=TREI  d) 1+2=3       e) 11+22=33  f) 111+222=333    4. Variabilele \u00eentregi i \u015fi x memoreaz\u0103 numere naturale. Tabloul unidimensional v con\u0163ine  numerele naturale 0,1,2,0,4,5,6. Num\u0103rul de elemente cu valoarea 10 din v, dup\u0103  rularea secven\u021bei de mai jos este?  Limbajul C++/C  i=0; x=10;    do    {      v[i++]=x;    } while (i < 6 &&  v[i]);  Limbajul Pascal  i:=0; x:=10;  repeat      v[i]:=x; i:=i+1;  until not ((i < 6)and(v[i]<>0));  a) zero   d) trei   b) unul   e) cinci   c) doua   f) \u0219apte     5. Se consider\u0103 urm\u0103torea secven\u021b\u0103. Stabili\u0163i ce se afi\u0219eaz\u0103 \u00een urma rul\u0103rii?  Limbajul C++/C  #include <iostream>  using namespace std;  Limbajul Pascal  var v:array[1..100] of  integer;", "sentences": ["224    3.", "Ce se va afi\u015fa \u00een urma execut\u0103rii secven\u0163ei de program al\u0103turate?", "      Limbajul C++/C  char s[]=\"UN11DOI22TREI33\";  int i=0;  while(s[i]!='\\0')     if(s[i]=='1')  {s[i+1]='+';i+=2;}     else     if(s[i]=='2')  {s[i+1]='=';i+=2;}     else     if(s[i]=='3')  {strcpy(s+i,s+i+1);i++;}     else strcpy(s+i,s+i+1);  cout<<s; | printf(\"%s\",s);    Limbajul Pascal  var s:string;i:integer;  begin  s:= \u2018UN11DOI22TREI33\u2019 ;  i:=1 ;  while i<=length(s)  do  if s[i]='1' then begin          s[i+1]:= '+' ;                  i:=i+2         end    else if s[i]='2' then begin         s[i+1]:='=';              i:=i+2        end    else if s[i]='3' then begin               delete(s,i,1);       i:=i+1       end  else delete(s,i,1);  write(s);  end.", " a) UN+DOI=TREI  b) UN+DOI=3        c) 1+2=TREI  d) 1+2=3       e) 11+22=33  f) 111+222=333    4.", "Variabilele \u00eentregi i \u015fi x memoreaz\u0103 numere naturale.", "Tabloul unidimensional v con\u0163ine  numerele naturale 0,1,2,0,4,5,6.", "Num\u0103rul de elemente cu valoarea 10 din v, dup\u0103  rularea secven\u021bei de mai jos este?", " Limbajul C++/C  i=0; x=10;    do    {      v[i++]=x;    } while (i < 6 &&  v[i]);  Limbajul Pascal  i:=0; x:=10;  repeat      v[i]:=x; i:=i+1;  until not ((i < 6)and(v[i]<>0));  a) zero   d) trei   b) unul   e) cinci   c) doua   f) \u0219apte     5.", "Se consider\u0103 urm\u0103torea secven\u021b\u0103.", "Stabili\u0163i ce se afi\u0219eaz\u0103 \u00een urma rul\u0103rii?", " Limbajul C++/C  #include <iostream>  using namespace std;  Limbajul Pascal  var v:array[1..100] of  integer;"], "page_sentence_count_spacy": 11}, {"page_number": 225, "page_char_count": 1575, "page_word_count": 456, "page_sentence_count_raw": 5, "page_token_count": 393.75, "text": "225    int main()  {  int l,lmax,umax,i,n,v[100];  cin>>n;   | scanf(\"%d\",&n);  for(i=1;i<=n;i++)  cin>>v[i];   | scanf(\"%d\",&v[i]);  l=lmax=1;  for(i=2;i<=n;i++)   if(v[i]%2+v[i-1]%2==1) l++;     else {       if(l>lmax)         {lmax=l;          umax=i-1;}          l=1;         }  if(l>lmax)    {lmax=l;umax=n;}  for(i=umax-lmax+1;i<=umax;i++)      cout<<v[i]<<' ';   | printf(\"%d\",v[i]);  return 0;  }  l,lmax,umax,i,n:integer;  begin  readln(n);  for i:=1 to n do  readln(v[i]);  l:=1; lmax:=1;  for i:=2 to n do   if v[i] mod 2+v[i-1] mod  2=1      then          l:=l+1       else      begin         if l>lmax then        begin                lmax:=l;                umax:=i-1              end;         l:=1      end;  if l>lmax then begin      lmax:=l; umax:=n  end;  for i:=umax-lmax+1 to umax   do  write(v[i],' '); end.   a) Cea mai lung\u0103  secven\u021b\u0103 de valori  de aceea\u0219i paritate  b) Cea mai scurt\u0103  secven\u021b\u0103 de valori  distincte  c) Cea mai lung\u0103  secven\u021b\u0103 de valori  egale   d) Cea mai lung\u0103  secven\u021b\u0103 de valori  impare  e) Cea mai lung\u0103  secven\u021b\u0103 de valori  pare  f) Cea mai lung\u0103  secven\u021b\u0103 de valori  de parit\u0103\u021bi  diferite     6. Se consider\u0103 un graf neorientat cu 10 v\u00e2rfuri numerotate de la 1 la 10, graf cu proprietatea  c\u0103 exist\u0103 muchie \u00eentre v\u00e2rfurile i \u0219i j dac\u0103 \u0219i numai dac\u0103 i \u0219i j sunt numere prime \u00eentre  ele. Care este suma gradelor v\u00e2rfurilor acestui graf?  a)  20  b)  30  c)  32  d)  50  e)  60  f)  62    7. Num\u0103rul maxim de muchii \u00eentr-un graf neorientat cu n v\u00e2rfuri \u0219i p componente conexe  (p<n) este:  a)  n*p  b)  n-p+1  c)  ((n-p)*(n-p-1))/2", "sentences": ["225    int main()  {  int l,lmax,umax,i,n,v[100];  cin>>n;   | scanf(\"%d\",&n);  for(i=1;i<=n;i++)  cin>>v[i];   | scanf(\"%d\",&v[i]);  l=lmax=1;  for(i=2;i<=n;i++)   if(v[i]%2+v[i-1]%2==1) l++;     else {       if(l>lmax)         {lmax=l;          umax=i-1;}          l=1;         }  if(l>lmax)    {lmax=l;umax=n;}  for(i=umax-lmax+1;i<=umax;i++)      cout<<v[i]<<' ';   | printf(\"%d\",v[i]);  return 0;  }  l,lmax,umax,i,n:integer;  begin  readln(n);  for i:=1 to n do  readln(v[i]);  l:=1; lmax:=1;  for i:=2 to n do   if v[i] mod 2+v[i-1] mod  2=1      then          l:=l+1       else      begin         if l>lmax then        begin                lmax:=l;                umax:=i-1              end;         l:=1      end;  if l>lmax then begin      lmax:=l; umax:=n  end;  for i:=umax-lmax+1 to umax   do  write(v[i],' '); end.", "  a) Cea mai lung\u0103  secven\u021b\u0103 de valori  de aceea\u0219i paritate  b) Cea mai scurt\u0103  secven\u021b\u0103 de valori  distincte  c) Cea mai lung\u0103  secven\u021b\u0103 de valori  egale   d) Cea mai lung\u0103  secven\u021b\u0103 de valori  impare  e) Cea mai lung\u0103  secven\u021b\u0103 de valori  pare  f) Cea mai lung\u0103  secven\u021b\u0103 de valori  de parit\u0103\u021bi  diferite     6.", "Se consider\u0103 un graf neorientat cu 10 v\u00e2rfuri numerotate de la 1 la 10, graf cu proprietatea  c\u0103 exist\u0103 muchie \u00eentre v\u00e2rfurile i \u0219i j dac\u0103 \u0219i numai dac\u0103 i \u0219i j sunt numere prime \u00eentre  ele.", "Care este suma gradelor v\u00e2rfurilor acestui graf?", " a)  20  b)  30  c)  32  d)  50  e)  60  f)  62    7.", "Num\u0103rul maxim de muchii \u00eentr-un graf neorientat cu n v\u00e2rfuri \u0219i p componente conexe  (p<n) este:  a)  n*p  b)  n-p+1  c)  ((n-p)*(n-p-1))/2"], "page_sentence_count_spacy": 6}, {"page_number": 226, "page_char_count": 1395, "page_word_count": 357, "page_sentence_count_raw": 7, "page_token_count": 348.75, "text": "226    d) C2n-p  e) C2n-p+1  f) C2n    8. Func\u021bia recursiv\u0103 suma trebuie definit\u0103 astfel \u00eenc\u00e2t apelul suma(n) s\u0103 returneze suma  p\u0103tratelor perfecte mai mici sau egale cu n. Care este expresia cu care trebuie completat\u0103  defini\u021bia func\u021biei?  Limbajul C++/C  long suma (int i)  {        if(i==0) return 0;        int j=sqrt(i);        return \u2026;  }  Limbajul Pascal  function   suma (i:longint):longint;  var j:longint;  begin  if i = 0 then suma:=0  else begin        j:=trunc(sqrt(i));       suma:= \u2026    end end;  a)   j*j+suma(j-1)  b)  j*j+suma(j) c)  j*j+suma(j*j -1)  d)   j+suma(j*j-1)  e)  j+suma(j-1) f)  j*j+suma(j*j )    9. Valoarea variabilei n la finalul rul\u0103rii urm\u0103torului program este?  Limbajul C++/C  int main()  {   int v[]={0, 1, 2, 3, 4, 5, 0};  int i=0, n=0;   do{ if (i==v[i]) n++;     } while(i<6 && v[i++]);  return 0;  }  Limbajul Pascal  var v:array[0..6] of  integer=(0, 1, 2, 3, 4, 5,  0); i,n:integer;  begin   i:=-1; n:=0;   repeat     i:=i+1;    if  i=v[i] then  n:=n+1;   until not((i<6)and  (v[i]<>0))  end.    a) 0  d) 5  b) 1  e) 7  c) 3  f) programul va intra  \u00eentr-un ciclu infinit     10. Un arbore binar complet este un arbore cu r\u0103d\u0103cin\u0103 \u00een care fiecare nod are exact doi fii sau  niciunul. \u015etiind c\u0103 r\u0103d\u0103cina se g\u0103se\u015fte pe nivelul 0, num\u0103rul maxim de noduri de pe  nivelul 5 dintr-un astfel de arbore este?  a)  15  b)  24  c)  31  d)  25  e)  50  f)  120", "sentences": ["226    d) C2n-p  e) C2n-p+1  f) C2n    8.", "Func\u021bia recursiv\u0103 suma trebuie definit\u0103 astfel \u00eenc\u00e2t apelul suma(n) s\u0103 returneze suma  p\u0103tratelor perfecte mai mici sau egale cu n. Care este expresia cu care trebuie completat\u0103  defini\u021bia func\u021biei?", " Limbajul C++/C  long suma (int i)  {        if(i==0) return 0;        int j=sqrt(i);        return \u2026;  }  Limbajul Pascal  function   suma (i:longint):longint;  var j:longint;  begin  if i = 0 then suma:=0  else begin        j:=trunc(sqrt(i));       suma:= \u2026    end end;  a)   j*j+suma(j-1)  b)  j*j+suma(j) c)  j*j+suma(j*j -1)  d)   j+suma(j*j-1)  e)  j+suma(j-1) f)  j*j+suma(j*j )    9.", "Valoarea variabilei n la finalul rul\u0103rii urm\u0103torului program este?", " Limbajul C++/C  int main()  {   int v[]={0, 1, 2, 3, 4, 5, 0};  int i=0, n=0;   do{ if (i==v[i]) n++;     } while(i<6 && v[i++]);  return 0;  }  Limbajul Pascal  var v:array[0..6] of  integer=(0, 1, 2, 3, 4, 5,  0); i,n:integer;  begin   i:=-1; n:=0;   repeat     i:=i+1;    if  i=v[i] then  n:=n+1;   until not((i<6)and  (v[i]<>0))  end.", "   a) 0  d) 5  b) 1  e) 7  c) 3  f) programul va intra  \u00eentr-un ciclu infinit     10.", "Un arbore binar complet este un arbore cu r\u0103d\u0103cin\u0103 \u00een care fiecare nod are exact doi fii sau  niciunul.", "\u015etiind c\u0103 r\u0103d\u0103cina se g\u0103se\u015fte pe nivelul 0, num\u0103rul maxim de noduri de pe  nivelul 5 dintr-un astfel de arbore este?", " a)  15  b)  24  c)  31  d)  25  e)  50  f)  120"], "page_sentence_count_spacy": 9}, {"page_number": 227, "page_char_count": 1790, "page_word_count": 371, "page_sentence_count_raw": 12, "page_token_count": 447.5, "text": "227    11. Un elev, folosind metoda backtracking, construie\u015fte toate numerele cu cifre distincte,  numere care au suma cifrelor egal\u0103 cu 5 \u015fi nu sunt divizibile cu 10. El ob\u0163ine, \u00een aceast\u0103  ordine, numerele: 104; 14; 203; 23; 302; 32; 401; 41; 5.  Folosind aceea\u015fi metod\u0103, el construie\u015fte toate numerele naturale cu cifre diferite,  nedivizibile cu 10 \u015fi cu suma cifrelor egal\u0103 cu 6.   Care sunt primele patru numere pe care le construie\u015fte?  a)114;123;132;141  d)1023;1032;105;1203  b)123;132;15;213  e)1014;105;15;6  c)1023;123;1032;132  f)1023;105;15;6  12. C\u0103utarea unui element \u00eentr-un vector sortat descresc\u0103tor se realizeaz\u0103 \u00een mod eficient cu  un algoritm care utilizeaz\u0103:  a)metoda c\u0103ut\u0103rii  binare  d) parcurgerea  elementelor de pe  pozi\u0163ii pare    b) metoda  backtracking  e) metoda  c\u0103ut\u0103rii  secven\u0163iale  c)sortarea cresc\u0103toare  a vectorului  f)parcurgerea  elementelor de pe  pozi\u0163ii impare  13. Generarea tablourilor bidimensionale p\u0103tratice de ordinul n, cu elemente 0 \u0219i 1, cu  proprietatea c\u0103 pe fiecare linie \u0219i pe fiecare coloan\u0103 exist\u0103 un singur element egal cu 1, se  poate realiza utiliz\u00e2nd metoda backtracking. Algoritmul utilizat este echivalent cu  algoritmul de generare a:  a)  produsului  cartezian  b)  combin\u0103rilo r  c)  aranjamentel or  d)  permut\u0103rilor  e)  submul\u0163imil or  f)  parti\u0163iilor    14. Fie graful orientat G=(V,E) unde card(V)=20 iar E={(i,j)|i<j,i,j\u2208V}.  Num\u0103rul de componente tare conexe ale grafului G este:  a)  1  b)  5  c)  8  d)  10  e)  15  f)  20    15. Stabili\u021bi valoarea apelului F(11111).  Limbajul C++/C  int  F(int N)  { if (N==1) return 0;   return 1+F(N/2);                }  Limbajul Pascal  function  F(N:integer):integer;  begin  if  N=1 then F:=0  else  F:=1+F(N div 2);   end;  a)  8  b)  10  c)  13  d)  20  e)  36  f)  50", "sentences": ["227    11.", "Un elev, folosind metoda backtracking, construie\u015fte toate numerele cu cifre distincte,  numere care au suma cifrelor egal\u0103 cu 5 \u015fi nu sunt divizibile cu 10.", "El ob\u0163ine, \u00een aceast\u0103  ordine, numerele: 104; 14; 203; 23; 302; 32; 401; 41; 5.", " Folosind aceea\u015fi metod\u0103, el construie\u015fte toate numerele naturale cu cifre diferite,  nedivizibile cu 10 \u015fi cu suma cifrelor egal\u0103 cu 6.", "  Care sunt primele patru numere pe care le construie\u015fte?", " a)114;123;132;141  d)1023;1032;105;1203  b)123;132;15;213  e)1014;105;15;6  c)1023;123;1032;132  f)1023;105;15;6  12.", "C\u0103utarea unui element \u00eentr-un vector sortat descresc\u0103tor se realizeaz\u0103 \u00een mod eficient cu  un algoritm care utilizeaz\u0103:  a)metoda c\u0103ut\u0103rii  binare  d) parcurgerea  elementelor de pe  pozi\u0163ii pare    b) metoda  backtracking  e) metoda  c\u0103ut\u0103rii  secven\u0163iale  c)sortarea cresc\u0103toare  a vectorului  f)parcurgerea  elementelor de pe  pozi\u0163ii impare  13.", "Generarea tablourilor bidimensionale p\u0103tratice de ordinul n, cu elemente 0 \u0219i 1, cu  proprietatea c\u0103 pe fiecare linie \u0219i pe fiecare coloan\u0103 exist\u0103 un singur element egal cu 1, se  poate realiza utiliz\u00e2nd metoda backtracking.", "Algoritmul utilizat este echivalent cu  algoritmul de generare a:  a)  produsului  cartezian  b)  combin\u0103rilo r  c)  aranjamentel or  d)  permut\u0103rilor  e)  submul\u0163imil or  f)  parti\u0163iilor    14.", "Fie graful orientat G=(V,E) unde card(V)=20 iar E={(i,j)|i<j,i,j\u2208V}.", " Num\u0103rul de componente tare conexe ale grafului G este:  a)  1  b)  5  c)  8  d)  10  e)  15  f)  20    15.", "Stabili\u021bi valoarea apelului F(11111).", " Limbajul C++/C  int  F(int N)  { if (N==1) return 0;   return 1+F(N/2);                }  Limbajul Pascal  function  F(N:integer):integer;  begin  if  N=1 then F:=0  else  F:=1+F(N div 2);   end;  a)  8  b)  10  c)  13  d)  20  e)  36  f)  50"], "page_sentence_count_spacy": 13}, {"page_number": 228, "page_char_count": 1450, "page_word_count": 394, "page_sentence_count_raw": 9, "page_token_count": 362.5, "text": "228    Varianta 43  1.  Variabila v re\u021bine un num\u0103r \u00eentreg. Indica\u021bi ce valoare va avea v dup\u0103 executarea  urm\u0103toarei secven\u021be de instruc\u021biuni?    Limbajul C++/C  int v=2;   v=v*v; v=2*v+v/2;   v=v-4;   v=v%5;    Limbajul Pascal  v:=2;   v:=v*v;   v:=2*v+v div 2; v:=v-4;   v:=v mod 5;  a) 0  b) 1  c) 2  d) 8  e) 10  f) 16    2.  Variabilele x \u0219i y sunt reale, iar i \u0219i j sunt \u00eentregi.  Indica\u021bi ce valoare va avea x dup\u0103  executarea urm\u0103toarei secven\u021be de instruc\u021biuni?    Limbajul C++/C  x=1.5; y=2.1;   i=x; j=y+1;  x=x*y+i/j;    Limbajul Pascal  x:=1.5; y:=2.1;  i:=trunc(x);   j:=trunc(y)+1;   x:=x*y+i div j;  a)2   b) 2.15  c) 3  d) 3.1  e) 3.15  f) 3.5    3.  Variabilele i,j \u0219i k sunt de tip \u00eentreg. Indica\u021bi ce valoare se afi\u0219eaz\u0103 dup\u0103 executarea  urm\u0103toarei secven\u021be?     Limbajul C++/C  i=0; j=0;   if(j) j--; else i++;   if(i) i--; else j++;   k=i+j;  cout<<k;\u2502printf(\"%d\",k);    Limbajul Pascal  i:=0; j:=0;   if j<>0 then dec(j)          else inc(i);   if i<>0 then dec(i)          else inc(j);   k:=i+j;  write(k);  a) -3  b) -2  c) -1  d) 0  e) 1  f) 2    4.  Variabilele n, p \u0219i x sunt de tip \u00eentreg. Indica\u021bi ce valoare se afi\u0219eaz\u0103 dup\u0103 executarea  urm\u0103toarei secven\u021be?     Limbajul C++/C  n=25198764, p=1, x=0;  while(n)  {if(n%2)   {p=p*10;    x=x+n%10*p;   }    n/=10;  }    Limbajul Pascal  n:=25198764; p:=1; x:=0;  while n<>0 do    begin     if n mod 2<>0 then       begin        p:=p*10;        x:=x+n mod 10 * p       end;", "sentences": ["228    Varianta 43  1.", " Variabila v re\u021bine un num\u0103r \u00eentreg.", "Indica\u021bi ce valoare va avea v dup\u0103 executarea  urm\u0103toarei secven\u021be de instruc\u021biuni?", "   Limbajul C++/C  int v=2;   v=v*v; v=2*v+v/2;   v=v-4;   v=v%5;    Limbajul Pascal  v:=2;   v:=v*v;   v:=2*v+v div 2; v:=v-4;   v:=v mod 5;  a) 0  b) 1  c) 2  d) 8  e) 10  f) 16    2.", " Variabilele x \u0219i y sunt reale, iar i \u0219i j sunt \u00eentregi.", " Indica\u021bi ce valoare va avea x dup\u0103  executarea urm\u0103toarei secven\u021be de instruc\u021biuni?", "   Limbajul C++/C  x=1.5; y=2.1;   i=x; j=y+1;  x=x*y+i/j;    Limbajul Pascal  x:=1.5; y:=2.1;  i:=trunc(x);   j:=trunc(y)+1;   x:=x*y+i div j;  a)2   b) 2.15  c) 3  d) 3.1  e) 3.15  f) 3.5    3.", " Variabilele i,j \u0219i k sunt de tip \u00eentreg.", "Indica\u021bi ce valoare se afi\u0219eaz\u0103 dup\u0103 executarea  urm\u0103toarei secven\u021be?", "    Limbajul C++/C  i=0; j=0;   if(j) j--; else i++;   if(i) i--; else j++;   k=i+j;  cout<<k;\u2502printf(\"%d\",k);    Limbajul Pascal  i:=0; j:=0;   if j<>0 then dec(j)          else inc(i);   if i<>0 then dec(i)          else inc(j);   k:=i+j;  write(k);  a) -3  b) -2  c) -1  d) 0  e) 1  f) 2    4.", " Variabilele n, p \u0219i x sunt de tip \u00eentreg.", "Indica\u021bi ce valoare se afi\u0219eaz\u0103 dup\u0103 executarea  urm\u0103toarei secven\u021be?", "    Limbajul C++/C  n=25198764, p=1, x=0;  while(n)  {if(n%2)   {p=p*10;    x=x+n%10*p;   }    n/=10;  }    Limbajul Pascal  n:=25198764; p:=1; x:=0;  while n<>0 do    begin     if n mod 2<>0 then       begin        p:=p*10;        x:=x+n mod 10 * p       end;"], "page_sentence_count_spacy": 13}, {"page_number": 229, "page_char_count": 1496, "page_word_count": 475, "page_sentence_count_raw": 4, "page_token_count": 374.0, "text": "229    cout<<x; \u2502printf(\"%d\",x);    n:=n div 10    end;  write(x);  a) 2864  b) 4682  c) 5197  d) 7915  e) 51970  f) 79150    5.  \u00cen secven\u021ba de mai jos toate variabilele sunt de tip \u00eentreg. Indica\u021bi ce valoare va fi afi\u0219at\u0103  pentru n=52?    Limbajul C++/C  cin>>n; \u2502scanf(\"%d\",&n);  x=2;  for(i=3; i<=n;i++)   {x*=i;     while(!(x%10)) x/=10;     x%=10;    }  cout<<x; \u2502printf(\"%d\",x);    Limbajul Pascal  readln(n); x:=2;  for i:=3 to n do    begin     x:=x*i;     while x mod 10=0 do          x:=x div 10;     x:=x mod 10    end;  write(x);  a) 2  b) 4  c) 5  d) 6  e) 7  f) 8    6.  Indica\u021bi ce valoare se va afi\u0219a dup\u0103 executarea secven\u021bei urm\u0103toare?     Limbajul C++/C  int v[15]={28,0,56,4,0,0,   13,6,0,18,0,26,90,0,25};  int k=15, i,j;  for(i=0;i<k;i++)    if(!v[i])     {for(j=i;j<k-1;j++)                         v[j]=v[j+1];      v[j]=0; k--; i--;      }  for(i=0;i<k;i++)          cout<<v[i]<<\" \";        \u2502printf(\"%d\",v[i]);    Limbajul Pascal  var v:array[0..14]of  integer =  (28,0,56,4,0,0,13,6,0,18,0,     26,90,0,25);      k,i,j:integer;  i:=0; k:=15;  while i<k do   begin   if v[i]=0 then      begin       for j:=i to k-2 do           v[j]:=v[j+1];       v[j+1]:=0;         dec(k);         dec(i)      end;   inc(i)  end;  for i:=0 to k-1 do  write(v[i],' ');  a)  4 6 13 18 25 26 28 56 90  b)  4 6 13 18 25 26 28 56 90 0 0 0  c)  4 6 13 18 25 26 28 56 90 0 0 0 0 0 0  d)  28 56 4 13 6 18 26 90 25  e)  28 56 4 13 6 18 26 90 25 0 0 0  f)   28 56 4 13 6 18 26 90 25 0 0 0 0 0 0", "sentences": ["229    cout<<x; \u2502printf(\"%d\",x);    n:=n div 10    end;  write(x);  a) 2864  b) 4682  c) 5197  d) 7915  e) 51970  f) 79150    5.", " \u00cen secven\u021ba de mai jos toate variabilele sunt de tip \u00eentreg.", "Indica\u021bi ce valoare va fi afi\u0219at\u0103  pentru n=52?", "   Limbajul C++/C  cin>>n; \u2502scanf(\"%d\",&n);  x=2;  for(i=3; i<=n;i++)   {x*=i;     while(!(x%10)) x/=10;     x%=10;    }  cout<<x; \u2502printf(\"%d\",x);    Limbajul Pascal  readln(n); x:=2;  for i:=3 to n do    begin     x:=x*i;     while x mod 10=0 do          x:=x div 10;     x:=x mod 10    end;  write(x);  a) 2  b) 4  c) 5  d) 6  e) 7  f) 8    6.", " Indica\u021bi ce valoare se va afi\u0219a dup\u0103 executarea secven\u021bei urm\u0103toare?", "    Limbajul C++/C  int v[15]={28,0,56,4,0,0,   13,6,0,18,0,26,90,0,25};  int k=15, i,j;  for(i=0;i<k;i++)    if(!v[i])     {for(j=i;j<k-1;j++)                         v[j]=v[j+1];      v[j]=0; k--; i--;      }  for(i=0;i<k;i++)          cout<<v[i]<<\" \";        \u2502printf(\"%d\",v[i]);    Limbajul Pascal  var v:array[0..14]of  integer =  (28,0,56,4,0,0,13,6,0,18,0,     26,90,0,25);      k,i,j:integer;  i:=0; k:=15;  while i<k do   begin   if v[i]=0 then      begin       for j:=i to k-2 do           v[j]:=v[j+1];       v[j+1]:=0;         dec(k);         dec(i)      end;   inc(i)  end;  for i:=0 to k-1 do  write(v[i],' ');  a)  4 6 13 18 25 26 28 56 90  b)  4 6 13 18 25 26 28 56 90 0 0 0  c)  4 6 13 18 25 26 28 56 90 0 0 0 0 0 0  d)  28 56 4 13 6 18 26 90 25  e)  28 56 4 13 6 18 26 90 25 0 0 0  f)   28 56 4 13 6 18 26 90 25 0 0 0 0 0 0"], "page_sentence_count_spacy": 6}, {"page_number": 230, "page_char_count": 1387, "page_word_count": 349, "page_sentence_count_raw": 6, "page_token_count": 346.75, "text": "230    7.  Indica\u021bi ce se va afi\u0219a dup\u0103 executarea secven\u021bei de program?    Limbajul C++/C  int main()  {  char s[100]=\"Poli- informatica\", *p;       p=strchr(s,'-');   (p+1)[0]-=32;   s[p-s]='\\0';   s[0]+=32;   strcat(p+1,\"-\");     strcat(p+1,s);       strcpy(s,p+1);   cout<<s;\u2502printf(\"%s\",s);  }    Limbajul Pascal  var s,p:string; i:integer;  begin  s:='Poli-informatica';  i:=pos('-',s);  s[i+1]:=chr(ord(s[i+1])-32);  s[1]:=chr(ord(s[1])+32);  p:=copy(s,i+1,length(s)-i);     delete(s,i,length(s)-i+1);  s:=p+'-'+s;  write(s);  end.    a) INFO-POLI  b) Informatica-poli  c) informatica   d) info-poli  e) informatica-poli  f) poli    8.  Indica\u021bi ce se va afi\u0219a dup\u0103 executarea urm\u0103toarei secven\u021be de  program?    Limbajul C++/C  typedef struct           {char *p;}S;  int main()   {char p[10]=\"abcd\";   S S[2];    int i;   for(i=0;i<2;i++)       S[i].p=p+i;   cout<<S[1].p[0];   \u2502printf(\"%c\",S[1].p[0]);     return 0;  }    Limbajul Pascal  type ST=record p:string  end;  var p:string;       S:array[0..1] of ST;      i:integer;  begin   p:='abcd';   for i:=0 to 1 do       begin         S[i].p:=copy(p,i+1,       length(p)-i+1);      end;    write(S[1].p[1]);   end.  a) a  b) b   c) c   d) d  e) e  f) f    9.  Pentru graful orientat al\u0103turat, indica\u021bi \u00eentre care perechi de noduri  exist\u0103 drum    de lungime 5?   a) A \u0219i B  b) A \u0219i C  c) A \u0219i D  d) B \u0219i C  e) B \u0219i D  f) C \u0219i A", "sentences": ["230    7.", " Indica\u021bi ce se va afi\u0219a dup\u0103 executarea secven\u021bei de program?", "   Limbajul C++/C  int main()  {  char s[100]=\"Poli- informatica\", *p;       p=strchr(s,'-');   (p+1)[0]-=32;   s[p-s]='\\0';   s[0]+=32;   strcat(p+1,\"-\");     strcat(p+1,s);       strcpy(s,p+1);   cout<<s;\u2502printf(\"%s\",s);  }    Limbajul Pascal  var s,p:string; i:integer;  begin  s:='Poli-informatica';  i:=pos('-',s);  s[i+1]:=chr(ord(s[i+1])-32);  s[1]:=chr(ord(s[1])+32);  p:=copy(s,i+1,length(s)-i);     delete(s,i,length(s)-i+1);  s:=p+'-'+s;  write(s);  end.", "   a) INFO-POLI  b) Informatica-poli  c) informatica   d) info-poli  e) informatica-poli  f) poli    8.", " Indica\u021bi ce se va afi\u0219a dup\u0103 executarea urm\u0103toarei secven\u021be de  program?", "   Limbajul C++/C  typedef struct           {char *p;}S;  int main()   {char p[10]=\"abcd\";   S S[2];    int i;   for(i=0;i<2;i++)       S[i].p=p+i;   cout<<S[1].p[0];   \u2502printf(\"%c\",S[1].p[0]);     return 0;  }    Limbajul Pascal  type ST=record p:string  end;  var p:string;       S:array[0..1] of ST;      i:integer;  begin   p:='abcd';   for i:=0 to 1 do       begin         S[i].p:=copy(p,i+1,       length(p)-i+1);      end;    write(S[1].p[1]);   end.", " a) a  b) b   c) c   d) d  e) e  f) f    9.", " Pentru graful orientat al\u0103turat, indica\u021bi \u00eentre care perechi de noduri  exist\u0103 drum    de lungime 5?", "  a) A \u0219i B  b) A \u0219i C  c) A \u0219i D  d) B \u0219i C  e) B \u0219i D  f) C \u0219i A"], "page_sentence_count_spacy": 9}, {"page_number": 231, "page_char_count": 1630, "page_word_count": 591, "page_sentence_count_raw": 4, "page_token_count": 407.5, "text": "231      10.  Fie func\u021bia recursiv\u0103 de mai jos. Ce valoare va avea apelul f(f(f(f(0))))?    Limbajul C++/C  int f(int x)   {if(x<7) return f(x+2)+1;      else  return x-5;}    Limbajul Pascal  function  f(x:integer):integer;  begin  if x<7 then f:=f(x+2)+1    else f:=x-5;  end;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    11.  Indica\u021bi ce se va afi\u0219a \u00een urma execut\u0103rii urm\u0103toarei secven\u021be?    Limbajul C++/C  int a[6][6]={{2,4,1,5,3},  {5,1,4,2,3},{1,2,3,4,5},{5,4 ,3,2,1},{4,1,5,3,2}};  int i,j,k=3;  for(int m=0;m<k;++m)  {for(i=4;i>1;--i)    for(j=0;j<5;++j)         a[i+1][j]=a[i][j];   for(j=0;j<5;j++)       a[2][j]=a[5][j];  }  for(i=0;i<5;++i)    {for(j=0;j<5;++j)         cout<<a[i][j]<< \" \";      \u2502printf(\"%d \",a[i][j]);     cout<<endl;\u2502printf(\"\\n\");    }    Limbajul Pascal  var a:array[0..5,0..4]of   integer=((2,4,1,5,3),(5,1,4 ,2,3),(1,2,3,4,5),(5,4,3,2, 1),  (4,1,5,3,2),(0,0,0,0,0));  i,j,k,m:integer;  k:=3;  for m:=0 to k-1 do     begin     for i:=4 downto 2 do        for j:=0 to 4 do          a[i+1,j]:=a[i,j];     for j:=0 to 4 do          a[2,j]:=a[5,j]    end;   for i:=0 to 4 do     begin     for j:= 0 to 4 do          write(a[i,j],' ');     writeln    end;        a)      2 3 1 5 4  5 1 4 2 3  1 2 3 4 5  5 4 3 2 1  2 1 5 3 4  b)    2 4 1 5 3     4 1 5 3 2    5 4 3 2 1   1 2 3 4 5   5 1 4 2 3  c)   2 4 1 5 3  5 1 4 2 3  1 2 3 4 5  5 4 3 2 1  4 1 5 3 2  d)          2 4 1 5 3        5 4 3 2 1        4 1 5 3 2        5 1 4 2 3         1 2 3 4 5  e)       2 4 1 5 3     5 4 3 2 1     4 1 5 3 2     5 1 4 2 3    1 2 3 5 4  f)          3 4 1 5 2       4 1 5 3 2       5 4 3 2 1       1 2 3 4 5       3 1 4 2 5", "sentences": ["231      10.", " Fie func\u021bia recursiv\u0103 de mai jos.", "Ce valoare va avea apelul f(f(f(f(0))))?", "   Limbajul C++/C  int f(int x)   {if(x<7) return f(x+2)+1;      else  return x-5;}    Limbajul Pascal  function  f(x:integer):integer;  begin  if x<7 then f:=f(x+2)+1    else f:=x-5;  end;  a) 1  b) 2  c) 3  d) 4  e) 5  f) 6    11.", " Indica\u021bi ce se va afi\u0219a \u00een urma execut\u0103rii urm\u0103toarei secven\u021be?", "   Limbajul C++/C  int a[6][6]={{2,4,1,5,3},  {5,1,4,2,3},{1,2,3,4,5},{5,4 ,3,2,1},{4,1,5,3,2}};  int i,j,k=3;  for(int m=0;m<k;++m)  {for(i=4;i>1;--i)    for(j=0;j<5;++j)         a[i+1][j]=a[i][j];   for(j=0;j<5;j++)       a[2][j]=a[5][j];  }  for(i=0;i<5;++i)    {for(j=0;j<5;++j)         cout<<a[i][j]<< \" \";      \u2502printf(\"%d \",a[i][j]);     cout<<endl;\u2502printf(\"\\n\");    }    Limbajul Pascal  var a:array[0..5,0..4]of   integer=((2,4,1,5,3),(5,1,4 ,2,3),(1,2,3,4,5),(5,4,3,2, 1),  (4,1,5,3,2),(0,0,0,0,0));  i,j,k,m:integer;  k:=3;  for m:=0 to k-1 do     begin     for i:=4 downto 2 do        for j:=0 to 4 do          a[i+1,j]:=a[i,j];     for j:=0 to 4 do          a[2,j]:=a[5,j]    end;   for i:=0 to 4 do     begin     for j:= 0 to 4 do          write(a[i,j],' ');     writeln    end;        a)      2 3 1 5 4  5 1 4 2 3  1 2 3 4 5  5 4 3 2 1  2 1 5 3 4  b)    2 4 1 5 3     4 1 5 3 2    5 4 3 2 1   1 2 3 4 5   5 1 4 2 3  c)   2 4 1 5 3  5 1 4 2 3  1 2 3 4 5  5 4 3 2 1  4 1 5 3 2  d)          2 4 1 5 3        5 4 3 2 1        4 1 5 3 2        5 1 4 2 3         1 2 3 4 5  e)       2 4 1 5 3     5 4 3 2 1     4 1 5 3 2     5 1 4 2 3    1 2 3 5 4  f)          3 4 1 5 2       4 1 5 3 2       5 4 3 2 1       1 2 3 4 5       3 1 4 2 5"], "page_sentence_count_spacy": 6}, {"page_number": 232, "page_char_count": 1744, "page_word_count": 437, "page_sentence_count_raw": 9, "page_token_count": 436.0, "text": "232      12.  Folosind metoda backtracking, se determin\u0103 \u00een ordine cresc\u0103toare, toate numerele de 4  cifre distincte, oricare dou\u0103 cifre al\u0103turate neput\u00e2nd fi prime. Primele 7 solu\u021bii sunt:  1024, 1026, 1028, 1029, 1034, 1036, 1038, ... Indica\u021bi care sunt  cele 2 numere generate \u00eenaintea solu\u021biei 7401?  a) 7091            7092  b) 7195         7198  c) 7196         7198  d)  7297             7298  e) 7397         7398  f) 7916            7918    13.  Secven\u021ba gradelor dintr-un graf neorientat este format\u0103 din gradele tuturor nodurilor  grafului, aranjate \u00een ordine descresc\u0103toare. Indica\u021bi care dintre urm\u0103toarele secven\u021be nu  poate fi secven\u021b\u0103 a gradelor pentru niciun graf?  I: 7, 6, 5, 4, 4, 3, 2, 1  II: 6, 6, 6, 6, 3, 3, 2, 2  III: 7, 6, 6, 4, 4, 3, 2, 2  IV: 8, 7, 7, 6, 4, 2, 1, 1  a) I \u0219i II  b) I \u0219i IV  c) II \u0219i IV  d) III \u0219i IV  e) doar II  f) doar IV    14.  Fie urm\u0103toarele func\u021bii recursive de mai jos. Indica\u021bi care este complexitatea timp a  celor dou\u0103 func\u021bii?    Limbajul C++/C  int f1(int n)  {if(n<=1) return 0;    return 2*f1(n-1);  }  int f2(int n)  { if(n<=1) return n;      return f2(n-1)+f2(n-1);  }    Limbajul Pascal  function  f1(n:integer):integer;  begin      if n<=1 then         f1:=0;f1:=2*f1(n-1)  end;  function  f2(n:integer):integer;  begin    if n<=1 then f2:=n;  f2:=f2(n-1)+f2(n-1)  end;  a) O(n2) pentru am\u00e2ndou\u0103  b) O(n)  pentru f1 \u0219i O(2n) pentru f2  c) O(2n) pentru f1 \u0219i O(n) pentru f2  d) O(n)  pentru am\u00e2ndou\u0103  e) O(3n) pentru f1  f)  O(3n) pentru f1 \u0219i f2    15.  Indica\u021bi care este complexitatea urm\u0103toarei secven\u021be de instruc\u021biuni:    Limbajul C++/C  int n,k,p;  cin>>n>>k;\u2502scanf(\"%d%d  \",&n,&k);  p=1;  while(k>0)    Limbajul Pascal  var n,k,p:integer;  readln(n,k);  p:=1;  while k>0 do", "sentences": ["232      12.", " Folosind metoda backtracking, se determin\u0103 \u00een ordine cresc\u0103toare, toate numerele de 4  cifre distincte, oricare dou\u0103 cifre al\u0103turate neput\u00e2nd fi prime.", "Primele 7 solu\u021bii sunt:  1024, 1026, 1028, 1029, 1034, 1036, 1038, ... Indica\u021bi care sunt  cele 2 numere generate \u00eenaintea solu\u021biei 7401?", " a) 7091            7092  b) 7195         7198  c) 7196         7198  d)  7297             7298  e) 7397         7398  f) 7916            7918    13.", " Secven\u021ba gradelor dintr-un graf neorientat este format\u0103 din gradele tuturor nodurilor  grafului, aranjate \u00een ordine descresc\u0103toare.", "Indica\u021bi care dintre urm\u0103toarele secven\u021be nu  poate fi secven\u021b\u0103 a gradelor pentru niciun graf?", " I: 7, 6, 5, 4, 4, 3, 2, 1  II: 6, 6, 6, 6, 3, 3, 2, 2  III: 7, 6, 6, 4, 4, 3, 2, 2  IV: 8, 7, 7, 6, 4, 2, 1, 1  a) I \u0219i II  b) I \u0219i IV  c) II \u0219i IV  d) III \u0219i IV  e) doar II  f) doar IV    14.", " Fie urm\u0103toarele func\u021bii recursive de mai jos.", "Indica\u021bi care este complexitatea timp a  celor dou\u0103 func\u021bii?", "   Limbajul C++/C  int f1(int n)  {if(n<=1) return 0;    return 2*f1(n-1);  }  int f2(int n)  { if(n<=1) return n;      return f2(n-1)+f2(n-1);  }    Limbajul Pascal  function  f1(n:integer):integer;  begin      if n<=1 then         f1:=0;f1:=2*f1(n-1)  end;  function  f2(n:integer):integer;  begin    if n<=1 then f2:=n;  f2:=f2(n-1)+f2(n-1)  end;  a) O(n2) pentru am\u00e2ndou\u0103  b) O(n)  pentru f1 \u0219i O(2n) pentru f2  c) O(2n) pentru f1 \u0219i O(n) pentru f2  d) O(n)  pentru am\u00e2ndou\u0103  e) O(3n) pentru f1  f)  O(3n) pentru f1 \u0219i f2    15.", " Indica\u021bi care este complexitatea urm\u0103toarei secven\u021be de instruc\u021biuni:    Limbajul C++/C  int n,k,p;  cin>>n>>k;\u2502scanf(\"%d%d  \",&n,&k);  p=1;  while(k>0)    Limbajul Pascal  var n,k,p:integer;  readln(n,k);  p:=1;  while k>0 do"], "page_sentence_count_spacy": 11}, {"page_number": 233, "page_char_count": 216, "page_word_count": 75, "page_sentence_count_raw": 1, "page_token_count": 54.0, "text": "233      if(k%2) p*=n, k--;    else n*=n, k/=2;   if  k mod 2<>0 then     begin p:=p*n; dec(k)      end    else      begin n:=n*n; k:=k div 2        end;  a) O(log2k) b) O(log2n)  c) O(k)  d) O(n)  e) O(n2)  f) O(k2)", "sentences": ["233      if(k%2) p*=n, k--;    else n*=n, k/=2;   if  k mod 2<>0 then     begin p:=p*n; dec(k)      end    else      begin n:=n*n; k:=k div 2        end;  a) O(log2k) b) O(log2n)  c) O(k)  d) O(n)  e) O(n2)  f) O(k2)"], "page_sentence_count_spacy": 1}, {"page_number": 234, "page_char_count": 1558, "page_word_count": 441, "page_sentence_count_raw": 8, "page_token_count": 389.5, "text": "234    Varianta 44  1.  Variabila v re\u021bine un num\u0103r \u00eentreg. Indica\u021bi ce valoare va avea v dup\u0103 executarea  urm\u0103toarei secven\u021be de instruc\u021biuni?    Limbajul C++/C  v=2;    v=5*v-v%3;    v=v+v/3;    Limbajul Pascal  v:=2;    v:=5*v-v mod 3;    v:=v+v div 3;  a) 7  b) 8  c) 10  d) 11  e) 12  f) 16    2.  Variabilele x \u0219i y sunt reale, iar i \u0219i j sunt \u00eentregi.  Indica\u021bi ce valoare va avea x dup\u0103  executarea urm\u0103toarei secven\u021be de instruc\u021biuni?    Limbajul C++/C  x=1.5; y=2.0;   i=2; j=4;   x=x*y+(float)i/j;    Limbajul Pascal  x:=1.5; y:=2.0;  i:=2; j:=4;   x:=x*y+i/j;  a) 2.15  b) 2.5  c) 3.0  d) 3.15  e) 3.5  f) 4.0    3.  Variabilele i \u0219i j sunt \u00eentregi. Indica\u021bi ce se va afi\u0219a dup\u0103 executarea urm\u0103toarei  secven\u021be?    Limbajul C++/C  i=2; j=3;   if(j) j--;     else if(i) i++;           else j++;  if(!j) i--;     else if(i) j++;           else j=0;  cout<<i+j;\u2502printf(\"%d\",i+ j);    Limbajul Pascal  i:=2; j:=3;   if j<>0 then dec(j)     else if i<>0 then                      inc(i)              else inc(j);  if not(j<>0)then inc(i)       else if(i<>0)then                    inc(j)              else j:=0;  write(i+j);  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    4.  Indica\u021bi ce se va afi\u0219a dup\u0103 executarea urm\u0103toarei secven\u021be de program?  Limbajul C++/C  int main()   {  char s[11]=\"ABCDE\",aux[11];    strcat(s+2,\"ABCDE\");  strcpy(aux, s+3);       strcpy(s,aux);   cout<<s[0]-s[2];  \u2502printf(\"%d\",s[0]-s[2]);    return 0;}  Limbajul Pascal  var s:string;  begin     s:='ABCDE';      s:=s+'ABCDE';     delete(s,1,3);  write(ord(s[1])-ord(s[3]));  end.", "sentences": ["234    Varianta 44  1.", " Variabila v re\u021bine un num\u0103r \u00eentreg.", "Indica\u021bi ce valoare va avea v dup\u0103 executarea  urm\u0103toarei secven\u021be de instruc\u021biuni?", "   Limbajul C++/C  v=2;    v=5*v-v%3;    v=v+v/3;    Limbajul Pascal  v:=2;    v:=5*v-v mod 3;    v:=v+v div 3;  a) 7  b) 8  c) 10  d) 11  e) 12  f) 16    2.", " Variabilele x \u0219i y sunt reale, iar i \u0219i j sunt \u00eentregi.", " Indica\u021bi ce valoare va avea x dup\u0103  executarea urm\u0103toarei secven\u021be de instruc\u021biuni?", "   Limbajul C++/C  x=1.5; y=2.0;   i=2; j=4;   x=x*y+(float)i/j;    Limbajul Pascal  x:=1.5; y:=2.0;  i:=2; j:=4;   x:=x*y+i/j;  a) 2.15  b) 2.5  c) 3.0  d) 3.15  e) 3.5  f) 4.0    3.", " Variabilele i \u0219i j sunt \u00eentregi.", "Indica\u021bi ce se va afi\u0219a dup\u0103 executarea urm\u0103toarei  secven\u021be?", "   Limbajul C++/C  i=2; j=3;   if(j) j--;     else if(i) i++;           else j++;  if(!j) i--;     else if(i) j++;           else j=0;  cout<<i+j;\u2502printf(\"%d\",i+ j);    Limbajul Pascal  i:=2; j:=3;   if j<>0 then dec(j)     else if i<>0 then                      inc(i)              else inc(j);  if not(j<>0)then inc(i)       else if(i<>0)then                    inc(j)              else j:=0;  write(i+j);  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    4.", " Indica\u021bi ce se va afi\u0219a dup\u0103 executarea urm\u0103toarei secven\u021be de program?", " Limbajul C++/C  int main()   {  char s[11]=\"ABCDE\",aux[11];    strcat(s+2,\"ABCDE\");  strcpy(aux, s+3);       strcpy(s,aux);   cout<<s[0]-s[2];  \u2502printf(\"%d\",s[0]-s[2]);    return 0;}  Limbajul Pascal  var s:string;  begin     s:='ABCDE';      s:=s+'ABCDE';     delete(s,1,3);  write(ord(s[1])-ord(s[3]));  end."], "page_sentence_count_spacy": 12}, {"page_number": 235, "page_char_count": 1478, "page_word_count": 436, "page_sentence_count_raw": 4, "page_token_count": 369.5, "text": "235    a) 0   b) 1  c) 2  d) 3  e) 4  f) 5     5.  Indica\u021bi ce se va afi\u0219a dup\u0103 executarea urm\u0103toarei secven\u021be de  program?    Limbajul C++  typedef struct        { int S;}S;  int f(S &s)  {return -- s.S;}  int main()  { int i;    S S={2};    i=f(S);    cout<<i;    return 0;    Limbajul C  typedef struct   { int S;}S;  int f(S *s)  {   return --(*s).S;}  int main()  { int i;    S S={2};    i=f(&S);    printf(\"%d\",i);    return 0;  }    Limbajul Pascal  type ST=record   S:integer end;  var S:ST=(S:2);       i:integer;  function f(var   s:ST):integer;  begin  dec(s.S);f:=s.S   end;  begin   i:=f(S);write(i)  end.  a) 0  b) 1  c) 2  d) 3    e) 4  f) eroare de compilare    6.  Indica\u021bi cu ce instruc\u021biune trebuie \u00eenlocuite punctele de suspensie din urm\u0103toarea  secven\u021b\u0103, astfel \u00eenc\u00e2t aceasta s\u0103 afi\u0219eze num\u0103rul de divizori pozitivi ai lui n (num\u0103r  natural nenul)?    Limbajul C++/C  int p=1,d,e;  for(d=2;d*d<=n;++d)  {    for(e=1;n%d==0;e++)       n/=d;    p*=e;  }  if(n>1) \u2026\u2026  cout<<p;\u2502printf(\"%d\",p);    Limbajul Pascal  var p,d,e:integer;  p:=1; d:=2;  while d*d<=n do   begin     e:=1;     while n mod d=0 do          begin            n:=n div d;               inc(e)         end;      p:=p*e   end;  if n>1 then \u2026  write(p);    a)    Limbajul C++/C    p*=2;   Limbajul Pascal    p:=p*2;  b)    Limbajul C++/C    p*=d;   Limbajul Pascal     p:=p*d;  c)  Limbajul C++/C   p*=d+1;   LimbajulPascal   p:=p*(d+1);  d)Limbajul C++/C    e)Limbajul C++/C   f)Limbajul C++/C", "sentences": ["235    a) 0   b) 1  c) 2  d) 3  e) 4  f) 5     5.", " Indica\u021bi ce se va afi\u0219a dup\u0103 executarea urm\u0103toarei secven\u021be de  program?", "   Limbajul C++  typedef struct        { int S;}S;  int f(S &s)  {return -- s.S;}  int main()  { int i;    S S={2};    i=f(S);    cout<<i;    return 0;    Limbajul C  typedef struct   { int S;}S;  int f(S *s)  {   return --(*s).S;}  int main()  { int i;    S S={2};    i=f(&S);    printf(\"%d\",i);    return 0;  }    Limbajul Pascal  type ST=record   S:integer end;  var S:ST=(S:2);       i:integer;  function f(var   s:ST):integer;  begin  dec(s.", "S);f:=s.", "S   end;  begin   i:=f(S);write(i)  end.", " a) 0  b) 1  c) 2  d) 3    e) 4  f) eroare de compilare    6.", " Indica\u021bi cu ce instruc\u021biune trebuie \u00eenlocuite punctele de suspensie din urm\u0103toarea  secven\u021b\u0103, astfel \u00eenc\u00e2t aceasta s\u0103 afi\u0219eze num\u0103rul de divizori pozitivi ai lui n (num\u0103r  natural nenul)?", "   Limbajul C++/C  int p=1,d,e;  for(d=2;d*d<=n;++d)  {    for(e=1;n%d==0;e++)       n/=d;    p*=e;  }  if(n>1) \u2026\u2026  cout<<p;\u2502printf(\"%d\",p);    Limbajul Pascal  var p,d,e:integer;  p:=1; d:=2;  while d*d<=n do   begin     e:=1;     while n mod d=0 do          begin            n:=n div d;               inc(e)         end;      p:=p*e   end;  if n>1 then \u2026  write(p);    a)    Limbajul C++/C    p*=2;   Limbajul Pascal    p:=p*2;  b)    Limbajul C++/C    p*=d;   Limbajul Pascal     p:=p*d;  c)  Limbajul C++/C   p*=d+1;   LimbajulPascal   p:=p*(d+1);  d)Limbajul C++/C    e)Limbajul C++/C   f)Limbajul C++/C"], "page_sentence_count_spacy": 8}, {"page_number": 236, "page_char_count": 1473, "page_word_count": 377, "page_sentence_count_raw": 5, "page_token_count": 368.25, "text": "236    p*=e;   Limbajul Pascal     p:=p*e;  p*=(e+1);  LimbajulPascal   p:=p*(e+1);  p*=(d+1);  LimbajulPascal   p:=p*(d+1);    7.  Urm\u0103toarea secven\u021b\u0103 afi\u0219eaz\u0103 num\u0103rul de perechi de elemente din vectorul v, cu  proprietatea c\u0103 suma celor dou\u0103 elemente din pereche este divizibil\u0103 cu k (k<100).  Se num\u0103r\u0103 numai perechile (v[i];v[j]) cu proprietatea enun\u021bat\u0103 care au i<j, unde  i \u0219i j sunt numere naturale, i<n, j<n. Indica\u021bi cu ce expresie trebuie \u00eenlocuite  punctele de suspensie?    Limbajul C++/C  int v[100],n,k;  cin>>n>>k;     \u2502scanf(\"%d%d\",&n,&k);  for(int i = 0; i<n; ++i)        cin>>v[i];\u2502scanf(\"%d\",&v [i]);  int x[100]={0};   for (int i=0; i<n;i++)       ++x[v[i]%k];   int sum = x[0]*(x[0]- 1)/2;   for(int i=1; i<=k/2 &&     i!=(k-i); i++)       sum += x[i] * x[k-i];  if (k % 2 == 0) sum +=\u2026;   cout<<sum;     \u2502printf(\"%d\",sum);    Limbajul Pascal  var n,k,i,sum:integer;  v,x:array[0..99] of integer;  begin    readln(n,k);    for i:=0 to n-1 do          readln(v[i]);    for i:=0 to n-1 do         inc(x[v[i] mod k]);    sum:=x[0]*(x[0]-1)div 2;    i:=1;    while (i<=k div 2) and        (i<>(k-i)) do         begin        sum:=sum+x[i]*x[k-i];        inc(i)       end;    if k mod 2=0 then       sum:=sum+\u2026;     write(sum);  end.  a)  x[k]  b)  x[n]    c)  x[k]*x[k]    d)  Limbajul C++/C  x[k]*(x[k]-1)/2  Limbajul Pascal   x[k]*(x[k]-1) div 2  e)    Limbajul C++/C  x[k/2]*(x[k/2]-1)/2  Limbajul Pascal  x[k div 2]* (x[k div 2]-1)  div  2  f) x[n]*x[n]", "sentences": ["236    p*=e;   Limbajul Pascal     p:=p*e;  p*=(e+1);  LimbajulPascal   p:=p*(e+1);  p*=(d+1);  LimbajulPascal   p:=p*(d+1);    7.", " Urm\u0103toarea secven\u021b\u0103 afi\u0219eaz\u0103 num\u0103rul de perechi de elemente din vectorul v, cu  proprietatea c\u0103 suma celor dou\u0103 elemente din pereche este divizibil\u0103 cu k (k<100).", " Se num\u0103r\u0103 numai perechile (v[i];v[j]) cu proprietatea enun\u021bat\u0103 care au i<j, unde  i \u0219i j sunt numere naturale, i<n, j<n. Indica\u021bi cu ce expresie trebuie \u00eenlocuite  punctele de suspensie?", "   Limbajul C++/C  int v[100],n,k;  cin>>n>>k;     \u2502scanf(\"%d%d\",&n,&k);  for(int i = 0; i<n; ++i)        cin>>v[i];\u2502scanf(\"%d\",&v [i]);  int x[100]={0};   for (int i=0; i<n;i++)       ++x[v[i]%k];   int sum = x[0]*(x[0]- 1)/2;   for(int i=1; i<=k/2 &&     i!=(k-i); i++)       sum += x[i] * x[k-i];  if (k % 2 == 0) sum +=\u2026;   cout<<sum;     \u2502printf(\"%d\",sum);    Limbajul Pascal  var n,k,i,sum:integer;  v,x:array[0..99] of integer;  begin    readln(n,k);    for i:=0 to n-1 do          readln(v[i]);    for i:=0 to n-1 do         inc(x[v[i] mod k]);    sum:=x[0]*(x[0]-1)div 2;    i:=1;    while (i<=k div 2) and        (i<>(k-i)) do         begin        sum:=sum+x[i]*x[k-i];        inc(i)       end;    if k mod 2=0 then       sum:=sum+\u2026;     write(sum);  end.", " a)  x[k]  b)  x[n]    c)  x[k]*x[k]    d)  Limbajul C++/C  x[k]*(x[k]-1)/2  Limbajul Pascal   x[k]*(x[k]-1) div 2  e)    Limbajul C++/C  x[k/2]*(x[k/2]-1)/2  Limbajul Pascal  x[k div 2]* (x[k div 2]-1)  div  2  f) x[n]*x[n]"], "page_sentence_count_spacy": 5}, {"page_number": 237, "page_char_count": 1913, "page_word_count": 539, "page_sentence_count_raw": 7, "page_token_count": 478.25, "text": "237    8.  Variabilele i \u015fi j sunt de tip \u00eentreg, iar variabila a memoreaz\u0103 un tablou bidimensional  cu n linii \u015fi n coloane, numerotate de la 0 la n-1, av\u00e2nd ini\u0163ial toate elementele egale  cu -1. Matricea se \u00eemparte \u00een 4 cadrane astfel:    Indica\u021bi cu ce instruc\u021biune trebuie \u00eenlocuite punctele de suspensie astfel \u00eenc\u00e2t, \u00een urma  execut\u0103rii secven\u0163ei ob\u0163inute, tabloul a s\u0103 memoreze \u00een cadranul I, doar valoarea 1, \u00een  cadranul II, doar valoarea 2, \u00een cadranul III doar valoarea 3 iar \u00een ultimul cadran doar  valoarea 4.  LimbajC++/C  for (i=0; i<n/2; i++)    for  (j=i+1;  j<n-i-1;  j++)    {      a[i][j]=1;      \u2026;      a[n-i-1][j]=3;      a[j][i]=4;   }  Limbaj Pascal  for  i:=0 to n div 2-1 do     for j:=i+1 to n-i-2 do            begin               a[i,j]:=1;               \u2026;               a[n-i-1,j]:=3;               a[j,i]:=4              end;  a)       Limbajul C++/C   a[i][n-j]=2;    Limbajul Pascal    a[i,n-j]:=2;  b)     Limbajul C++/C    a[n-i][n-j]=2;     Limbajul Pascal     a[n-i,n-j]:=2;    c)    Limbajul C++/C   a[n-j-1][n-i-1]=2;    Limbajul Pascal    a[n-j-1,n-i-1]:=2;   d)   Limbajul C++/C  a[n-j][n-i]=2;   Limbajul Pascal   a[n-j,n-i]:=2;    e)    Limbajul C++/C   a[j][n-i]=2;    Limbajul Pascal    a[j][n-i]:=2;    f)    Limbajul C++/C   a[i][i]=2;    Limbajul Pascal    a[i][i]:=2;    9.  Fie func\u021bia recursiv\u0103 de mai jos. Indiva\u021bi ce valoare va avea apelul f(16)?    Limbajul C++/C  int f(int x)   {if(x>8)     return f(f(x-3))+4;    else return x-5;  }    Limbajul Pascal  function f(x:integer):integer;  begin   if x>8 then           f:=f(f(x-3))+4      else f:=x-5;  end;  a) -5  b) -2  c) -1  d) 1  e) 2  f) 5    10.  Indica\u021bi c\u00e2te componente tare conexe are graful orientat G=(V,E) unde V={1, 2, 3,  4, 5, 6, 7, 8, 9, 10} iar E={(1,2), (1,7), (1,10), (2,6),  (3,2), (3,5), (3,9), (4,3), (4,6), (5,2), (6,1), (8,7),  (9,6), (9,8)}?   a) 6  b) 7  c) 8   d) 9  e) 10  f) 5", "sentences": ["237    8.", " Variabilele i \u015fi j sunt de tip \u00eentreg, iar variabila a memoreaz\u0103 un tablou bidimensional  cu n linii \u015fi n coloane, numerotate de la 0 la n-1, av\u00e2nd ini\u0163ial toate elementele egale  cu -1.", "Matricea se \u00eemparte \u00een 4 cadrane astfel:    Indica\u021bi cu ce instruc\u021biune trebuie \u00eenlocuite punctele de suspensie astfel \u00eenc\u00e2t, \u00een urma  execut\u0103rii secven\u0163ei ob\u0163inute, tabloul a s\u0103 memoreze \u00een cadranul I, doar valoarea 1, \u00een  cadranul II, doar valoarea 2, \u00een cadranul III doar valoarea 3 iar \u00een ultimul cadran doar  valoarea 4.", " LimbajC++/C  for (i=0; i<n/2; i++)    for  (j=i+1;  j<n-i-1;  j++)    {      a[i][j]=1;      \u2026;      a[n-i-1][j]=3;      a[j][i]=4;   }  Limbaj Pascal  for  i:=0 to n div 2-1 do     for j:=i+1 to n-i-2 do            begin               a[i,j]:=1;               \u2026;               a[n-i-1,j]:=3;               a[j,i]:=4              end;  a)       Limbajul C++/C   a[i][n-j]=2;    Limbajul Pascal    a[i,n-j]:=2;  b)     Limbajul C++/C    a[n-i][n-j]=2;     Limbajul Pascal     a[n-i,n-j]:=2;    c)    Limbajul C++/C   a[n-j-1][n-i-1]=2;    Limbajul Pascal    a[n-j-1,n-i-1]:=2;   d)   Limbajul C++/C  a[n-j][n-i]=2;   Limbajul Pascal   a[n-j,n-i]:=2;    e)    Limbajul C++/C   a[j][n-i]=2;    Limbajul Pascal    a[j][n-i]:=2;    f)    Limbajul C++/C   a[i][i]=2;    Limbajul Pascal    a[i][i]:=2;    9.", " Fie func\u021bia recursiv\u0103 de mai jos.", "Indiva\u021bi ce valoare va avea apelul f(16)?", "   Limbajul C++/C  int f(int x)   {if(x>8)     return f(f(x-3))+4;    else return x-5;  }    Limbajul Pascal  function f(x:integer):integer;  begin   if x>8 then           f:=f(f(x-3))+4      else f:=x-5;  end;  a) -5  b) -2  c) -1  d) 1  e) 2  f) 5    10.", " Indica\u021bi c\u00e2te componente tare conexe are graful orientat G=(V,E) unde V={1, 2, 3,  4, 5, 6, 7, 8, 9, 10} iar E={(1,2), (1,7), (1,10), (2,6),  (3,2), (3,5), (3,9), (4,3), (4,6), (5,2), (6,1), (8,7),  (9,6), (9,8)}?", "  a) 6  b) 7  c) 8   d) 9  e) 10  f) 5"], "page_sentence_count_spacy": 9}, {"page_number": 238, "page_char_count": 1773, "page_word_count": 469, "page_sentence_count_raw": 12, "page_token_count": 443.25, "text": "238      11.  Folosind metoda backtracking, se determin\u0103 \u00een ordine lexicografic\u0103, toate cuvintele de 6  litere distincte din mul\u021bimea {a, e, i, o, u, b, c, d, m, n, p}, oricare  dou\u0103 litere al\u0103turate neput\u00e2nd fi vocale. Primele 5 solu\u021bii sunt: abecid, abecim,  abecin, abecip, abecod. Indica\u021bi care cuv\u00e2nt este generat \u00eenaintea solu\u021biei  ebacid?   a) mnpdb  b) apcdmn   c) apmncd  d) apmndc  e) apnmdc  f)   ebdcpa    12.  Fie un graf neorientat G cu 1002 noduri numerotate cu numere naturale consecutive de  la 1 la 1002. \u0218tiind c\u0103 oricare dou\u0103 noduri de aceea\u0219i paritate sunt adiacente, se cere s\u0103  indica\u021bi cum trebuie modificat graful, astfel \u00eenc\u00e2t acesta s\u0103 devin\u0103 eulerian.  a) se elimin\u0103 dou\u0103 muchii    b) se elimin\u0103 o muchie \u0219i se  adaug\u0103 dou\u0103 muchii noi  c) se adaug\u0103 dou\u0103 muchii  noi  d) se elimin\u0103  o muchie  e) se adaug\u0103  trei muchii noi  f) se elimin\u0103 trei muchii    13.  Fie un arbore cu r\u0103d\u0103cin\u0103 care are 5000 de noduri iar fiecare nod are maxim 4 fii.  Indica\u021bi care este \u00een\u0103l\u021bimea minim\u0103 a arborelui?  a) 4  b) 5  c) 6  d) 7  e) 8  f) 9    14.  Indica\u021bi care este complexitatea urm\u0103toarei func\u021bii?    Limbajul C++/C   void f(int n)    {int i ,j,nr=0;     for(i=n/2; i<=n; i++)        for(j=n; j>=1; j/=2)               nr++;    }    Limbajul Pascal  procedure f(n:integer);  var i,j,nr:integer;  begin   for i:=n div 2 to n do          begin        j:=n;        while j>=1 do          begin            inc(nr);           j:=j div 2          end     end  end;  a) O(logn)  b) O(n2)  c) O(n2logn)  d) O(nlogn)  e) O(n)  f) O(n3)    15.  Fie x, a0, a1, ..., an numere reale nenule. Indica\u021bi num\u0103rul minim de \u00eenmul\u021biri  care este necesar pentru a calcula optim a0+a1*x+a2*x2+a3*x3+...+an*xn?  a) n-1  b) n  c)  \ud835\udc5b 2  d)   (\ud835\udc5b+1)(\ud835\udc5b+2) 2   e) n-2  f)  (\ud835\udc5b\u22121)(\ud835\udc5b+1) 2", "sentences": ["238      11.", " Folosind metoda backtracking, se determin\u0103 \u00een ordine lexicografic\u0103, toate cuvintele de 6  litere distincte din mul\u021bimea {a, e, i, o, u, b, c, d, m, n, p}, oricare  dou\u0103 litere al\u0103turate neput\u00e2nd fi vocale.", "Primele 5 solu\u021bii sunt: abecid, abecim,  abecin, abecip, abecod.", "Indica\u021bi care cuv\u00e2nt este generat \u00eenaintea solu\u021biei  ebacid?", "  a) mnpdb  b) apcdmn   c) apmncd  d) apmndc  e) apnmdc  f)   ebdcpa    12.", " Fie un graf neorientat G cu 1002 noduri numerotate cu numere naturale consecutive de  la 1 la 1002.", "\u0218tiind c\u0103 oricare dou\u0103 noduri de aceea\u0219i paritate sunt adiacente, se cere s\u0103  indica\u021bi cum trebuie modificat graful, astfel \u00eenc\u00e2t acesta s\u0103 devin\u0103 eulerian.", " a) se elimin\u0103 dou\u0103 muchii    b) se elimin\u0103 o muchie \u0219i se  adaug\u0103 dou\u0103 muchii noi  c) se adaug\u0103 dou\u0103 muchii  noi  d) se elimin\u0103  o muchie  e) se adaug\u0103  trei muchii noi  f) se elimin\u0103 trei muchii    13.", " Fie un arbore cu r\u0103d\u0103cin\u0103 care are 5000 de noduri iar fiecare nod are maxim 4 fii.", " Indica\u021bi care este \u00een\u0103l\u021bimea minim\u0103 a arborelui?", " a) 4  b) 5  c) 6  d) 7  e) 8  f) 9    14.", " Indica\u021bi care este complexitatea urm\u0103toarei func\u021bii?", "   Limbajul C++/C   void f(int n)    {int i ,j,nr=0;     for(i=n/2; i<=n; i++)        for(j=n; j>=1; j/=2)               nr++;    }    Limbajul Pascal  procedure f(n:integer);  var i,j,nr:integer;  begin   for i:=n div 2 to n do          begin        j:=n;        while j>=1 do          begin            inc(nr);           j:=j div 2          end     end  end;  a) O(logn)  b) O(n2)  c) O(n2logn)  d) O(nlogn)  e) O(n)  f) O(n3)    15.", " Fie x, a0, a1, ..., an numere reale nenule.", "Indica\u021bi num\u0103rul minim de \u00eenmul\u021biri  care este necesar pentru a calcula optim a0+a1*x+a2*x2+a3*x3+...+an*xn?", " a) n-1  b) n  c)  \ud835\udc5b 2  d)   (\ud835\udc5b+1)(\ud835\udc5b+2) 2   e) n-2  f)  (\ud835\udc5b\u22121)(\ud835\udc5b+1) 2"], "page_sentence_count_spacy": 16}, {"page_number": 239, "page_char_count": 1495, "page_word_count": 349, "page_sentence_count_raw": 9, "page_token_count": 373.75, "text": "239    Varianta 45  1. Variabilele \u00eentregi i, j, k memoreaz\u0103 numere naturale. Valoarea variabilei k dup\u0103  rularea urm\u0103toarei secven\u021be de instruc\u021biuni este?  Limbajul C/C++  i=4; j=5; k=--i*j++;  Limbajul Pascal  i:=4;j:=5;dec(i);  k:=i*j;inc(j);  a) 12  b) 13  c) 14  d) 15  e) 16  f) 17    2. Variabilele \u00eentregi i, j, k memoreaz\u0103 numere naturale. Valoarea variabilei k, dup\u0103  rularea urm\u0103toarei secven\u021be de instruc\u021biuni, este?  Limbajul C/C++  i=3; j=-3; k=i*j;  k+=j;  k/=i;  Limbajul Pascal  i:=3; j:=-3; k:=i*j; k:=k+j; k:=k div  i;  a) -8  b) -6  c) -4  d) 4  e) 6  f) 8    3. Variabilele \u00eentregi i, j, k memoreaz\u0103 numere naturale. Dup\u0103 rularea urm\u0103toarei  secven\u021be de instruc\u021biuni se va afi\u0219a?  Limbajul C/C++  i=2; j=-2; if(j) i--;  if(i) j++; k=i*j;   cout<<k;\u2502printf(\"%d\",k);  Limbajul Pascal  i:=2; j:=-2;   if j<>0 then dec(i);  if(i<>0) then inc(j); k:=i*j;  write(k);  a) -2  b) -1  c) 0  d) 1  e) 2  f) 3    4. Dup\u0103 rularea urm\u0103torului program se afi\u0219eaz\u0103?  Limbajul C++  #include<iostream>  using namespace std;  int f(int&i)  {   return i++;  }  int main(){    int i=1,j;   j=f(i);    cout<<i<<' '<<j;  return 0;  }  Limbajul C  #include <stdio.h>  int f(int *i)   {     return (*i)++;  }  int main() {   int i=1,j;  j=f(&i);  printf(\"%d %d\",i,j);  return 0;  }  Limbajul Pascal  var i,j:integer;  function f(var  i:integer):integer;  begin     f:= i; inc(i)  end;  begin    i:=1; j:=f(i);    write(i, ' ',j)  end.  a) 0 2  b) 1 1  c) 1 2  d) 2 1  e) 2 2  f) eroare de compilare", "sentences": ["239    Varianta 45  1.", "Variabilele \u00eentregi i, j, k memoreaz\u0103 numere naturale.", "Valoarea variabilei k dup\u0103  rularea urm\u0103toarei secven\u021be de instruc\u021biuni este?", " Limbajul C/C++  i=4; j=5; k=--i*j++;  Limbajul Pascal  i:=4;j:=5;dec(i);  k:=i*j;inc(j);  a) 12  b) 13  c) 14  d) 15  e) 16  f) 17    2.", "Variabilele \u00eentregi i, j, k memoreaz\u0103 numere naturale.", "Valoarea variabilei k, dup\u0103  rularea urm\u0103toarei secven\u021be de instruc\u021biuni, este?", " Limbajul C/C++  i=3; j=-3; k=i*j;  k+=j;  k/=i;  Limbajul Pascal  i:=3; j:=-3; k:=i*j; k:=k+j; k:=k div  i;  a) -8  b) -6  c) -4  d) 4  e) 6  f) 8    3.", "Variabilele \u00eentregi i, j, k memoreaz\u0103 numere naturale.", "Dup\u0103 rularea urm\u0103toarei  secven\u021be de instruc\u021biuni se va afi\u0219a?", " Limbajul C/C++  i=2; j=-2; if(j) i--;  if(i) j++; k=i*j;   cout<<k;\u2502printf(\"%d\",k);  Limbajul Pascal  i:=2; j:=-2;   if j<>0 then dec(i);  if(i<>0) then inc(j); k:=i*j;  write(k);  a) -2  b) -1  c) 0  d) 1  e) 2  f) 3    4.", "Dup\u0103 rularea urm\u0103torului program se afi\u0219eaz\u0103?", " Limbajul C++  #include<iostream>  using namespace std;  int f(int&i)  {   return i++;  }  int main(){    int i=1,j;   j=f(i);    cout<<i<<' '<<j;  return 0;  }  Limbajul C  #include <stdio.h>  int f(int *i)   {     return (*i)++;  }  int main() {   int i=1,j;  j=f(&i);  printf(\"%d %d\",i,j);  return 0;  }  Limbajul Pascal  var i,j:integer;  function f(var  i:integer):integer;  begin     f:= i; inc(i)  end;  begin    i:=1; j:=f(i);    write(i, ' ',j)  end.", " a) 0 2  b) 1 1  c) 1 2  d) 2 1  e) 2 2  f) eroare de compilare"], "page_sentence_count_spacy": 13}, {"page_number": 240, "page_char_count": 1665, "page_word_count": 376, "page_sentence_count_raw": 8, "page_token_count": 416.25, "text": "240    5. Dup\u0103 rularea programului de mai jos se afi\u0219eaz\u0103?  Limbajul C++  #include<iostream>  using namespace std;  struct S    {int a[2];};  int main()   {  S S[2]; int i;  for(i=0;i<2;i++)  S[i].a[1-i]=4*!i;  cout<<S[0].a[1];   return 0;  }  Limbajul C  #include <stdio.h>  struct S    {int a[2];};  int main() {  struct S S[2];     int i;  for(i=0;i<2;i++)   S[i].a[1-i]=4*!i;  printf(\"%d\",  S[0].a[1]);  return 0;}  Limbajul Pascal  type ST=record    a:array[0..1] of    integer    end;  var S:array[0..1] of  ST;  i:integer;  begin  for i:=0 to 1 do  S[i].a[1-i]:=         4*(1-i);  write(S[0].a[1])  end.  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    6. Variabilele \u00eentregi i,x memoreaz\u0103 numere naturale. Num\u0103rul de numere afi\u0219ate dup\u0103  executarea urm\u0103toarei secven\u021be de instruc\u021biuni este?  Limbajul C/C++  for(i=1;i<=10000;i++)  {x=i-4;  while(x>2  &&(x%10==0||x%10==2))     x=x/10, x=x-4;   if(x==0 || x==2)    cout<<i;\u2502printf(\"%d\",i);  }  Limbajul Pascal  for i:=1 to 10000 do begin   x:=i-4;   while (x>2) and ((x mod    10=0)or(x mod 10=2)) do   begin     x:=x div 10; x:=x-4    end;   if (x=0) or (x=2) then      write(i)  end;  a) 100  b) 50  c) 45  d) 40  e) 35  f) 30    7. Tabloul bidimensional a,p\u0103tratic, are liniile \u0219i coloanele numerotate de la 1 la 1000 \u0219i  este \u00eemp\u0103r\u021bit \u00een 4 zone delimitate de diagonale, ca \u00een desen . Variabilele \u00eentregi  i, j, s memoreaz\u0103 numere naturale. Elementele care sunt adunate \u00een algoritmul  urm\u0103tor se g\u0103sesc \u00een zona/zonele?  Limbajul C/C++  s=0;  for(i=120;i<=380;++i)    for(j=i+1;j<=1000-i;j++)  s+=a[1001-j][1001-i];  Limbajul Pascal  s:=0;  for i:=120 to 380 do    for j:=i+1 to 1000-i   do    s:=s+a[1001-j,1001-i];", "sentences": ["240    5.", "Dup\u0103 rularea programului de mai jos se afi\u0219eaz\u0103?", " Limbajul C++  #include<iostream>  using namespace std;  struct S    {int a[2];};  int main()   {  S S[2]; int i;  for(i=0;i<2;i++)  S[i].a[1-i]=4*!i;  cout<<S[0].a[1];   return 0;  }  Limbajul C  #include <stdio.h>  struct S    {int a[2];};  int main() {  struct S S[2];     int i;  for(i=0;i<2;i++)   S[i].a[1-i]=4*!i;  printf(\"%d\",  S[0].a[1]);  return 0;}  Limbajul Pascal  type ST=record    a:array[0..1] of    integer    end;  var S:array[0..1] of  ST;  i:integer;  begin  for i:=0 to 1 do  S[i].a[1-i]:=         4*(1-i);  write(S[0].a[1])  end.", " a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    6.", "Variabilele \u00eentregi i,x memoreaz\u0103 numere naturale.", "Num\u0103rul de numere afi\u0219ate dup\u0103  executarea urm\u0103toarei secven\u021be de instruc\u021biuni este?", " Limbajul C/C++  for(i=1;i<=10000;i++)  {x=i-4;  while(x>2  &&(x%10==0||x%10==2))     x=x/10, x=x-4;   if(x==0 || x==2)    cout<<i;\u2502printf(\"%d\",i);  }  Limbajul Pascal  for i:=1 to 10000 do begin   x:=i-4;   while (x>2) and ((x mod    10=0)or(x mod 10=2)) do   begin     x:=x div 10; x:=x-4    end;   if (x=0) or (x=2) then      write(i)  end;  a) 100  b) 50  c) 45  d) 40  e) 35  f) 30    7.", "Tabloul bidimensional a,p\u0103tratic, are liniile \u0219i coloanele numerotate de la 1 la 1000 \u0219i  este \u00eemp\u0103r\u021bit \u00een 4 zone delimitate de diagonale, ca \u00een desen .", "Variabilele \u00eentregi  i, j, s memoreaz\u0103 numere naturale.", "Elementele care sunt adunate \u00een algoritmul  urm\u0103tor se g\u0103sesc \u00een zona/zonele?", " Limbajul C/C++  s=0;  for(i=120;i<=380;++i)    for(j=i+1;j<=1000-i;j++)  s+=a[1001-j][1001-i];  Limbajul Pascal  s:=0;  for i:=120 to 380 do    for j:=i+1 to 1000-i   do    s:=s+a[1001-j,1001-i];"], "page_sentence_count_spacy": 11}, {"page_number": 241, "page_char_count": 1591, "page_word_count": 331, "page_sentence_count_raw": 5, "page_token_count": 397.75, "text": "241    a) I  b) I \u0219i II  c) II  d) II \u0219i III  e) II \u0219i IV  d) IV    8.   Dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni se afi\u0219eaz\u0103?  Limbajul C/C++  char s[100]=\"UPB- automatica\",*p;  p=strchr(s,'-');  (p+1)[0]-=32; s[p-s]='\\0';  p++; strcat(p,\"-\");  strcat(p,s); strcpy(s,p);  cout<<s;\u2502printf(\"%s\",s);  Limbajul Pascal  var s,p:string; i:integer;  s:='UPB-automatica'; i:=pos('- ',s);  s[i+1]:=chr(ord(s[i+1])-32);  p:=copy(s,i+1,length(s)-i);  delete(s,i,length(s)-i+1);  s:=p+'-'+s;  write(s);  a) Auto  b) Automatica-UPB  c) Auto-UPB  d) UPB  e) automatica-UPB  f) automatica-UPB-automatica    9. Pentru ca tabloul unidimensional a s\u0103 fie ordonat cresc\u0103tor dup\u0103 rularea secven\u021bei de  instruc\u021biuni de mai jos, punctele de suspensie se \u00eenlocuiesc cu?  Limbajul C/C++  int a[10]={8, 2, 1, 9,  10, 3, 7, 5, 4, 6},   b[10]={ 0 }, c[10],i, j;  for(i=0;i<10;++i)    for(j=i+1;j<10;++j)      if(...)  b[i]++;      else b[j]++;  for(i=0;i<10;i++)    c[b[i]]=a[i];  for(i=0;i<10;i++)    a[i]=c[i];  Limbajul Pascal  var a:array[0..9] of integer=    (8,2,1,9,10,3,7,5,4,6);  b, c:array[0..9] of integer;  i, j:integer;  for i:=0 to 9 do       for j:=i+1 to 9 do         if ..... then inc(b[i])        else inc(b[j]);  for i:=0 to 9 do    c[b[i]]:=a[i];  for i:=0 to 9 do a[i]:=c[i];  a)  a[i]<a[j]  b) a[i]<=a[j]  c) a[i]!=a[j]\u2502a[i]<>a[j]  d) a[i]==a[j]\u2502a[i]=a[j]   e)    a[i]+a[j]  f) a[i]>a[j]       10. Apelul f(19,7)are valoarea?  Limbajul C/C++  int f(int x, int y)   {  if(x>y)  Limbajul Pascal  function f(x,y:integer):integer;  begin  if x>y then f:=f(x-3,y+1)-2         else if x=y then", "sentences": ["241    a) I  b) I \u0219i II  c) II  d) II \u0219i III  e) II \u0219i IV  d) IV    8.", "  Dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni se afi\u0219eaz\u0103?", " Limbajul C/C++  char s[100]=\"UPB- automatica\",*p;  p=strchr(s,'-');  (p+1)[0]-=32; s[p-s]='\\0';  p++; strcat(p,\"-\");  strcat(p,s); strcpy(s,p);  cout<<s;\u2502printf(\"%s\",s);  Limbajul Pascal  var s,p:string; i:integer;  s:='UPB-automatica'; i:=pos('- ',s);  s[i+1]:=chr(ord(s[i+1])-32);  p:=copy(s,i+1,length(s)-i);  delete(s,i,length(s)-i+1);  s:=p+'-'+s;  write(s);  a) Auto  b) Automatica-UPB  c) Auto-UPB  d) UPB  e) automatica-UPB  f) automatica-UPB-automatica    9.", "Pentru ca tabloul unidimensional a s\u0103 fie ordonat cresc\u0103tor dup\u0103 rularea secven\u021bei de  instruc\u021biuni de mai jos, punctele de suspensie se \u00eenlocuiesc cu?", " Limbajul C/C++  int a[10]={8, 2, 1, 9,  10, 3, 7, 5, 4, 6},   b[10]={ 0 }, c[10],i, j;  for(i=0;i<10;++i)    for(j=i+1;j<10;++j)      if(...)  b[i]++;      else b[j]++;  for(i=0;i<10;i++)    c[b[i]]=a[i];  for(i=0;i<10;i++)    a[i]=c[i];  Limbajul Pascal  var a:array[0..9] of integer=    (8,2,1,9,10,3,7,5,4,6);  b, c:array[0..9] of integer;  i, j:integer;  for i:=0 to 9 do       for j:=i+1 to 9 do         if ..... then inc(b[i])        else inc(b[j]);  for i:=0 to 9 do    c[b[i]]:=a[i];  for i:=0 to 9 do a[i]:=c[i];  a)  a[i]<a[j]  b) a[i]<=a[j]  c) a[i]!=a[j]\u2502a[i]<>a[j]  d) a[i]==a[j]\u2502a[i]=a[j]   e)    a[i]+a[j]  f) a[i]>a[j]       10.", "Apelul f(19,7)are valoarea?", " Limbajul C/C++  int f(int x, int y)   {  if(x>y)  Limbajul Pascal  function f(x,y:integer):integer;  begin  if x>y then f:=f(x-3,y+1)-2         else if x=y then"], "page_sentence_count_spacy": 7}, {"page_number": 242, "page_char_count": 1664, "page_word_count": 408, "page_sentence_count_raw": 10, "page_token_count": 416.0, "text": "242      return f(x-3, y+1)- 2;   else    if(x==y)     return f(x+1, y);       else      return 3*x- 2*y;}                f:=f(x+1,y)              else f:=3*x-2*y  end;  a) -6  b) -5  c) -4  d) 4  e) 5  f) 6    11. Folosind metoda backtracking, se determin\u0103 \u00een ordine descresc\u0103toare, toate numerele de 4  cifre nenule distincte, cifrele impare apar \u00een ordine descresc\u0103toare, cele pare \u00een ordine  cresc\u0103toare \u0219i oricare dou\u0103 cifre al\u0103turate nu pot fi pare,. Primele 7 solu\u021bii sunt: 9875,  9873, 9871, 9853, 9851, 9831. Cele 3 numere generate \u00eenaintea solu\u021biei 3416  sunt?   a) 3618 3421 3418  b) 3816 4312 4316  c) 4316 3618 3418  d) 4318 4316 3618  e)4516 4318 3418  f) 4512 4516 4518    12. Fie T un arbore oarecare cu un num\u0103r par de noduri, \u00een care fiecare nod are maxim 2 fii.  Num\u0103rul maxim de noduri de pe ultimul nivel i, \u0219tiind c\u0103 r\u0103d\u0103cina arborelui se afl\u0103 pe  nivelul 1, este?  a) 2i+1  b) 2i+1  c) 2i  d) 2 \ud835\udc56+1 2   e) 2i-1  f) 2i-1 \u2013 1    13. Un graf este bipartit dac\u0103 nodurile lui pot fi \u00eemp\u0103r\u021bite \u00een dou\u0103 submul\u021bimi disjuncte,  astfel \u00eenc\u00e2t fiecare muchie are o extremitate \u00een prima submul\u021bime \u0219i cealalt\u0103 \u00een a doua  submul\u021bime. Fie G un graf neorientat, bipartit, cu 10 noduri. Num\u0103rul maxim de muchii  pe care poate s\u0103 le aib\u0103 graful G este?  a) 5  b) 15  c) 25  d) 35  e) 45  f) 55    14. Complexitatea urm\u0103toarei func\u021bii este?  Limbajul C/C++  void f(int n, int v[101])  {  int i, j=0;  for(i=0;i<n;i++)   while(j<n && v[i]<v[j])    j++;  }  Limbajul Pascal  procedure f(n:integer;    v:array[0..100] of  integer);  var i,j:integer;  begin  j:=0;  for i:=0 to n-1 do   while (j<n) and (v[i]<v[j])  do  inc(j)  end;  a) O(\u221a\ud835\udc8f)  b) O(n)  c) O(nlogn)", "sentences": ["242      return f(x-3, y+1)- 2;   else    if(x==y)     return f(x+1, y);       else      return 3*x- 2*y;}                f:=f(x+1,y)              else f:=3*x-2*y  end;  a) -6  b) -5  c) -4  d) 4  e) 5  f) 6    11.", "Folosind metoda backtracking, se determin\u0103 \u00een ordine descresc\u0103toare, toate numerele de 4  cifre nenule distincte, cifrele impare apar \u00een ordine descresc\u0103toare, cele pare \u00een ordine  cresc\u0103toare \u0219i oricare dou\u0103 cifre al\u0103turate nu pot fi pare,.", "Primele 7 solu\u021bii sunt: 9875,  9873, 9871, 9853, 9851, 9831.", "Cele 3 numere generate \u00eenaintea solu\u021biei 3416  sunt?", "  a) 3618 3421 3418  b) 3816 4312 4316  c) 4316 3618 3418  d) 4318 4316 3618  e)4516 4318 3418  f) 4512 4516 4518    12.", "Fie T un arbore oarecare cu un num\u0103r par de noduri, \u00een care fiecare nod are maxim 2 fii.", " Num\u0103rul maxim de noduri de pe ultimul nivel i, \u0219tiind c\u0103 r\u0103d\u0103cina arborelui se afl\u0103 pe  nivelul 1, este?", " a) 2i+1  b) 2i+1  c) 2i  d) 2 \ud835\udc56+1 2   e) 2i-1  f) 2i-1 \u2013 1    13.", "Un graf este bipartit dac\u0103 nodurile lui pot fi \u00eemp\u0103r\u021bite \u00een dou\u0103 submul\u021bimi disjuncte,  astfel \u00eenc\u00e2t fiecare muchie are o extremitate \u00een prima submul\u021bime \u0219i cealalt\u0103 \u00een a doua  submul\u021bime.", "Fie G un graf neorientat, bipartit, cu 10 noduri.", "Num\u0103rul maxim de muchii  pe care poate s\u0103 le aib\u0103 graful G este?", " a) 5  b) 15  c) 25  d) 35  e) 45  f) 55    14.", "Complexitatea urm\u0103toarei func\u021bii este?", " Limbajul C/C++  void f(int n, int v[101])  {  int i, j=0;  for(i=0;i<n;i++)   while(j<n && v[i]<v[j])    j++;  }  Limbajul Pascal  procedure f(n:integer;    v:array[0..100] of  integer);  var i,j:integer;  begin  j:=0;  for i:=0 to n-1 do   while (j<n) and (v[i]<v[j])  do  inc(j)  end;  a) O(\u221a\ud835\udc8f)  b) O(n)  c) O(nlogn)"], "page_sentence_count_spacy": 14}, {"page_number": 243, "page_char_count": 160, "page_word_count": 49, "page_sentence_count_raw": 1, "page_token_count": 40.0, "text": "243    e) O(n(logn)2)  d) O(n2)  f) O(n3)    15  Num\u0103rul de drumuri de lungime 3 din graful orientat al\u0103turat este?    a) 10  b) 15  c) 20   d) 25  e) 30  f) 40", "sentences": ["243    e) O(n(logn)2)  d) O(n2)  f) O(n3)    15  Num\u0103rul de drumuri de lungime 3 din graful orientat al\u0103turat este?", "   a) 10  b) 15  c) 20   d) 25  e) 30  f) 40"], "page_sentence_count_spacy": 2}, {"page_number": 244, "page_char_count": 1468, "page_word_count": 339, "page_sentence_count_raw": 6, "page_token_count": 367.0, "text": "244    Varianta 46  1. Variabila \u00eentreag\u0103 v memoreaz\u0103 numere naturale. Valoarea variabilei v dup\u0103 rularea  urm\u0103toarei secven\u021be de instruc\u021biuni este?  Limbajul C/C++  v=2;  v=v*v;  v=v-v%2*3;  v=v%3+5;  Limbajul Pascal  v:=2; v:=v*v;  v:=v-v mod 2*3;  v:=v mod 3 + 5;  a) 4   b) 5  c) 6  d) 7  e) 8   f) 9    2. Variabilele \u00eentregi i, x memoreaz\u0103 numere naturale. Num\u0103rul de numere de 5 cifre ce  vor fi afi\u0219ate dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni este?  Limbajul C/C++  for(i=1;i<=100000;i++){   x=i-5;   while(x>2&&(x%10==0||x%10==2))     x=x/10,x=x-5;   if(x==0 || x==2)    cout<<i;     \u2502printf(\"%d\",i);  }  Limbajul Pascal  for i:=1 to 100000 do  begin  x:=i-5;  while (x>2)and((x mod  10=0) or (x mod 10=2)) do   begin    x:=x div 10; x:=x-5   end;  if (x=0) or (x=2) then    write(i)  end;  a) 28  b) 29  c) 30  d) 31  e) 32  f) 33    3. Dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni se afi\u0219eaz\u0103?  Limbajul C/C++  int i=0,j=5,aux,    v[]={41,52,26,11,48,65};  while(i<j){  for(;i<j && !(v[i]%2);i++);  for(;i<j && (v[j]%2);j--);   if(i<j)  aux=v[i],v[i]=v[j],v[j]=aux;  }  for(i=0;i<6;++i)   cout<<v[i]<<\" \";\u2502     printf(\"%d \",v[i]);  Limbajul Pascal  var i,j,aux:integer;    v:array[0..5] of  integer=  (41, 52, 26,11,  48, 65);  i:=0; j:=5;  while i<j do begin    while (i<j)and(not(v[i]  mod 2=1)) do    inc(i);    while (i<j)and(v[j] mod  2=1) do dec(j);    if i<j then begin          aux:=v[i];         v[i]:=v[j];        v[j]:=aux end;  end;", "sentences": ["244    Varianta 46  1.", "Variabila \u00eentreag\u0103 v memoreaz\u0103 numere naturale.", "Valoarea variabilei v dup\u0103 rularea  urm\u0103toarei secven\u021be de instruc\u021biuni este?", " Limbajul C/C++  v=2;  v=v*v;  v=v-v%2*3;  v=v%3+5;  Limbajul Pascal  v:=2; v:=v*v;  v:=v-v mod 2*3;  v:=v mod 3 + 5;  a) 4   b) 5  c) 6  d) 7  e) 8   f) 9    2.", "Variabilele \u00eentregi i, x memoreaz\u0103 numere naturale.", "Num\u0103rul de numere de 5 cifre ce  vor fi afi\u0219ate dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni este?", " Limbajul C/C++  for(i=1;i<=100000;i++){   x=i-5;   while(x>2&&(x%10==0||x%10==2))     x=x/10,x=x-5;   if(x==0 || x==2)    cout<<i;     \u2502printf(\"%d\",i);  }  Limbajul Pascal  for i:=1 to 100000 do  begin  x:=i-5;  while (x>2)and((x mod  10=0) or (x mod 10=2)) do   begin    x:=x div 10; x:=x-5   end;  if (x=0) or (x=2) then    write(i)  end;  a) 28  b) 29  c) 30  d) 31  e) 32  f) 33    3.", "Dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni se afi\u0219eaz\u0103?", " Limbajul C/C++  int i=0,j=5,aux,    v[]={41,52,26,11,48,65};  while(i<j){  for(;i<j && !(", "v[i]%2);i++);  for(;i<j && (v[j]%2);j--);   if(i<j)  aux=v[i],v[i]=v[j],v[j]=aux;  }  for(i=0;i<6;++i)   cout<<v[i]<<\" \";\u2502     printf(\"%d \",v[i]);  Limbajul Pascal  var i,j,aux:integer;    v:array[0..5] of  integer=  (41, 52, 26,11,  48, 65);  i:=0; j:=5;  while i<j do begin    while (i<j)and(not(v[i]  mod 2=1)) do    inc(i);    while (i<j)and(v[j] mod  2=1) do dec(j);    if i<j then begin          aux:=v[i];         v[i]:=v[j];        v[j]:=aux end;  end;"], "page_sentence_count_spacy": 10}, {"page_number": 245, "page_char_count": 1425, "page_word_count": 312, "page_sentence_count_raw": 3, "page_token_count": 356.25, "text": "245    for i:=0 to 5 do   write(v[i],' ');  a) 11 26 41 48 52 65  b) 65 41 11 52 48 26  c) 26 48 52 11 41 65  d) 48 52 26 11 41 65  e) 52 48 26 65 41 11  f) 11 41 65 48 52 26    4. Dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni se afi\u0219eaz\u0103?  Limbajul C/C++  char s[50]=\"test informatica\";  char *p;  strtok(s, \" \");   p=strtok(NULL,\" \");  strcpy(s,strcat(p,s));  cout<<s;\u2502printf(\"%s\",s);  Limbajul Pascal  var s,p:string;  s:='test informatica';  p:=copy(s,pos(' ',s)+1,  length(s) - pos(' ',s));   delete(s,pos(' ',s),  length(s)-pos(' ',s)+1);  s:=p+s; write(s);  a) testtest  b) testinformatica  c) test  d) informaticatest  e) informatica  f) info    5. Pentru ca secven\u021ba urm\u0103toare de instruc\u021biuni s\u0103 determine dac\u0103 cele n intervale memorate  \u00een tabloul unidimensional v sunt disjuncte, punctele de suspensie se \u00eenlocuiesc cu?  Limbajul C/C++  struct interval{int x, y;}         v[100];   int i, j, r, t,n;  r=v[0].x; t=v[0].y;  for(i=1;i<n;++i) {    if(r<v[i].x) r=v[i].x;    if(t>v[i].y) t=v[i].y;}   if(\u2026)  cout<<\"DA\";\u2502printf(\"DA\");    else  cout<<\"NU\";\u2502printf(\"NU\");  Limbajul Pascal  type interval=record       x,y:integer end;  var v:array[0..99] of         interval;    i,j,r,t,n:integer;  r:=v[0].x; t:=v[0].y;  for i:=1 to n-1 do begin   if r<v[i].x then    r:=v[i].x;    if t>v[i].y then  t:=v[i].y  end;  if \u2026 then write('DA')      else write('NU');  a) r<t  b) r<=t  c) r==t  d) r!=t \u2502r<>t  e) r>=t  f) r>t", "sentences": ["245    for i:=0 to 5 do   write(v[i],' ');  a) 11 26 41 48 52 65  b) 65 41 11 52 48 26  c) 26 48 52 11 41 65  d) 48 52 26 11 41 65  e) 52 48 26 65 41 11  f) 11 41 65 48 52 26    4.", "Dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni se afi\u0219eaz\u0103?", " Limbajul C/C++  char s[50]=\"test informatica\";  char *p;  strtok(s, \" \");   p=strtok(NULL,\" \");  strcpy(s,strcat(p,s));  cout<<s;\u2502printf(\"%s\",s);  Limbajul Pascal  var s,p:string;  s:='test informatica';  p:=copy(s,pos(' ',s)+1,  length(s) - pos(' ',s));   delete(s,pos(' ',s),  length(s)-pos(' ',s)+1);  s:=p+s; write(s);  a) testtest  b) testinformatica  c) test  d) informaticatest  e) informatica  f) info    5.", "Pentru ca secven\u021ba urm\u0103toare de instruc\u021biuni s\u0103 determine dac\u0103 cele n intervale memorate  \u00een tabloul unidimensional v sunt disjuncte, punctele de suspensie se \u00eenlocuiesc cu?", " Limbajul C/C++  struct interval{int x, y;}         v[100];   int i, j, r, t,n;  r=v[0].x; t=v[0].y;  for(i=1;i<n;++i) {    if(r<v[i].x) r=v[i].x;    if(t>v[i].y) t=v[i].y;}   if(\u2026)  cout<<\"DA\";\u2502printf(\"DA\");    else  cout<<\"NU\";\u2502printf(\"NU\");  Limbajul Pascal  type interval=record       x,y:integer end;  var v:array[0..99] of         interval;    i,j,r,t,n:integer;  r:=v[0].x; t:=v[0].y;  for i:=1 to n-1 do begin   if r<v[i].x then    r:=v[i].x;    if t>v[i].y then  t:=v[i].y  end;  if \u2026 then write('DA')      else write('NU');  a) r<t  b) r<=t  c) r==t  d) r!=t \u2502r<>t  e) r>=t  f) r>t"], "page_sentence_count_spacy": 5}, {"page_number": 246, "page_char_count": 1556, "page_word_count": 366, "page_sentence_count_raw": 6, "page_token_count": 389.0, "text": "246    6. Variabilele \u00eentregi i, j, s memoreaz\u0103 numere naturale. Tabloul bidimensional a,  p\u0103tratic, cu elemente numere naturale, are n linii \u0219i n coloane, numerotate de la 1 la n \u0219i  este \u00eemp\u0103r\u021bit \u00een 4 zone ca \u00een desen  . Pentru ca algoritmul urm\u0103tor s\u0103 adune  elemente din zona II, punctele de suspensie se \u00eenlocuiesc cu?  Limbajul C++/C  s=0;    for(i=1;i<=(n-1)/2;++i)    for(j=i+1;j<=n-i;j++)      s+=\u2026\u2026;  Limbajul Pascal  s:=0;    for i:=1 to (n-1) div 2 do    for j:=i+1 to n-i do      s:=s+\u2026\u2026;  a) a[n-i+1][j] \u2502 a[n-i+1, j]  b) a[i][j] \u2502 a[i,j]  c) a[n+1-i][n+1-j] \u2502   a[n+1-i, n+1-j]  d) a[n-i][n-j] \u2502 a[n-i,n-j]  e) a[j][i] \u2502 a[j, i]  f) a[n+1-j][n+1-i] \u2502     a[n+1-j, n+1-i]    7. Pentru ca, dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni, s\u0103 se afi\u0219eze valoarea 7,  punctele de suspensie se \u00eenlocuiesc cu?  Limbajul C/C++  int i, p, v[10]={2, 6, 8, 12,  20, 25, 30, 37, 41, 92};  for (p = 1; p < 10; p *=2);  for (i = 0; p; \u2026)    if (i+p<10 && v[i+p]<= 40)        i += p;  cout<<i;\u2502printf(\"%d\",i);  Limbajul Pascal  var v:array[0..9] of  integer = (2, 6, 8, 12,  20, 25, 30, 37, 41, 92);    i,p:integer;  p:=1;  while p<10 do p:=p*2;  i:=0;  while p<>0 do  begin    if (i+p<10) and  (v[i+p]<=40) then    i:=i+p;    p:=\u2026\u2026.;  end;  write(i);  a) p/=2 \u2502 p div 2  b) p*2  c) p++\u2502p+1  d) p-- \u2502 p-1  e) p+2  f) p+=i\u2502p+i    8. Dup\u0103 rularea urm\u0103torului program se afi\u0219eaz\u0103?  Limbajul C++  #include<iostream>  using namespace  std;  Limbajul  C  #include <stdio.h>  struct Q{    int a, b, c;};  Limbajul Pascal  type QT = record  a,b,c:integer    end;", "sentences": ["246    6.", "Variabilele \u00eentregi i, j, s memoreaz\u0103 numere naturale.", "Tabloul bidimensional a,  p\u0103tratic, cu elemente numere naturale, are n linii \u0219i n coloane, numerotate de la 1 la n \u0219i  este \u00eemp\u0103r\u021bit \u00een 4 zone ca \u00een desen  .", "Pentru ca algoritmul urm\u0103tor s\u0103 adune  elemente din zona II, punctele de suspensie se \u00eenlocuiesc cu?", " Limbajul C++/C  s=0;    for(i=1;i<=(n-1)/2;++i)    for(j=i+1;j<=n-i;j++)      s+=\u2026\u2026;  Limbajul Pascal  s:=0;    for i:=1 to (n-1) div 2 do    for j:=i+1 to n-i do      s:=s+\u2026\u2026;  a) a[n-i+1][j] \u2502 a[n-i+1, j]  b) a[i][j] \u2502 a[i,j]  c) a[n+1-i][n+1-j] \u2502   a[n+1-i, n+1-j]  d) a[n-i][n-j] \u2502 a[n-i,n-j]  e) a[j][i] \u2502 a[j, i]  f) a[n+1-j][n+1-i] \u2502     a[n+1-j, n+1-i]    7.", "Pentru ca, dup\u0103 rularea urm\u0103toarei secven\u021be de instruc\u021biuni, s\u0103 se afi\u0219eze valoarea 7,  punctele de suspensie se \u00eenlocuiesc cu?", " Limbajul C/C++  int i, p, v[10]={2, 6, 8, 12,  20, 25, 30, 37, 41, 92};  for (p = 1; p < 10; p *=2);  for (i = 0; p; \u2026)    if (i+p<10 && v[i+p]<= 40)        i += p;  cout<<i;\u2502printf(\"%d\",i);  Limbajul Pascal  var v:array[0..9] of  integer = (2, 6, 8, 12,  20, 25, 30, 37, 41, 92);    i,p:integer;  p:=1;  while p<10 do p:=p*2;  i:=0;  while p<>0 do  begin    if (i+p<10) and  (v[i+p]<=40) then    i:=i+p;    p:=\u2026\u2026.;", " end;  write(i);  a) p/=2 \u2502 p div 2  b) p*2  c) p++\u2502p+1  d) p-- \u2502 p-1  e) p+2  f) p+=i\u2502p+i    8.", "Dup\u0103 rularea urm\u0103torului program se afi\u0219eaz\u0103?", " Limbajul C++  #include<iostream>  using namespace  std;  Limbajul  C  #include <stdio.h>  struct Q{    int a, b, c;};  Limbajul Pascal  type QT = record  a,b,c:integer    end;"], "page_sentence_count_spacy": 10}, {"page_number": 247, "page_char_count": 1541, "page_word_count": 416, "page_sentence_count_raw": 7, "page_token_count": 385.25, "text": "247    struct Q{    int a, b, c;};  struct S{    int a, b, c;    struct Q Q;};  int main(){  Q Q={3, 2, 1};   S S={4, 5, 6};  S.Q=Q;  cout<<S.b-S.Q.b;  return 0;}    struct S{    int a, b, c;    struct Q Q;};  int main() {    struct Q Q={3,2,1};  struct S S={4,5,6};  S.Q=Q;  printf(\"%d\", S.b-S.Q.b);  return 0;}  ST = record  a,b,c:integer;   Q:QT end;  var Q:QT =    (a:3;b:2;c:1);  S:ST =    (a:4;b:5;c:6);  begin  S.Q:=Q;  write(S.b-S.Q.b)  end.  a) 5  b) 4  c) 3  d) 2  e) 1  f) 0    9. Apelul f(6,2) are valoarea?  Limbajul C/C++  int f(int x, int y) {    if(x>y)     return f(f(y,x), x/y)-1;    else    if(x==y)    return f(x+y, x)+2;      else return y-x;}  Limbajul Pascal  function f(x,y:integer):            integer;  begin  if x>y then    f:=f(f(y,x),x div y)-1         else if x=y then    f:=f(x+y,x)+2                     else    f:=y-x;  end;  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    10. Num\u0103rul de circuite elementare diferite (care au cel pu\u021bin un arc diferit) care trec prin  nodul A din graful orientat al\u0103turat este?    a) 4  b) 5  c) 6  d) 7  e) 8  f) 9    11. Folosind metoda backtracking, se determin\u0103 \u00een ordine lexicografic\u0103, toate cuvintele de 4  litere distincte din mul\u021bimea {a,b,e,f,g,i,l,m,o,p,r,u} oricare dou\u0103 litere  al\u0103turate s\u0103 nu fie consecutive \u00een mul\u021bimea dat\u0103, iar vocalele s\u0103 apar\u0103 \u00een ordine  descresc\u0103toare. Primele 5 solu\u021bii sunt: afbg, afbl, afbm, afbp, afbr.   Cele 2 cuvinte generate \u00eenaintea cuv\u00e2ntului elaf sunt?   a) farg farl  b) egrl egrm  c) egmf egmp  d) eglr eglu  e) buri buro  f) bopl bupm", "sentences": ["247    struct Q{    int a, b, c;};  struct S{    int a, b, c;    struct Q Q;};  int main(){  Q Q={3, 2, 1};   S S={4, 5, 6};  S.Q=Q;  cout<<S.b-S.Q.b;  return 0;}    struct S{    int a, b, c;    struct Q Q;};  int main() {    struct Q Q={3,2,1};  struct S S={4,5,6};  S.Q=Q;  printf(\"%d\", S.b-S.Q.b);  return 0;}  ST = record  a,b,c:integer;   Q:QT end;  var Q:QT =    (a:3;b:2;c:1);  S:ST =    (a:4;b:5;c:6);  begin  S.Q:=Q;  write(S.b-S.Q.b)  end.", " a) 5  b) 4  c) 3  d) 2  e) 1  f) 0    9.", "Apelul f(6,2) are valoarea?", " Limbajul C/C++  int f(int x, int y) {    if(x>y)     return f(f(y,x), x/y)-1;    else    if(x==y)    return f(x+y, x)+2;      else return y-x;}  Limbajul Pascal  function f(x,y:integer):            integer;  begin  if x>y then    f:=f(f(y,x),x div y)-1         else if x=y then    f:=f(x+y,x)+2                     else    f:=y-x;  end;  a) 0  b) 1  c) 2  d) 3  e) 4  f) 5    10.", "Num\u0103rul de circuite elementare diferite (care au cel pu\u021bin un arc diferit) care trec prin  nodul A din graful orientat al\u0103turat este?", "   a) 4  b) 5  c) 6  d) 7  e) 8  f) 9    11.", "Folosind metoda backtracking, se determin\u0103 \u00een ordine lexicografic\u0103, toate cuvintele de 4  litere distincte din mul\u021bimea {a,b,e,f,g,i,l,m,o,p,r,u} oricare dou\u0103 litere  al\u0103turate s\u0103 nu fie consecutive \u00een mul\u021bimea dat\u0103, iar vocalele s\u0103 apar\u0103 \u00een ordine  descresc\u0103toare.", "Primele 5 solu\u021bii sunt: afbg, afbl, afbm, afbp, afbr.", "  Cele 2 cuvinte generate \u00eenaintea cuv\u00e2ntului elaf sunt?", "  a) farg farl  b) egrl egrm  c) egmf egmp  d) eglr eglu  e) buri buro  f) bopl bupm"], "page_sentence_count_spacy": 10}, {"page_number": 248, "page_char_count": 1350, "page_word_count": 299, "page_sentence_count_raw": 8, "page_token_count": 337.5, "text": "248      12. Un arbore oarecare cu r\u0103d\u0103cin\u0103 este reprezentat prin vectorul de ta\u021bi t. Dac\u0103 algoritmul  urm\u0103tor determin\u0103 nivelul pe care se g\u0103se\u0219te un nod x \u00een arbore, cu ce secven\u021b\u0103 de cod se  pot \u00eenlocui punctele de suspensie de mai jos?  Limbajul C/C++  int nivel=0;  while(t[x]){      \u2026      nivel++;}  Limbajul Pascal  nivel:=0;  while t[x]<>0 begin      \u2026      inc(nivel)  end;  a) t[x]=x; \u2502 t[x]:=x;  b) t[x]--; \u2502 t[x]:=t[x]-1;  c) x=t[x]; \u2502 x:=t[x];  d) t[x]++; \u2502 t[x]:=t[x]+1;  e) x=t[t[x]]; \u2502 x:=t[t[x]];  f) t[x]=x+t[x]; \u2502 t[x]:=x+t[x];    13. Num\u0103rul de numere \u00eentregi din intervalul [100, 10000] pentru care rularea urm\u0103toarei  secven\u021be de instruc\u021biuni afi\u0219eaz\u0103 valoarea 5 este?  Limbajul C/C++  cin>>n; \u2502scanf(\"%d\",&n);  while(n>9) n=n/10+n%10;  cout<<n;\u2502printf(\"%d\",n);  Limbajul Pascal  readln(n);  while n>9 do n:=n div 10  + n mod 10;  write(n);  a) 1100   b) 1110  c) 1200  d) 1450  e) 1500  f) 1890    14. Un algoritm determin\u0103 minimul \u0219i maximul dintr-un tablou unidimensional cu 100 de  numere, prin oper\u021bii de comparare a elementelor. Num\u0103rul minim de compar\u0103ri necesare  este?  a) 140  b) 142  c) 144  d) 146  e) 148  f) 150    15. \u00cen graful neorientat G cu 100 de noduri, dou\u0103 noduri i \u0219i j sunt adiacente dac\u0103 |\ud835\udc56\u2212\ud835\udc57| = 8  sau |\ud835\udc56\u2212\ud835\udc57| = 12. Num\u0103rul de componente conexe ale grafului este:   a) 1  b) 2  c) 3   d) 4  e) 25  f) 50", "sentences": ["248      12.", "Un arbore oarecare cu r\u0103d\u0103cin\u0103 este reprezentat prin vectorul de ta\u021bi t. Dac\u0103 algoritmul  urm\u0103tor determin\u0103 nivelul pe care se g\u0103se\u0219te un nod x \u00een arbore, cu ce secven\u021b\u0103 de cod se  pot \u00eenlocui punctele de suspensie de mai jos?", " Limbajul C/C++  int nivel=0;  while(t[x]){      \u2026      nivel++;}  Limbajul Pascal  nivel:=0;  while t[x]<>0 begin      \u2026      inc(nivel)  end;  a) t[x]=x; \u2502 t[x]:=x;  b) t[x]--; \u2502 t[x]:=t[x]-1;  c) x=t[x]; \u2502 x:=t[x];  d) t[x]++; \u2502 t[x]:=t[x]+1;  e) x=t[t[x]]; \u2502 x:=t[t[x]];  f) t[x]=x+t[x]; \u2502 t[x]:=x+t[x];    13.", "Num\u0103rul de numere \u00eentregi din intervalul [100, 10000] pentru care rularea urm\u0103toarei  secven\u021be de instruc\u021biuni afi\u0219eaz\u0103 valoarea 5 este?", " Limbajul C/C++  cin>>n; \u2502scanf(\"%d\",&n);  while(n>9) n=n/10+n%10;  cout<<n;\u2502printf(\"%d\",n);  Limbajul Pascal  readln(n);  while n>9 do n:=n div 10  + n mod 10;  write(n);  a) 1100   b) 1110  c) 1200  d) 1450  e) 1500  f) 1890    14.", "Un algoritm determin\u0103 minimul \u0219i maximul dintr-un tablou unidimensional cu 100 de  numere, prin oper\u021bii de comparare a elementelor.", "Num\u0103rul minim de compar\u0103ri necesare  este?", " a) 140  b) 142  c) 144  d) 146  e) 148  f) 150    15.", "\u00cen graful neorientat G cu 100 de noduri, dou\u0103 noduri i \u0219i j sunt adiacente dac\u0103 |\ud835\udc56\u2212\ud835\udc57| = 8  sau |\ud835\udc56\u2212\ud835\udc57| = 12.", "Num\u0103rul de componente conexe ale grafului este:   a) 1  b) 2  c) 3   d) 4  e) 25  f) 50"], "page_sentence_count_spacy": 10}, {"page_number": 249, "page_char_count": 48, "page_word_count": 25, "page_sentence_count_raw": 1, "page_token_count": 12.0, "text": "249                      INDICA\u021aII \u0218I R\u0102SPUNSURI", "sentences": ["249                      INDICA\u021aII \u0218I R\u0102SPUNSURI"], "page_sentence_count_spacy": 1}, {"page_number": 250, "page_char_count": 1559, "page_word_count": 544, "page_sentence_count_raw": 11, "page_token_count": 389.75, "text": "250    Varianta 1  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect:   a) not ((a<-3) or (a>2)) or (a=3) or (a=5) or (a=9) (Pascal) respectiv       !((a<-3) || (a>2)) || (a==3) || (a==5) || (a==9)  (C/C++)  Indica\u021bii: Valoarea lui a trebuie s\u0103 fie mai mare sau egal\u0103 cu -3 \u0219i mai mic\u0103 sau egal\u0103 dec\u00e2t  2 sau egal\u0103 cu 3 sau egal\u0103 cu 5 sau egal\u0103 cu 9  2.  R\u0103spuns corect: c) q-1+j  3.  R\u0103spuns corect: f) info  4.  R\u0103spuns corect: d)  Limbajul C++/LimbajulC    s=0; i=1;       while(i<=n)        {s=s+x[p][i];           i++;}   Limbajul Pascal    s:=0; i:=1;       while i<=n do          begin           s:=s+x[p,i];           i:=i+1;          end;  Indica\u021bii:   Fiind vorba de suma elementelor pe linia p, primul indice al elementului din tabloul  bidimensional trebuie s\u0103 fie p. Av\u00e2nd n coloane \u00een matrice, cel de-al doilea indice al  elementutlui din matrice trebuie s\u0103 parcurg\u0103 toate valorile de la 1 la n.  5.  R\u0103spuns corect:                                                                                                                                                                                                                   Indica\u021bii: Se observ\u0103 cu ajutorul desenului de mai sus, c\u0103 de la nodurile 4 \u0219i 5 nu exist\u0103  niciun drum la nodurile 1, 2 \u0219i 3. Deci \u00een matrice doar elementele a41, a42, a43, a51, a52 \u0219i  a53  vor avea valoarea 0 restul elementelor din matrice av\u00e2nd valoarea 1.  6.  R\u0103spuns corect: b) (3, 3, 3)  Indica\u021bii: Mul\u021bimea A2 nu con\u021bine elementul 3, deci \u00een produsul cartezian a celor 3 mul\u021bimi  nu putem avea ca solu\u021bie (3, 3, 3).", "sentences": ["250    Varianta 1  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect:   a) not ((a<-3) or (a>2)) or (a=3) or (a=5) or (a=9) (Pascal) respectiv       !((", "a<-3) || (a>2)) || (a==3) || (a==5) || (a==9)  (C/C++)  Indica\u021bii: Valoarea lui a trebuie s\u0103 fie mai mare sau egal\u0103 cu -3 \u0219i mai mic\u0103 sau egal\u0103 dec\u00e2t  2 sau egal\u0103 cu 3 sau egal\u0103 cu 5 sau egal\u0103 cu 9  2.", " R\u0103spuns corect: c) q-1+j  3.", " R\u0103spuns corect: f) info  4.", " R\u0103spuns corect: d)  Limbajul C++/LimbajulC    s=0; i=1;       while(i<=n)        {s=s+x[p][i];           i++;}   Limbajul Pascal    s:=0; i:=1;       while i<=n do          begin           s:=s+x[p,i];           i:=i+1;          end;  Indica\u021bii:   Fiind vorba de suma elementelor pe linia p, primul indice al elementului din tabloul  bidimensional trebuie s\u0103 fie p. Av\u00e2nd n coloane \u00een matrice, cel de-al doilea indice al  elementutlui din matrice trebuie s\u0103 parcurg\u0103 toate valorile de la 1 la n.  5.", " R\u0103spuns corect:                                                                                                                                                                                                                   Indica\u021bii: Se observ\u0103 cu ajutorul desenului de mai sus, c\u0103 de la nodurile 4 \u0219i 5 nu exist\u0103  niciun drum la nodurile 1, 2 \u0219i 3.", "Deci \u00een matrice doar elementele a41, a42, a43, a51, a52 \u0219i  a53  vor avea valoarea 0 restul elementelor din matrice av\u00e2nd valoarea 1.", " 6.", " R\u0103spuns corect: b) (3, 3, 3)  Indica\u021bii: Mul\u021bimea A2 nu con\u021bine elementul 3, deci \u00een produsul cartezian a celor 3 mul\u021bimi  nu putem avea ca solu\u021bie (3, 3, 3)."], "page_sentence_count_spacy": 10}, {"page_number": 251, "page_char_count": 1569, "page_word_count": 339, "page_sentence_count_raw": 18, "page_token_count": 392.25, "text": "251    7.  R\u0103spuns corect: a)  Limbajul C++/LimbajulC  Limbajul Pascal  a)  if ( p(x,x)==2) cout<<\u201dprim\u201d;              |  printf(\u201dprim\u201d);  a)  if p(x, x)=2 then  write(\u2019prim\u2019);    Indica\u021bii: Func\u021bia calculeaz\u0103 num\u0103rul de divizori al lui a care sunt mai mici sau   egali cu b.  8.  R\u0103spuns corect: d)  2, 4, 0, 3, 4  9.  R\u0103spuns corect: f) 673656  Indica\u021bii: \u00cen urma apelului t(7,7)  x=7-1=6, y=6+1=7 deci se afi\u0219eaz\u0103 67, iar la ie\u0219irea din  func\u021bie y va avea valoarea 6 datorit\u0103 primului parametru al func\u021biei transmis prin adres\u0103, iar  x va avea valoarea 3. Se va afi\u0219a x \u0219i y adic\u0103 3 \u0219i 6. \u00cen urma apelului t(6,3) x=6-1=5,  y=5+1=6, se va afi\u0219a 56.  10.  R\u0103spuns corect: c)  Limbajul C++/LimbajulC  Limbajul Pascal  c) par(a, b) == (b-a+1)/2  c) par(a, b) = (b-a+1) DIV 2  Indica\u021bii: Pentru verificarea expresiilor, se pot folosi perechi de valori cu aceea\u0219i paritate  sau de parit\u0103\u021bi diferite.       11.  R\u0103spuns corect: c)    Limbajul C++/LimbajulC  Limbajul Pascal  c) c = mini(c, v[i]);  c) c : =mini(c, v[i]);    12.  R\u0103spuns corect: e) amTre  13.  R\u0103spuns corect: a)   Limbajul C++/LimbajulC  Limbajul Pascal  a) e[10] = x;  a) e[10] := x;    14.  R\u0103spuns corect: f) 5120  Indica\u021bii: Cu 5 noduri se pot forma 2(5*4)/2=210=1024  grafuri neorientate distincte. Deci  avem 1024 de grafuri distincte \u00een care nodul 2 este adiacent cu nodul 1, alte 1024 de grafuri  distincte \u00een care nodul 2 este adiacent cu nodul 3, ..., 1024 de grafuri distincte \u00een care nodul  2 este adiacent cu nodul 6. \u00cen total sunt 1024*5= 5120 de grafuri distincte.  15.  R\u0103spuns corect: c) 5", "sentences": ["251    7.", " R\u0103spuns corect: a)  Limbajul C++/LimbajulC  Limbajul Pascal  a)  if ( p(x,x)==2) cout<<\u201dprim\u201d;              |  printf(\u201dprim\u201d);  a)  if p(x, x)=2 then  write(\u2019prim\u2019);    Indica\u021bii: Func\u021bia calculeaz\u0103 num\u0103rul de divizori al lui a care sunt mai mici sau   egali cu b.  8.", " R\u0103spuns corect: d)  2, 4, 0, 3, 4  9.", " R\u0103spuns corect: f) 673656  Indica\u021bii: \u00cen urma apelului t(7,7)  x=7-1=6, y=6+1=7 deci se afi\u0219eaz\u0103 67, iar la ie\u0219irea din  func\u021bie y va avea valoarea 6 datorit\u0103 primului parametru al func\u021biei transmis prin adres\u0103, iar  x va avea valoarea 3.", "Se va afi\u0219a x \u0219i y adic\u0103 3 \u0219i 6.", "\u00cen urma apelului t(6,3) x=6-1=5,  y=5+1=6, se va afi\u0219a 56.", " 10.", " R\u0103spuns corect: c)  Limbajul C++/LimbajulC  Limbajul Pascal  c) par(a, b) == (b-a+1)/2  c) par(a, b) = (b-a+1) DIV 2  Indica\u021bii: Pentru verificarea expresiilor, se pot folosi perechi de valori cu aceea\u0219i paritate  sau de parit\u0103\u021bi diferite.", "      11.", " R\u0103spuns corect: c)    Limbajul C++/LimbajulC  Limbajul Pascal  c) c = mini(c, v[i]);  c) c : =mini(c, v[i]);    12.", " R\u0103spuns corect: e) amTre  13.", " R\u0103spuns corect: a)   Limbajul C++/LimbajulC  Limbajul Pascal  a) e[10] = x;  a) e[10] := x;    14.", " R\u0103spuns corect: f) 5120  Indica\u021bii: Cu 5 noduri se pot forma 2(5*4)/2=210=1024  grafuri neorientate distincte.", "Deci  avem 1024 de grafuri distincte \u00een care nodul 2 este adiacent cu nodul 1, alte 1024 de grafuri  distincte \u00een care nodul 2 este adiacent cu nodul 3, ..., 1024 de grafuri distincte \u00een care nodul  2 este adiacent cu nodul 6.", "\u00cen total sunt 1024*5= 5120 de grafuri distincte.", " 15.", " R\u0103spuns corect: c) 5"], "page_sentence_count_spacy": 17}, {"page_number": 252, "page_char_count": 1788, "page_word_count": 383, "page_sentence_count_raw": 17, "page_token_count": 447.0, "text": "252    Varianta 2  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: c)543212222543445  2.  R\u0103spuns corect: d)   Limbajul C++/LimbajulC  Limbajul Pascal  d) (x>y || x<z) && x>t  d) ((x>y) or (x<z)) and (x>t     )    3.  R\u0103spuns corect: e)  Limbajul C++/LimbajulC  Limbajul Pascal  e) a[i][j] == a[n+1-j][n+1-i]  e) a[i, j] = a[n+1-j, n+1-i]  Indica\u021bii: Se observ\u0103 c\u0103 elementele unui tablou bidimensional      cu 4 linii \u0219i 4 coloane sunt  simetrice fa\u021b\u0103 de diagonala secundar\u0103 astfel: a11=a44, a12=a34, a13=a24, a21=a43, a22=a33,  a31=a42, deci putem deduce expresia pe caz general ai,j=an+1-j,n+1-i.  4.  R\u0103spuns corect: d)  10  5.  R\u0103spuns corect: f) (s.A.y+s.B.y)/2  6.  R\u0103spuns corect: b)   0010                     0100                     1000                     0001  Indica\u021bii: Se observ\u0103 c\u0103 fiec\u0103rui tabloul bidimensional \u00eei corespunde o permutare.  Permutarea este o func\u021bie f:{1,2,..,n}->{1,2,..,n}, bijectiv\u0103. Not\u0103m linia 1000 cu 1, linia 0100  cu 2, linia 0010 cu 3 \u0219i linia 0001 cu 4. Observ\u0103m ca permutarea pentru tabloul bidimensional  dat este (3,1,4,2) iar permutarea urm\u0103toare acesteia din punct de vedere lexicografic este  (3,2,1,4), corespunz\u0103toare tabloului bidimensional de la punctul b.  7.  R\u0103spuns corect: d) 3  Indica\u021bii: Func\u021bia calculeaz\u0103 num\u0103rul de moduri distincte \u00een care poate fi scris un num\u0103r x  ca sum\u0103 de y numere naturale strict pozitive. Deci 6 poate fi scris in 3 moduri: 6=1+2+3,  6=1+1+4, 6=2+2+2, acela\u0219i rezultat se ob\u021bine urm\u0103rind apelurile recursive efectuate de  func\u021bia nr.  8.  R\u0103spuns corect: b) 5, 6, 7,  9, 10  9.  R\u0103spuns corect: e) 2 2  Indica\u021bii: \u00cen urma apelului F(x, y)  respectiv F(&x, y) ,  variabila x este singura variabil\u0103  care \u00ee\u0219i modific\u0103 valoarea dup\u0103 apel, fiind un parametru transmis prin adres\u0103, deci y  r\u0103m\u00e2ne neschimbat.", "sentences": ["252    Varianta 2  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: c)543212222543445  2.", " R\u0103spuns corect: d)   Limbajul C++/LimbajulC  Limbajul Pascal  d) (x>y || x<z) && x>t  d) ((x>y) or (x<z)) and (x>t     )    3.", " R\u0103spuns corect: e)  Limbajul C++/LimbajulC  Limbajul Pascal  e) a[i][j] == a[n+1-j][n+1-i]  e) a[i, j] = a[n+1-j, n+1-i]  Indica\u021bii: Se observ\u0103 c\u0103 elementele unui tablou bidimensional      cu 4 linii \u0219i 4 coloane sunt  simetrice fa\u021b\u0103 de diagonala secundar\u0103 astfel: a11=a44, a12=a34, a13=a24, a21=a43, a22=a33,  a31=a42, deci putem deduce expresia pe caz general ai,j=an+1-j,n+1-i.", " 4.", " R\u0103spuns corect: d)  10  5.", " R\u0103spuns corect: f) (s.A.y+s.", "B.y)/2  6.", " R\u0103spuns corect: b)   0010                     0100                     1000                     0001  Indica\u021bii: Se observ\u0103 c\u0103 fiec\u0103rui tabloul bidimensional \u00eei corespunde o permutare.", " Permutarea este o func\u021bie f:{1,2,..,n}->{1,2,..,n}, bijectiv\u0103.", "Not\u0103m linia 1000 cu 1, linia 0100  cu 2, linia 0010 cu 3 \u0219i linia 0001 cu 4.", "Observ\u0103m ca permutarea pentru tabloul bidimensional  dat este (3,1,4,2) iar permutarea urm\u0103toare acesteia din punct de vedere lexicografic este  (3,2,1,4), corespunz\u0103toare tabloului bidimensional de la punctul b.  7.", " R\u0103spuns corect: d) 3  Indica\u021bii: Func\u021bia calculeaz\u0103 num\u0103rul de moduri distincte \u00een care poate fi scris un num\u0103r x  ca sum\u0103 de y numere naturale strict pozitive.", "Deci 6 poate fi scris in 3 moduri: 6=1+2+3,  6=1+1+4, 6=2+2+2, acela\u0219i rezultat se ob\u021bine urm\u0103rind apelurile recursive efectuate de  func\u021bia nr.  8.", " R\u0103spuns corect: b) 5, 6, 7,  9, 10  9.", " R\u0103spuns corect: e) 2 2  Indica\u021bii: \u00cen urma apelului F(x, y)  respectiv F(&x, y) ,  variabila x este singura variabil\u0103  care \u00ee\u0219i modific\u0103 valoarea dup\u0103 apel, fiind un parametru transmis prin adres\u0103, deci y  r\u0103m\u00e2ne neschimbat."], "page_sentence_count_spacy": 16}, {"page_number": 253, "page_char_count": 763, "page_word_count": 157, "page_sentence_count_raw": 9, "page_token_count": 190.75, "text": "253    10.  R\u0103spuns corect: c) 3  Indica\u021bii: O solu\u021bie: culoarea 1 nodurile 1, 4 \u0219i 6, culoarea 2 nodurile 3 \u0219i 8, culoarea 3  nodurile 5 \u0219i 7, iar nodul 2 fiind nod izolat propun culoarea 1(se putea colora \u0219i cu 2 \u0219i cu  3).  11.  R\u0103spuns corect: f) 45  Indica\u021bii: Avem formula: Nrmaxmuchii=(n-p)(n-p+1)/2, unde n reprezint\u0103 num\u0103rul de  noduri iar p num\u0103rul de componente conexe.  12.  R\u0103spuns corect: a)   Limbajul C++/LimbajulC  Limbajul Pascal  a) cout<<strchr(c, \u2019d\u2019)-c; |         printf(\u201d%d\u201d, strchr(c, \u2019d\u2019)-c );  a) write(pos(\u2018d\u2019, c));      13.  R\u0103spuns corect: c) 2021  Indica\u021bii: Instruc\u021biunea for nu produce efecte  14.  R\u0103spuns corect: e) combin\u0103rilor de 30 de elemente luate c\u00e2te 5  Indica\u021bii: Nu conteaz\u0103 ordinea \u00een echip\u0103  15.  R\u0103spuns corect: f) 14", "sentences": ["253    10.", " R\u0103spuns corect: c) 3  Indica\u021bii: O solu\u021bie: culoarea 1 nodurile 1, 4 \u0219i 6, culoarea 2 nodurile 3 \u0219i 8, culoarea 3  nodurile 5 \u0219i 7, iar nodul 2 fiind nod izolat propun culoarea 1(se putea colora \u0219i cu 2 \u0219i cu  3).", " 11.", " R\u0103spuns corect: f) 45  Indica\u021bii: Avem formula: Nrmaxmuchii=(n-p)(n-p+1)/2, unde n reprezint\u0103 num\u0103rul de  noduri iar p num\u0103rul de componente conexe.", " 12.", " R\u0103spuns corect: a)   Limbajul C++/LimbajulC  Limbajul Pascal  a) cout<<strchr(c, \u2019d\u2019)-c; |         printf(\u201d%d\u201d, strchr(c, \u2019d\u2019)-c );  a) write(pos(\u2018d\u2019, c));      13.", " R\u0103spuns corect: c) 2021  Indica\u021bii: Instruc\u021biunea for nu produce efecte  14.", " R\u0103spuns corect: e) combin\u0103rilor de 30 de elemente luate c\u00e2te 5  Indica\u021bii: Nu conteaz\u0103 ordinea \u00een echip\u0103  15.", " R\u0103spuns corect: f) 14"], "page_sentence_count_spacy": 9}, {"page_number": 254, "page_char_count": 1257, "page_word_count": 254, "page_sentence_count_raw": 20, "page_token_count": 314.25, "text": "254    Varianta 3  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: e) 64  Indica\u021bii: n poate avea valori de la  36  la  99  2.  R\u0103spuns corect: a)   3.  R\u0103spuns corect: d)   Indica\u021bii: Suma tuturor elementelor tabloului a este 0. \u00cen cadrul programului, se adun\u0103  toate elementele tabloului a, mai pu\u021bin cele pentru care i+1=j. Sunt 19 elemente pentru  care i+j=1 \u0219i fiecare dintre ele are valoarea -1. Deci s+(-19)=0 => s=19.   4.  R\u0103spuns corect: d)   Indica\u021bii: Algoritmul nu este corect implementat. \u00cen majoritatea cazurilor, genereaz\u0103  ciclare infinit\u0103.  5.  R\u0103spuns corect: d)   Indica\u021bii:  Se \u021bine cont de ordinea \u0219i modul de transmitere al parametrilor  6.  R\u0103spuns corect: b)   Indica\u021bii:  Func\u021bia dat\u0103 calculeaz\u0103  x*y  7.  R\u0103spuns corect: a)   Indica\u021bii: Se verific\u0103 dac\u0103 elementul are loc \u00een stiv\u0103  8.  R\u0103spuns corect: f)   9.  R\u0103spuns corect: e)   Indica\u021bii: Num\u0103rul poate avea 1, 2 sau 3 cifre  10.  R\u0103spuns corect: c)   11.  R\u0103spuns corect: e)   Indica\u021bii: Num\u0103rul valorilor se calculeaz\u0103 direct prin formula n*(n-1)/2  12.  R\u0103spuns corect: c)   13.  R\u0103spuns corect: a)   Indica\u021bii: Arcele (2,1),(2,3) \u0219i (2,4) au extremitatea ini\u021bial\u0103 nodul 2(cu gradul  exterior 0), iar  arcele (3,1)\u0219i (4,1) au extremitatea final\u0103 nodul 1(cu gradul interior  0)", "sentences": ["254    Varianta 3  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: e) 64  Indica\u021bii: n poate avea valori de la  36  la  99  2.", " R\u0103spuns corect: a)   3.", " R\u0103spuns corect: d)   Indica\u021bii: Suma tuturor elementelor tabloului a este 0.", "\u00cen cadrul programului, se adun\u0103  toate elementele tabloului a, mai pu\u021bin cele pentru care i+1=j. Sunt 19 elemente pentru  care i+j=1 \u0219i fiecare dintre ele are valoarea -1.", "Deci s+(-19)=0 => s=19.", "  4.", " R\u0103spuns corect: d)   Indica\u021bii: Algoritmul nu este corect implementat.", "\u00cen majoritatea cazurilor, genereaz\u0103  ciclare infinit\u0103.", " 5.", " R\u0103spuns corect: d)   Indica\u021bii:  Se \u021bine cont de ordinea \u0219i modul de transmitere al parametrilor  6.", " R\u0103spuns corect: b)   Indica\u021bii:  Func\u021bia dat\u0103 calculeaz\u0103  x*y  7.", " R\u0103spuns corect: a)   Indica\u021bii: Se verific\u0103 dac\u0103 elementul are loc \u00een stiv\u0103  8.", " R\u0103spuns corect: f)   9.", " R\u0103spuns corect: e)   Indica\u021bii: Num\u0103rul poate avea 1, 2 sau 3 cifre  10.", " R\u0103spuns corect: c)   11.", " R\u0103spuns corect: e)   Indica\u021bii: Num\u0103rul valorilor se calculeaz\u0103 direct prin formula n*(n-1)/2  12.", " R\u0103spuns corect: c)   13.", " R\u0103spuns corect: a)   Indica\u021bii: Arcele (2,1),(2,3) \u0219i (2,4) au extremitatea ini\u021bial\u0103 nodul 2(cu gradul  exterior 0), iar  arcele (3,1)\u0219i (4,1) au extremitatea final\u0103 nodul 1(cu gradul interior  0)"], "page_sentence_count_spacy": 19}, {"page_number": 255, "page_char_count": 218, "page_word_count": 57, "page_sentence_count_raw": 4, "page_token_count": 54.5, "text": "255    14.  R\u0103spuns corect: b)    Indica\u021bii: Num\u0103rul ciclurilor hamiltoniene dintr-un graf complet cu n noduri este:                   (n-1)!/2.  15.  R\u0103spuns corect: d)   Indica\u021bii: Afirma\u021bile 1,4 \u0219i 5 sunt adev\u0103rate.", "sentences": ["255    14.", " R\u0103spuns corect: b)    Indica\u021bii: Num\u0103rul ciclurilor hamiltoniene dintr-un graf complet cu n noduri este:                   (n-1)!/2.", " 15.", " R\u0103spuns corect: d)   Indica\u021bii: Afirma\u021bile 1,4 \u0219i 5 sunt adev\u0103rate."], "page_sentence_count_spacy": 4}, {"page_number": 256, "page_char_count": 1366, "page_word_count": 300, "page_sentence_count_raw": 18, "page_token_count": 341.5, "text": "256    Varianta 4  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: d)      Indica\u021bii: \u00cendeplinesc condi\u021bia cerut\u0103 expresiile 1, 2 \u0219i 4  2.  R\u0103spuns corect: f)   Indica\u021bii: dou\u0103 drepte paralele au aceea\u0219i pant\u0103  3.  R\u0103spuns corect: e)  a+b+c-f(a,f(c,b))    Indica\u021bii: a+b+c-max(a,b,c)=a+b+c-max(a,max(b,c))  4.  R\u0103spuns corect: a) -1 2 2 -1 -1 1     Indica\u021bii: Mecanismul de transmiterea parametrilor.  5.  R\u0103spuns corect: e) 152004    Indica\u021bii: Se mut\u0103 grupurile de c\u00e2te 2 cifre. Datorit\u0103 num\u0103rului impar de cifre a lui n, \u00een m  apare o cifr\u0103 \u00een plus.  6.  R\u0103spuns corect: d) 10239     Indica\u021bii: Algoritmul determin\u0103 baza minim\u0103 x \u00een care \u00eel consider\u0103 pe n-ul ini\u021bial \u0219i \u00eel  transform\u0103 \u00een baza 10   7.  R\u0103spuns corect: e)     Indica\u021bii: Linia n-j+1 din matricea a devine coloana j \u00een matricea b  8.  R\u0103spuns corect: c)    9.  R\u0103spuns corect: b)      Indica\u021bii: Indicii sunt de la 1 la n; parcurgere liniar\u0103 a vectorului.  10.  R\u0103spuns corect: f)  Insereaz\u0103 \u0219irul t \u00een \u0219irul s, \u00eencep\u00e2nd cu pozi\u021bia k           11.  R\u0103spuns corect: a) 0     Indica\u021bii: Graful este tare conex  12.  R\u0103spuns corect: f) (1,3,5,2,1,2)    Indica\u021bii: (3,2,1,5,1,1) \u2013 are num\u0103r impar de noduri de grad impar  (5,1,6,4,5,3) \u0219i (1,1,1,1,1,6) \u2013 au  un nod cu grad prea mare  (1,1,1,1,2,2) \u2013  nu poate fi conex deoarece are doar 4 muchii  (2,1,3,1,0,1) are un nod izolat  13.  R\u0103spuns corect: b) 8", "sentences": ["256    Varianta 4  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: d)      Indica\u021bii: \u00cendeplinesc condi\u021bia cerut\u0103 expresiile 1, 2 \u0219i 4  2.", " R\u0103spuns corect: f)   Indica\u021bii: dou\u0103 drepte paralele au aceea\u0219i pant\u0103  3.", " R\u0103spuns corect: e)  a+b+c-f(a,f(c,b))    Indica\u021bii: a+b+c-max(a,b,c)=a+b+c-max(a,max(b,c))  4.", " R\u0103spuns corect: a) -1 2 2 -1 -1 1     Indica\u021bii: Mecanismul de transmiterea parametrilor.", " 5.", " R\u0103spuns corect: e) 152004    Indica\u021bii: Se mut\u0103 grupurile de c\u00e2te 2 cifre.", "Datorit\u0103 num\u0103rului impar de cifre a lui n, \u00een m  apare o cifr\u0103 \u00een plus.", " 6.", " R\u0103spuns corect: d) 10239     Indica\u021bii: Algoritmul determin\u0103 baza minim\u0103 x \u00een care \u00eel consider\u0103 pe n-ul ini\u021bial \u0219i \u00eel  transform\u0103 \u00een baza 10   7.", " R\u0103spuns corect: e)     Indica\u021bii: Linia n-j+1 din matricea a devine coloana j \u00een matricea b  8.", " R\u0103spuns corect: c)    9.", " R\u0103spuns corect: b)      Indica\u021bii: Indicii sunt de la 1 la n; parcurgere liniar\u0103 a vectorului.", " 10.", " R\u0103spuns corect: f)  Insereaz\u0103 \u0219irul t \u00een \u0219irul s, \u00eencep\u00e2nd cu pozi\u021bia k           11.", " R\u0103spuns corect: a) 0     Indica\u021bii: Graful este tare conex  12.", " R\u0103spuns corect: f) (1,3,5,2,1,2)    Indica\u021bii: (3,2,1,5,1,1) \u2013 are num\u0103r impar de noduri de grad impar  (5,1,6,4,5,3) \u0219i (1,1,1,1,1,6) \u2013 au  un nod cu grad prea mare  (1,1,1,1,2,2) \u2013  nu poate fi conex deoarece are doar 4 muchii  (2,1,3,1,0,1) are un nod izolat  13.", " R\u0103spuns corect: b) 8"], "page_sentence_count_spacy": 18}, {"page_number": 257, "page_char_count": 186, "page_word_count": 48, "page_sentence_count_raw": 3, "page_token_count": 46.5, "text": "257    Indica\u021bii: 3n+2\u2264n(n-1)/2  14.  R\u0103spuns corect: c) 3     Indica\u021bii: Numerele 12, 16 \u0219i 18 genereaz\u0103 arbori cu 8 frunze  15.  R\u0103spuns corect: d) 25     Indica\u021bii: \ud835\udc365 2 + \ud835\udc365 3 + \ud835\udc365 4", "sentences": ["257    Indica\u021bii: 3n+2\u2264n(n-1)/2  14.", " R\u0103spuns corect: c) 3     Indica\u021bii: Numerele 12, 16 \u0219i 18 genereaz\u0103 arbori cu 8 frunze  15.", " R\u0103spuns corect: d) 25     Indica\u021bii: \ud835\udc365 2 + \ud835\udc365 3 + \ud835\udc365 4"], "page_sentence_count_spacy": 3}, {"page_number": 258, "page_char_count": 1414, "page_word_count": 284, "page_sentence_count_raw": 21, "page_token_count": 353.5, "text": "258    Varianta 5  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: e)   2.  R\u0103spuns corect: b)   Indica\u021bii: Operatorul % (mod) nu func\u021bioneaz\u0103 pe tipul real  3.  R\u0103spuns corect: c) dmtr  Indica\u021bii: La \u0219tergerea unei litere, vecina din dreapta \u00eei va lua locul \u0219i nu va mai fi  eliminat\u0103   4.  R\u0103spuns corect: d) Graful G con\u021bine cel pu\u021bin un ciclu  Indica\u021bii: Graful aciclic maximal cu 100 de noduri este un arbore \u0219i are 99 de muchii.   5.  R\u0103spuns corect: d) 30  Indica\u021bii: Numarul de valori 1 din matricea de adiacen\u021b\u0103 este egal cu num\u0103rul de arce  6.  R\u0103spuns corect: e) 5  Indica\u021bii: Nodurile terminale au gradul 1, restul nodurilor av\u00e2nd gradul 3  7.  R\u0103spuns corect: b)  8.  R\u0103spuns corect: a)  (1, 21, 13, 23, 33, 17, 27)  Indica\u021bii: \u0218irul trebuie s\u0103 fie sortat \u00een func\u021bie de cifra unit\u0103\u021bilor  9.  R\u0103spuns corect: c)   10.  R\u0103spuns corect: b) 12  11.  R\u0103spuns corect: a) 3 \u0219i 3  Indica\u021bii: Parametrul transmis prin valoare nu se modific\u0103, pe c\u00e2nd cel transmis prin  referin\u021b\u0103/adres\u0103, da.  12.  R\u0103spuns corect: a)   Indica\u021bii: Atribuirea este corect\u0103 \u00eentre dou\u0103 variabile de acela\u0219i tip RECORD/struct  13.  R\u0103spuns corect: e) 15  Indica\u021bii: Matricea de adiacen\u021b\u0103 are valori 0 pe diagonala principal\u0103. Dintre celelalte 6  elemente, 4 trebuie s\u0103 con\u021bin\u0103 valori 1, ordinea nefiind important\u0103. A\u0219adar num\u0103rul de  grafuri este \ud835\udc366 4.  14.  R\u0103spuns corect: e)  15.  R\u0103spuns corect: b) Graful G este un graf hamiltonian", "sentences": ["258    Varianta 5  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: e)   2.", " R\u0103spuns corect: b)   Indica\u021bii: Operatorul % (mod) nu func\u021bioneaz\u0103 pe tipul real  3.", " R\u0103spuns corect: c) dmtr  Indica\u021bii: La \u0219tergerea unei litere, vecina din dreapta \u00eei va lua locul \u0219i nu va mai fi  eliminat\u0103   4.", " R\u0103spuns corect: d) Graful G con\u021bine cel pu\u021bin un ciclu  Indica\u021bii: Graful aciclic maximal cu 100 de noduri este un arbore \u0219i are 99 de muchii.", "  5.", " R\u0103spuns corect: d) 30  Indica\u021bii: Numarul de valori 1 din matricea de adiacen\u021b\u0103 este egal cu num\u0103rul de arce  6.", " R\u0103spuns corect: e) 5  Indica\u021bii: Nodurile terminale au gradul 1, restul nodurilor av\u00e2nd gradul 3  7.", " R\u0103spuns corect: b)  8.", " R\u0103spuns corect: a)  (1, 21, 13, 23, 33, 17, 27)  Indica\u021bii: \u0218irul trebuie s\u0103 fie sortat \u00een func\u021bie de cifra unit\u0103\u021bilor  9.", " R\u0103spuns corect: c)   10.", " R\u0103spuns corect: b) 12  11.", " R\u0103spuns corect: a) 3 \u0219i 3  Indica\u021bii: Parametrul transmis prin valoare nu se modific\u0103, pe c\u00e2nd cel transmis prin  referin\u021b\u0103/adres\u0103, da.", " 12.", " R\u0103spuns corect: a)   Indica\u021bii: Atribuirea este corect\u0103 \u00eentre dou\u0103 variabile de acela\u0219i tip RECORD/struct  13.", " R\u0103spuns corect: e) 15  Indica\u021bii: Matricea de adiacen\u021b\u0103 are valori 0 pe diagonala principal\u0103.", "Dintre celelalte 6  elemente, 4 trebuie s\u0103 con\u021bin\u0103 valori 1, ordinea nefiind important\u0103.", "A\u0219adar num\u0103rul de  grafuri este \ud835\udc366 4.", " 14.", " R\u0103spuns corect: e)  15.", " R\u0103spuns corect: b) Graful G este un graf hamiltonian"], "page_sentence_count_spacy": 21}, {"page_number": 259, "page_char_count": 1197, "page_word_count": 245, "page_sentence_count_raw": 19, "page_token_count": 299.25, "text": "259      Varianta 6  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: b) 8  Indica\u021bii: num\u0103rul este par (k*2).   2.  R\u0103spuns corect: c) (a+b)%2==0  Indica\u021bii: suma a dou\u0103 numere de aceea\u0219i paritate este un num\u0103r par      .  3.  R\u0103spuns corect: a) aticamatica  4.  R\u0103spuns corect: b) 9  Indica\u021bii: se ob\u021bine un nod izolat  5.  R\u0103spuns corect: d) (1,2,2,1,2,2)  Indica\u021bii: suma gradelor tuturor nodurilor unui graf neorientat este un num\u0103r par.  6.  R\u0103spuns corect: b)12  7.  R\u0103spuns corect: b) 3   Indica\u021bii: graful va con\u021bine un circuit elementar cu toate nodurile grafului \u0219i \u00eenc\u0103 dou\u0103 arce  care au extremitatea ini\u021bial\u0103 \u00een acela\u0219i nod.  8.  R\u0103spuns corect: b) Suma elementelor de pe diagonala secundar\u0103 a tabloului a   Indica\u021bii: pentru ca un element s\u0103 se g\u0103seasc\u0103 pe diagonal secundar\u0103 tr     ebuie ca suma  dintre indicele liniei \u0219i cel al coloanei s\u0103 fie n+1      .  9.  R\u0103spuns corect: b) 4  Indica\u021bii: x=a[1][2]+a[3][4]=1+3=4  10.  R\u0103spuns corect: a) aranjamentelor   Indica\u021bii: elementele ce formeaz\u0103 o solu\u021bie sunt distincte iar ordinea lor \u00een cadrul unei  solu\u021bii conteaz\u0103.  11.  R\u0103spuns corect: d) 60  Indica\u021bii: \u22012 5 \u2217\u22012 4   12.  R\u0103spuns corect: c) determinarea elementului maxim din \u0219ir", "sentences": ["259      Varianta 6  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: b) 8  Indica\u021bii: num\u0103rul este par (k*2).", "  2.", " R\u0103spuns corect: c) (a+b)%2==0  Indica\u021bii: suma a dou\u0103 numere de aceea\u0219i paritate este un num\u0103r par      .", " 3.", " R\u0103spuns corect: a) aticamatica  4.", " R\u0103spuns corect: b) 9  Indica\u021bii: se ob\u021bine un nod izolat  5.", " R\u0103spuns corect: d) (1,2,2,1,2,2)  Indica\u021bii: suma gradelor tuturor nodurilor unui graf neorientat este un num\u0103r par.", " 6.", " R\u0103spuns corect: b)12  7.", " R\u0103spuns corect: b) 3   Indica\u021bii: graful va con\u021bine un circuit elementar cu toate nodurile grafului \u0219i \u00eenc\u0103 dou\u0103 arce  care au extremitatea ini\u021bial\u0103 \u00een acela\u0219i nod.", " 8.", " R\u0103spuns corect: b) Suma elementelor de pe diagonala secundar\u0103 a tabloului a   Indica\u021bii: pentru ca un element s\u0103 se g\u0103seasc\u0103 pe diagonal secundar\u0103 tr     ebuie ca suma  dintre indicele liniei \u0219i cel al coloanei s\u0103 fie n+1      .", " 9.", " R\u0103spuns corect: b) 4  Indica\u021bii: x=a[1][2]+a[3][4]=1+3=4  10.", " R\u0103spuns corect: a) aranjamentelor   Indica\u021bii: elementele ce formeaz\u0103 o solu\u021bie sunt distincte iar ordinea lor \u00een cadrul unei  solu\u021bii conteaz\u0103.", " 11.", " R\u0103spuns corect: d) 60  Indica\u021bii: \u22012 5 \u2217\u22012 4   12.", " R\u0103spuns corect: c) determinarea elementului maxim din \u0219ir"], "page_sentence_count_spacy": 19}, {"page_number": 260, "page_char_count": 232, "page_word_count": 49, "page_sentence_count_raw": 6, "page_token_count": 58.0, "text": "260    13.  R\u0103spuns corect: a) p.x*p.y>0  Indica\u021bii: \u00een aceste cadrane abscisa \u0219i ordonata au acela\u0219i semn.  14.  R\u0103spuns corect: b) 90   Indica\u021bii: toate nodurile \u00eel au ca \u201ctat\u0103\u201d pe nodul etichetat cu 10.  15.  R\u0103spuns corect: b) 2", "sentences": ["260    13.", " R\u0103spuns corect: a) p.x*p.y>0  Indica\u021bii: \u00een aceste cadrane abscisa \u0219i ordonata au acela\u0219i semn.", " 14.", " R\u0103spuns corect: b) 90   Indica\u021bii: toate nodurile \u00eel au ca \u201ctat\u0103\u201d pe nodul etichetat cu 10.", " 15.", " R\u0103spuns corect: b) 2"], "page_sentence_count_spacy": 6}, {"page_number": 261, "page_char_count": 1225, "page_word_count": 368, "page_sentence_count_raw": 16, "page_token_count": 306.25, "text": "261    Varianta 7  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect:   b)   !(x<-4 || x>-1) || !(x<1 || x>4) || !(x<10)   (C++/C)  respectiv     b)   not((x<-4) or ( x>-1)) or not((x<1)or (x>4)) or not(x<10)     (Pascal)  2.  R\u0103spuns corect:   c) floor(5.19) == floor(5.91)  (C++/C)   respectiv     c) trunc(5.19)=trunc(5.91)   (Pascal)  3.  R\u0103spuns corect:   d) (3, 4, 10, 17, 46)    4.  R\u0103spuns corect:   e) 3   (valorile comparate cu x fiind 12, 18, 17 )  5.  R\u0103spuns corect:   f) 3  (5, 6, 7)  6.  R\u0103spuns corect:   d) 20  (C63 = 20)  7.  R\u0103spuns corect:   e) 6  8.  R\u0103spuns corect:   f)  f.close(); (C++) sau    fclose(f);  (C)  sau close(f);  (Pascal)       9.  R\u0103spuns corect:   c) 9  10.  R\u0103spuns corect:   f) ((c.p1+c.p2)*0.8+c.medbac*0.2)>=5.0  11.  R\u0103spuns corect:   d)   void cifre (unsigned n, unsigned &prim, unsigned &ult)  (C++)                                       void cifre (unsigned n, unsigned *prim, unsigned *ult)  (C)                                        procedure cifre (n: longint; var prim,ult: byte);    (Pascal)  12.  R\u0103spuns corect:   f) 10 \u015fi 1  13.  R\u0103spuns corect:   c)  15 \u0219i 210 (nr minim arce = nr v\u00e2rfuri; nr maxim = n*(n-1))  14.  R\u0103spuns corect:   f) 1 \u015fi 2  15.  R\u0103spuns corect:   d)  63", "sentences": ["261    Varianta 7  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect:   b)   !(", "x<-4 || x>-1) || !(", "x<1 || x>4) || !(", "x<10)   (C++/C)  respectiv     b)   not((x<-4) or ( x>-1)) or not((x<1)or (x>4)) or not(x<10)     (Pascal)  2.", " R\u0103spuns corect:   c) floor(5.19) == floor(5.91)  (C++/C)   respectiv     c) trunc(5.19)=trunc(5.91)   (Pascal)  3.", " R\u0103spuns corect:   d) (3, 4, 10, 17, 46)    4.", " R\u0103spuns corect:   e) 3   (valorile comparate cu x fiind 12, 18, 17 )  5.", " R\u0103spuns corect:   f) 3  (5, 6, 7)  6.", " R\u0103spuns corect:   d) 20  (C63 = 20)  7.", " R\u0103spuns corect:   e) 6  8.", " R\u0103spuns corect:   f)  f.close(); (C++) sau    fclose(f);  (C)  sau close(f);  (Pascal)       9.", " R\u0103spuns corect:   c) 9  10.", " R\u0103spuns corect:   f) ((c.p1+c.p2)*0.8+c.medbac*0.2)>=5.0  11.", " R\u0103spuns corect:   d)   void cifre (unsigned n, unsigned &prim, unsigned &ult)  (C++)                                       void cifre (unsigned n, unsigned *prim, unsigned *ult)  (C)                                        procedure cifre (n: longint; var prim,ult: byte);    (Pascal)  12.", " R\u0103spuns corect:   f) 10 \u015fi 1  13.", " R\u0103spuns corect:   c)  15 \u0219i 210 (nr minim arce = nr v\u00e2rfuri; nr maxim = n*(n-1))  14.", " R\u0103spuns corect:   f) 1 \u015fi 2  15.", " R\u0103spuns corect:   d)  63"], "page_sentence_count_spacy": 19}, {"page_number": 262, "page_char_count": 1387, "page_word_count": 366, "page_sentence_count_raw": 16, "page_token_count": 346.75, "text": "262    Varianta 8  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect:   e) !((x>=  -4  &&  x<=  -1)  ||  (x>= 1 && x<= 4)  ||  (x>= 10))    (C/C++)   respectiv   e) not((x>= -4 and  x<= -1) or (x>=1 and  x<=4) or (x>=10))      (Pascal)    2.  R\u0103spuns corect:   c) floor(5.19) == floor(5.91)      (C/C++)  respectiv   c) trunc(5.19)=trunc(5.91)      (Pascal)    3.  R\u0103spuns corect:   f) (3, 4, 7, 10, 12, 17, 18, 20, 46)  4.  R\u0103spuns corect:   e) (3, 4, 10, 17, 46) \u015fi (7, 10, 12, 18, 20)    5.  R\u0103spuns corect:   c) 9  6.  R\u0103spuns corect:   d) 70  7.  R\u0103spuns corect:   e) 512  8.  R\u0103spuns corect:   d) f.close(); (C++) sau    fclose(f); (C)    sau     close(f); (Pascal)    9.  R\u0103spuns corect:   b) \u20189\u2019  10.  R\u0103spuns corect:   f) (e.sex==\u2019F\u2019 || e.sex==\u2019f\u2019) && (e.dn.l==7 && e.dn.z<=10)         (C/C++)  respectiv    ((e.sex=\u2019F\u2019) or (e.sex=\u2019f\u2019)) and (e.dn.l=7) and (e.dn.z<=10)      (Pascal)    11.  R\u0103spuns corect:   c)  return  suma(n);      (C/C++)   respectiv     c)  suma(n);     (Pascal)  12.  R\u0103spuns corect:   f)  56  (num\u0103rul minim de muchii se ob\u0163ine pentru dou\u0103 componente  conexe, fiecare graf complet cu 8 v\u00e2rfuri; m=8*7/2=28 reprezint\u0103 num\u0103rul de muchii  pentru fiecare dintre aceste componente)  13.  R\u0103spuns corect:   e)  9  (graful, av\u00e2nd 10 v\u00e2rfuri, gradul maxim al unui v\u00e2rf poate fi n- 1=9)  14.  R\u0103spuns corect:   c)  Graful este (slab) conex  15.  R\u0103spuns corect:   d) 33", "sentences": ["262    Varianta 8  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect:   e) !((", "x>=  -4  &&  x<=  -1)  ||  (x>= 1 && x<= 4)  ||  (x>= 10))    (C/C++)   respectiv   e) not((x>= -4 and  x<= -1) or (x>=1 and  x<=4) or (x>=10))      (Pascal)    2.", " R\u0103spuns corect:   c) floor(5.19) == floor(5.91)      (C/C++)  respectiv   c) trunc(5.19)=trunc(5.91)      (Pascal)    3.", " R\u0103spuns corect:   f) (3, 4, 7, 10, 12, 17, 18, 20, 46)  4.", " R\u0103spuns corect:   e) (3, 4, 10, 17, 46) \u015fi (7, 10, 12, 18, 20)    5.", " R\u0103spuns corect:   c) 9  6.", " R\u0103spuns corect:   d) 70  7.", " R\u0103spuns corect:   e) 512  8.", " R\u0103spuns corect:   d) f.close(); (C++) sau    fclose(f); (C)    sau     close(f); (Pascal)    9.", " R\u0103spuns corect:   b) \u20189\u2019  10.", " R\u0103spuns corect:   f) (e.sex==\u2019F\u2019 || e.sex==\u2019f\u2019) && (e.dn.l==7 && e.dn.z<=10)         (C/C++)  respectiv    ((e.sex=\u2019F\u2019) or (e.sex=\u2019f\u2019)) and (e.dn.l=7) and (e.dn.z<=10)      (Pascal)    11.", " R\u0103spuns corect:   c)  return  suma(n);      (C/C++)   respectiv     c)  suma(n);     (Pascal)  12.", " R\u0103spuns corect:   f)  56  (num\u0103rul minim de muchii se ob\u0163ine pentru dou\u0103 componente  conexe, fiecare graf complet cu 8 v\u00e2rfuri; m=8*7/2=28 reprezint\u0103 num\u0103rul de muchii  pentru fiecare dintre aceste componente)  13.", " R\u0103spuns corect:   e)  9  (graful, av\u00e2nd 10 v\u00e2rfuri, gradul maxim al unui v\u00e2rf poate fi n- 1=9)  14.", " R\u0103spuns corect:   c)  Graful este (slab) conex  15.", " R\u0103spuns corect:   d) 33"], "page_sentence_count_spacy": 17}, {"page_number": 263, "page_char_count": 1576, "page_word_count": 299, "page_sentence_count_raw": 11, "page_token_count": 394.0, "text": "263      Varianta 9  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect:b)  Indica\u021bii: verificare direct\u0103 a fiec\u0103rei variante folosind pentru n o valoare cu cel putin 4  cifre  2.  R\u0103spuns corect: f)  Indica\u021bii: se \u021bine cont de preceden\u021ba operatorilor \u0219i de regulile de negare a unei expresii  logice  3.  R\u0103spuns corect: d)  Indica\u021bii: \u0219irul ini\u021bial are 8 caractere, pentru c\u0103 la fiecare itera\u021bie se elimin\u0103 un caracter.  Mai departe, se analizeaz\u0103 caracterele afi\u0219ate     : primul caracter este 'a', prin urmare al  doilea caracter din \u0219irul ini\u021bial trebuie s\u0103 fie 'b' \u0219.a.m.d  4.  R\u0103spuns corect: d)  Indica\u021bii:un arbore cu 4 noduri are 3 muchii, este conex \u0219i f\u0103r\u0103 cicluri  5.  R\u0103spuns corect:d)   Indica\u021bii:calcul direct al valorilor din matrice, apoi se num\u0103r\u0103 c\u00e2te dintre elemente      sunt  valori prime  6.  R\u0103spuns corect: b)  Indica\u021bii: se analizeaz\u0103 solu\u021biile din enun\u021b: solu\u021bia care are pe prima pozi\u021bie valoarea 1 va  fi prima generat\u0103, apoi urmeaz\u0103 solu\u021biile care au pe prima pozi\u021bie valoarea 2; solu\u021bia care  con\u021bine valoarea 3 pe pozi\u021bia a 2-a va fi generat\u0103 \u00eenaintea celei care con\u021bine  pe pozi\u021bia a 2- a valoarea 8; solu\u021bia care are pe prima pozi\u021bie valoarea 3 va fi generat\u0103 ultima  7.  R\u0103spuns corect: e)  Indica\u021bii: (1,2,3,1), (1,3,5,1), (3,4,5,3), (1,2,3,5,1), (1,3,4,5,1), (1,2,3,4,5,1)  8.  R\u0103spuns corect:d)  Indica\u021bii: componentele tare conexe sunt alc\u0103tuite din urm\u0103toarele mul\u021bimi de noduri  {1,2,3,6},{4},{5},{7}   9.  R\u0103spuns corect:e)  Indica\u021bii:lan\u021burile de lungime maxim\u0103 se afl\u0103 \u00eentre nodurile 9 \u0219i 12, 9 \u0219i 8, 9 \u0219i 11, 10 \u0219i 12,  10 \u0219i 8, 10 \u0219i 11", "sentences": ["263      Varianta 9  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect:b)  Indica\u021bii: verificare direct\u0103 a fiec\u0103rei variante folosind pentru n o valoare cu cel putin 4  cifre  2.", " R\u0103spuns corect: f)  Indica\u021bii: se \u021bine cont de preceden\u021ba operatorilor \u0219i de regulile de negare a unei expresii  logice  3.", " R\u0103spuns corect: d)  Indica\u021bii: \u0219irul ini\u021bial are 8 caractere, pentru c\u0103 la fiecare itera\u021bie se elimin\u0103 un caracter.", " Mai departe, se analizeaz\u0103 caracterele afi\u0219ate     : primul caracter este 'a', prin urmare al  doilea caracter din \u0219irul ini\u021bial trebuie s\u0103 fie 'b' \u0219.a.m.d  4.", " R\u0103spuns corect: d)  Indica\u021bii:un arbore cu 4 noduri are 3 muchii, este conex \u0219i f\u0103r\u0103 cicluri  5.", " R\u0103spuns corect:d)   Indica\u021bii:calcul direct al valorilor din matrice, apoi se num\u0103r\u0103 c\u00e2te dintre elemente      sunt  valori prime  6.", " R\u0103spuns corect: b)  Indica\u021bii: se analizeaz\u0103 solu\u021biile din enun\u021b: solu\u021bia care are pe prima pozi\u021bie valoarea 1 va  fi prima generat\u0103, apoi urmeaz\u0103 solu\u021biile care au pe prima pozi\u021bie valoarea 2; solu\u021bia care  con\u021bine valoarea 3 pe pozi\u021bia a 2-a va fi generat\u0103 \u00eenaintea celei care con\u021bine  pe pozi\u021bia a 2- a valoarea 8; solu\u021bia care are pe prima pozi\u021bie valoarea 3 va fi generat\u0103 ultima  7.", " R\u0103spuns corect: e)  Indica\u021bii: (1,2,3,1), (1,3,5,1), (3,4,5,3), (1,2,3,5,1), (1,3,4,5,1), (1,2,3,4,5,1)  8.", " R\u0103spuns corect:d)  Indica\u021bii: componentele tare conexe sunt alc\u0103tuite din urm\u0103toarele mul\u021bimi de noduri  {1,2,3,6},{4},{5},{7}   9.", " R\u0103spuns corect:e)  Indica\u021bii:lan\u021burile de lungime maxim\u0103 se afl\u0103 \u00eentre nodurile 9 \u0219i 12, 9 \u0219i 8, 9 \u0219i 11, 10 \u0219i 12,  10 \u0219i 8, 10 \u0219i 11"], "page_sentence_count_spacy": 11}, {"page_number": 264, "page_char_count": 882, "page_word_count": 163, "page_sentence_count_raw": 9, "page_token_count": 220.5, "text": "264    10.  R\u0103spuns corect: e)  Indica\u021bii: se verific\u0103 dac\u0103 distan\u021ba de la centrul cercului la originea sistemului de  coordonate este mai mic\u0103 dec\u00e2t raza cercului  11.  R\u0103spuns corect: a)  12.  R\u0103spuns corect: a)  13.  R\u0103spuns corect: b)  Indica\u021bii: variabila global\u0103 y este vizibil\u0103 \u00een toate func\u021biile \u0219i va fi modificat\u0103 de fiecare  apel al acestora. Variabila global\u0103 x nu va fi modificat\u0103, deoarece \u00een fiecare dintre func\u021bii  exist\u0103 un parametru cu acela\u0219i nume, iar apelul g(x) va prelua pe segmentul de stiv\u0103 doar  valoarea lui x.  14.  R\u0103spuns corect: d)  Indica\u021bii:secven\u021ba determin\u0103 num\u0103rul de numere cu cel mult 4 cifre care au num\u0103rul  divizorilor num\u0103r par; se \u0219tie c\u0103 doar p\u0103tratele perfecte au num\u0103r impar de divizori   15.  R\u0103spuns corect: e)  Indica\u021bii:func\u021bia verific\u0103 (utiliz\u00e2nd Divide et Impera) dac\u0103 vectorul este sortat strict  cresc\u0103tor \u00eentre pozi\u021biile 2 \u0219i 5", "sentences": ["264    10.", " R\u0103spuns corect: e)  Indica\u021bii: se verific\u0103 dac\u0103 distan\u021ba de la centrul cercului la originea sistemului de  coordonate este mai mic\u0103 dec\u00e2t raza cercului  11.", " R\u0103spuns corect: a)  12.", " R\u0103spuns corect: a)  13.", " R\u0103spuns corect: b)  Indica\u021bii: variabila global\u0103 y este vizibil\u0103 \u00een toate func\u021biile \u0219i va fi modificat\u0103 de fiecare  apel al acestora.", "Variabila global\u0103 x nu va fi modificat\u0103, deoarece \u00een fiecare dintre func\u021bii  exist\u0103 un parametru cu acela\u0219i nume, iar apelul g(x) va prelua pe segmentul de stiv\u0103 doar  valoarea lui x.  14.", " R\u0103spuns corect: d)  Indica\u021bii:secven\u021ba determin\u0103 num\u0103rul de numere cu cel mult 4 cifre care au num\u0103rul  divizorilor num\u0103r par; se \u0219tie c\u0103 doar p\u0103tratele perfecte au num\u0103r impar de divizori   15.", " R\u0103spuns corect: e)  Indica\u021bii:func\u021bia verific\u0103 (utiliz\u00e2nd Divide et Impera) dac\u0103 vectorul este sortat strict  cresc\u0103tor \u00eentre pozi\u021biile 2 \u0219i 5"], "page_sentence_count_spacy": 8}, {"page_number": 265, "page_char_count": 1614, "page_word_count": 303, "page_sentence_count_raw": 18, "page_token_count": 403.5, "text": "265    Varianta 10  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect:  c)  Indica\u021bii: verificare direct\u0103, \u021bin\u00e2nd cont de preceden\u021ba operatorior  2.  R\u0103spuns corect: d)  Indica\u021bii:verificare direct\u0103 a fiec\u0103rei variante de r\u0103spuns  3.  R\u0103spuns corect: b)  Indica\u021bii: Algoritmul determin\u0103 ultima cifr\u0103 a num\u0103rului xy. Cum ultima cifr\u0103 a lui x este  7, ultima cifr\u0103 a puterilor lui x va fi 7, 9, 3, 1, apoi se repet\u0103. Pentru y sunt posibile 90  de  valori (de la 10 la 99), \u00eenseamn\u0103 c\u0103 22 dintre acestea vor determina pentru z valoarea 1.   4.  R\u0103spuns corect:d)  5.  R\u0103spuns corect: a)  Indica\u021bii: f(f(775125) + f(97917))=f(5+7)=f(12)=-1  6.  R\u0103spuns corect: f)  Indica\u021bii: primele 11 solu\u021bii sunt: {1}, {1,2}, {1,2,3}, {1,2,3,4}, {1,2,3,4,5},  {1,2,3,4,5,6}, {1,2,3,4,5,6,7}, {1,2,3,4,5,7},{1,2,3,4,6}, {1,2,3,4,6,7}, {1,2,3,4,7}  7.  R\u0103spuns corect: e)  Indica\u021bii: nodurile 1 \u0219i 3 au gradul 3 \u0219i sunt adiacente, prin urmare pentru a ob\u021bine un graf  eulerian este necesar ca acestea s\u0103 ajung\u0103 s\u0103 aib\u0103      gradul 4.       8.  R\u0103spuns corect: b)  Indica\u021bii: cele 16 muchii pot determina o componenta conex\u0103 cu 17 noduri (arbore), deci  r\u0103m\u00e2n 13 noduri izolate \u0219i prin urmare num\u0103rul minim de componente conexe este 14.  Pentru a determina num\u0103rul maxim de componente conexe, se caut\u0103 graful complet cel mai  mare care are cel mult 16 muchii. K6 are  15 muchii, deci vom avea o component\u0103 conex\u0103  cu 7 noduri, 23 de noduri izolate, adic\u0103 24 componente conexe  9.  R\u0103spuns corect: c)  Indica\u021bii: graful con\u021bine arcele: (2,4), (2,6), (2,8), (2,10), (3,6),(3,9), (4,8), (5,10)  10.  R\u0103spuns corect: b)  11.  R\u0103spuns corect: c)", "sentences": ["265    Varianta 10  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect:  c)  Indica\u021bii: verificare direct\u0103, \u021bin\u00e2nd cont de preceden\u021ba operatorior  2.", " R\u0103spuns corect: d)  Indica\u021bii:verificare direct\u0103 a fiec\u0103rei variante de r\u0103spuns  3.", " R\u0103spuns corect: b)  Indica\u021bii: Algoritmul determin\u0103 ultima cifr\u0103 a num\u0103rului xy.", "Cum ultima cifr\u0103 a lui x este  7, ultima cifr\u0103 a puterilor lui x va fi 7, 9, 3, 1, apoi se repet\u0103.", "Pentru y sunt posibile 90  de  valori (de la 10 la 99), \u00eenseamn\u0103 c\u0103 22 dintre acestea vor determina pentru z valoarea 1.", "  4.", " R\u0103spuns corect:d)  5.", " R\u0103spuns corect: a)  Indica\u021bii: f(f(775125) + f(97917))=f(5+7)=f(12)=-1  6.", " R\u0103spuns corect: f)  Indica\u021bii: primele 11 solu\u021bii sunt: {1}, {1,2}, {1,2,3}, {1,2,3,4}, {1,2,3,4,5},  {1,2,3,4,5,6}, {1,2,3,4,5,6,7}, {1,2,3,4,5,7},{1,2,3,4,6}, {1,2,3,4,6,7}, {1,2,3,4,7}  7.", " R\u0103spuns corect: e)  Indica\u021bii: nodurile 1 \u0219i 3 au gradul 3 \u0219i sunt adiacente, prin urmare pentru a ob\u021bine un graf  eulerian este necesar ca acestea s\u0103 ajung\u0103 s\u0103 aib\u0103      gradul 4.", "      8.", " R\u0103spuns corect: b)  Indica\u021bii: cele 16 muchii pot determina o componenta conex\u0103 cu 17 noduri (arbore), deci  r\u0103m\u00e2n 13 noduri izolate \u0219i prin urmare num\u0103rul minim de componente conexe este 14.", " Pentru a determina num\u0103rul maxim de componente conexe, se caut\u0103 graful complet cel mai  mare care are cel mult 16 muchii.", "K6 are  15 muchii, deci vom avea o component\u0103 conex\u0103  cu 7 noduri, 23 de noduri izolate, adic\u0103 24 componente conexe  9.", " R\u0103spuns corect: c)  Indica\u021bii: graful con\u021bine arcele: (2,4), (2,6), (2,8), (2,10), (3,6),(3,9), (4,8), (5,10)  10.", " R\u0103spuns corect: b)  11.", " R\u0103spuns corect: c)"], "page_sentence_count_spacy": 18}, {"page_number": 266, "page_char_count": 544, "page_word_count": 98, "page_sentence_count_raw": 6, "page_token_count": 136.0, "text": "266    Indica\u021bii: fiecare apel recursiv va gestiona propria variabil\u0103 local\u0103 i   12.  R\u0103spuns corect: d)  Sunt 12 valori afi\u0219ate: 19 20 21 22 30 38 46 45 44 43 35 27  13.  R\u0103spuns corect: f)  Indica\u021bii: verificare direct\u0103  14.  R\u0103spuns corect: d)  Indica\u021bii:dup\u0103 executarea subprogramului, vectorul a con\u021bine valorile (1,6,15,20,15,6,1)  15.  R\u0103spuns corect: e)  Indica\u021bii:secven\u021ba determin\u0103 suma cifrelor \u00een baza b=3. Pentru a determina suma maxim\u0103,  \u00eeincerc\u0103m s\u0103 consider\u0103m c\u00e2t mai multe cifre 2 (cifra maxim\u0103 \u00een baza 3):  2*1+2*3+2*9+2*27=80", "sentences": ["266    Indica\u021bii: fiecare apel recursiv va gestiona propria variabil\u0103 local\u0103 i   12.", " R\u0103spuns corect: d)  Sunt 12 valori afi\u0219ate: 19 20 21 22 30 38 46 45 44 43 35 27  13.", " R\u0103spuns corect: f)  Indica\u021bii: verificare direct\u0103  14.", " R\u0103spuns corect: d)  Indica\u021bii:dup\u0103 executarea subprogramului, vectorul a con\u021bine valorile (1,6,15,20,15,6,1)  15.", " R\u0103spuns corect: e)  Indica\u021bii:secven\u021ba determin\u0103 suma cifrelor \u00een baza b=3.", "Pentru a determina suma maxim\u0103,  \u00eeincerc\u0103m s\u0103 consider\u0103m c\u00e2t mai multe cifre 2 (cifra maxim\u0103 \u00een baza 3):  2*1+2*3+2*9+2*27=80"], "page_sentence_count_spacy": 6}, {"page_number": 267, "page_char_count": 942, "page_word_count": 198, "page_sentence_count_raw": 20, "page_token_count": 235.5, "text": "267    Varianta 11   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect e)  2.  R\u0103spuns corect c)  3.  R\u0103spuns corect f)  Indica\u021bie: Este suficient s\u0103 fie calculat radical de ordinul 3 din n pentru a afla c\u00e2te  cuburi mai mici sau egale dec\u00e2t n exist\u0103.  4.  R\u0103spuns corect d)  5.  R\u0103spuns corect e)  6.  R\u0103spuns corect c)  7.  R\u0103spuns corect a)  Indica\u021bie: Pentru ca un graf neorientat cu n noduri s\u0103 fie conex, num\u0103rul minim de  muchii necesare este n-1.  8.  R\u0103spuns corect f)  9.  R\u0103spuns corect d)  Indica\u021bie: Suma gradelor nu trebuie sa fie egal\u0103 cu 2n-2 (n=num\u0103rul v\u00e2rfurilor)  10.  R\u0103spuns corect e)  11.  R\u0103spuns corect b)  Indica\u021bie: La sum\u0103 se adun\u0103 doar numerele divizibile cu 3, iar condi\u021bia de oprire a  recursivit\u0103\u021bii este c\u00e2nd i este egal cu 3*n.  12.  R\u0103spuns corect b)  13.  R\u0103spuns corect a)  Indica\u021bie: pentru b=29 si b=30.   Subprogramul calculeaz\u0103 num\u0103rul valorilor naturale impare din intervalul [a, b].  14.  R\u0103spuns corect b)", "sentences": ["267    Varianta 11   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect e)  2.", " R\u0103spuns corect c)  3.", " R\u0103spuns corect f)  Indica\u021bie: Este suficient s\u0103 fie calculat radical de ordinul 3 din n pentru a afla c\u00e2te  cuburi mai mici sau egale dec\u00e2t n exist\u0103.", " 4.", " R\u0103spuns corect d)  5.", " R\u0103spuns corect e)  6.", " R\u0103spuns corect c)  7.", " R\u0103spuns corect a)  Indica\u021bie: Pentru ca un graf neorientat cu n noduri s\u0103 fie conex, num\u0103rul minim de  muchii necesare este n-1.", " 8.", " R\u0103spuns corect f)  9.", " R\u0103spuns corect d)  Indica\u021bie: Suma gradelor nu trebuie sa fie egal\u0103 cu 2n-2 (n=num\u0103rul v\u00e2rfurilor)  10.", " R\u0103spuns corect e)  11.", " R\u0103spuns corect b)  Indica\u021bie: La sum\u0103 se adun\u0103 doar numerele divizibile cu 3, iar condi\u021bia de oprire a  recursivit\u0103\u021bii este c\u00e2nd i este egal cu 3*n.", " 12.", " R\u0103spuns corect b)  13.", " R\u0103spuns corect a)  Indica\u021bie: pentru b=29 si b=30.", "  Subprogramul calculeaz\u0103 num\u0103rul valorilor naturale impare din intervalul [a, b].", " 14.", " R\u0103spuns corect b)"], "page_sentence_count_spacy": 20}, {"page_number": 268, "page_char_count": 103, "page_word_count": 23, "page_sentence_count_raw": 2, "page_token_count": 25.75, "text": "268    Indica\u021bie: Calculeaz\u0103 \ud835\udc36\ud835\udc5b \ud835\udc58  15.  R\u0103spuns corect b)  Indica\u021bie: Calculeaz\u0103 ultima cifr\u0103 a lui  xy", "sentences": ["268    Indica\u021bie: Calculeaz\u0103 \ud835\udc36\ud835\udc5b \ud835\udc58  15.", " R\u0103spuns corect b)  Indica\u021bie: Calculeaz\u0103 ultima cifr\u0103 a lui  xy"], "page_sentence_count_spacy": 2}, {"page_number": 269, "page_char_count": 814, "page_word_count": 165, "page_sentence_count_raw": 16, "page_token_count": 203.5, "text": "269    Varianta 12   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect b)  Indica\u021bie: num\u0103rul muchiilor unui graf neorientat complet este n*(n-1)/2  2.  R\u0103spuns corect a)  Indica\u021bie: condi\u021bia ca un element s\u0103 se situeze pe diagonala secundar\u0103 a unui tablou  bidimensional este i+j=n+1 (unde i, j reprezint\u0103 indicii de linie \u0219i coloan\u0103 ai  elementului  3.  R\u0103spuns corect d)  4.  R\u0103spuns corect f)  5.  R\u0103spuns corect a)  6.  R\u0103spuns corect e)  7.  R\u0103spuns corect c)  8.  R\u0103spuns corect d)  9.  R\u0103spuns corect a)  Indica\u021bie: Suma gradelor trebuie sa fie egala cu 2n-2 (n=num\u0103rul v\u00e2rfurilor)  10.  R\u0103spuns corect d)  11.  R\u0103spuns corect b)  12.  R\u0103spuns corect e)  13.  R\u0103spuns corect c)  14.  R\u0103spuns corect d)  Indica\u021bie: Valoarea calculat\u0103 reprezint\u0103 num\u0103rul divizorilor pozitivi ai variabilei n  15.  R\u0103spuns corect c)", "sentences": ["269    Varianta 12   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect b)  Indica\u021bie: num\u0103rul muchiilor unui graf neorientat complet este n*(n-1)/2  2.", " R\u0103spuns corect a)  Indica\u021bie: condi\u021bia ca un element s\u0103 se situeze pe diagonala secundar\u0103 a unui tablou  bidimensional este i+j=n+1 (unde i, j reprezint\u0103 indicii de linie \u0219i coloan\u0103 ai  elementului  3.", " R\u0103spuns corect d)  4.", " R\u0103spuns corect f)  5.", " R\u0103spuns corect a)  6.", " R\u0103spuns corect e)  7.", " R\u0103spuns corect c)  8.", " R\u0103spuns corect d)  9.", " R\u0103spuns corect a)  Indica\u021bie: Suma gradelor trebuie sa fie egala cu 2n-2 (n=num\u0103rul v\u00e2rfurilor)  10.", " R\u0103spuns corect d)  11.", " R\u0103spuns corect b)  12.", " R\u0103spuns corect e)  13.", " R\u0103spuns corect c)  14.", " R\u0103spuns corect d)  Indica\u021bie: Valoarea calculat\u0103 reprezint\u0103 num\u0103rul divizorilor pozitivi ai variabilei n  15.", " R\u0103spuns corect c)"], "page_sentence_count_spacy": 16}, {"page_number": 270, "page_char_count": 1238, "page_word_count": 293, "page_sentence_count_raw": 21, "page_token_count": 309.5, "text": "270    Varianta 13   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect c) 2  Indica\u021bii: corecte sunt variantele 3 \u0219i 4   2.  R\u0103spuns corect e) 2 14  3.  R\u0103spuns corect e) 112  4.  R\u0103spuns corect b) 2 4 6  5.  R\u0103spuns corect a) 4               6 3  6.  R\u0103spuns corect c) neenUB  7.  R\u0103spuns corect d) 1225  Indica\u021bii: 49+48+...+1=50*49/2= 1225 (suma Gauss)  8.  R\u0103spuns corect  b) dcafe;               dcbaf  9.  R\u0103spuns corect f) 350  Indica\u021bii: meniu= felul \u00eent\u00e2i + felul doi sau                    meniu= felul \u00eent\u00e2i + felul doi + desert  10.  R\u0103spuns corect c) 31  Indica\u021bii: Graful dat are 14 muchii. K10 are 45 muchii. 45-14=31 muchii trebuie  ad\u0103ugate pentru a ob\u021bine un K10  11.  R\u0103spuns corect a) 0   12.  R\u0103spuns corect f) 30  Indica\u021bii: \u00centr-un arbore binar se face diferen\u021ba \u00eentre fiul st\u00e2ng \u0219i fiul drept. Sunt 5  configura\u021bii posibile * 6 etichet\u0103ri diferite=30 cazuri  13.  R\u0103spuns corect b) 5  Indica\u021bii: descenden\u021bii nodului 4 sunt: 3, 6, 11, 13, 15  14.  R\u0103spuns corect d) 52\u00e2\u02c6\u21222276  Indica\u021bii: Fie n num\u0103rul de noduri din graf. Un nod este izolat \u0219i cu restul se  construiesc grafuri neorientate cu n-1 noduri  (2(n-1)\u00e2\u02c6\u2122(n-2)/2  cazuri). Orice nod  poate fi ales ca nod izolat. Total grafuri neorientate n\u00e2\u02c6\u21222(n-1)\u00e2\u02c6\u2122(n-2)/2.", "sentences": ["270    Varianta 13   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect c) 2  Indica\u021bii: corecte sunt variantele 3 \u0219i 4   2.", " R\u0103spuns corect e) 2 14  3.", " R\u0103spuns corect e) 112  4.", " R\u0103spuns corect b) 2 4 6  5.", " R\u0103spuns corect a) 4               6 3  6.", " R\u0103spuns corect c) neenUB  7.", " R\u0103spuns corect d) 1225  Indica\u021bii: 49+48+...+1=50*49/2= 1225 (suma Gauss)  8.", " R\u0103spuns corect  b) dcafe;               dcbaf  9.", " R\u0103spuns corect f) 350  Indica\u021bii: meniu= felul \u00eent\u00e2i + felul doi sau                    meniu= felul \u00eent\u00e2i + felul doi + desert  10.", " R\u0103spuns corect c) 31  Indica\u021bii: Graful dat are 14 muchii.", "K10 are 45 muchii.", "45-14=31 muchii trebuie  ad\u0103ugate pentru a ob\u021bine un K10  11.", " R\u0103spuns corect a) 0   12.", " R\u0103spuns corect f) 30  Indica\u021bii: \u00centr-un arbore binar se face diferen\u021ba \u00eentre fiul st\u00e2ng \u0219i fiul drept.", "Sunt 5  configura\u021bii posibile * 6 etichet\u0103ri diferite=30 cazuri  13.", " R\u0103spuns corect b) 5  Indica\u021bii: descenden\u021bii nodului 4 sunt: 3, 6, 11, 13, 15  14.", " R\u0103spuns corect d) 52\u00e2\u02c6\u21222276  Indica\u021bii: Fie n num\u0103rul de noduri din graf.", "Un nod este izolat \u0219i cu restul se  construiesc grafuri neorientate cu n-1 noduri  (2(n-1)\u00e2\u02c6\u2122(n-2)/2  cazuri).", "Orice nod  poate fi ales ca nod izolat.", "Total grafuri neorientate n\u00e2\u02c6\u21222(n-1)\u00e2\u02c6\u2122(n-2)/2."], "page_sentence_count_spacy": 21}, {"page_number": 271, "page_char_count": 36, "page_word_count": 10, "page_sentence_count_raw": 2, "page_token_count": 9.0, "text": "271    15.  R\u0103spuns corect c) p\u00e2\u02c6\u2122n3", "sentences": ["271    15.", " R\u0103spuns corect c) p\u00e2\u02c6\u2122n3"], "page_sentence_count_spacy": 2}, {"page_number": 272, "page_char_count": 1141, "page_word_count": 261, "page_sentence_count_raw": 21, "page_token_count": 285.25, "text": "272    Varianta 14    Indica\u021bii \u0219i r\u0103spunsuri    1.  R\u0103spuns corect c) 3  2.  R\u0103spuns corect d) 3 1   3.  R\u0103spuns corect a) 5 30               5 70  4.  R\u0103spuns corect b) 2600  5.  R\u0103spuns corect c) 8 11 14  6.  R\u0103spuns corect e) EBPU-UPB    7.  R\u0103spuns corect d) 4950  Indica\u021bii: (n-1)+(n-2)+...+1=n*(n-1)/2 (suma Gauss), unde n este num\u0103rul de  elemente  al tabloului unidimensional  8.  R\u0103spuns corect b) 13122  Indica\u021bii: 2\u00e2\u02c6\u212238\u00e2\u02c6\u21221   9.  R\u0103spuns corect a) 1212;4322  10.  R\u0103spuns corect b) 15  11.  R\u0103spuns corect c) 50  12.  R\u0103spuns corect d) 50  Indica\u021bii: Pentru ca arborele binar s\u0103 aib\u0103 \u00een\u0103l\u021bime minim\u0103  se ocup\u0103 fiecare nivel x  cu c\u00e2te 2x  noduri, unde x este de la 0 la 5 (r\u0103d\u0103cina este pe nivelul 0). Pe nivelul 5  avem 32 frunze. S-au folosit 26 -1=63 noduri. Pe nivelul 6 se adaug\u0103 \u00eenc\u0103 37 de  noduri. Astfel, deduc c\u0103 r\u0103m\u00e2n 13 frunze pe nivelul 5, deoarece 18 noduri au c\u00e2te doi  fii \u0219i  un nod are un fiu (32-18-1=13 frunze), iar  pe nivelul 6 sunt 37 frunze.  Total:  50 frunze.   13.  R\u0103spuns corect d) 5  Indica\u021bii: L1:10,1,5,7; L2:10,1,5,12; L3:10,4,3,11;  L4:10,4,3,13; L5:10,4,3,15;   14.  R\u0103spuns corect d) 52\u00e2\u02c6\u21222552", "sentences": ["272    Varianta 14    Indica\u021bii \u0219i r\u0103spunsuri    1.", " R\u0103spuns corect c) 3  2.", " R\u0103spuns corect d) 3 1   3.", " R\u0103spuns corect a) 5 30               5 70  4.", " R\u0103spuns corect b) 2600  5.", " R\u0103spuns corect c) 8 11 14  6.", " R\u0103spuns corect e) EBPU-UPB    7.", " R\u0103spuns corect d) 4950  Indica\u021bii: (n-1)+(n-2)+...+1=n*(n-1)/2 (suma Gauss), unde n este num\u0103rul de  elemente  al tabloului unidimensional  8.", " R\u0103spuns corect b) 13122  Indica\u021bii: 2\u00e2\u02c6\u212238\u00e2\u02c6\u21221   9.", " R\u0103spuns corect a) 1212;4322  10.", " R\u0103spuns corect b) 15  11.", " R\u0103spuns corect c) 50  12.", " R\u0103spuns corect d) 50  Indica\u021bii: Pentru ca arborele binar s\u0103 aib\u0103 \u00een\u0103l\u021bime minim\u0103  se ocup\u0103 fiecare nivel x  cu c\u00e2te 2x  noduri, unde x este de la 0 la 5 (r\u0103d\u0103cina este pe nivelul 0).", "Pe nivelul 5  avem 32 frunze.", "S-au folosit 26 -1=63 noduri.", "Pe nivelul 6 se adaug\u0103 \u00eenc\u0103 37 de  noduri.", "Astfel, deduc c\u0103 r\u0103m\u00e2n 13 frunze pe nivelul 5, deoarece 18 noduri au c\u00e2te doi  fii \u0219i  un nod are un fiu (32-18-1=13 frunze), iar  pe nivelul 6 sunt 37 frunze.", " Total:  50 frunze.", "  13.", " R\u0103spuns corect d) 5  Indica\u021bii: L1:10,1,5,7; L2:10,1,5,12; L3:10,4,3,11;  L4:10,4,3,13; L5:10,4,3,15;   14.", " R\u0103spuns corect d) 52\u00e2\u02c6\u21222552"], "page_sentence_count_spacy": 21}, {"page_number": 273, "page_char_count": 294, "page_word_count": 52, "page_sentence_count_raw": 5, "page_token_count": 73.5, "text": "273    Indica\u021bii: Fie n num\u0103rul de noduri din graf. Un nod este izolat \u0219i cu restul se  construiesc grafuri orientate cu n-1 noduri  (4(n-1)\u00e2\u02c6\u2122(n-2)/2 cazuri=2(n-1)\u00e2\u02c6\u2122(n-2)   cazuri). Orice nod poate fi ales ca nod izolat. Total grafuri orientate n\u00e2\u02c6\u21222(n-1)\u00e2\u02c6\u2122(n-2)  15.  R\u0103spuns corect a) O(n)", "sentences": ["273    Indica\u021bii: Fie n num\u0103rul de noduri din graf.", "Un nod este izolat \u0219i cu restul se  construiesc grafuri orientate cu n-1 noduri  (4(n-1)\u00e2\u02c6\u2122(n-2)/2 cazuri=2(n-1)\u00e2\u02c6\u2122(n-2)   cazuri).", "Orice nod poate fi ales ca nod izolat.", "Total grafuri orientate n\u00e2\u02c6\u21222(n-1)\u00e2\u02c6\u2122(n-2)  15.", " R\u0103spuns corect a) O(n)"], "page_sentence_count_spacy": 5}, {"page_number": 274, "page_char_count": 751, "page_word_count": 207, "page_sentence_count_raw": 16, "page_token_count": 187.75, "text": "274    Varianta 15   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect  f)  90  2.  R\u0103spuns corect  b)  n \u0219i i>0  3.  R\u0103spuns corect  a)  (Limbajul  C/C++)  if(a>b && a%2==0 || b>=a && b%2==0)c=a;     else c=b;  (Limbajul  Pascal)  if ((a>b) and (a mod 2=0)) or ((b>=a) and (b mod 2=0))  then c:=a    else c:=b;  4.  R\u0103spuns corect  e)  8  5.  R\u0103spuns corect  c)   (5,8,4,0,4,5,3,6,7,8)  6.  R\u0103spuns corect  a)  (Limbajul  C/C++)  i<j && i+j<n+1   (Limbajul  Pascal)  (i<j) and (i+j<n+1)   7.  R\u0103spuns corect  f)  2  8.  R\u0103spuns corect  e)  3  9.  R\u0103spuns corect  d)  24  10.  R\u0103spuns corect  a)  2  11.  R\u0103spuns corect  c)  2b4d4  12.  R\u0103spuns corect  b)  diarrafetbdul  13.  R\u0103spuns corect  f)  -8  14.  R\u0103spuns corect  b)  2 0  15.  R\u0103spuns corect  a)  9", "sentences": ["274    Varianta 15   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect  f)  90  2.", " R\u0103spuns corect  b)  n \u0219i i>0  3.", " R\u0103spuns corect  a)  (Limbajul  C/C++)  if(a>b && a%2==0 || b>=a && b%2==0)c=a;     else c=b;  (Limbajul  Pascal)  if ((a>b) and (a mod 2=0)) or ((b>=a) and (b mod 2=0))  then c:=a    else c:=b;  4.", " R\u0103spuns corect  e)  8  5.", " R\u0103spuns corect  c)   (5,8,4,0,4,5,3,6,7,8)  6.", " R\u0103spuns corect  a)  (Limbajul  C/C++)  i<j && i+j<n+1   (Limbajul  Pascal)  (i<j) and (i+j<n+1)   7.", " R\u0103spuns corect  f)  2  8.", " R\u0103spuns corect  e)  3  9.", " R\u0103spuns corect  d)  24  10.", " R\u0103spuns corect  a)  2  11.", " R\u0103spuns corect  c)  2b4d4  12.", " R\u0103spuns corect  b)  diarrafetbdul  13.", " R\u0103spuns corect  f)  -8  14.", " R\u0103spuns corect  b)  2 0  15.", " R\u0103spuns corect  a)  9"], "page_sentence_count_spacy": 16}, {"page_number": 275, "page_char_count": 851, "page_word_count": 230, "page_sentence_count_raw": 16, "page_token_count": 212.75, "text": "275    Varianta 16   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect  d)  31  2.  R\u0103spuns corect  a)  (Limbajul  C/C++)  n \u0219i i=i-1;  (Limbajul  Pascal)  n \u0219i i:=i-1;  3.  R\u0103spuns corect  a)  (Limbajul  C/C++)  if(a>b && a%2==0 && b%2==0) c=a;  if(a>b && a%2==0 && b%2!=0) c=b;  (Limbajul  Pascal)  if (a>b) and (a mod 2=0) and (b mod 2=0) then c:=a;  if (a>b) and (a mod 2=0) and (b mod 2<>0) then c:=b;  4.  R\u0103spuns corect  f)  44  5.  R\u0103spuns corect  a)  1, 2, 6, 8, 10  6.  R\u0103spuns corect    (Limbajul  C/C++) c) i+j==n+2    (Limbajul  Pascal)  c) i+j=n+2  7.  R\u0103spuns corect  a)  \ud835\udc31\u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce) \u222a[\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)  8.  R\u0103spuns corect  e)  2  9.  R\u0103spuns corect  b)  23  10.  R\u0103spuns corect  f)  3  11.  R\u0103spuns corect  a)  2c3d4  12.  R\u0103spuns corect  c)  eAiunieeUIa  13.  R\u0103spuns corect  c)  7 8 9 2  14.  R\u0103spuns corect  d)  2 0  15.  R\u0103spuns corect  e)  6284", "sentences": ["275    Varianta 16   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect  d)  31  2.", " R\u0103spuns corect  a)  (Limbajul  C/C++)  n \u0219i i=i-1;  (Limbajul  Pascal)  n \u0219i i:=i-1;  3.", " R\u0103spuns corect  a)  (Limbajul  C/C++)  if(a>b && a%2==0 && b%2==0) c=a;  if(a>b && a%2==0 && b%2!=0) c=b;  (Limbajul  Pascal)  if (a>b) and (a mod 2=0) and (b mod 2=0) then c:=a;  if (a>b) and (a mod 2=0) and (b mod 2<>0) then c:=b;  4.", " R\u0103spuns corect  f)  44  5.", " R\u0103spuns corect  a)  1, 2, 6, 8, 10  6.", " R\u0103spuns corect    (Limbajul  C/C++) c) i+j==n+2    (Limbajul  Pascal)  c) i+j=n+2  7.", " R\u0103spuns corect  a)  \ud835\udc31\u2208(\u2212\u221e, \u2212\ud835\udfcf\ud835\udfce) \u222a[\ud835\udfcf\ud835\udfce, \ud835\udfcf\ud835\udfce\ud835\udfce)  8.", " R\u0103spuns corect  e)  2  9.", " R\u0103spuns corect  b)  23  10.", " R\u0103spuns corect  f)  3  11.", " R\u0103spuns corect  a)  2c3d4  12.", " R\u0103spuns corect  c)  eAiunieeUIa  13.", " R\u0103spuns corect  c)  7 8 9 2  14.", " R\u0103spuns corect  d)  2 0  15.", " R\u0103spuns corect  e)  6284"], "page_sentence_count_spacy": 16}, {"page_number": 276, "page_char_count": 568, "page_word_count": 146, "page_sentence_count_raw": 16, "page_token_count": 142.0, "text": "276    Varianta 17   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect  b) 2  2.  R\u0103spuns corect  d) 4  3.  R\u0103spuns corect  c) 90  4.  R\u0103spuns corect  a) 1  5.  R\u0103spuns corect  f) 1110  Indica\u021bii: num\u0103rul ciclomatic =m-n+p  6.  R\u0103spuns corect  e) oli 2020  7.  R\u0103spuns corect  d) Bucuresti 2020 ADMIS  8.  R\u0103spuns corect  a) 864  9.  R\u0103spuns corect  f) 4  10.  R\u0103spuns corect  f) nici o valoare  11.  R\u0103spuns corect  a)  \ud835\udfd1 \ud835\udfd2\u2219(\ud835\udc8f+ \ud835\udfcf) \u2219\ud835\udc8f  12.  R\u0103spuns corect  c) int/int/integer   13.  R\u0103spuns corect  f) 2014  14.  R\u0103spuns corect  c) O(2n)  15.  R\u0103spuns corect  a) O(n\u2219log(n))", "sentences": ["276    Varianta 17   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect  b) 2  2.", " R\u0103spuns corect  d) 4  3.", " R\u0103spuns corect  c) 90  4.", " R\u0103spuns corect  a) 1  5.", " R\u0103spuns corect  f) 1110  Indica\u021bii: num\u0103rul ciclomatic =m-n+p  6.", " R\u0103spuns corect  e) oli 2020  7.", " R\u0103spuns corect  d) Bucuresti 2020 ADMIS  8.", " R\u0103spuns corect  a) 864  9.", " R\u0103spuns corect  f) 4  10.", " R\u0103spuns corect  f) nici o valoare  11.", " R\u0103spuns corect  a)  \ud835\udfd1 \ud835\udfd2\u2219(\ud835\udc8f+ \ud835\udfcf) \u2219\ud835\udc8f  12.", " R\u0103spuns corect  c) int/int/integer   13.", " R\u0103spuns corect  f) 2014  14.", " R\u0103spuns corect  c) O(2n)  15.", " R\u0103spuns corect  a) O(n\u2219log(n))"], "page_sentence_count_spacy": 16}, {"page_number": 277, "page_char_count": 652, "page_word_count": 153, "page_sentence_count_raw": 17, "page_token_count": 163.0, "text": "277    Varianta 18   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect  b) 2  2.  R\u0103spuns corect  d) 4  3.  R\u0103spuns corect  a) 0.83  4.  R\u0103spuns corect  a) 1  5.  R\u0103spuns corect  f) 6  Indica\u021bii: 215=2n(n-1)/2=32768  6.  R\u0103spuns corect  f) 0202 iloP  7.  R\u0103spuns corect  d) Politehnica Bucuresti 2020XXXXXXXXXXXX  8.  R\u0103spuns corect  f) 16460640  9.  R\u0103spuns corect  c) O(n)  Indica\u021bii: Algoritmul de interclasare  10.  R\u0103spuns corect  c) \u03b8(2n)  Indica\u021bii: Turnurile din Hanoi.  11.  R\u0103spuns corect  a)   \ud835\udfd3 \ud835\udfd2\u2219(\ud835\udc8f+ \ud835\udfcf) \u2219\ud835\udc8f  12.  R\u0103spuns corect  c) double/double/real  13.  R\u0103spuns corect  e) 34340 1  14.  R\u0103spuns corect  a) O(n+m)  15.  R\u0103spuns corect  d) O(n2)", "sentences": ["277    Varianta 18   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect  b) 2  2.", " R\u0103spuns corect  d) 4  3.", " R\u0103spuns corect  a) 0.83  4.", " R\u0103spuns corect  a) 1  5.", " R\u0103spuns corect  f) 6  Indica\u021bii: 215=2n(n-1)/2=32768  6.", " R\u0103spuns corect  f) 0202 iloP  7.", " R\u0103spuns corect  d) Politehnica Bucuresti 2020XXXXXXXXXXXX  8.", " R\u0103spuns corect  f) 16460640  9.", " R\u0103spuns corect  c) O(n)  Indica\u021bii: Algoritmul de interclasare  10.", " R\u0103spuns corect  c) \u03b8(2n)  Indica\u021bii: Turnurile din Hanoi.", " 11.", " R\u0103spuns corect  a)   \ud835\udfd3 \ud835\udfd2\u2219(\ud835\udc8f+ \ud835\udfcf) \u2219\ud835\udc8f  12.", " R\u0103spuns corect  c) double/double/real  13.", " R\u0103spuns corect  e) 34340 1  14.", " R\u0103spuns corect  a) O(n+m)  15.", " R\u0103spuns corect  d) O(n2)"], "page_sentence_count_spacy": 17}, {"page_number": 278, "page_char_count": 1495, "page_word_count": 294, "page_sentence_count_raw": 23, "page_token_count": 373.75, "text": "278    Varianta 19   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: b) 45     2.  R\u0103spuns corect: e) 2 instruc\u021biuni   Indica\u021bii: pentru n\u00e2\u2030\u00a4i se execut\u0103 doar cele dou\u0103 atribuiri.  3.  R\u0103spuns corect: f) 4 componente  Indica\u021bii:{1},{2,3,4,5},{6},{7}  4.  R\u0103spuns corect: d)  6  5.  R\u0103spuns corect: c)       Limbajul  C++: int &x,int y; Limbajul C: int *x, int y;        Limbajul  Pascal: var  x:integer;  y:integer;  6.  R\u0103spuns corect: b) 9138  Indica\u021bii: Sunt 3n(n-1)/2 grafuri complete orientate. Pentru n=24 avem 3276  7.  R\u0103spuns corect: a) 20v  8.  R\u0103spuns corect: f) 1  Indica\u021bii: Se \u0219terge de exemplu muchia (1,2).  9.  R\u0103spuns corect: e) 16  10.  R\u0103spuns corect: a) O(m\u2219log(n))  Indica\u021bii: Avem o structur\u0103 repetitiv\u0103 cu  valori de la 1 la m, \u00een interiorul c\u0103reia  avem o c\u0103utare binar\u0103 - deci O(m\u2219log(n))  11.  R\u0103spuns corect: c) O(n)  Indica\u021bi: Citirea vectorului are complexitatea O(n), subprogramul are  complexitatea O(log(n)). Prin urmare ordinul de complexitate al secven\u021bei este  O(n).  12.  R\u0103spuns corect: b) 419-1  Indica\u021bii: Sunt 1+2+22+23+\u2026+237 noduri, adic\u0103 238-1=419-1  13.  R\u0103spuns corect: a) 42 72 152 1518  14.  R\u0103spuns corect: b) 1001997  Indica\u021bii: Fie v=[n,n-1,\u2026,2,1] unde n se afl\u0103 pe pozi\u021bia 1, n-1 pe pozi\u021bia 2,   1 pe pozi\u021bia n. Pentru fiecare element de pe pozi\u021bia  i, i\u00e2\u2030\ud835\udc342 se execut\u0103 3+2(i- 1) pa\u0219i. Sunt \u00een total 3(n-1)+ 2[(n(n-1)/2] pa\u0219i, adic\u0103 (n-1)(n+3) pa\u0219i.  Pentru n=6 avem 5(6+3)=45 pa\u0219i, iar pentru n=1000 se execut\u0103  999(1000+3)=999x1003=1001997 pa\u0219i.", "sentences": ["278    Varianta 19   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: b) 45     2.", " R\u0103spuns corect: e) 2 instruc\u021biuni   Indica\u021bii: pentru n\u00e2\u2030\u00a4i se execut\u0103 doar cele dou\u0103 atribuiri.", " 3.", " R\u0103spuns corect: f) 4 componente  Indica\u021bii:{1},{2,3,4,5},{6},{7}  4.", " R\u0103spuns corect: d)  6  5.", " R\u0103spuns corect: c)       Limbajul  C++: int &x,int y; Limbajul C: int *x, int y;        Limbajul  Pascal: var  x:integer;  y:integer;  6.", " R\u0103spuns corect: b) 9138  Indica\u021bii: Sunt 3n(n-1)/2 grafuri complete orientate.", "Pentru n=24 avem 3276  7.", " R\u0103spuns corect: a) 20v  8.", " R\u0103spuns corect: f) 1  Indica\u021bii: Se \u0219terge de exemplu muchia (1,2).", " 9.", " R\u0103spuns corect: e) 16  10.", " R\u0103spuns corect: a) O(m\u2219log(n))  Indica\u021bii: Avem o structur\u0103 repetitiv\u0103 cu  valori de la 1 la m, \u00een interiorul c\u0103reia  avem o c\u0103utare binar\u0103 - deci O(m\u2219log(n))  11.", " R\u0103spuns corect: c) O(n)  Indica\u021bi: Citirea vectorului are complexitatea O(n), subprogramul are  complexitatea O(log(n)).", "Prin urmare ordinul de complexitate al secven\u021bei este  O(n).", " 12.", " R\u0103spuns corect: b) 419-1  Indica\u021bii: Sunt 1+2+22+23+\u2026+237 noduri, adic\u0103 238-1=419-1  13.", " R\u0103spuns corect: a) 42 72 152 1518  14.", " R\u0103spuns corect: b) 1001997  Indica\u021bii: Fie v=[n,n-1,\u2026,2,1] unde n se afl\u0103 pe pozi\u021bia 1, n-1 pe pozi\u021bia 2,   1 pe pozi\u021bia n. Pentru fiecare element de pe pozi\u021bia  i, i\u00e2\u2030\ud835\udc342 se execut\u0103 3+2(i- 1) pa\u0219i.", "Sunt \u00een total 3(n-1)+ 2[(n(n-1)/2] pa\u0219i, adic\u0103 (n-1)(n+3) pa\u0219i.", " Pentru n=6 avem 5(6+3)=45 pa\u0219i, iar pentru n=1000 se execut\u0103  999(1000+3)=999x1003=1001997 pa\u0219i."], "page_sentence_count_spacy": 22}, {"page_number": 279, "page_char_count": 164, "page_word_count": 45, "page_sentence_count_raw": 2, "page_token_count": 41.0, "text": "279    15.  R\u0103spuns corect: a) 15  Indica\u021bii: valorile afi\u0219ate vor fi: 1 1 1 2 1 2 1 1  2 1 3 1 1 2 1  deci \u00een total  instruc\u021biunea de decizie se execut\u0103 de 15 ori.", "sentences": ["279    15.", " R\u0103spuns corect: a) 15  Indica\u021bii: valorile afi\u0219ate vor fi: 1 1 1 2 1 2 1 1  2 1 3 1 1 2 1  deci \u00een total  instruc\u021biunea de decizie se execut\u0103 de 15 ori."], "page_sentence_count_spacy": 2}, {"page_number": 280, "page_char_count": 1542, "page_word_count": 291, "page_sentence_count_raw": 20, "page_token_count": 385.5, "text": "280    Varianta 20   Indica\u021bii \u0219i r\u0103spunsuri    1.  R\u0103spuns corect: b) 2 apeluri  Indica\u021bii: f(720,2) \u0219i f(120,1).  2.  R\u0103spuns corect: b) c,a  Indica\u021bii: \u00cen stiv\u0103 se re\u021bin valorile variabilelor locale (variabila a) \u0219i valorile  parametrilor transmi\u0219i prin valoare (variabila  c).  3.  R\u0103spuns corect: c)  O(n2)  4.  R\u0103spuns corect: b) Limbajul  C/C++: !(x*y+y-3*x-3>=0)                                  Limbajul  Pascal: NOT(x*y+y-3*x-3 > = 0)  Indica\u021bii: x>-1 \u0219i y<3 implic\u0103 (x+1)(y-3)<0 echivalent cu xy+y-3x-3<0  echivalent cu !(x*y+y-3*x-3>=0) \u00een limbajul C++, respectiv    NOT(x*y+y-3*x-3>=0) \u00een limbajul Pascal.  5.  R\u0103spuns corect: a) 3  Indica\u021bii: {0,1,2,3,4},{0,1,4,5},{0,2,3,5}  6.  R\u0103spuns corect: b) aib  Indica\u021bii: Solu\u021biile  care au dou\u0103 vocale \u00een ordinea gener\u0103rii sunt: abe, abi, abu,  ace, aci, acu, aeb,aec,aib,aic,aie ....  7.  R\u0103spuns corect: c) 7  Indica\u021bii: 2+2+2+2+2+2; 2+2+2+3+3; 2+2+3+5; 2+3+7; 2+5+5; 3+3+3+3; 5+7  8.  R\u0103spuns corect: a) {biologie, mate, info};  Indica\u021bii: Solutiile  \u00een ordinea gener\u0103rii sunt: {fizica, biologie, chimie};  {fizica, biologie, mate}; {fizica, biologie, info};  {fizica,chimie, mate}; {fizica, chimie, info}; {fizica,  mate, info}; {biologie, chimie, mate};{biologie, chimie,  info};{biologie, mate, info}; {chimie, mate, info}  9.  R\u0103spuns corect: c) 2k  10.  R\u0103spuns corect: a) linia 5, coloana 7  Indica\u021bii: Elementul de pe linia i, coloana j are valoarea (i-1)m+j. 123=3m+3  deci m=40. Prin urmare sunt 40 elemente pe o linie 167= 40*4+7. Deci i=5,j=7.  11.  R\u0103spuns corect: e) n", "sentences": ["280    Varianta 20   Indica\u021bii \u0219i r\u0103spunsuri    1.", " R\u0103spuns corect: b) 2 apeluri  Indica\u021bii: f(720,2) \u0219i f(120,1).", " 2.", " R\u0103spuns corect: b) c,a  Indica\u021bii: \u00cen stiv\u0103 se re\u021bin valorile variabilelor locale (variabila a) \u0219i valorile  parametrilor transmi\u0219i prin valoare (variabila  c).", " 3.", " R\u0103spuns corect: c)  O(n2)  4.", " R\u0103spuns corect: b) Limbajul  C/C++: !(", "x*y+y-3*x-3>=0)                                  Limbajul  Pascal: NOT(x*y+y-3*x-3 > = 0)  Indica\u021bii: x>-1 \u0219i y<3 implic\u0103 (x+1)(y-3)<0 echivalent cu xy+y-3x-3<0  echivalent cu !(", "x*y+y-3*x-3>=0) \u00een limbajul C++, respectiv    NOT(x*y+y-3*x-3>=0) \u00een limbajul Pascal.", " 5.", " R\u0103spuns corect: a) 3  Indica\u021bii: {0,1,2,3,4},{0,1,4,5},{0,2,3,5}  6.", " R\u0103spuns corect: b) aib  Indica\u021bii: Solu\u021biile  care au dou\u0103 vocale \u00een ordinea gener\u0103rii sunt: abe, abi, abu,  ace, aci, acu, aeb,aec,aib,aic,aie ....  7.", " R\u0103spuns corect: c) 7  Indica\u021bii: 2+2+2+2+2+2; 2+2+2+3+3; 2+2+3+5; 2+3+7; 2+5+5; 3+3+3+3; 5+7  8.", " R\u0103spuns corect: a) {biologie, mate, info};  Indica\u021bii: Solutiile  \u00een ordinea gener\u0103rii sunt: {fizica, biologie, chimie};  {fizica, biologie, mate}; {fizica, biologie, info};  {fizica,chimie, mate}; {fizica, chimie, info}; {fizica,  mate, info}; {biologie, chimie, mate};{biologie, chimie,  info};{biologie, mate, info}; {chimie, mate, info}  9.", " R\u0103spuns corect: c) 2k  10.", " R\u0103spuns corect: a) linia 5, coloana 7  Indica\u021bii: Elementul de pe linia i, coloana j are valoarea (i-1)m+j.", "123=3m+3  deci m=40.", "Prin urmare sunt 40 elemente pe o linie 167= 40*4+7.", "Deci i=5,j=7.", " 11.", " R\u0103spuns corect: e) n"], "page_sentence_count_spacy": 21}, {"page_number": 281, "page_char_count": 743, "page_word_count": 145, "page_sentence_count_raw": 11, "page_token_count": 185.75, "text": "281    Indica\u021bii: Cazul cel mai defavorabil este atunci c\u00e2nd n este num\u0103r prim. \u00cen acest caz,  \u00een afara structurii repetitive sunt 2 instruc\u021biuni de atribuire iar \u00een cadrul structurii  repetitive sunt n-2 instruc\u021biuni  de incrementare. \u00cen total n instruc\u021biuni.  12.  R\u0103spuns corect: e) 2 4 6  13.  R\u0103spuns corect: b) 4 4 3  Indica\u021bii: Subprogramul calculeaz\u0103 recursiv \ud835\udc651 \ud835\udc5b+ \ud835\udc652 \ud835\udc5b unde s=x1+x2 iar p=x1*x2.   Prin urmare \ud835\udc651 4 + \ud835\udc652 4=82 dac\u0103 x1 +x2=4 \u0219i x1 *x2=3, atunci  x1=3 \u0219i x2=1 deci  34+1=82.  14.  R\u0103spuns corect: b) n=6; k=1  Indica\u021bii: Se construie\u0219te un tablou bidimensional care are elemente cu valoarea 1 pe  primele k diagonale paralele cu cele dou\u0103 diagonale, \u00een rest, elemente cu valoarea 2.  15.  R\u0103spuns corect: c) \u03b1=j; \u03b2= 4-j-k", "sentences": ["281    Indica\u021bii: Cazul cel mai defavorabil este atunci c\u00e2nd n este num\u0103r prim.", "\u00cen acest caz,  \u00een afara structurii repetitive sunt 2 instruc\u021biuni de atribuire iar \u00een cadrul structurii  repetitive sunt n-2 instruc\u021biuni  de incrementare.", "\u00cen total n instruc\u021biuni.", " 12.", " R\u0103spuns corect: e) 2 4 6  13.", " R\u0103spuns corect: b) 4 4 3  Indica\u021bii: Subprogramul calculeaz\u0103 recursiv \ud835\udc651 \ud835\udc5b+ \ud835\udc652 \ud835\udc5b unde s=x1+x2 iar p=x1*x2.", "  Prin urmare \ud835\udc651 4 + \ud835\udc652 4=82 dac\u0103 x1 +x2=4 \u0219i x1 *x2=3, atunci  x1=3 \u0219i x2=1 deci  34+1=82.", " 14.", " R\u0103spuns corect: b) n=6; k=1  Indica\u021bii: Se construie\u0219te un tablou bidimensional care are elemente cu valoarea 1 pe  primele k diagonale paralele cu cele dou\u0103 diagonale, \u00een rest, elemente cu valoarea 2.", " 15.", " R\u0103spuns corect: c) \u03b1=j; \u03b2= 4-j-k"], "page_sentence_count_spacy": 11}, {"page_number": 282, "page_char_count": 1041, "page_word_count": 232, "page_sentence_count_raw": 22, "page_token_count": 260.25, "text": "282    Varianta 21   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect d)  2.  R\u0103spuns corect d)  3.  R\u0103spuns corect c)   Indica\u021bie: At\u00e2t \u00een Limbajul  Pascal c\u00e2t \u0219i \u00een Limbajul  C/C++, ; este instruc\u021biunea  vid\u0103.  4.  R\u0103spuns corect d)  5.  R\u0103spuns corect c)  6.  R\u0103spuns corect c)  7.  R\u0103spuns corect d)  8.  R\u0103spuns corect c)  9.  R\u0103spuns corect d)  10.  R\u0103spuns corect b)  11.  R\u0103spuns corect d)  12.  R\u0103spuns corect d)   Indica\u021bie: Fun\u021bia va returna 0 dac\u0103 toate elementele vectorului sunt \u00een ordine  descresc\u0103toare. \u00cen evaluarea expresiei v[n-1]<v[n] || f(n-1) are loc o scurtcircuitare,  dac\u0103 o singur\u0103 dat\u0103 rela\u021bia v[n-1]<v[n] este adev\u0103rat\u0103 func\u021bia va returna valoarea 1  (true) \u0219i se \u00eentrerupe apelul recursiv.  13.  R\u0103spuns corect d)   Indica\u021bie: Num\u0103rul grafurilor par\u021biale este egal cu num\u0103rul submul\u021bimilor mul\u021bimii  muchiilor adic\u0103 24.  14.  R\u0103spuns corect a)   Indica\u021bie: formula este \u2211 \u2211 \u2211 1 = \u2211 \u2211 \ud835\udc57= \u2211 (1 + 2+. . +\ud835\udc56) = 10 \ud835\udc56=1 \ud835\udc56 \ud835\udc57=1 10 \ud835\udc56=1 \ud835\udc57 \ud835\udc58=1 \ud835\udc56 \ud835\udc57=1 10 \ud835\udc56=1 \u2211 \ud835\udc56(\ud835\udc56+1) 2 10 \ud835\udc56=1 = 1 2 \u2211 (\ud835\udc562 + \ud835\udc56) = 220 10 \ud835\udc56=1   15.  R\u0103spuns corect d)", "sentences": ["282    Varianta 21   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect d)  2.", " R\u0103spuns corect d)  3.", " R\u0103spuns corect c)   Indica\u021bie: At\u00e2t \u00een Limbajul  Pascal c\u00e2t \u0219i \u00een Limbajul  C/C++, ; este instruc\u021biunea  vid\u0103.", " 4.", " R\u0103spuns corect d)  5.", " R\u0103spuns corect c)  6.", " R\u0103spuns corect c)  7.", " R\u0103spuns corect d)  8.", " R\u0103spuns corect c)  9.", " R\u0103spuns corect d)  10.", " R\u0103spuns corect b)  11.", " R\u0103spuns corect d)  12.", " R\u0103spuns corect d)   Indica\u021bie: Fun\u021bia va returna 0 dac\u0103 toate elementele vectorului sunt \u00een ordine  descresc\u0103toare.", "\u00cen evaluarea expresiei v[n-1]<v[n] || f(n-1) are loc o scurtcircuitare,  dac\u0103 o singur\u0103 dat\u0103 rela\u021bia v[n-1]<v[n] este adev\u0103rat\u0103 func\u021bia va returna valoarea 1  (true) \u0219i se \u00eentrerupe apelul recursiv.", " 13.", " R\u0103spuns corect d)   Indica\u021bie: Num\u0103rul grafurilor par\u021biale este egal cu num\u0103rul submul\u021bimilor mul\u021bimii  muchiilor adic\u0103 24.", " 14.", " R\u0103spuns corect a)   Indica\u021bie: formula este \u2211 \u2211 \u2211 1 = \u2211 \u2211 \ud835\udc57= \u2211 (1 + 2+. .", "+\ud835\udc56) = 10 \ud835\udc56=1 \ud835\udc56 \ud835\udc57=1 10 \ud835\udc56=1 \ud835\udc57 \ud835\udc58=1 \ud835\udc56 \ud835\udc57=1 10 \ud835\udc56=1 \u2211 \ud835\udc56(\ud835\udc56+1) 2 10 \ud835\udc56=1 = 1 2 \u2211 (\ud835\udc562 + \ud835\udc56) = 220 10 \ud835\udc56=1   15.", " R\u0103spuns corect d)"], "page_sentence_count_spacy": 21}, {"page_number": 283, "page_char_count": 1349, "page_word_count": 296, "page_sentence_count_raw": 24, "page_token_count": 337.25, "text": "283    Varianta 22   Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect c)   Indica\u021bie: Num\u0103rul de frunze este egal cu num\u0103rul de factori primi din  descompunerea num\u0103rului.  2.  R\u0103spuns corect b)  3.  R\u0103spuns corect c)  4.  R\u0103spuns corect d)  5.  R\u0103spuns corect b)  6.  R\u0103spuns corect a)  7.  R\u0103spuns corect d)  Indica\u021bie:  a) Deoarece nodul 7 are gradul 6, el este adiacent cu toate celelalte noduri, deci nu este  posibil ca un nod sa aib\u0103 gradul zero.  b) Deoarece nodul 7 are gradul 6, el este adiacent cu toate celelalte noduri. Nodul 6  are gradul 5, aceasta \u00eenseamn\u0103 c\u0103 el este adiacent cu 7 \u0219i \u00eenc\u0103 4 noduri, deci trebuie s\u0103  existe 4 noduri care s\u0103 aib\u0103 minim gradul 2 \u0219i nu exist\u0103.  c) Deoarece nodul 7 are gradul 6, el este adiacent cu toate celelalte noduri. Pentru ca  nodul 5 s\u0103 poat\u0103 avea gradul 2 trebuie ca \u00eenc\u0103 un nod s\u0103 aib\u0103 minim gradul 2.  e) Deoarece nodul 7 are gradul 5, el este adiacent cu 5 noduri \u0219i nu pot exista dou\u0103  noduri care s\u0103 aib\u0103 gradul 0.  f) Deoarece nodul 7 are gradul 3, el este adiacent cu 3 noduri. Deoarece nodul 6 are  gradul 2, el este adiacent cu 7 si cu \u00eenc\u0103 un nod. Dar nu mai exist\u0103 un nod de grad 2.   8.  R\u0103spuns corect d)  9.  R\u0103spuns corect b)  10. R\u0103spuns corect d)  11. R\u0103spuns corect a)  12. R\u0103spuns corect d)  13. R\u0103spuns corect b)  Indica\u021bie:  Pentru n=3 avem un singur ciclu hamiltonian 1 2 3 1.", "sentences": ["283    Varianta 22   Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect c)   Indica\u021bie: Num\u0103rul de frunze este egal cu num\u0103rul de factori primi din  descompunerea num\u0103rului.", " 2.", " R\u0103spuns corect b)  3.", " R\u0103spuns corect c)  4.", " R\u0103spuns corect d)  5.", " R\u0103spuns corect b)  6.", " R\u0103spuns corect a)  7.", " R\u0103spuns corect d)  Indica\u021bie:  a) Deoarece nodul 7 are gradul 6, el este adiacent cu toate celelalte noduri, deci nu este  posibil ca un nod sa aib\u0103 gradul zero.", " b) Deoarece nodul 7 are gradul 6, el este adiacent cu toate celelalte noduri.", "Nodul 6  are gradul 5, aceasta \u00eenseamn\u0103 c\u0103 el este adiacent cu 7 \u0219i \u00eenc\u0103 4 noduri, deci trebuie s\u0103  existe 4 noduri care s\u0103 aib\u0103 minim gradul 2 \u0219i nu exist\u0103.", " c) Deoarece nodul 7 are gradul 6, el este adiacent cu toate celelalte noduri.", "Pentru ca  nodul 5 s\u0103 poat\u0103 avea gradul 2 trebuie ca \u00eenc\u0103 un nod s\u0103 aib\u0103 minim gradul 2.", " e) Deoarece nodul 7 are gradul 5, el este adiacent cu 5 noduri \u0219i nu pot exista dou\u0103  noduri care s\u0103 aib\u0103 gradul 0.", " f) Deoarece nodul 7 are gradul 3, el este adiacent cu 3 noduri.", "Deoarece nodul 6 are  gradul 2, el este adiacent cu 7 si cu \u00eenc\u0103 un nod.", "Dar nu mai exist\u0103 un nod de grad 2.", "  8.", " R\u0103spuns corect d)  9.", " R\u0103spuns corect b)  10.", "R\u0103spuns corect d)  11.", "R\u0103spuns corect a)  12.", "R\u0103spuns corect d)  13.", "R\u0103spuns corect b)  Indica\u021bie:  Pentru n=3 avem un singur ciclu hamiltonian 1 2 3 1."], "page_sentence_count_spacy": 24}, {"page_number": 284, "page_char_count": 674, "page_word_count": 129, "page_sentence_count_raw": 8, "page_token_count": 168.5, "text": "284    Pentru n=4, \u00eel intercal\u0103m pe 4 \u00een toate modurile posibile \u0219i ob\u021binem ciclurile  hamiltoniene: 1 4 2 3 1, 1 2 4 3 1, 1 2 3 4 1.  Presupunem ca \u00een graful cu n noduri avem  (\ud835\udc5b\u22121)! 2  cicluri hamiltoniene.  \u00cen graful cu n+1 noduri, intercal\u00e2nd pe n+1 \u00een toate modurile posibile ob\u021binem  n\uf0d7 (\ud835\udc5b\u22121)! 2 = \ud835\udc5b! 2 cicluri hamiltoniene.  14. R\u0103spuns corect d)   Indica\u021bie: Func\u021bia va returna 0 dac\u0103 toate elementele vectorului sunt \u00een ordine  descresc\u0103toare. \u00cen evaluarea expresiei v[n-1]<v[n] || f(n-1) are loc o scurtcircuitare,  dac\u0103 o singur\u0103 dat\u0103 rela\u021bia v[n-1]<v[n] este adev\u0103rat\u0103 func\u021bia va returna valoarea 1  (true) \u0219i se \u00eentrerupe apelul recursiv.  15. R\u0103spuns corect d)", "sentences": ["284    Pentru n=4, \u00eel intercal\u0103m pe 4 \u00een toate modurile posibile \u0219i ob\u021binem ciclurile  hamiltoniene: 1 4 2 3 1, 1 2 4 3 1, 1 2 3 4 1.", " Presupunem ca \u00een graful cu n noduri avem  (\ud835\udc5b\u22121)!", "2  cicluri hamiltoniene.", " \u00cen graful cu n+1 noduri, intercal\u00e2nd pe n+1 \u00een toate modurile posibile ob\u021binem  n\uf0d7 (\ud835\udc5b\u22121)!", "2 = \ud835\udc5b!", "2 cicluri hamiltoniene.", " 14.", "R\u0103spuns corect d)   Indica\u021bie: Func\u021bia va returna 0 dac\u0103 toate elementele vectorului sunt \u00een ordine  descresc\u0103toare.", "\u00cen evaluarea expresiei v[n-1]<v[n] || f(n-1) are loc o scurtcircuitare,  dac\u0103 o singur\u0103 dat\u0103 rela\u021bia v[n-1]<v[n] este adev\u0103rat\u0103 func\u021bia va returna valoarea 1  (true) \u0219i se \u00eentrerupe apelul recursiv.", " 15.", "R\u0103spuns corect d)"], "page_sentence_count_spacy": 11}, {"page_number": 285, "page_char_count": 2088, "page_word_count": 471, "page_sentence_count_raw": 25, "page_token_count": 522.0, "text": "285    Varianta 23  Indica\u021bii \u0219i r\u0103spunsuri    1.  R\u0103spuns corect: c) b+a/10!=b%c*a/c (limbaj C++/C)                                    b+a div 10 <>b mod c *a div c  (limbaj Pascal)  2.  R\u0103spuns corect: f) 11    Indica\u021bii: suma gradelor trebuie s\u0103 fie un num\u0103r par. Pentru n=13 \u0219i d=11 suma  gradelor ar fi 143.  3.  R\u0103spuns corect: c) 7  Indica\u021bii: i=1;  i=2;  i=4;  i=8;  i=16;  i=32;  i=64  4.  R\u0103spuns corect: e) 8  Indica\u021bii: se elimin\u0103 cifrele, dar nu cele care sunt precedate de o cifr\u0103 \u0219tears\u0103  5.  R\u0103spuns corect: b)  n*(n-1)/2    Indica\u021bii: se execut\u0103 (n-1)+(n-2)+...+2+1 compara\u021bii  6.  R\u0103spuns corect: c) -4  Indica\u021bii: x=15; x=14; x=7; x=2; x=1; x=-4;  7.  R\u0103spuns corect: d) 13  Indica\u021bii: Se genereaz\u0103: 1003, 1012, 1021, 1030, 1102, 1111, 1120, 1201, 1210, 1300,  2002, 2011, 2020  8.  R\u0103spuns corect: a) suma elementelor de sub diagonala principal\u0103 exclusiv elementele  diagonalei principale  9.  R\u0103spuns corect: e) h.g.c[2]  10.  R\u0103spuns corect: e)    1, 4, 5, 6, 8  Indica\u021bii: lan\u021burile elementare de lungime 3 sunt: (1,2,3,4), (1,2,3,6) (1,2,7,5) (8,2,3,4)  (8,2,3,6) (8,2,7,5) (3,2,7,5) (6,3,2,7) (4,3,2,7)  Nodurile 1, 4, 5, 6 \u0219i 8 apar \u00een c\u00e2te 3 lan\u021buri elementare, celelalte noduri apar de mai  multe ori.  11.  R\u0103spuns corect: f)    6 3 1 3 2 1  Indica\u021bii: Primul \u201cfor\u201d atribuie tabloului: 0 5 1 3 2 1  a[a[6]]=2*6%7       a[1]=5  a[a[5]]=2*5%7   a[2]=3  a[a[4]]=2*4%7   a[3]=1  a[a[3]]=2*3%7   a[1]=6  12.  R\u0103spuns corect: c) s(2020,2)=4 \u0219i reprezint\u0103 suma exponen\u021bilor divizorilor  primi din descompunerea \u00een factori primi a num\u0103rului 2020  13.  R\u0103spuns corect: d) 1792    Indica\u021bii: Sunt 26=64 grafuri cu 4 noduri (nodurile 3, 4, 5, 6).   Dac\u0103 exist\u0103 muchia [1, 2] atunci 2 se conecteaz\u0103 cu 3 sau 4 sau 5 sau 6. Deci \u00een acest  caz avem 4 variante.   Dac\u0103 1 se conecteaz\u0103 cu 3 sau 4 sau 5 sau 6 atunci \u0219i 2 se conecteaz\u0103 cu dou\u0103 dintre  nodurile  3, 4, 5, 6. \u00cen acest caz avem 4*6=24 variante.   \u00cen total avem 4+24=28 variante de conectare pentru 1 \u0219i 2. \u00cen total avem 28*64=1792  grafuri cu proprietatea cerut\u0103.  14.  R\u0103spuns corect: f) 3 11 2 2 10 2 1 9 2 1 6", "sentences": ["285    Varianta 23  Indica\u021bii \u0219i r\u0103spunsuri    1.", " R\u0103spuns corect: c) b+a/10!=b%c*a/c (limbaj C++/C)                                    b+a div 10 <>b mod c *a div c  (limbaj Pascal)  2.", " R\u0103spuns corect: f) 11    Indica\u021bii: suma gradelor trebuie s\u0103 fie un num\u0103r par.", "Pentru n=13 \u0219i d=11 suma  gradelor ar fi 143.", " 3.", " R\u0103spuns corect: c) 7  Indica\u021bii: i=1;  i=2;  i=4;  i=8;  i=16;  i=32;  i=64  4.", " R\u0103spuns corect: e) 8  Indica\u021bii: se elimin\u0103 cifrele, dar nu cele care sunt precedate de o cifr\u0103 \u0219tears\u0103  5.", " R\u0103spuns corect: b)  n*(n-1)/2    Indica\u021bii: se execut\u0103 (n-1)+(n-2)+...+2+1 compara\u021bii  6.", " R\u0103spuns corect: c) -4  Indica\u021bii: x=15; x=14; x=7; x=2; x=1; x=-4;  7.", " R\u0103spuns corect: d) 13  Indica\u021bii: Se genereaz\u0103: 1003, 1012, 1021, 1030, 1102, 1111, 1120, 1201, 1210, 1300,  2002, 2011, 2020  8.", " R\u0103spuns corect: a) suma elementelor de sub diagonala principal\u0103 exclusiv elementele  diagonalei principale  9.", " R\u0103spuns corect: e) h.g.c[2]  10.", " R\u0103spuns corect: e)    1, 4, 5, 6, 8  Indica\u021bii: lan\u021burile elementare de lungime 3 sunt: (1,2,3,4), (1,2,3,6) (1,2,7,5) (8,2,3,4)  (8,2,3,6) (8,2,7,5) (3,2,7,5) (6,3,2,7) (4,3,2,7)  Nodurile 1, 4, 5, 6 \u0219i 8 apar \u00een c\u00e2te 3 lan\u021buri elementare, celelalte noduri apar de mai  multe ori.", " 11.", " R\u0103spuns corect: f)    6 3 1 3 2 1  Indica\u021bii: Primul \u201cfor\u201d atribuie tabloului: 0 5 1 3 2 1  a[a[6]]=2*6%7       a[1]=5  a[a[5]]=2*5%7   a[2]=3  a[a[4]]=2*4%7   a[3]=1  a[a[3]]=2*3%7   a[1]=6  12.", " R\u0103spuns corect: c) s(2020,2)=4 \u0219i reprezint\u0103 suma exponen\u021bilor divizorilor  primi din descompunerea \u00een factori primi a num\u0103rului 2020  13.", " R\u0103spuns corect: d) 1792    Indica\u021bii: Sunt 26=64 grafuri cu 4 noduri (nodurile 3, 4, 5, 6).", "  Dac\u0103 exist\u0103 muchia [1, 2] atunci 2 se conecteaz\u0103 cu 3 sau 4 sau 5 sau 6.", "Deci \u00een acest  caz avem 4 variante.", "  Dac\u0103 1 se conecteaz\u0103 cu 3 sau 4 sau 5 sau 6 atunci \u0219i 2 se conecteaz\u0103 cu dou\u0103 dintre  nodurile  3, 4, 5, 6.", "\u00cen acest caz avem 4*6=24 variante.", "  \u00cen total avem 4+24=28 variante de conectare pentru 1 \u0219i 2.", "\u00cen total avem 28*64=1792  grafuri cu proprietatea cerut\u0103.", " 14.", " R\u0103spuns corect: f) 3 11 2 2 10 2 1 9 2 1 6"], "page_sentence_count_spacy": 25}, {"page_number": 286, "page_char_count": 1289, "page_word_count": 302, "page_sentence_count_raw": 7, "page_token_count": 322.25, "text": "286    15.  R\u0103spuns corect: f)   Aplic\u00e2nd metoda de sortare prin inser\u021bie se poate ob\u021bine ca etap\u0103  intermediar\u0103 tabloul v=(1, 3, 4, 2, 5, 7, 6)   Indica\u021bii: Dac\u0103 se parcurge tabloul de la primul element la ultimul, prin inser\u021bie avem:  (2, 3, 4, 5, 1, 7, 6) (1, 2, 3, 4, 5, 7, 6) (1, 2, 3, 4, 5, 6, 7)  Bubble Sort:  prima traversare: se schimb\u0103 4 cu 2, 5 cu 1, 7 cu 6 \u0219i se ob\u021bine tabloul (3, 2, 4, 1, 5,  6, 7); a doua traversare:  se schimb\u0103 3 cu 2, 4 cu 1 \u0219i se ob\u021bine tabloul (2, 3, 1, 4, 5,  7); a treia traversare:  se schimb\u0103 3 cu 1 \u0219i se ob\u021bine tabloul (2, 1, 3, 4, 5, 6, 7); a  patra traversare:  se schimb\u0103 2 cu 1 \u0219i se ob\u021bine tabloul sortat    b) interclasare: dac\u0103 se interclaseaz\u0103 (2, 3, 4, 5) cu (1, 6, 7), se compar\u0103 1 cu 2 \u0219i 1  devine primul \u00een tablou, apoi 2 cu 6, 3 cu 6 etc.  Dac\u0103 se interclaseaz\u0103 (2, 3, 4) cu (1,5, 6,7) se compar\u0103 1 cu 2 si 1 devine primul \u00een  tablou, apoi 2 cu 5, 3 cu 5 etc.   c) prin selec\u021bia minimului/maximului se fac cel mult n-1 interschimb\u0103ri  d) la prima parcurgere se compar\u0103 3 cu 2 \u0219i minimul devine 2. Tabloul devine (1, 4,  2, 5, 3, 7, 6). La a doua parcurgere minimul ini\u021bial este 4, apoi devine 2 \u0219i se compar\u0103  cu 3, iar 2 este plasat pe a doua pozi\u021bie a tabloului.  e) Dup\u0103 prima traversare se ob\u021bine tabloul  (3, 2, 4, 1, 5, 6, 7)", "sentences": ["286    15.", " R\u0103spuns corect: f)   Aplic\u00e2nd metoda de sortare prin inser\u021bie se poate ob\u021bine ca etap\u0103  intermediar\u0103 tabloul v=(1, 3, 4, 2, 5, 7, 6)   Indica\u021bii: Dac\u0103 se parcurge tabloul de la primul element la ultimul, prin inser\u021bie avem:  (2, 3, 4, 5, 1, 7, 6) (1, 2, 3, 4, 5, 7, 6) (1, 2, 3, 4, 5, 6, 7)  Bubble Sort:  prima traversare: se schimb\u0103 4 cu 2, 5 cu 1, 7 cu 6 \u0219i se ob\u021bine tabloul (3, 2, 4, 1, 5,  6, 7); a doua traversare:  se schimb\u0103 3 cu 2, 4 cu 1 \u0219i se ob\u021bine tabloul (2, 3, 1, 4, 5,  7); a treia traversare:  se schimb\u0103 3 cu 1 \u0219i se ob\u021bine tabloul (2, 1, 3, 4, 5, 6, 7); a  patra traversare:  se schimb\u0103 2 cu 1 \u0219i se ob\u021bine tabloul sortat    b) interclasare: dac\u0103 se interclaseaz\u0103 (2, 3, 4, 5) cu (1, 6, 7), se compar\u0103 1 cu 2 \u0219i 1  devine primul \u00een tablou, apoi 2 cu 6, 3 cu 6 etc.  Dac\u0103 se interclaseaz\u0103 (2, 3, 4) cu (1,5, 6,7) se compar\u0103 1 cu 2 si 1 devine primul \u00een  tablou, apoi 2 cu 5, 3 cu 5 etc.   c) prin selec\u021bia minimului/maximului se fac cel mult n-1 interschimb\u0103ri  d) la prima parcurgere se compar\u0103 3 cu 2 \u0219i minimul devine 2.", "Tabloul devine (1, 4,  2, 5, 3, 7, 6).", "La a doua parcurgere minimul ini\u021bial este 4, apoi devine 2 \u0219i se compar\u0103  cu 3, iar 2 este plasat pe a doua pozi\u021bie a tabloului.", " e) Dup\u0103 prima traversare se ob\u021bine tabloul  (3, 2, 4, 1, 5, 6, 7)"], "page_sentence_count_spacy": 5}, {"page_number": 287, "page_char_count": 2012, "page_word_count": 416, "page_sentence_count_raw": 21, "page_token_count": 503.0, "text": "287    Varianta 24  Indica\u021bii \u0219i r\u0103spunsuri    1.  R\u0103spuns corect: d)  num\u0103r natural impar de o singur\u0103 cifr\u0103  Indica\u021bii: n%2==1 este adev\u0103rat\u0103 pentru numere naturale impare  2.  R\u0103spuns corect: f) i+j=n+1  3.  R\u0103spuns corect: d) este hamiltonian dar nu eulerian  Indica\u021bii: fiecare nod are gradul 9, care nu este un num\u0103r par  4.  R\u0103spuns corect:  c) a[i]-a[i-1]!=d (C++/C)  respectiv a[i]-a[i-1]<>d   (Pascal)   5.  R\u0103spuns corect: b) 2  Indica\u021bii: cele mai lungi lan\u021buri elementare sunt (5, 7, 2, 3, 6), (5, 7, 2, 3, 4) \u0219i au \u00een  mijloc nodul 2  6.  R\u0103spuns corect: a) 1326     Indica\u021bii: se compar\u0103 la fiecare pas ultima cifr\u0103 a num\u0103rului a cu ultima cifr\u0103 a  num\u0103rului b \u0219i cea mai mic\u0103 dintre acestea este ad\u0103ugat\u0103 num\u0103rului p.   a=11357  b= 1426  7.  R\u0103spuns corect: c) 19  Indica\u021bii: se determin\u0103 maxim pentru to\u021bi indicii, mai pu\u021bin pentru ultimul indice  8.  R\u0103spuns corect: c)  orientat cu 4 noduri \u0219i 6 arce   Indica\u021bii: Matricea are 4 linii \u0219i 4 coloane, deci graful are 4 noduri. Matricea nu este  simetric\u0103, deci nu este graf neorientat. Are 6 elemente nenule, deci are 6 arce.  9.  R\u0103spuns corect: e)   noram \u0219i nramo  Indica\u021bii: dup\u0103 ordonarea alfabetic\u0103 a literelor cuv\u00e2ntului roman se ob\u021bine amnor.  Daca nu le ordoneaz\u0103 \u0219i consider\u0103 ca prim\u0103 solu\u021bie cuv\u00e2ntul dat se ob\u021bine r\u0103spunsul a  10.  R\u0103spuns corect: c)  o rama alba    Indica\u021bii: Se elimin\u0103 spa\u021biile din \u0219ir \u0219i se verific\u0103 dac\u0103 este palindrom. Singurul care  nu este palindrom este oramaalba  11.  R\u0103spuns corect: d)    14  Indica\u021bii: f(3)=f(2)+2*f(0)=3+2*1=5   f(2)=f(1)+2*f(-1)=1+2=3    deci f(3) are 4 apeluri  f(5)=f(4)+2*f(2)       f(2)=f(1)+2*f(-1)   f(4)=f(3)+2*f(1)   f(3)=f(2)+2*f(0)   f(2)=f(1)+2*f(-1)  f(5) \u0219i f(3) nu se num\u0103r\u0103 pentru c\u0103 sunt apeluri din programul principal. Se  cere num\u0103rul de autoapeluri!  12.  R\u0103spuns corect: c)  14  Indica\u021bii: se genereaz\u0103 tabloul    1 2 3 4   5 6 7 3   8 9 6 2  10 8 5 1  13.  R\u0103spuns corect:   f) 112  \u0219i 166  Indica\u021bii: f(95)=f(1+f(97))=f(110)=112;    f(97)=f(1+f(99))=f(107)=109;", "sentences": ["287    Varianta 24  Indica\u021bii \u0219i r\u0103spunsuri    1.", " R\u0103spuns corect: d)  num\u0103r natural impar de o singur\u0103 cifr\u0103  Indica\u021bii: n%2==1 este adev\u0103rat\u0103 pentru numere naturale impare  2.", " R\u0103spuns corect: f) i+j=n+1  3.", " R\u0103spuns corect: d) este hamiltonian dar nu eulerian  Indica\u021bii: fiecare nod are gradul 9, care nu este un num\u0103r par  4.", " R\u0103spuns corect:  c) a[i]-a[i-1]!=d (C++/C)  respectiv a[i]-a[i-1]<>d   (Pascal)   5.", " R\u0103spuns corect: b) 2  Indica\u021bii: cele mai lungi lan\u021buri elementare sunt (5, 7, 2, 3, 6), (5, 7, 2, 3, 4) \u0219i au \u00een  mijloc nodul 2  6.", " R\u0103spuns corect: a) 1326     Indica\u021bii: se compar\u0103 la fiecare pas ultima cifr\u0103 a num\u0103rului a cu ultima cifr\u0103 a  num\u0103rului b \u0219i cea mai mic\u0103 dintre acestea este ad\u0103ugat\u0103 num\u0103rului p.   a=11357  b= 1426  7.", " R\u0103spuns corect: c) 19  Indica\u021bii: se determin\u0103 maxim pentru to\u021bi indicii, mai pu\u021bin pentru ultimul indice  8.", " R\u0103spuns corect: c)  orientat cu 4 noduri \u0219i 6 arce   Indica\u021bii: Matricea are 4 linii \u0219i 4 coloane, deci graful are 4 noduri.", "Matricea nu este  simetric\u0103, deci nu este graf neorientat.", "Are 6 elemente nenule, deci are 6 arce.", " 9.", " R\u0103spuns corect: e)   noram \u0219i nramo  Indica\u021bii: dup\u0103 ordonarea alfabetic\u0103 a literelor cuv\u00e2ntului roman se ob\u021bine amnor.", " Daca nu le ordoneaz\u0103 \u0219i consider\u0103 ca prim\u0103 solu\u021bie cuv\u00e2ntul dat se ob\u021bine r\u0103spunsul a  10.", " R\u0103spuns corect: c)  o rama alba    Indica\u021bii: Se elimin\u0103 spa\u021biile din \u0219ir \u0219i se verific\u0103 dac\u0103 este palindrom.", "Singurul care  nu este palindrom este oramaalba  11.", " R\u0103spuns corect: d)    14  Indica\u021bii: f(3)=f(2)+2*f(0)=3+2*1=5   f(2)=f(1)+2*f(-1)=1+2=3    deci f(3) are 4 apeluri  f(5)=f(4)+2*f(2)       f(2)=f(1)+2*f(-1)   f(4)=f(3)+2*f(1)   f(3)=f(2)+2*f(0)   f(2)=f(1)+2*f(-1)  f(5) \u0219i f(3) nu se num\u0103r\u0103 pentru c\u0103 sunt apeluri din programul principal.", "Se  cere num\u0103rul de autoapeluri!", " 12.", " R\u0103spuns corect: c)  14  Indica\u021bii: se genereaz\u0103 tabloul    1 2 3 4   5 6 7 3   8 9 6 2  10 8 5 1  13.", " R\u0103spuns corect:   f) 112  \u0219i 166  Indica\u021bii: f(95)=f(1+f(97))=f(110)=112;    f(97)=f(1+f(99))=f(107)=109;"], "page_sentence_count_spacy": 21}, {"page_number": 288, "page_char_count": 1152, "page_word_count": 221, "page_sentence_count_raw": 6, "page_token_count": 288.0, "text": "288    f(99)=f(1+f(101))=f(1+103)=f(104)=106;  Se observ\u0103 c\u0103 plec\u00e2nd de la x=99, dac\u0103 x scade cu 2, f(x) cre\u0219te cu 3.   Plec\u00e2nd de la 99 avem 99-59=40;  40/2=20;  20*3=60; 60+106=166  sau  Plec\u00e2nd de la 95 avem 95-59=36;  36/2=18;  18*3=54; 54+112=166  14.  R\u0103spuns corect: e) Cel mai mic num\u0103r de opera\u021bii s-a efectuat pentru z.  Indica\u021bii: ca opera\u021bii avem:  opera\u021bii comune la toate tablourile:  -num\u0103rul de compara\u021bii pentru determinarea minimului este 6   -ini\u021bializarea indicelui valorii minime 3 opera\u021bii  -verificare dac\u0103 minimul se afl\u0103 pe pozi\u021bia i (ca s\u0103 nu fac interschimbare cu el \u00eensu\u0219i)  3 opera\u021bii  diferen\u021be:  -(d1) nr de interschimb\u0103ri  -(d2) nr de actualiz\u0103ri ale indicelui minimului   v: d1=3 \u0219i d2=3   x: d1=2 \u0219i d2=2   y: d1=2 \u0219i d2=2   z: d1=1 \u0219i d2=2   15.  R\u0103spuns corect: d)  divizorii primi ai lui x \u0219i num\u0103rul tuturor divizorilor lui x   EXEMPLU: pentru x=36 se afi\u0219eaz\u0103 2 3 9  Indica\u021bii: este o descompunere \u00een factori primi care afi\u0219eaz\u0103 divizorii primi (la prima  apari\u021bie \u00een descompunere ) \u0219i returneaz\u0103 num\u0103rul total de divizori calculat ca produs  de exponen\u021bi plus 1.  36=22\u221932  num\u0103rul divizorilor este (2+1)\u2219(2+1)=9", "sentences": ["288    f(99)=f(1+f(101))=f(1+103)=f(104)=106;  Se observ\u0103 c\u0103 plec\u00e2nd de la x=99, dac\u0103 x scade cu 2, f(x) cre\u0219te cu 3.", "  Plec\u00e2nd de la 99 avem 99-59=40;  40/2=20;  20*3=60; 60+106=166  sau  Plec\u00e2nd de la 95 avem 95-59=36;  36/2=18;  18*3=54; 54+112=166  14.", " R\u0103spuns corect: e) Cel mai mic num\u0103r de opera\u021bii s-a efectuat pentru z.  Indica\u021bii: ca opera\u021bii avem:  opera\u021bii comune la toate tablourile:  -num\u0103rul de compara\u021bii pentru determinarea minimului este 6   -ini\u021bializarea indicelui valorii minime 3 opera\u021bii  -verificare dac\u0103 minimul se afl\u0103 pe pozi\u021bia i (ca s\u0103 nu fac interschimbare cu el \u00eensu\u0219i)  3 opera\u021bii  diferen\u021be:  -(d1) nr de interschimb\u0103ri  -(d2) nr de actualiz\u0103ri ale indicelui minimului   v: d1=3 \u0219i d2=3   x: d1=2 \u0219i d2=2   y: d1=2 \u0219i d2=2   z: d1=1 \u0219i d2=2   15.", " R\u0103spuns corect: d)  divizorii primi ai lui x \u0219i num\u0103rul tuturor divizorilor lui x   EXEMPLU: pentru x=36 se afi\u0219eaz\u0103 2 3 9  Indica\u021bii: este o descompunere \u00een factori primi care afi\u0219eaz\u0103 divizorii primi (la prima  apari\u021bie \u00een descompunere ) \u0219i returneaz\u0103 num\u0103rul total de divizori calculat ca produs  de exponen\u021bi plus 1.", " 36=22\u221932  num\u0103rul divizorilor este (2+1)\u2219(2+1)=9"], "page_sentence_count_spacy": 5}, {"page_number": 289, "page_char_count": 950, "page_word_count": 319, "page_sentence_count_raw": 7, "page_token_count": 237.5, "text": "289    Varianta 25   Indica\u021bii \u0219i r\u0103spunsuri    1. R\u0103spuns corect: b) 4*a*(a-1)<a*a-2  Indica\u021bii: 4*a*(a-1)<a*a-2 se scrie astfel 3a2-4a+2<0 unde delta este -8,  rezult\u0103 c\u0103 ecua\u021bia de gradul al II-lea va fi pozitiv\u0103 mereu.  2. R\u0103spuns corect: a) 167238945   Indica\u021bii:        Se afi\u0219eaz\u0103    i=4 j=0  A[4][0]=1  j<>4 (A) i=3 j=0  A[3][0]=6    i=3 j=1  A[3][1]=7  j<>4 (A) i=2 j=1  A[2][1]=2    i=2 j=2  A[2][2]=3  j<>4 (A) i=1 j=2  A[1][2]=8    i=1 j=3  A[1][3]=9  j<>4 (A) i=0 j=3  A[0][3]=4    i=0 j=4  A[0][4]=5  j<>4 (F)          3. R\u0103spuns corect: e) 7  Indica\u021bii:  Ad(3) 3       El() 9                        El()         Ad(5) 9  5                      Ad(7) 7        Ad(2) 9  5  2                    Ad(9) 7  9     El() 5  2      4. R\u0103spuns corect: c) 2  Indica\u021bii:         Componenta conex\u0103 I este format\u0103 din nodurile: 1, 4, 6  Componenta conex\u0103 II este format\u0103 din nodurile: 2, 3, 5  5. R\u0103spuns corect: f) 9 4  Indica\u021bii:   1  4  6  2  5  3", "sentences": ["289    Varianta 25   Indica\u021bii \u0219i r\u0103spunsuri    1.", "R\u0103spuns corect: b) 4*a*(a-1)<a*a-2  Indica\u021bii: 4*a*(a-1)<a*a-2 se scrie astfel 3a2-4a+2<0 unde delta este -8,  rezult\u0103 c\u0103 ecua\u021bia de gradul al II-lea va fi pozitiv\u0103 mereu.", " 2.", "R\u0103spuns corect: a) 167238945   Indica\u021bii:        Se afi\u0219eaz\u0103    i=4 j=0  A[4][0]=1  j<>4 (A) i=3 j=0  A[3][0]=6    i=3 j=1  A[3][1]=7  j<>4 (A) i=2 j=1  A[2][1]=2    i=2 j=2  A[2][2]=3  j<>4 (A) i=1 j=2  A[1][2]=8    i=1 j=3  A[1][3]=9  j<>4 (A) i=0 j=3  A[0][3]=4    i=0 j=4  A[0][4]=5  j<>4 (F)          3.", "R\u0103spuns corect: e) 7  Indica\u021bii:  Ad(3) 3       El() 9                        El()         Ad(5) 9  5                      Ad(7) 7        Ad(2) 9  5  2                    Ad(9) 7  9     El() 5  2      4.", "R\u0103spuns corect: c) 2  Indica\u021bii:         Componenta conex\u0103 I este format\u0103 din nodurile: 1, 4, 6  Componenta conex\u0103 II este format\u0103 din nodurile: 2, 3, 5  5.", "R\u0103spuns corect: f) 9 4  Indica\u021bii:   1  4  6  2  5  3"], "page_sentence_count_spacy": 7}, {"page_number": 290, "page_char_count": 1800, "page_word_count": 397, "page_sentence_count_raw": 17, "page_token_count": 450.0, "text": "290                                  6. R\u0103spuns corect: e) 8  Indica\u021bii: 114, 123, 132, 141, 213, 222, 231, 312  7. R\u0103spuns corect: a) xxmmnn  Indica\u021bii: Instruc\u021biunea repetitiv\u0103 for parcurge \u0219irul \"examen\" p\u00e2n\u0103 la  penultimul caracter inclusiv \u0219i verific\u0103 dac\u0103 valoarea elementului de pe  pozi\u021bia i este strict mai mic\u0103 din punct de vedere lexicografic dec\u00e2t valoarea  elementului urm\u0103tor, a[i+1]. Dac\u0103 acest element este strict mai mic dec\u00e2t urm\u0103torul,  lui a[i] i se atribuie valoarea lui a[i+1].   8. R\u0103spuns corect: b) 4324                                   97  Indica\u021bii: Deoarece exist\u0103 o instruc\u021biune if cu condi\u021bia n<=100, \u00eenseamn\u0103 c\u0103 func\u021bia  numar se va opri c\u00e2nd n=82. P\u00e2n\u0103 atunci va verifica fiecare cifr\u0103 a num\u0103rului n. Dac\u0103  cifra este mai mic\u0103 dec\u00e2t 5 aceasta va fi afi\u0219at\u0103 imediat deoarece afi\u0219area se face \u00eenainte  de reapelarea func\u021biei (4, 3, 2 \u0219i 4). Dac\u0103 cifra este mai mare dec\u00e2t 5 (9 \u0219i 7) aceasta  va fi afi\u0219at\u0103 la sf\u00e2r\u0219it, \u00een ordine invers\u0103 a g\u0103sirii ei, deoarece afi\u0219area se execut\u0103 dup\u0103  reapelarea func\u021biei.  9. R\u0103spuns corect: b) 3  Indica\u021bii: Liniile de cod afl\u0103 c\u00e2\u021bi divizori primi are valoarea memorat\u0103 \u00een variabila a.  Variabila c, care ini\u021bial are valoarea 2, este incrementat\u0103 cu 1 p\u00e2n\u0103 c\u00e2nd valoarea  variabilei a devine 1. Valoarea variabilei a ajunge la 1 deoarece este \u00eemp\u0103r\u021bit\u0103, pe  r\u00e2nd, dac\u0103 este posibil, la valorile luate de variabila c. De c\u00e2te ori se g\u0103se\u0219te un num\u0103r  \u00een variabila c care divide valoarea variabilei a, valoarea variabilei b cre\u0219te cu 1.  10. R\u0103spuns corect: c) v=[5,8,2,6,6,5,4,4]    Indica\u021bii:   i=0 v[0]<5 (F) v[0]=5 v[7]>v[0] (A) v[7]=4  i=1 v[1]<5 (F) v[1]=8 v[6]>v[1] (F) v[6]=4  i=2 v[2]<5 (A) v[2]=2 v[5]>v[2] (A) v[5]=5  i=3 v[3]<5 (A) v[3]=6 v[4]>v[3] (F) v[4]=6    11. R\u0103spuns corect: d)  \ud835\udc84\u2219(\ud835\udc84+\ud835\udfd0) \ud835\udfd2   1  2  3  4  5  6  7  8  9", "sentences": ["290                                  6.", "R\u0103spuns corect: e) 8  Indica\u021bii: 114, 123, 132, 141, 213, 222, 231, 312  7.", "R\u0103spuns corect: a) xxmmnn  Indica\u021bii: Instruc\u021biunea repetitiv\u0103 for parcurge \u0219irul \"examen\" p\u00e2n\u0103 la  penultimul caracter inclusiv \u0219i verific\u0103 dac\u0103 valoarea elementului de pe  pozi\u021bia i este strict mai mic\u0103 din punct de vedere lexicografic dec\u00e2t valoarea  elementului urm\u0103tor, a[i+1].", "Dac\u0103 acest element este strict mai mic dec\u00e2t urm\u0103torul,  lui a[i] i se atribuie valoarea lui a[i+1].", "  8.", "R\u0103spuns corect: b) 4324                                   97  Indica\u021bii: Deoarece exist\u0103 o instruc\u021biune if cu condi\u021bia n<=100, \u00eenseamn\u0103 c\u0103 func\u021bia  numar se va opri c\u00e2nd n=82.", "P\u00e2n\u0103 atunci va verifica fiecare cifr\u0103 a num\u0103rului n. Dac\u0103  cifra este mai mic\u0103 dec\u00e2t 5 aceasta va fi afi\u0219at\u0103 imediat deoarece afi\u0219area se face \u00eenainte  de reapelarea func\u021biei (4, 3, 2 \u0219i 4).", "Dac\u0103 cifra este mai mare dec\u00e2t 5 (9 \u0219i 7) aceasta  va fi afi\u0219at\u0103 la sf\u00e2r\u0219it, \u00een ordine invers\u0103 a g\u0103sirii ei, deoarece afi\u0219area se execut\u0103 dup\u0103  reapelarea func\u021biei.", " 9.", "R\u0103spuns corect: b) 3  Indica\u021bii: Liniile de cod afl\u0103 c\u00e2\u021bi divizori primi are valoarea memorat\u0103 \u00een variabila a.  Variabila c, care ini\u021bial are valoarea 2, este incrementat\u0103 cu 1 p\u00e2n\u0103 c\u00e2nd valoarea  variabilei a devine 1.", "Valoarea variabilei a ajunge la 1 deoarece este \u00eemp\u0103r\u021bit\u0103, pe  r\u00e2nd, dac\u0103 este posibil, la valorile luate de variabila c. De c\u00e2te ori se g\u0103se\u0219te un num\u0103r  \u00een variabila c care divide valoarea variabilei a, valoarea variabilei b cre\u0219te cu 1.", " 10.", "R\u0103spuns corect: c) v=[5,8,2,6,6,5,4,4]    Indica\u021bii:   i=0 v[0]<5 (F) v[0]=5 v[7]>v[0] (A) v[7]=4  i=1 v[1]<5 (F) v[1]=8 v[6]>v[1] (F) v[6]=4  i=2 v[2]<5 (A) v[2]=2 v[5]>v[2] (A) v[5]=5  i=3 v[3]<5 (A) v[3]=6 v[4]>v[3] (F) v[4]=6    11.", "R\u0103spuns corect: d)  \ud835\udc84\u2219(\ud835\udc84+\ud835\udfd0) \ud835\udfd2   1  2  3  4  5  6  7  8  9"], "page_sentence_count_spacy": 14}, {"page_number": 291, "page_char_count": 2232, "page_word_count": 470, "page_sentence_count_raw": 22, "page_token_count": 558.0, "text": "291    Indica\u021bii: 2 + 4 + 6 + \u22ef+ \ud835\udc5b= 2 \u2217(1 + 2 + 3 + \u22ef+ \ud835\udc5b 2) = 2 \u2217 \ud835\udc5b 2\u2217(\ud835\udc5b 2+1) 2 .  Instruc\u021biunea repetitiv\u0103 for calculeaz\u0103 suma 1 + 2 + 3 + \u22ef+ \ud835\udc5b 2.  12. R\u0103spuns corect: a) 1 2 3 4 5 6 7    Indica\u021bii:  i=1 a[1]=7  a[7]=1  i=2 a[2]=6  a[6]=2  i=3 a[3]=5  a[5]=3    i=4 a[4]=4  a[4]=4  i=5 a[5]=3  a[3]=5  i=6 a[6]=2  a[2]=6  i=7 a[7]=1  a[1]=7      13. R\u0103spuns corect: d) 101    Indica\u021bii: Instruc\u021biunile respective num\u0103r\u0103 c\u0103te cifre impare exist\u0103, \u00een total, \u00een  intervalul [200,300]. Prin urmare pe pozi\u021bia cifrei sutelor, o cifr\u0103 impar\u0103 va ap\u0103rea  doar pentru num\u0103rul 300.  Pe pozi\u021bia zecilor, o cifr\u0103 impar\u0103, se va reg\u0103si de exact 50 de ori \u00een acest interval,  pentru numerele de forma 2\ud835\udc4e\ud835\udc4f \u0305\u0305\u0305\u0305\u0305 unde \ud835\udc4e\u2208{\ud835\udfcf, \ud835\udfd1, \ud835\udfd3, \ud835\udfd5, \ud835\udfd7} iar \ud835\udc4f\u2208{0, 1, 2, \u2026 , 9}.  Cifra unit\u0103\u021bilor va avea o valoare impar\u0103 pentru numere de forma 2\ud835\udc4e\ud835\udc4f \u0305\u0305\u0305\u0305\u0305 unde \ud835\udc4e\u2208 {0,1,2, \u2026 ,9} iar \ud835\udc4f\u2208{1,3,5,7,9}.  Putem deduce de aici c\u0103 \u00een intervalul [200,300] pe  pozi\u021bia cifrei unit\u0103\u021bilor vom reg\u0103si o cifr\u0103 impar\u0103 de exact 50 de ori.   Pe pozi\u021bia sutelor exist\u0103 o singur\u0103 cifr\u0103 impar\u0103. Deci 50+50+1=101.  14. R\u0103spuns corect: c) determinantul matricei  Indica\u021bii: Subprogramul mat calculeaz\u0103 recursiv determinantul matricei d, primit\u0103 ca  parametru, prin descompunerea acesteia dup\u0103 linii \u0219i coloane.  \u00cen variabila e, declarat\u0103 tot ca tablou bidimensional, este re\u021binut\u0103 matricea rezultat\u0103  dup\u0103 descompunerea matricei ini\u021biale, \u00een func\u021bie de elementul d[i][j]. Prin urmare,  tabloul bidimensional e va re\u021bine o matrice de n-1 linii \u0219i n-1 coloane.  Aceasta metod\u0103 se aplic\u0103 recursiv p\u00e2n\u0103 c\u00e2nd matricea re\u021binut\u0103 \u00een tabloul bidimensional  e va avea un singur element.  15. R\u0103spuns corect: b) 5417032963258410  Indica\u021bii: \u00cen cazul de fa\u021b\u0103 func\u021bia recursiv\u0103 denumit\u0103 afis se va opri \u00een momentul \u00een  care k devine 1. De men\u021bionat c\u0103, \u00een cazul de fa\u021b\u0103, k porne\u0219te de la valoarea 8 care  este valoarea sumei indicilor lui a[4][4], elementul din dreapta jos.  Valoarea variabilei k scade cu 1 la fiecare reapelare a func\u021biei. Pentru k par se vor  afi\u0219a elementele de la st\u00e2nga spre dreapta iar pentru k impar se vor afi\u0219a elementele de  la dreapta spre st\u00e2nga.  \ud835\udc97= ( \ud835\udc97\ud835\udfcf \ud835\udfcf \ud835\udc97\ud835\udfcf \ud835\udfd0 \ud835\udc97\ud835\udfd0 \ud835\udfcf \ud835\udc97\ud835\udfd0 \ud835\udfd0 \ud835\udc97\ud835\udfcf \ud835\udfd1 \ud835\udc97\ud835\udfcf \ud835\udfd2 \ud835\udc97\ud835\udfd0 \ud835\udfd1 \ud835\udc97\ud835\udfd0 \ud835\udfd2 \ud835\udc97\ud835\udfd1 \ud835\udfcf \ud835\udc97\ud835\udfd1 \ud835\udfd0 \ud835\udc97\ud835\udfd2 \ud835\udfcf \ud835\udc97\ud835\udfd2 \ud835\udfd0 \ud835\udc97\ud835\udfd1 \ud835\udfd1 \ud835\udc97\ud835\udfd1 \ud835\udfd2 \ud835\udc97\ud835\udfd2 \ud835\udfd1 \ud835\udc97\ud835\udfd2 \ud835\udfd2 )  \ud835\udc49= ( 0 1 4 5 2 3 6 7 8 9 2 3 0 1 4 5 )", "sentences": ["291    Indica\u021bii: 2 + 4 + 6 + \u22ef+ \ud835\udc5b= 2 \u2217(1 + 2 + 3 + \u22ef+ \ud835\udc5b 2) = 2 \u2217 \ud835\udc5b 2\u2217(\ud835\udc5b 2+1) 2 .", " Instruc\u021biunea repetitiv\u0103 for calculeaz\u0103 suma 1 + 2 + 3 + \u22ef+ \ud835\udc5b 2.", " 12.", "R\u0103spuns corect: a) 1 2 3 4 5 6 7    Indica\u021bii:  i=1 a[1]=7  a[7]=1  i=2 a[2]=6  a[6]=2  i=3 a[3]=5  a[5]=3    i=4 a[4]=4  a[4]=4  i=5 a[5]=3  a[3]=5  i=6 a[6]=2  a[2]=6  i=7 a[7]=1  a[1]=7      13.", "R\u0103spuns corect: d) 101    Indica\u021bii: Instruc\u021biunile respective num\u0103r\u0103 c\u0103te cifre impare exist\u0103, \u00een total, \u00een  intervalul [200,300].", "Prin urmare pe pozi\u021bia cifrei sutelor, o cifr\u0103 impar\u0103 va ap\u0103rea  doar pentru num\u0103rul 300.", " Pe pozi\u021bia zecilor, o cifr\u0103 impar\u0103, se va reg\u0103si de exact 50 de ori \u00een acest interval,  pentru numerele de forma 2\ud835\udc4e\ud835\udc4f \u0305\u0305\u0305\u0305\u0305 unde \ud835\udc4e\u2208{\ud835\udfcf, \ud835\udfd1, \ud835\udfd3, \ud835\udfd5, \ud835\udfd7} iar \ud835\udc4f\u2208{0, 1, 2, \u2026 , 9}.", " Cifra unit\u0103\u021bilor va avea o valoare impar\u0103 pentru numere de forma 2\ud835\udc4e\ud835\udc4f \u0305\u0305\u0305\u0305\u0305 unde \ud835\udc4e\u2208 {0,1,2, \u2026 ,9} iar \ud835\udc4f\u2208{1,3,5,7,9}.", " Putem deduce de aici c\u0103 \u00een intervalul [200,300] pe  pozi\u021bia cifrei unit\u0103\u021bilor vom reg\u0103si o cifr\u0103 impar\u0103 de exact 50 de ori.", "  Pe pozi\u021bia sutelor exist\u0103 o singur\u0103 cifr\u0103 impar\u0103.", "Deci 50+50+1=101.", " 14.", "R\u0103spuns corect: c) determinantul matricei  Indica\u021bii: Subprogramul mat calculeaz\u0103 recursiv determinantul matricei d, primit\u0103 ca  parametru, prin descompunerea acesteia dup\u0103 linii \u0219i coloane.", " \u00cen variabila e, declarat\u0103 tot ca tablou bidimensional, este re\u021binut\u0103 matricea rezultat\u0103  dup\u0103 descompunerea matricei ini\u021biale, \u00een func\u021bie de elementul d[i][j].", "Prin urmare,  tabloul bidimensional e va re\u021bine o matrice de n-1 linii \u0219i n-1 coloane.", " Aceasta metod\u0103 se aplic\u0103 recursiv p\u00e2n\u0103 c\u00e2nd matricea re\u021binut\u0103 \u00een tabloul bidimensional  e va avea un singur element.", " 15.", "R\u0103spuns corect: b) 5417032963258410  Indica\u021bii: \u00cen cazul de fa\u021b\u0103 func\u021bia recursiv\u0103 denumit\u0103 afis se va opri \u00een momentul \u00een  care k devine 1.", "De men\u021bionat c\u0103, \u00een cazul de fa\u021b\u0103, k porne\u0219te de la valoarea 8 care  este valoarea sumei indicilor lui a[4][4], elementul din dreapta jos.", " Valoarea variabilei k scade cu 1 la fiecare reapelare a func\u021biei.", "Pentru k par se vor  afi\u0219a elementele de la st\u00e2nga spre dreapta iar pentru k impar se vor afi\u0219a elementele de  la dreapta spre st\u00e2nga.", " \ud835\udc97= ( \ud835\udc97\ud835\udfcf \ud835\udfcf \ud835\udc97\ud835\udfcf \ud835\udfd0 \ud835\udc97\ud835\udfd0 \ud835\udfcf \ud835\udc97\ud835\udfd0 \ud835\udfd0 \ud835\udc97\ud835\udfcf \ud835\udfd1 \ud835\udc97\ud835\udfcf \ud835\udfd2 \ud835\udc97\ud835\udfd0 \ud835\udfd1 \ud835\udc97\ud835\udfd0 \ud835\udfd2 \ud835\udc97\ud835\udfd1 \ud835\udfcf \ud835\udc97\ud835\udfd1 \ud835\udfd0 \ud835\udc97\ud835\udfd2 \ud835\udfcf \ud835\udc97\ud835\udfd2 \ud835\udfd0 \ud835\udc97\ud835\udfd1 \ud835\udfd1 \ud835\udc97\ud835\udfd1 \ud835\udfd2 \ud835\udc97\ud835\udfd2 \ud835\udfd1 \ud835\udc97\ud835\udfd2 \ud835\udfd2 )  \ud835\udc49= ( 0 1 4 5 2 3 6 7 8 9 2 3 0 1 4 5 )"], "page_sentence_count_spacy": 22}, {"page_number": 292, "page_char_count": 1786, "page_word_count": 454, "page_sentence_count_raw": 14, "page_token_count": 446.5, "text": "292    Varianta 26   Indica\u021bii \u0219i r\u0103spunsuri    1.  R\u0103spuns corect: e) C++: (a%3+a%7)/9                                              Pascal: (a MOD 3+a MOD 7) DIV 9  Indica\u021bii: Restul \u00eemp\u0103r\u021birii unui num\u0103r la 3 poate fi 0, 1 sau 2. Restul \u00eemp\u0103r\u021birii unui  num\u0103r la 7 poate fi maxim 6. \u00cen concluzie, suma acestor dou\u0103 resturi nu poate fi mai  mare de 8.  2.  R\u0103spuns corect: b) v=(5,3,4,8,6,2,1,9)  Indica\u021bii: Instruc\u021biunile din cadrul instruc\u021biunii repetitive while   (C++: v[i]=v[i]+v[j]; v[j]=v[i]-v[j]; v[i]=v[i]-v[j]; sau  Pascal: v[i]:=v[i]+v[j]; v[j]:=v[i]-v[j]; v[i]:=v[i]-v[j];)  interschimb\u0103 valoarea aflat\u0103 \u00een v[i] cu valoarea aflat\u0103 \u00een v[j].  i=0  j=1  v[0]=5  v[1]=3  i=2  j=3  v[2]=4  v[3]=8  i=4  j=5  v[4]=6  v[5]=2  i=6  j=7  v[6]=1  v[7]=9    3.  R\u0103spuns corect: f) poLItEHnica  Indica\u021bii: Toate literele mai mici dec\u00e2t litera n, \u00een ordine alfabetic\u0103, p\u00e2n\u0103 la pozi\u021bia 7  din \u0219irul de caractere memorat \u00een variabila a, sunt transformate \u00een litere mari (spre  exemplu: l devine L)    4.  R\u0103spuns corect: d)  \ud835\udc34= ( 0 1 1 2 2 3 2 4 2 2 3 4 4 3 3 6 )  Indica\u021bii: Cele dou\u0103 instruc\u021biuni repetitive while parcurg toate elementele tabloului  bidimensional A. Elementele care respect\u0103 condi\u021bia instruc\u021biunii if (i+j s\u0103 fie par)  sunt: A[0][0]=0, A[0][2]=2, A[1][1]=2, A[1][3]=4, A[2][0]=2,  A[2][2]=4, A[3][1]=4 \u0219i A[3][3]=6.  Celelalte elemente au valoarea celui mai mare dintre indicii i \u0219i j: A[0][1]=1,  A[0][3]=3,  A[1][0]=1,  A[1][2]=2,  A[2][1]=2,  A[2][3]=3,  A[3][0]=3 \u0219i A[3][2]=3.  5.  R\u0103spuns corect: d) 11  Indica\u021bii:  Ad(3)  Ad(7)  Ad(5)   El()    El()   Ad(8)          5                  7    7    7        8  3    3    3    3    3    3    6.  R\u0103spuns corect: d) 24  Indica\u021bii: 4a8b (4185, 4189, 4581, 4589, 4981, 4985) - 6 numere                   8a4b - 6 numere", "sentences": ["292    Varianta 26   Indica\u021bii \u0219i r\u0103spunsuri    1.", " R\u0103spuns corect: e) C++: (a%3+a%7)/9                                              Pascal: (a MOD 3+a MOD 7) DIV 9  Indica\u021bii: Restul \u00eemp\u0103r\u021birii unui num\u0103r la 3 poate fi 0, 1 sau 2.", "Restul \u00eemp\u0103r\u021birii unui  num\u0103r la 7 poate fi maxim 6.", "\u00cen concluzie, suma acestor dou\u0103 resturi nu poate fi mai  mare de 8.", " 2.", " R\u0103spuns corect: b) v=(5,3,4,8,6,2,1,9)  Indica\u021bii: Instruc\u021biunile din cadrul instruc\u021biunii repetitive while   (C++: v[i]=v[i]+v[j]; v[j]=v[i]-v[j]; v[i]=v[i]-v[j]; sau  Pascal: v[i]:=v[i]+v[j]; v[j]:=v[i]-v[j]; v[i]:=v[i]-v[j];)  interschimb\u0103 valoarea aflat\u0103 \u00een v[i] cu valoarea aflat\u0103 \u00een v[j].", " i=0  j=1  v[0]=5  v[1]=3  i=2  j=3  v[2]=4  v[3]=8  i=4  j=5  v[4]=6  v[5]=2  i=6  j=7  v[6]=1  v[7]=9    3.", " R\u0103spuns corect: f) poLItEHnica  Indica\u021bii: Toate literele mai mici dec\u00e2t litera n, \u00een ordine alfabetic\u0103, p\u00e2n\u0103 la pozi\u021bia 7  din \u0219irul de caractere memorat \u00een variabila a, sunt transformate \u00een litere mari (spre  exemplu: l devine L)    4.", " R\u0103spuns corect: d)  \ud835\udc34= ( 0 1 1 2 2 3 2 4 2 2 3 4 4 3 3 6 )  Indica\u021bii: Cele dou\u0103 instruc\u021biuni repetitive while parcurg toate elementele tabloului  bidimensional A. Elementele care respect\u0103 condi\u021bia instruc\u021biunii if (i+j s\u0103 fie par)  sunt: A[0][0]=0, A[0][2]=2, A[1][1]=2, A[1][3]=4, A[2][0]=2,  A[2][2]=4, A[3][1]=4 \u0219i A[3][3]=6.", " Celelalte elemente au valoarea celui mai mare dintre indicii i \u0219i j: A[0][1]=1,  A[0][3]=3,  A[1][0]=1,  A[1][2]=2,  A[2][1]=2,  A[2][3]=3,  A[3][0]=3 \u0219i A[3][2]=3.", " 5.", " R\u0103spuns corect: d) 11  Indica\u021bii:  Ad(3)  Ad(7)  Ad(5)   El()    El()   Ad(8)          5                  7    7    7        8  3    3    3    3    3    3    6.", " R\u0103spuns corect: d) 24  Indica\u021bii: 4a8b (4185, 4189, 4581, 4589, 4981, 4985) - 6 numere                   8a4b - 6 numere"], "page_sentence_count_spacy": 13}, {"page_number": 293, "page_char_count": 1510, "page_word_count": 433, "page_sentence_count_raw": 17, "page_token_count": 377.5, "text": "293                     a4b8 - 6 numere                   a8b4 - 6 numere  7.  R\u0103spuns corect: f) 2 2 2 1 1 2  Indica\u021bii: Nodul cu num\u0103rul 2 din varianta de r\u0103spuns a indic\u0103 faptul c\u0103 este adiacent  cu 5 noduri chiar dac\u0103 gradul nodului 3 este 0. Acela\u0219i ra\u021bionament se aplic\u0103 \u0219i pentru  varianta d. \u00centr-un graf neorientat suma gradelor tuturor nodurilor trebuie s\u0103 fie un  num\u0103r par. Prin urmare variantele b \u0219i e sunt false. Nodul cu num\u0103rul 3 din varianta de  r\u0103spuns c are gradul 7 chiar dac\u0103 graful are 6 noduri.  8.  R\u0103spuns corect: d) \ud835\udc7b= (\ud835\udfce \ud835\udfd3 \ud835\udfd5 \ud835\udfd1 \ud835\udfcf \ud835\udfd1 \ud835\udfcf \ud835\udfd0)  Indica\u021bii:  Reprezentarea grafic\u0103 a variantei a:                  Reprezentarea grafic\u0103 a variantei b:    Reprezentarea grafic\u0103 a variantei c:              Reprezentarea grafic\u0103 a variantei d:        Reprezentarea grafic\u0103 a variantei e:                      Reprezentarea grafic\u0103 a variantei f:      9.  R\u0103spuns corect: b) a2+1  Indica\u021bii: Cele dou\u0103 instruc\u021biuni repetitive while \u0219i do... while /                repeat... until aflate \u00een interiorul instruc\u021biunii for parcurg intervalul [1,a].  Instruc\u021biunea while parcurge intervalul [1,i] iar instruc\u021biunea do... while /  repeat... until parcurge intervalul complementar [i+1,a].  Deoarece aceste instruc\u021biuni se afl\u0103 \u00eentr-un for care parcurge acela\u0219i interval [1,a],  variabila s va avea valoarea a2. Va afi\u0219a a2+1 deoarece instruc\u021biunea do... while  1  2  5  6  7  3  4  8  1  2  4  6  5  3  8  7  1  2  4  6  5  3  8  7  1  5  2  6  8  7  3  4  1  2  4  6  5  3  8  7  1  5  2  6  8  7  3  4", "sentences": ["293                     a4b8 - 6 numere                   a8b4 - 6 numere  7.", " R\u0103spuns corect: f) 2 2 2 1 1 2  Indica\u021bii: Nodul cu num\u0103rul 2 din varianta de r\u0103spuns a indic\u0103 faptul c\u0103 este adiacent  cu 5 noduri chiar dac\u0103 gradul nodului 3 este 0.", "Acela\u0219i ra\u021bionament se aplic\u0103 \u0219i pentru  varianta d. \u00centr-un graf neorientat suma gradelor tuturor nodurilor trebuie s\u0103 fie un  num\u0103r par.", "Prin urmare variantele b \u0219i e sunt false.", "Nodul cu num\u0103rul 3 din varianta de  r\u0103spuns c are gradul 7 chiar dac\u0103 graful are 6 noduri.", " 8.", " R\u0103spuns corect: d) \ud835\udc7b= (\ud835\udfce \ud835\udfd3 \ud835\udfd5 \ud835\udfd1 \ud835\udfcf \ud835\udfd1 \ud835\udfcf \ud835\udfd0)  Indica\u021bii:  Reprezentarea grafic\u0103 a variantei a:                  Reprezentarea grafic\u0103 a variantei b:    Reprezentarea grafic\u0103 a variantei c:              Reprezentarea grafic\u0103 a variantei d:        Reprezentarea grafic\u0103 a variantei e:                      Reprezentarea grafic\u0103 a variantei f:      9.", " R\u0103spuns corect: b) a2+1  Indica\u021bii: Cele dou\u0103 instruc\u021biuni repetitive while \u0219i do... while /                repeat... until aflate \u00een interiorul instruc\u021biunii for parcurg intervalul [1,a].", " Instruc\u021biunea while parcurge intervalul [1,i] iar instruc\u021biunea do... while /  repeat... until parcurge intervalul complementar [i+1,a].", " Deoarece aceste instruc\u021biuni se afl\u0103 \u00eentr-un for care parcurge acela\u0219i interval [1,a],  variabila s va avea valoarea a2.", "Va afi\u0219a a2+1 deoarece instruc\u021biunea do... while  1  2  5  6  7  3  4  8  1  2  4  6  5  3  8  7  1  2  4  6  5  3  8  7  1  5  2  6  8  7  3  4  1  2  4  6  5  3  8  7  1  5  2  6  8  7  3  4"], "page_sentence_count_spacy": 11}, {"page_number": 294, "page_char_count": 1727, "page_word_count": 533, "page_sentence_count_raw": 13, "page_token_count": 431.75, "text": "294    / repeat... until va incrementa cu 1 variabila s \u00een ultima apelare a instruc\u021biunii  chiar dac\u0103 condi\u021bia este fals\u0103 deoarece este instruc\u021biune repetitiv\u0103 cu test final.  Pentru C++ nu se va afi\u0219a a2, ci a2+1 deoarece s\u2014- decrementeaz\u0103 variabila s dup\u0103  afi\u0219are!  10.  R\u0103spuns corect: d) 53078520  Indica\u021bii: \u00cen cazul de fa\u021b\u0103 func\u021bia recursiv\u0103 denumit\u0103 afis se va opri \u00een momentul \u00een  care k devine 1. De men\u021bionat c\u0103, \u00een cazul de fa\u021b\u0103, k porne\u0219te de la valoarea 8 care  este valoarea sumei indicilor lui a[4][4], elementul din dreapta jos.  Valoarea variabilei k scade cu 2 la fiecare reapelare a func\u021biei. Elementele se vor afi\u0219a  din partea dreapt\u0103 spre cea st\u00e2ng\u0103.   \ud835\udc97= ( \ud835\udc97\ud835\udfcf \ud835\udfcf \ud835\udc97\ud835\udfcf \ud835\udfd0 \ud835\udc97\ud835\udfd0 \ud835\udfcf \ud835\udc97\ud835\udfd0 \ud835\udfd0 \ud835\udc97\ud835\udfcf \ud835\udfd1 \ud835\udc97\ud835\udfcf \ud835\udfd2 \ud835\udc97\ud835\udfd0 \ud835\udfd1 \ud835\udc97\ud835\udfd0 \ud835\udfd2 \ud835\udc97\ud835\udfd1 \ud835\udfcf \ud835\udc97\ud835\udfd1 \ud835\udfd0 \ud835\udc97\ud835\udfd2 \ud835\udfcf \ud835\udc97\ud835\udfd2 \ud835\udfd0 \ud835\udc97\ud835\udfd1 \ud835\udfd1 \ud835\udc97\ud835\udfd1 \ud835\udfd2 \ud835\udc97\ud835\udfd2 \ud835\udfd1 \ud835\udc97\ud835\udfd2 \ud835\udfd2 )  \ud835\udc49= ( 0 1 4 5 2 3 6 7 8 9 2 3 0 1 4 5 )    11.  R\u0103spuns corect: f) \ud835\udc87(\ud835\udc95) \u2218\u2026 \u2218\ud835\udc87(\ud835\udc95) \u23df         \ud835\udc84   Indica\u021bii: abc(functie(t),c-1) apeleaz\u0103 subprogramul functie() de c ori.  Aceast\u0103 apelare se face cu rezultatul primit deja de la subprogramul functie(),  adic\u0103 f(f(x)).  12.  R\u0103spuns corect: d) cuei  Indica\u021bii:  Pentru C++: A fost definit un tablou bidimensional de caractere, astfel:    0  1  2  3  4  5  6  7  8  9 10  1  b  a  c  a  L  a  u  r  e  a  t  2  l  i  c  e  U              3  e  x  a  m  E  n  e          4  p  o  l  i  T  e  h  n  i  c  a  Prin urmare sunt afi\u0219ate elementele:  i=1 a[1][2]=`c`  i=2 a[2][4]=`u`  i=3 a[3][6]=`e`  i=4 a[4][8]=`i`    Pentru Pascal: \u00cen compara\u021bie cu C++ unde \u0219irul de caractere porne\u0219te de la 0, aici  porne\u0219te de la 1. Prin urmare avem urm\u0103toarele date:    1  2  3  4  5  6  7  8  9 10 11  1  b  a  c  a  L  a  u  R  e  a  T  2  l  i  c  e  U              3  e  x  a  m  E  n  e          4  p  o  l  i  T  e  h  N  i  c  a", "sentences": ["294    / repeat... until va incrementa cu 1 variabila s \u00een ultima apelare a instruc\u021biunii  chiar dac\u0103 condi\u021bia este fals\u0103 deoarece este instruc\u021biune repetitiv\u0103 cu test final.", " Pentru C++ nu se va afi\u0219a a2, ci a2+1 deoarece s\u2014- decrementeaz\u0103 variabila s dup\u0103  afi\u0219are!", " 10.", " R\u0103spuns corect: d) 53078520  Indica\u021bii: \u00cen cazul de fa\u021b\u0103 func\u021bia recursiv\u0103 denumit\u0103 afis se va opri \u00een momentul \u00een  care k devine 1.", "De men\u021bionat c\u0103, \u00een cazul de fa\u021b\u0103, k porne\u0219te de la valoarea 8 care  este valoarea sumei indicilor lui a[4][4], elementul din dreapta jos.", " Valoarea variabilei k scade cu 2 la fiecare reapelare a func\u021biei.", "Elementele se vor afi\u0219a  din partea dreapt\u0103 spre cea st\u00e2ng\u0103.", "  \ud835\udc97= ( \ud835\udc97\ud835\udfcf \ud835\udfcf \ud835\udc97\ud835\udfcf \ud835\udfd0 \ud835\udc97\ud835\udfd0 \ud835\udfcf \ud835\udc97\ud835\udfd0 \ud835\udfd0 \ud835\udc97\ud835\udfcf \ud835\udfd1 \ud835\udc97\ud835\udfcf \ud835\udfd2 \ud835\udc97\ud835\udfd0 \ud835\udfd1 \ud835\udc97\ud835\udfd0 \ud835\udfd2 \ud835\udc97\ud835\udfd1 \ud835\udfcf \ud835\udc97\ud835\udfd1 \ud835\udfd0 \ud835\udc97\ud835\udfd2 \ud835\udfcf \ud835\udc97\ud835\udfd2 \ud835\udfd0 \ud835\udc97\ud835\udfd1 \ud835\udfd1 \ud835\udc97\ud835\udfd1 \ud835\udfd2 \ud835\udc97\ud835\udfd2 \ud835\udfd1 \ud835\udc97\ud835\udfd2 \ud835\udfd2 )  \ud835\udc49= ( 0 1 4 5 2 3 6 7 8 9 2 3 0 1 4 5 )    11.", " R\u0103spuns corect: f) \ud835\udc87(\ud835\udc95) \u2218\u2026 \u2218\ud835\udc87(\ud835\udc95) \u23df         \ud835\udc84   Indica\u021bii: abc(functie(t),c-1) apeleaz\u0103 subprogramul functie() de c ori.", " Aceast\u0103 apelare se face cu rezultatul primit deja de la subprogramul functie(),  adic\u0103 f(f(x)).", " 12.", " R\u0103spuns corect: d) cuei  Indica\u021bii:  Pentru C++: A fost definit un tablou bidimensional de caractere, astfel:    0  1  2  3  4  5  6  7  8  9 10  1  b  a  c  a  L  a  u  r  e  a  t  2  l  i  c  e  U              3  e  x  a  m  E  n  e          4  p  o  l  i  T  e  h  n  i  c  a  Prin urmare sunt afi\u0219ate elementele:  i=1 a[1][2]=`c`  i=2 a[2][4]=`u`  i=3 a[3][6]=`e`  i=4 a[4][8]=`i`    Pentru Pascal: \u00cen compara\u021bie cu C++ unde \u0219irul de caractere porne\u0219te de la 0, aici  porne\u0219te de la 1.", "Prin urmare avem urm\u0103toarele date:    1  2  3  4  5  6  7  8  9 10 11  1  b  a  c  a  L  a  u  R  e  a  T  2  l  i  c  e  U              3  e  x  a  m  E  n  e          4  p  o  l  i  T  e  h  N  i  c  a"], "page_sentence_count_spacy": 13}, {"page_number": 295, "page_char_count": 919, "page_word_count": 209, "page_sentence_count_raw": 9, "page_token_count": 229.75, "text": "295    Urm\u0103toarele elemente sunt afi\u0219ate:  i=1 a[1][3]=`c`  i=2 a[2][5]=`u`  i=3 a[3][7]=`e`  i=4 a[4][9]=`i`    13.  R\u0103spuns corect: a) 17 5  Indica\u021bii: m=6, n=3 rezult\u0103 c\u0103 dup\u0103 apelarea f1(m,n) vor fi urm\u0103toarele valori:  f1(6,3)=10, m=6, n=2.  Apelarea f1(f1(m,n),m) se face, de fapt, pentru  f1(10,6) care conduce la valorile f1(10,6)=17, m=5, n=2.   14.  R\u0103spuns corect: \ud835\udc52) \ud835\udc4f= ( 29 38 47 38 50 62 47 62 77 )  Indica\u021bii:  i=1  j=1  k=1  b[1][1]=4  i=1  j=1  k=2  b[1][1]=13  i=1  j=1  k=3  b[1][1]=29  i=1  j=2  k=1  b[1][2]=6  i=1  j=2  k=2  b[1][2]=18  i=1  j=2  k=3  b[1][2]=38  i=1  j=3  k=1  b[1][3]=8  i=1  j=3  k=2  b[1][3]=23  i=1  j=3  k=3  b[1][3]=47  Identic se procedeaz\u0103 \u0219i pentru i=2 \u0219i i=3.  15.  R\u0103spuns corect: e) 24  Indica\u021bii: n=4 rezult\u0103 c\u0103 variabila b din functie devine 12. Dac\u0103 b devine 12  rezult\u0103 c\u0103 \u0219i n devine 12. Instruc\u021biunea a=2*a; atribuie lui a valoarea 2*n iar n este  12, adic\u0103 24.", "sentences": ["295    Urm\u0103toarele elemente sunt afi\u0219ate:  i=1 a[1][3]=`c`  i=2 a[2][5]=`u`  i=3 a[3][7]=`e`  i=4 a[4][9]=`i`    13.", " R\u0103spuns corect: a) 17 5  Indica\u021bii: m=6, n=3 rezult\u0103 c\u0103 dup\u0103 apelarea f1(m,n) vor fi urm\u0103toarele valori:  f1(6,3)=10, m=6, n=2.", " Apelarea f1(f1(m,n),m) se face, de fapt, pentru  f1(10,6) care conduce la valorile f1(10,6)=17, m=5, n=2.", "  14.", " R\u0103spuns corect: \ud835\udc52) \ud835\udc4f= ( 29 38 47 38 50 62 47 62 77 )  Indica\u021bii:  i=1  j=1  k=1  b[1][1]=4  i=1  j=1  k=2  b[1][1]=13  i=1  j=1  k=3  b[1][1]=29  i=1  j=2  k=1  b[1][2]=6  i=1  j=2  k=2  b[1][2]=18  i=1  j=2  k=3  b[1][2]=38  i=1  j=3  k=1  b[1][3]=8  i=1  j=3  k=2  b[1][3]=23  i=1  j=3  k=3  b[1][3]=47  Identic se procedeaz\u0103 \u0219i pentru i=2 \u0219i i=3.", " 15.", " R\u0103spuns corect: e) 24  Indica\u021bii: n=4 rezult\u0103 c\u0103 variabila b din functie devine 12.", "Dac\u0103 b devine 12  rezult\u0103 c\u0103 \u0219i n devine 12.", "Instruc\u021biunea a=2*a; atribuie lui a valoarea 2*n iar n este  12, adic\u0103 24."], "page_sentence_count_spacy": 9}, {"page_number": 296, "page_char_count": 2684, "page_word_count": 536, "page_sentence_count_raw": 30, "page_token_count": 671.0, "text": "296      Varianta 27  Indica\u021bii \u0219i r\u0103spunsuri    1.  R\u0103spuns corect: b) -24  Indica\u021bii: Se evalueaz\u0103 mai \u00eent\u00e2i rezultatul din parantez\u0103, care este -2, apoi se  calculeaz\u0103 c\u00e2tul \u00eemp\u0103r\u021birii lui 16 la -2 \u0219i \u00een final acesta se \u00eenmul\u021be\u0219te cu 3.   2.  R\u0103spuns corect: b) n / 10 % 10 \u00een varianta C/C++, respectiv n div 10 mod  10 \u00een varianta Pascal.  EXEMPLU: Pentru n=3185, n/10 = n div 10 = 318, iar n/10%10 =  318%10 = 8, respectiv n div 10 mod 10 = 318 mod 10 = 8.  3.  R\u0103spuns corect: f) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r p\u0103trat  perfect.  EXEMPLE: Pentru n=11 vom avea d1=1 \u0219i d2=11, deci d1\u2260d2, pentru n=125=53  vom avea d1=5 \u0219i d2=25, deci d1\u2260d2, pentru n=21 vom avea d1=3 \u0219i d2=7, , deci  d1\u2260d2. Pentru orice p\u0103trat perfect de forma n=r2, vom avea d1=d2=r. De exemplu,  pentru n=36 vom avea d1=d2=6.  Indica\u021bii: Algoritmul re\u021bine la final \u00een d1 cel mai mare divizor al lui n al c\u0103rui p\u0103trat  e mai mic sau egal cu n, iar \u00een d2 divizorul \u201ecomplementar\u201d, care \u00eenmul\u021bit cu d1 d\u0103  rezultatul n. Doar \u00een cazul p\u0103tratelor perfecte d1=d2.  4.  R\u0103spuns corect: a) for (j = n - 2; j >= i; j--) \u00een varianta C/C++,  respectiv for j := n-2 downto i do \u00een varianta Pascal.  EXEMPLU: Dac\u0103 n=4 \u0219i v=(3,2,1,4), la primul pas, \u00een care i=0 vor fi  comparate 1 \u0219i 4, f\u0103r\u0103 a fi nevoie de interschimbare, apoi 2 \u0219i 1, care vor fi  interschimbate \u0219i la final 3 \u0219i 1, care vor fi de asemenea interschimbate. Tabloul va  deveni astfel (1,3,2,4). Pentru i=1 vor fi comparate 2 \u0219i 4 f\u0103r\u0103 a fi interschimbate,  apoi 3 \u0219i 2, care vor fi interschimbate. Tabloul va deveni (1,2,3,4). Pentru i=2  vor mai fi comparate, f\u0103r\u0103 a fi interschimbate 3 \u0219i 4.  Indica\u021bii: Algoritmul se aseam\u0103n\u0103 foarte mult cu sortarea prin metoda bulelor (Bubble  Sort), const\u00e2nd de asemenea din parcurgeri succesive ale tabloului, \u00een cadrul c\u0103rora  sunt comparate \u0219i eventual interschimbate elemente aflate pe pozi\u021bii consecutive. \u00cen  cazul s\u0103u \u00eens\u0103 parcurgerile se fac de la dreapta la st\u00e2nga, \u00een cadrul fiec\u0103reia elementul  minim fiind mutat \u00een st\u00e2nga subsecven\u021bei prelucrate.  5.  R\u0103spuns corect: c) f(1, n) == n \u00een varianta C/C++, respectiv f(1, n) = n  \u00een varianta Pascal.  Indica\u021bii: Apelul f(d,n) returneaz\u0103 cel mai mic divizor al lui n mai mare strict ca  d. \u00cen cazul \u00een care n este prim acesta va fi n \u0219i reciproc (\u00een enun\u021b se garanteaz\u0103 c\u0103 n  este natural, mai mare strict ca 1).  6.  R\u0103spuns corect: e) 36  Indica\u021bii: Un arbore cu 10 v\u00e2rfuri are cu siguran\u021b\u0103 9 muchii, iar un graf complet cu  10 v\u00e2rfuri are cu siguran\u021b\u0103 10*(10-1)/2 = 45 de muchii. Prin urmare, vor trebui  ad\u0103ugate 45-9 = 36 de muchii.  7.  R\u0103spuns corect: e) 65  Indica\u021bii: Secven\u021ba de instruc\u021biuni construie\u0219te urm\u0103toarea matrice:", "sentences": ["296      Varianta 27  Indica\u021bii \u0219i r\u0103spunsuri    1.", " R\u0103spuns corect: b) -24  Indica\u021bii: Se evalueaz\u0103 mai \u00eent\u00e2i rezultatul din parantez\u0103, care este -2, apoi se  calculeaz\u0103 c\u00e2tul \u00eemp\u0103r\u021birii lui 16 la -2 \u0219i \u00een final acesta se \u00eenmul\u021be\u0219te cu 3.", "  2.", " R\u0103spuns corect: b) n / 10 % 10 \u00een varianta C/C++, respectiv n div 10 mod  10 \u00een varianta Pascal.", " EXEMPLU: Pentru n=3185, n/10 = n div 10 = 318, iar n/10%10 =  318%10 = 8, respectiv n div 10 mod 10 = 318 mod 10 = 8.", " 3.", " R\u0103spuns corect: f) La final d1 \u0219i d2 vor fi egale doar dac\u0103 n re\u021bine un num\u0103r p\u0103trat  perfect.", " EXEMPLE: Pentru n=11 vom avea d1=1 \u0219i d2=11, deci d1\u2260d2, pentru n=125=53  vom avea d1=5 \u0219i d2=25, deci d1\u2260d2, pentru n=21 vom avea d1=3 \u0219i d2=7, , deci  d1\u2260d2.", "Pentru orice p\u0103trat perfect de forma n=r2, vom avea d1=d2=r. De exemplu,  pentru n=36 vom avea d1=d2=6.", " Indica\u021bii: Algoritmul re\u021bine la final \u00een d1 cel mai mare divizor al lui n al c\u0103rui p\u0103trat  e mai mic sau egal cu n, iar \u00een d2 divizorul \u201ecomplementar\u201d, care \u00eenmul\u021bit cu d1 d\u0103  rezultatul n. Doar \u00een cazul p\u0103tratelor perfecte d1=d2.", " 4.", " R\u0103spuns corect: a) for (j = n - 2; j >= i; j--) \u00een varianta C/C++,  respectiv for j := n-2 downto i do \u00een varianta Pascal.", " EXEMPLU: Dac\u0103 n=4 \u0219i v=(3,2,1,4), la primul pas, \u00een care i=0 vor fi  comparate 1 \u0219i 4, f\u0103r\u0103 a fi nevoie de interschimbare, apoi 2 \u0219i 1, care vor fi  interschimbate \u0219i la final 3 \u0219i 1, care vor fi de asemenea interschimbate.", "Tabloul va  deveni astfel (1,3,2,4).", "Pentru i=1 vor fi comparate 2 \u0219i 4 f\u0103r\u0103 a fi interschimbate,  apoi 3 \u0219i 2, care vor fi interschimbate.", "Tabloul va deveni (1,2,3,4).", "Pentru i=2  vor mai fi comparate, f\u0103r\u0103 a fi interschimbate 3 \u0219i 4.", " Indica\u021bii: Algoritmul se aseam\u0103n\u0103 foarte mult cu sortarea prin metoda bulelor (Bubble  Sort), const\u00e2nd de asemenea din parcurgeri succesive ale tabloului, \u00een cadrul c\u0103rora  sunt comparate \u0219i eventual interschimbate elemente aflate pe pozi\u021bii consecutive.", "\u00cen  cazul s\u0103u \u00eens\u0103 parcurgerile se fac de la dreapta la st\u00e2nga, \u00een cadrul fiec\u0103reia elementul  minim fiind mutat \u00een st\u00e2nga subsecven\u021bei prelucrate.", " 5.", " R\u0103spuns corect: c) f(1, n) == n \u00een varianta C/C++, respectiv f(1, n) = n  \u00een varianta Pascal.", " Indica\u021bii: Apelul f(d,n) returneaz\u0103 cel mai mic divizor al lui n mai mare strict ca  d. \u00cen cazul \u00een care n este prim acesta va fi n \u0219i reciproc (\u00een enun\u021b se garanteaz\u0103 c\u0103 n  este natural, mai mare strict ca 1).", " 6.", " R\u0103spuns corect: e) 36  Indica\u021bii: Un arbore cu 10 v\u00e2rfuri are cu siguran\u021b\u0103 9 muchii, iar un graf complet cu  10 v\u00e2rfuri are cu siguran\u021b\u0103 10*(10-1)/2 = 45 de muchii.", "Prin urmare, vor trebui  ad\u0103ugate 45-9 = 36 de muchii.", " 7.", " R\u0103spuns corect: e) 65  Indica\u021bii: Secven\u021ba de instruc\u021biuni construie\u0219te urm\u0103toarea matrice:"], "page_sentence_count_spacy": 27}, {"page_number": 297, "page_char_count": 2339, "page_word_count": 470, "page_sentence_count_raw": 20, "page_token_count": 584.75, "text": "297      25  24  23  22  21    20  19  18  17  16    15  14  13  12  11    10   9   8   7   6     5   4   3   2   1  8.  R\u0103spuns corect: c) (2,1,0,2,0)  Indica\u021bii: Dac\u0103 numerot\u0103m v\u00e2rfurile ca  \u00een figura al\u0103turat\u0103, vom ob\u021bine \u0219irul  gradelor interne de la punctul c)    9.  R\u0103spuns corect: c) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele  cuv\u00e2ntului citit care nu au vocale pe pozi\u021bii al\u0103turate.  Indica\u021bii: Ordinea alfabetic\u0103 a literelor din cuvintele pilo \u0219i poli este i, l, o, p.  Prin urmare varianta a) nu are cum s\u0103 fie cea corect\u0103 (este \u00eenaintea lui pilo \u00een ordine  invers lexicografic\u0103). Variantele b) \u0219i d) nu sunt corecte, deoarece \u00een ambele cazuri,  penultimul cuv\u00e2nt generat ar fi poil.   10.  R\u0103spuns corect: a) strcpy(t, strchr(s, ' ')); \u00een varianta C/C++, respectiv  t:=copy(s, pos(' ', s), 5); \u00een varianta Pascal.  Indica\u021bii: Variantele b), d), e) \u0219i f) ar produce erori de compilare, iar c) ar face ca \u00een  variabila t s\u0103 fie re\u021binut \"Politehnica 20202020\".  11.  R\u0103spuns corect: b) 31  Indica\u021bii: Ordinea apelurilor recursive va fi: f(24,34) = 2+f(25,34) =  2+(1+f(26,33)) = 3+f(26,31) = 3+f(26,29) = 3+(1+f(27,28))  = 4+f(27,26) = 4+27 = 31  12.  R\u0103spuns corect: f) 3  Indica\u021bii: Putem elimina muchiile {1,3}, {3,4} \u0219i {3,5}.Vom avea 3 cicluri  elementare: (1,5,6,1), (2,5,6,2) \u0219i (1,5,2,6,1).   13.  R\u0103spuns corect: d) 0 1 1 1 3 5  Indica\u021bii: Primii trei vectori \u00een ordine lexicografic\u0103 sunt: (0,1,1,1,2,5),  (0,1,1,1,3,5)\u0219i (0,1,1,1,4,5). Vectorul (0,1,2,3,1,1) nu este al  doilea,  (0,1,1,1,1,3) corespunde unui arbore cu \u00een\u0103l\u021bimea  2, iar  (0,1,1,1,2,6) nu corespunde unui arbore (6 nu poate fi propriul s\u0103u tat\u0103).  14.  R\u0103spuns corect: b) m * m >= x  EXEMPLU: Dac\u0103 x=30 \u0219i apelurile subprogramului sunt urm\u0103toarele (f\u0103c\u00e2nd  observa\u021bia c\u0103 rezultatul dorit nu poate fi mai mare ca x):  rad(1,30,30) = rad  (1,15,30) = rad (1,8,30) = rad (5,8,30) = rad(6,8,30) =  rad (6,7,30) = rad (6,6,30) = 6  Indica\u021bii: Subprogramul folose\u0219te o versiune modificat\u0103 a c\u0103ut\u0103rii binare pentru a  ob\u021bine rezultatul dorit. Astfel dac\u0103 elementul din mijlocul intervalului \u00een care se caut\u0103  rezultatul are proprietatea dorit\u0103 (p\u0103tratul s\u0103u e mai mare sau egal cu x), c\u0103utarea  continu\u0103 \u00een prima jum\u0103tate, altfel \u00een cea de-a doua.  15.  R\u0103spuns corect: d) s -= v[j]; \u00een varianta C/C++, respectiv s := s-v[j]; \u00een  varianta Pascal.", "sentences": ["297      25  24  23  22  21    20  19  18  17  16    15  14  13  12  11    10   9   8   7   6     5   4   3   2   1  8.", " R\u0103spuns corect: c) (2,1,0,2,0)  Indica\u021bii: Dac\u0103 numerot\u0103m v\u00e2rfurile ca  \u00een figura al\u0103turat\u0103, vom ob\u021bine \u0219irul  gradelor interne de la punctul c)    9.", " R\u0103spuns corect: c) Algoritmul genereaz\u0103 \u00een ordine lexicografic\u0103 anagramele  cuv\u00e2ntului citit care nu au vocale pe pozi\u021bii al\u0103turate.", " Indica\u021bii: Ordinea alfabetic\u0103 a literelor din cuvintele pilo \u0219i poli este i, l, o, p.  Prin urmare varianta a) nu are cum s\u0103 fie cea corect\u0103 (este \u00eenaintea lui pilo \u00een ordine  invers lexicografic\u0103).", "Variantele b) \u0219i d) nu sunt corecte, deoarece \u00een ambele cazuri,  penultimul cuv\u00e2nt generat ar fi poil.", "  10.", " R\u0103spuns corect: a) strcpy(t, strchr(s, ' ')); \u00een varianta C/C++, respectiv  t:=copy(s, pos(' ', s), 5); \u00een varianta Pascal.", " Indica\u021bii: Variantele b), d), e) \u0219i f) ar produce erori de compilare, iar c) ar face ca \u00een  variabila t s\u0103 fie re\u021binut \"Politehnica 20202020\".", " 11.", " R\u0103spuns corect: b) 31  Indica\u021bii: Ordinea apelurilor recursive va fi: f(24,34) = 2+f(25,34) =  2+(1+f(26,33)) = 3+f(26,31) = 3+f(26,29) = 3+(1+f(27,28))  = 4+f(27,26) = 4+27 = 31  12.", " R\u0103spuns corect: f) 3  Indica\u021bii: Putem elimina muchiile {1,3}, {3,4} \u0219i {3,5}.Vom avea 3 cicluri  elementare: (1,5,6,1), (2,5,6,2) \u0219i (1,5,2,6,1).", "  13.", " R\u0103spuns corect: d) 0 1 1 1 3 5  Indica\u021bii: Primii trei vectori \u00een ordine lexicografic\u0103 sunt: (0,1,1,1,2,5),  (0,1,1,1,3,5)\u0219i (0,1,1,1,4,5).", "Vectorul (0,1,2,3,1,1) nu este al  doilea,  (0,1,1,1,1,3) corespunde unui arbore cu \u00een\u0103l\u021bimea  2, iar  (0,1,1,1,2,6) nu corespunde unui arbore (6 nu poate fi propriul s\u0103u tat\u0103).", " 14.", " R\u0103spuns corect: b) m * m >= x  EXEMPLU: Dac\u0103 x=30 \u0219i apelurile subprogramului sunt urm\u0103toarele (f\u0103c\u00e2nd  observa\u021bia c\u0103 rezultatul dorit nu poate fi mai mare ca x):  rad(1,30,30) = rad  (1,15,30) = rad (1,8,30) = rad (5,8,30) = rad(6,8,30) =  rad (6,7,30) = rad (6,6,30) = 6  Indica\u021bii: Subprogramul folose\u0219te o versiune modificat\u0103 a c\u0103ut\u0103rii binare pentru a  ob\u021bine rezultatul dorit.", "Astfel dac\u0103 elementul din mijlocul intervalului \u00een care se caut\u0103  rezultatul are proprietatea dorit\u0103 (p\u0103tratul s\u0103u e mai mare sau egal cu x), c\u0103utarea  continu\u0103 \u00een prima jum\u0103tate, altfel \u00een cea de-a doua.", " 15.", " R\u0103spuns corect: d) s -= v[j]; \u00een varianta C/C++, respectiv s := s-v[j]; \u00een  varianta Pascal."], "page_sentence_count_spacy": 19}, {"page_number": 298, "page_char_count": 1002, "page_word_count": 185, "page_sentence_count_raw": 4, "page_token_count": 250.5, "text": "298    EXEMPLU: Dac\u0103 n=8, v=(3,5,4,1,2,8,19,3) \u0219i t=10 atunci lmax va avea  la sf\u00e2r\u0219itul execut\u0103rii secven\u021bei de instruc\u021biuni valoarea 3. Mai precis pentru i=0 se va  g\u0103si j=0, pentru i=1 se va g\u0103si de asemenea j=0, deoarece suma primelor 2 elemente  ale tabloului nu dep\u0103\u0219e\u0219te t=10, pentru i=2 se va g\u0103si j=1, deoarece suma primelor  3 elemente dep\u0103\u0219e\u0219te t, dar v[1]+v[2]\u2264t, pentru i=3 se va g\u0103si j=1, pentru i=4  se va g\u0103si j=2, pentru i=5 se va g\u0103si j=4, pentru i=6 se va g\u0103si j=7, pentru i=7  se va g\u0103si j=7,  Indica\u021bii: Pentru fiecare i cuprins \u00eentre 0 \u0219i n-1, algoritmul determin\u0103 \u00een timp liniar  cel mai mare j cu proprietatea c\u0103 subsecven\u021ba de la pozi\u021bia i p\u00e2n\u0103 la pozi\u021bia j inclusiv  respect\u0103 restric\u021bia de a avea suma mai mic\u0103 sau egal\u0103 cu t. Pentru verificarea acestei  condi\u021bii este p\u0103strat\u0103 \u00een permanen\u021b\u0103 \u00een variabila s suma elementelor din subsecven\u021ba  curent\u0103. Incrementarea lui j este echivalent\u0103 cu eliminarea lui v[j] din subsecven\u021b\u0103,  prin urmarea este necesar ca s s\u0103 scad\u0103 cu v[j].", "sentences": ["298    EXEMPLU: Dac\u0103 n=8, v=(3,5,4,1,2,8,19,3) \u0219i t=10 atunci lmax va avea  la sf\u00e2r\u0219itul execut\u0103rii secven\u021bei de instruc\u021biuni valoarea 3.", "Mai precis pentru i=0 se va  g\u0103si j=0, pentru i=1 se va g\u0103si de asemenea j=0, deoarece suma primelor 2 elemente  ale tabloului nu dep\u0103\u0219e\u0219te t=10, pentru i=2 se va g\u0103si j=1, deoarece suma primelor  3 elemente dep\u0103\u0219e\u0219te t, dar v[1]+v[2]\u2264t, pentru i=3 se va g\u0103si j=1, pentru i=4  se va g\u0103si j=2, pentru i=5 se va g\u0103si j=4, pentru i=6 se va g\u0103si j=7, pentru i=7  se va g\u0103si j=7,  Indica\u021bii: Pentru fiecare i cuprins \u00eentre 0 \u0219i n-1, algoritmul determin\u0103 \u00een timp liniar  cel mai mare j cu proprietatea c\u0103 subsecven\u021ba de la pozi\u021bia i p\u00e2n\u0103 la pozi\u021bia j inclusiv  respect\u0103 restric\u021bia de a avea suma mai mic\u0103 sau egal\u0103 cu t. Pentru verificarea acestei  condi\u021bii este p\u0103strat\u0103 \u00een permanen\u021b\u0103 \u00een variabila s suma elementelor din subsecven\u021ba  curent\u0103.", "Incrementarea lui j este echivalent\u0103 cu eliminarea lui v[j] din subsecven\u021b\u0103,  prin urmarea este necesar ca s s\u0103 scad\u0103 cu v[j]."], "page_sentence_count_spacy": 3}, {"page_number": 299, "page_char_count": 2980, "page_word_count": 614, "page_sentence_count_raw": 28, "page_token_count": 745.0, "text": "299    Varianta 28  Indica\u021bii \u0219i r\u0103spunsuri    1.  R\u0103spuns corect: d)(a+b+c+d)*0.25  Indica\u021bii: Varianta a) ar fi corect\u0103 doar dac\u0103 suma a+b+c+d ar fi scris\u0103 \u00eentre  paranteze. Variantele b), c), e) \u0219i f) sunt incorecte din punct de vedere  matematic, de\u0219i nu au erori de sintax\u0103.   2.  R\u0103spuns corect: c) At\u00e2t S1, c\u00e2t \u0219i S2  Indica\u021bii: Ambele secven\u021be de instruc\u021biuni au ca efect ob\u021binerea \u00een variabila p a primei  cifre a num\u0103rului re\u021binut ini\u021bial de n. \u00cen cadrul S1 p re\u021bine mai \u00eent\u00e2i o copie a lui n, iar  apoi, c\u00e2t timp p are mai mult de o cifr\u0103 se elimin\u0103 ultima dintre acestea. \u00cen S2 se re\u021bine  \u00een mod repetat \u00een p ultima cifr\u0103 a lui n, apoi aceasta se elimin\u0103 prin p\u0103strarea \u00een n a  c\u00e2tului \u00eemp\u0103r\u021birii \u00eentregi a lui n la 10. \u00cen felul acesta ultima cifr\u0103 eliminat\u0103 este evident  prima cifr\u0103 a num\u0103rului re\u021binut ini\u021bial de n, aceasta fiind valoarea final\u0103 a lui p. Singura  diferen\u021b\u0103 dintre S1 \u0219i S2 este c\u0103 \u00een cazul celei de-a doua secven\u021be de instruc\u021biuni  valoarea ini\u021bial\u0103 a lui n se va pierde, aceasta fiind \u00eenlocuit\u0103 cu 0 la sf\u00e2r\u0219itul execut\u0103rii  buclei.  3.  R\u0103spuns corect: f) n % d == 0 \u00een varianta C/C++, respectiv n mod d = 0 \u00een  varianta Pascal.  EXEMPLU: Pentru n=300, c\u00e2nd d=2, \u00een bucla while (n%d == 0) a programului  C/C++, respectiv while n mod d = 0 do a variantei Pascal n va deveni 75, iar  p \u0219i nr vor deveni 1. Apoi, pentru d=3, \u00een aceea\u0219i bucl\u0103 n va deveni 25, p, din nou 1,  iar nr va primi valoarea 2. Pentru d=4 nu se va intra \u00een bucla while intern\u0103, deci p  va r\u0103m\u00e2ne 0, iar n \u0219i nr nu se vor modifica. \u00cen fine, c\u00e2nd d=5, p va deveni din nou 1,  nr va deveni 3, iar n va ajunge 1, ceea ce va face ca bucla while exterioar\u0103 s\u0103 se  \u00eencheie.  Indica\u021bii: Algoritmul g\u0103se\u0219te divizorii primi ai lui n baz\u00e2ndu-se pe faptul c\u0103, dac\u0103  atunci c\u00e2nd e g\u0103sit un divizor d, n e \u00eemp\u0103r\u021bit la el de c\u00e2te ori e posibil, atunci nu se va  intra \u00een bucla interioar\u0103 dec\u00e2t pentru divizorii primi ai num\u0103rului re\u021binut ini\u021bial de n.  4.  R\u0103spuns corect: e) v[i+1] = x \u00een varianta C/C++, respectiv v[i+1] := x \u00een  varianta Pascal.  EXEMPLE: Dac\u0103 n=5,  v=(2,3,5,5,8) \u0219i x=4, la primul pas, \u00een care i=4 sunt  comparate 4 \u0219i 8, iar v[5] devine 8, apoi i devine 3 \u0219i, pentru c\u0103 v[3]=5 \u0219i e \u00een  continuare mai mare ca x=4, v[4] devine 5. Acela\u0219i lucru se \u00eent\u00e2mpl\u0103 pentru i=2 \u0219i  v[3] devine de asemenea 5. Bucla se \u00eencheie cu i=1, pentru c\u0103 v[1]=3 \u0219i 3 nu e  mai mare strict ca x=4. Evident, 4 va fi inserat dup\u0103 3, pe pozi\u021bia i+1 = 2. Vectorul  va deveni astfel (2,3,4,5,5,8).   Dac\u0103 n=4,  v=(2,3,5,5) \u0219i x=1, atunci \u00een bucla while vor fi mutate cu o pozi\u021bie  spre dreapta toate elementele vectorului, iar la final i va avea valoarea -1. Pe pozi\u021bia  i+1=0 va fi scris x=1. Vectorul va deveni astfel (1,2,3,5,5,8).  Indica\u021bii: Algoritmul \u00eel insereaz\u0103 pe x \u00een v dup\u0103 ce mut\u0103 spre dreapta cu o pozi\u021bie toate  componentele mai mari strict ca x. Bucla while se poate termina fie atunci c\u00e2nd toate  elementele lui v sunt strict mai mici ca x \u0219i sunt mutate (i devine -1), fie c\u00e2nd se", "sentences": ["299    Varianta 28  Indica\u021bii \u0219i r\u0103spunsuri    1.", " R\u0103spuns corect: d)(a+b+c+d)*0.25  Indica\u021bii: Varianta a) ar fi corect\u0103 doar dac\u0103 suma a+b+c+d ar fi scris\u0103 \u00eentre  paranteze.", "Variantele b), c), e) \u0219i f) sunt incorecte din punct de vedere  matematic, de\u0219i nu au erori de sintax\u0103.", "  2.", " R\u0103spuns corect: c) At\u00e2t S1, c\u00e2t \u0219i S2  Indica\u021bii: Ambele secven\u021be de instruc\u021biuni au ca efect ob\u021binerea \u00een variabila p a primei  cifre a num\u0103rului re\u021binut ini\u021bial de n. \u00cen cadrul S1 p re\u021bine mai \u00eent\u00e2i o copie a lui n, iar  apoi, c\u00e2t timp p are mai mult de o cifr\u0103 se elimin\u0103 ultima dintre acestea.", "\u00cen S2 se re\u021bine  \u00een mod repetat \u00een p ultima cifr\u0103 a lui n, apoi aceasta se elimin\u0103 prin p\u0103strarea \u00een n a  c\u00e2tului \u00eemp\u0103r\u021birii \u00eentregi a lui n la 10.", "\u00cen felul acesta ultima cifr\u0103 eliminat\u0103 este evident  prima cifr\u0103 a num\u0103rului re\u021binut ini\u021bial de n, aceasta fiind valoarea final\u0103 a lui p. Singura  diferen\u021b\u0103 dintre S1 \u0219i S2 este c\u0103 \u00een cazul celei de-a doua secven\u021be de instruc\u021biuni  valoarea ini\u021bial\u0103 a lui n se va pierde, aceasta fiind \u00eenlocuit\u0103 cu 0 la sf\u00e2r\u0219itul execut\u0103rii  buclei.", " 3.", " R\u0103spuns corect: f) n % d == 0 \u00een varianta C/C++, respectiv n mod d = 0 \u00een  varianta Pascal.", " EXEMPLU: Pentru n=300, c\u00e2nd d=2, \u00een bucla while (n%d == 0) a programului  C/C++, respectiv while n mod d = 0 do a variantei Pascal n va deveni 75, iar  p \u0219i nr vor deveni 1.", "Apoi, pentru d=3, \u00een aceea\u0219i bucl\u0103 n va deveni 25, p, din nou 1,  iar nr va primi valoarea 2.", "Pentru d=4 nu se va intra \u00een bucla while intern\u0103, deci p  va r\u0103m\u00e2ne 0, iar n \u0219i nr nu se vor modifica.", "\u00cen fine, c\u00e2nd d=5, p va deveni din nou 1,  nr va deveni 3, iar n va ajunge 1, ceea ce va face ca bucla while exterioar\u0103 s\u0103 se  \u00eencheie.", " Indica\u021bii: Algoritmul g\u0103se\u0219te divizorii primi ai lui n baz\u00e2ndu-se pe faptul c\u0103, dac\u0103  atunci c\u00e2nd e g\u0103sit un divizor d, n e \u00eemp\u0103r\u021bit la el de c\u00e2te ori e posibil, atunci nu se va  intra \u00een bucla interioar\u0103 dec\u00e2t pentru divizorii primi ai num\u0103rului re\u021binut ini\u021bial de n.  4.", " R\u0103spuns corect: e) v[i+1] = x \u00een varianta C/C++, respectiv v[i+1] := x \u00een  varianta Pascal.", " EXEMPLE: Dac\u0103 n=5,  v=(2,3,5,5,8) \u0219i x=4, la primul pas, \u00een care i=4 sunt  comparate 4 \u0219i 8, iar v[5] devine 8, apoi i devine 3 \u0219i, pentru c\u0103 v[3]=5 \u0219i e \u00een  continuare mai mare ca x=4, v[4] devine 5.", "Acela\u0219i lucru se \u00eent\u00e2mpl\u0103 pentru i=2 \u0219i  v[3] devine de asemenea 5.", "Bucla se \u00eencheie cu i=1, pentru c\u0103 v[1]=3 \u0219i 3 nu e  mai mare strict ca x=4.", "Evident, 4 va fi inserat dup\u0103 3, pe pozi\u021bia i+1 = 2.", "Vectorul  va deveni astfel (2,3,4,5,5,8).", "  Dac\u0103 n=4,  v=(2,3,5,5) \u0219i x=1, atunci \u00een bucla while vor fi mutate cu o pozi\u021bie  spre dreapta toate elementele vectorului, iar la final i va avea valoarea -1.", "Pe pozi\u021bia  i+1=0 va fi scris x=1.", "Vectorul va deveni astfel (1,2,3,5,5,8).", " Indica\u021bii: Algoritmul \u00eel insereaz\u0103 pe x \u00een v dup\u0103 ce mut\u0103 spre dreapta cu o pozi\u021bie toate  componentele mai mari strict ca x. Bucla while se poate termina fie atunci c\u00e2nd toate  elementele lui v sunt strict mai mici ca x \u0219i sunt mutate (i devine -1), fie c\u00e2nd se"], "page_sentence_count_spacy": 24}, {"page_number": 300, "page_char_count": 1721, "page_word_count": 380, "page_sentence_count_raw": 19, "page_token_count": 430.25, "text": "300    ajunge la un i cu proprietatea c\u0103 v[i]\u2264x. \u00cen ambele cazuri este necesar ca x s\u0103 fie  inserat pe pozi\u021bia i+1.  5.  R\u0103spuns corect: b) 60.  Indica\u021bii: Secven\u021ba de instruc\u021biuni construie\u0219te urm\u0103toarea matrice:    5   4   3   2   1    6   5   4   3   2    7   6   5   4   3    8   7   6   5   4    9   8   7   6   5  6.  R\u0103spuns corect: b) f(225)  Indica\u021bii: \u00cen cadrul buclei while r devine cel mai mic num\u0103r al c\u0103rui p\u0103trat este mai  mare sau egal cu n (partea \u00eentreag\u0103 superioar\u0103 a r\u0103d\u0103cinii p\u0103trate a lui n). Subprogramul  returneaz\u0103 astfel 0 dac\u0103 \u0219i numai dac\u0103 n este p\u0103trat perfect.  7.  R\u0103spuns corect: d) (1,1,2,2)  Indica\u021bii: Variantele a) \u0219i f) sunt incorecte, pentru c\u0103 un v\u00e2rf nu poate avea gradul  intern mai mare dec\u00e2t 3. Varianta b) are suma gradelor interne mai mare dec\u00e2t suma  gradelor externe, iar varianta e) are suma suma gradelor interne mai mic\u0103 dec\u00e2t suma  gradelor externe. \u00cen cazul variantei c) contradic\u021bia provine din faptul c\u0103 v\u00e2rful 4 are  gradul intern 0, deci nu poate exista un arc (1,4), iar 1 are gradul extern 3. Graful cu  arcele (1,2), (1,3), (1,4), (2,1), (3,4), (4,3), corespunde \u0219irului  gradelor interne (1,1,2,2).   8.  R\u0103spuns corect: c) 5  Indica\u021bii: Arborele din  figura al\u0103turat\u0103 corespunde  vectorului de ta\u021bi dat.    9.  R\u0103spuns corect: a) strcpy(p,p+1) \u00een varianta C/C++, respectiv  delete(s,p,1) \u00een varianta Pascal.  Indica\u021bii: Av\u00e2nd \u00een vedere c\u0103 de fiecare dat\u0103 caracterul c este c\u0103utat de la \u00eenceputul  \u0219irului (p = strchr(s, c);, respectiv p := pos(c, s)) de caractere s, e  necesar ca la fiecare itera\u021bie a buclei while s\u0103 se \u0219tearg\u0103 ultima apari\u021bie g\u0103sit\u0103.   10.  R\u0103spuns corect: f) 012013  Indica\u021bii: Arborele apelurilor recursive este cel din figura de mai jos.", "sentences": ["300    ajunge la un i cu proprietatea c\u0103 v[i]\u2264x.", "\u00cen ambele cazuri este necesar ca x s\u0103 fie  inserat pe pozi\u021bia i+1.", " 5.", " R\u0103spuns corect: b) 60.", " Indica\u021bii: Secven\u021ba de instruc\u021biuni construie\u0219te urm\u0103toarea matrice:    5   4   3   2   1    6   5   4   3   2    7   6   5   4   3    8   7   6   5   4    9   8   7   6   5  6.", " R\u0103spuns corect: b) f(225)  Indica\u021bii: \u00cen cadrul buclei while r devine cel mai mic num\u0103r al c\u0103rui p\u0103trat este mai  mare sau egal cu n (partea \u00eentreag\u0103 superioar\u0103 a r\u0103d\u0103cinii p\u0103trate a lui n).", "Subprogramul  returneaz\u0103 astfel 0 dac\u0103 \u0219i numai dac\u0103 n este p\u0103trat perfect.", " 7.", " R\u0103spuns corect: d) (1,1,2,2)  Indica\u021bii: Variantele a) \u0219i f) sunt incorecte, pentru c\u0103 un v\u00e2rf nu poate avea gradul  intern mai mare dec\u00e2t 3.", "Varianta b) are suma gradelor interne mai mare dec\u00e2t suma  gradelor externe, iar varianta e) are suma suma gradelor interne mai mic\u0103 dec\u00e2t suma  gradelor externe.", "\u00cen cazul variantei c) contradic\u021bia provine din faptul c\u0103 v\u00e2rful 4 are  gradul intern 0, deci nu poate exista un arc (1,4), iar 1 are gradul extern 3.", "Graful cu  arcele (1,2), (1,3), (1,4), (2,1), (3,4), (4,3), corespunde \u0219irului  gradelor interne (1,1,2,2).", "  8.", " R\u0103spuns corect: c) 5  Indica\u021bii: Arborele din  figura al\u0103turat\u0103 corespunde  vectorului de ta\u021bi dat.", "   9.", " R\u0103spuns corect: a) strcpy(p,p+1) \u00een varianta C/C++, respectiv  delete(s,p,1) \u00een varianta Pascal.", " Indica\u021bii: Av\u00e2nd \u00een vedere c\u0103 de fiecare dat\u0103 caracterul c este c\u0103utat de la \u00eenceputul  \u0219irului (p = strchr(s, c);, respectiv p := pos(c, s)) de caractere s, e  necesar ca la fiecare itera\u021bie a buclei while s\u0103 se \u0219tearg\u0103 ultima apari\u021bie g\u0103sit\u0103.", "  10.", " R\u0103spuns corect: f) 012013  Indica\u021bii: Arborele apelurilor recursive este cel din figura de mai jos."], "page_sentence_count_spacy": 19}, {"page_number": 301, "page_char_count": 1813, "page_word_count": 377, "page_sentence_count_raw": 16, "page_token_count": 453.25, "text": "301      Apelul cu n=3 va afi\u0219a pe ecran 012, apoi apelul cu n=1 va afi\u0219a 01 \u0219i \u00een final apelul  cu n=3 va mai afi\u0219a 3. Celelalte 3 apeluri nu vor afi\u0219a nimic, \u00eentruc\u00e2t condi\u021bia n>0 nu  va fi verificat\u0103 \u00een cazul lor.  11.  R\u0103spuns corect: b) Generarea tuturor permut\u0103rilor mul\u021bimii {1,2,...,n}.  Indica\u021bii: \u00cen cazul ambelor probleme elementul curent din vectorul solu\u021bie, sol[p]  trebuie s\u0103 respecte condi\u021bia sol[p]\u2260sol[i] pentru orice i<p.  12.  R\u0103spuns corect: d) G nu poate fi eulerian  Indica\u021bii: Un graf cu 10 v\u00e2rfuri \u0219i mai pu\u021bin de 9 muchii nu poate fi conex, deci  afirma\u021bia de la punctul a) este adev\u0103rat\u0103. Un graf care nu este conex nu poate fi  hamiltonian, deci afirma\u021bia de la punctul c) este adev\u0103rat\u0103. Graful G poate avea dou\u0103  cicluri elementare cu c\u00e2te 4 v\u00e2rfuri \u0219i 4 muchii \u0219i 2 v\u00e2rfuri izolate (4 componente  conexe \u00een total), deci afirma\u021bia de la punctul b) este adev\u0103rat\u0103. \u00cen fine, un graf eulerian  poate avea v\u00e2rfuri izolate, deci \u00een cazul lui G putem avea un ciclu cu 8 v\u00e2rfuri care s\u0103  con\u021bin\u0103 toate cele 8 muchii \u0219i alte dou\u0103 v\u00e2rfuri izolate. Prin urmare, afirma\u021bia de la  punctul d) este singura care nu e adev\u0103rat\u0103.   13.  R\u0103spuns corect: e) 5  Indica\u021bii: O solu\u021bie posibil\u0103 este un arbore cu vectorul de ta\u021bi:  (0,1,1,1,2,2,2,5,5,5,8,11) cu lan\u021bul (1,2,5,8,11,12)de lungime 5,  care une\u0219te r\u0103d\u0103cina 1 cu frunza 12.  14.  R\u0103spuns corect: a)   if (v[n-2] > v[n-1])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  pentru limbajul C/C++, respectiv  if v[n-2] > v[n-1] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;      mysort(n-1, v)    end  pentru limbajul Pascal  Indica\u021bii: \u00cen urma apelului recursiv mysort(n-1,v), primele n-1 componente ale  lui v vor fi ordonate. Dac\u0103 v[n-2] \u2264 v[n-1], atunci nu mai sunt necesare alte", "sentences": ["301      Apelul cu n=3 va afi\u0219a pe ecran 012, apoi apelul cu n=1 va afi\u0219a 01 \u0219i \u00een final apelul  cu n=3 va mai afi\u0219a 3.", "Celelalte 3 apeluri nu vor afi\u0219a nimic, \u00eentruc\u00e2t condi\u021bia n>0 nu  va fi verificat\u0103 \u00een cazul lor.", " 11.", " R\u0103spuns corect: b) Generarea tuturor permut\u0103rilor mul\u021bimii {1,2,...,n}.", " Indica\u021bii: \u00cen cazul ambelor probleme elementul curent din vectorul solu\u021bie, sol[p]  trebuie s\u0103 respecte condi\u021bia sol[p]\u2260sol[i] pentru orice i<p.  12.", " R\u0103spuns corect: d) G nu poate fi eulerian  Indica\u021bii: Un graf cu 10 v\u00e2rfuri \u0219i mai pu\u021bin de 9 muchii nu poate fi conex, deci  afirma\u021bia de la punctul a) este adev\u0103rat\u0103.", "Un graf care nu este conex nu poate fi  hamiltonian, deci afirma\u021bia de la punctul c) este adev\u0103rat\u0103.", "Graful G poate avea dou\u0103  cicluri elementare cu c\u00e2te 4 v\u00e2rfuri \u0219i 4 muchii \u0219i 2 v\u00e2rfuri izolate (4 componente  conexe \u00een total), deci afirma\u021bia de la punctul b) este adev\u0103rat\u0103.", "\u00cen fine, un graf eulerian  poate avea v\u00e2rfuri izolate, deci \u00een cazul lui G putem avea un ciclu cu 8 v\u00e2rfuri care s\u0103  con\u021bin\u0103 toate cele 8 muchii \u0219i alte dou\u0103 v\u00e2rfuri izolate.", "Prin urmare, afirma\u021bia de la  punctul d) este singura care nu e adev\u0103rat\u0103.", "  13.", " R\u0103spuns corect: e) 5  Indica\u021bii: O solu\u021bie posibil\u0103 este un arbore cu vectorul de ta\u021bi:  (0,1,1,1,2,2,2,5,5,5,8,11) cu lan\u021bul (1,2,5,8,11,12)de lungime 5,  care une\u0219te r\u0103d\u0103cina 1 cu frunza 12.", " 14.", " R\u0103spuns corect: a)   if (v[n-2] > v[n-1])  {    aux = v[n-1];    v[n-1] = v[n-2];    v[n-2] = aux;    mysort(n - 1, v);  }  pentru limbajul C/C++, respectiv  if v[n-2] > v[n-1] then    begin      aux := v[n-1];      v[n-1] := v[n-2];      v[n-2] := aux;      mysort(n-1, v)    end  pentru limbajul Pascal  Indica\u021bii: \u00cen urma apelului recursiv mysort(n-1,v), primele n-1 componente ale  lui v vor fi ordonate.", "Dac\u0103 v[n-2] \u2264 v[n-1], atunci nu mai sunt necesare alte"], "page_sentence_count_spacy": 15}, {"page_number": 302, "page_char_count": 1361, "page_word_count": 236, "page_sentence_count_raw": 11, "page_token_count": 340.25, "text": "302    prelucr\u0103ri. \u00cen caz contrar ultimele dou\u0103 componente ale subsecven\u021bei (v[0], v[1],  ..., v[n-2], v[n-1]) care trebuie ordonat\u0103 vor fi interschimbate, iar procesul  va fi reluat pentru primele n-1 elemente printr-un nou apel recursiv cu acelea\u0219i  argumente. Cum v[n-1] este cu siguran\u021b\u0103 elementul maxim dup\u0103 interschimbare, la  revenirea din apelul recursiv, subsecven\u021ba va fi ordonat\u0103.  15.  R\u0103spuns corect: c) v[i]>s[m-1]  EXEMPLU:  Dac\u0103  n=8,  v=(3,3,1,8,2,1,5,4),  corespunz\u0103tor  lui  X=33182154 \u0219i k=4 atunci aplic\u00e2nd algoritmul vom ob\u021bine vectorul s=(8,2,5,4),  corespunz\u0103tor lui Y=8254. Acesta e cel mai mare num\u0103r natural care poate fi ob\u021binut  din X prin eliminarea a exact 4 cifre, f\u0103r\u0103 a schimba ordinea \u00een care cifrele ap\u0103reau \u00een  X.  Indica\u021bii: Algoritmul folose\u0219te vectorul s, organizat dup\u0103 principiul \u201eultimul sosit \u2013  primul servit\u201d. Componentele acestuia sunt acele cifre care pot face parte din Y. \u00cen  momentul lu\u0103rii \u00een considerare a unei noi cifre (v[i]) aceasta este introdus\u0103 cu  siguran\u021b\u0103 \u00een s (nu se \u0219tie \u00eenc\u0103 nimic despre cifrele care urmeaz\u0103 \u0219i deci acestea ar putea  fi mai mici). Apari\u021bia cifrei curente (v[i]) poate avea ca efect eliminarea din s a altor  cifre, mai mici, care nu trebuie s\u0103 se afle \u00eenaintea lui v[i] \u00een Y. Aceste elimin\u0103ri se  fac \u00een bucla while prin decrementarea lui m (num\u0103rul de elemente din vectorul s).", "sentences": ["302    prelucr\u0103ri.", "\u00cen caz contrar ultimele dou\u0103 componente ale subsecven\u021bei (v[0], v[1],  ..., v[n-2], v[n-1]) care trebuie ordonat\u0103 vor fi interschimbate, iar procesul  va fi reluat pentru primele n-1 elemente printr-un nou apel recursiv cu acelea\u0219i  argumente.", "Cum v[n-1] este cu siguran\u021b\u0103 elementul maxim dup\u0103 interschimbare, la  revenirea din apelul recursiv, subsecven\u021ba va fi ordonat\u0103.", " 15.", " R\u0103spuns corect: c) v[i]>s[m-1]  EXEMPLU:  Dac\u0103  n=8,  v=(3,3,1,8,2,1,5,4),  corespunz\u0103tor  lui  X=33182154 \u0219i k=4 atunci aplic\u00e2nd algoritmul vom ob\u021bine vectorul s=(8,2,5,4),  corespunz\u0103tor lui Y=8254.", "Acesta e cel mai mare num\u0103r natural care poate fi ob\u021binut  din X prin eliminarea a exact 4 cifre, f\u0103r\u0103 a schimba ordinea \u00een care cifrele ap\u0103reau \u00een  X.  Indica\u021bii: Algoritmul folose\u0219te vectorul s, organizat dup\u0103 principiul \u201eultimul sosit \u2013  primul servit\u201d.", "Componentele acestuia sunt acele cifre care pot face parte din Y. \u00cen  momentul lu\u0103rii \u00een considerare a unei noi cifre (v[i]) aceasta este introdus\u0103 cu  siguran\u021b\u0103 \u00een s (nu se \u0219tie \u00eenc\u0103 nimic despre cifrele care urmeaz\u0103 \u0219i deci acestea ar putea  fi mai mici).", "Apari\u021bia cifrei curente (v[i]) poate avea ca efect eliminarea din s a altor  cifre, mai mici, care nu trebuie s\u0103 se afle \u00eenaintea lui v[i] \u00een Y. Aceste elimin\u0103ri se  fac \u00een bucla while prin decrementarea lui m (num\u0103rul de elemente din vectorul s)."], "page_sentence_count_spacy": 8}, {"page_number": 303, "page_char_count": 2202, "page_word_count": 491, "page_sentence_count_raw": 18, "page_token_count": 550.5, "text": "303    Varianta 29  Indica\u021bii \u0219i r\u0103spunsuri    1.  R\u0103spuns corect: c) (n-1)/2     EXEMPLU: Pentru n=7 \u0219i tabloul unidimensional (4 2 3 1 6 8 5) se ob\u021bine tabloul  (5 8 6 1 3 2 4).   Indica\u021bii: Elementul de pe pozi\u021bia din mijloc nu este necesar s\u0103 fie mutat. Se interschimb\u0103  4 cu 5, 2 cu 8 \u0219i 3 cu 6, 3 interschimb\u0103ri, adic\u0103 se fac  (n-1)/2 interschimb\u0103ri.  2.  R\u0103spuns corect: b) (1 15 102 18 91)     Indica\u021bii: Se mut\u0103 al treilea element spre st\u00e2nga cu 2 pozi\u021bii \u0219.a.m.d. Primele 2 elemente  se mut\u0103 \u00een aceea\u0219i ordine la sf\u00e2r\u0219it.  3.  EXEMPLU:       x            x  x            x    R\u0103spuns corect: c) 3 1 4 2  Indica\u021bii: Dou\u0103 dame nu se atac\u0103 \u00eentre ele dac\u0103  nu se afl\u0103 pe aceea\u0219i coloan\u0103, pe aceea\u0219i  diagonal\u0103 sau pe acela\u0219i r\u00e2nd. Astfel a\u0219ezarea lor  poate fi: dama 1 pe r\u00e2ndul 3, dama 2 pe r\u00e2ndul 1,  dama 3 pe r\u00e2ndul 4, dama 4 pe r\u00e2ndul 2.  4.  R\u0103spuns corect: b) 10     EXEMPLU: Pentru tabloul unidimensional (10 24 9 11 33 7 15) se fac  urm\u0103toarele interschimb\u0103ri:   Pasul 1: (10 9 11 24 7 15 33): 4 interschimb\u0103ri  Pasul 2: (9 10 11 7 15 24 33): 3 interschimb\u0103ri  Pasul 3: (9 10 7 11 15 24 33): 1 interschimbare  Pasul 4: (9 7 10 11 15 24 33): 1 interschimbare  Pasul 5: (7 9 10 11 15 24 33): 1 interschimbare  Indica\u021bii: O interschimbare se face dac\u0103 sunt \u00eendeplinite simultan comdi\u021biile  v[i]>v[j] \u0219i i<j.   5.  R\u0103spuns corect: f) 26789 34567 34568 34569 34578     Indica\u021bii:  a) 45678 45679 45689 45789 46789 56789 \u2013 lipse\u0219te num\u0103rul subliniat  b) 34789 35678 35679 35689 36789 45678 \u2013 lipse\u0219te num\u0103rul subliniat  c) 34578 34569 34568 34567 26789 \u2013 nu sunt \u00een ordine cresc\u0103toare  d) 13458 13459 13467 13469 13478 13479 \u2013 lipse\u0219te num\u0103rul subliniat  e) 13458 13459 13467 13468 13469\u2013 num\u0103rul subliniat are mai mult de 2 cifre  al\u0103turate de aceea\u0219i paritate  6.  R\u0103spuns corect: c) 2349     Indica\u021bii: Subprogramul parcurge recursiv cele dou\u0103 numere a \u0219i b \u0219i returneaz\u0103 un  num\u0103r format cu cifra mai mare de pe aceea\u0219i pozi\u021bie din cele dou\u0103 numere.  7.  R\u0103spuns corect: d) 3     Indica\u021bii: Num\u0103rul minim de compara\u021bii se ob\u021bine folosind algoritmul de c\u0103utare binar\u0103.  Compara\u021bia 1: elementul din mijloc: 73; Compara\u021bia 2: elementul din mijloc: 95;  Compara\u021bia 3: elementul din mijloc: 82;", "sentences": ["303    Varianta 29  Indica\u021bii \u0219i r\u0103spunsuri    1.", " R\u0103spuns corect: c) (n-1)/2     EXEMPLU: Pentru n=7 \u0219i tabloul unidimensional (4 2 3 1 6 8 5) se ob\u021bine tabloul  (5 8 6 1 3 2 4).", "  Indica\u021bii: Elementul de pe pozi\u021bia din mijloc nu este necesar s\u0103 fie mutat.", "Se interschimb\u0103  4 cu 5, 2 cu 8 \u0219i 3 cu 6, 3 interschimb\u0103ri, adic\u0103 se fac  (n-1)/2 interschimb\u0103ri.", " 2.", " R\u0103spuns corect: b) (1 15 102 18 91)     Indica\u021bii: Se mut\u0103 al treilea element spre st\u00e2nga cu 2 pozi\u021bii \u0219.a.m.d. Primele 2 elemente  se mut\u0103 \u00een aceea\u0219i ordine la sf\u00e2r\u0219it.", " 3.", " EXEMPLU:       x            x  x            x    R\u0103spuns corect: c) 3 1 4 2  Indica\u021bii: Dou\u0103 dame nu se atac\u0103 \u00eentre ele dac\u0103  nu se afl\u0103 pe aceea\u0219i coloan\u0103, pe aceea\u0219i  diagonal\u0103 sau pe acela\u0219i r\u00e2nd.", "Astfel a\u0219ezarea lor  poate fi: dama 1 pe r\u00e2ndul 3, dama 2 pe r\u00e2ndul 1,  dama 3 pe r\u00e2ndul 4, dama 4 pe r\u00e2ndul 2.", " 4.", " R\u0103spuns corect: b) 10     EXEMPLU: Pentru tabloul unidimensional (10 24 9 11 33 7 15) se fac  urm\u0103toarele interschimb\u0103ri:   Pasul 1: (10 9 11 24 7 15 33): 4 interschimb\u0103ri  Pasul 2: (9 10 11 7 15 24 33): 3 interschimb\u0103ri  Pasul 3: (9 10 7 11 15 24 33): 1 interschimbare  Pasul 4: (9 7 10 11 15 24 33): 1 interschimbare  Pasul 5: (7 9 10 11 15 24 33): 1 interschimbare  Indica\u021bii: O interschimbare se face dac\u0103 sunt \u00eendeplinite simultan comdi\u021biile  v[i]>v[j] \u0219i i<j.   5.", " R\u0103spuns corect: f) 26789 34567 34568 34569 34578     Indica\u021bii:  a) 45678 45679 45689 45789 46789 56789 \u2013 lipse\u0219te num\u0103rul subliniat  b) 34789 35678 35679 35689 36789 45678 \u2013 lipse\u0219te num\u0103rul subliniat  c) 34578 34569 34568 34567 26789 \u2013 nu sunt \u00een ordine cresc\u0103toare  d) 13458 13459 13467 13469 13478 13479 \u2013 lipse\u0219te num\u0103rul subliniat  e) 13458 13459 13467 13468 13469\u2013 num\u0103rul subliniat are mai mult de 2 cifre  al\u0103turate de aceea\u0219i paritate  6.", " R\u0103spuns corect: c) 2349     Indica\u021bii: Subprogramul parcurge recursiv cele dou\u0103 numere a \u0219i b \u0219i returneaz\u0103 un  num\u0103r format cu cifra mai mare de pe aceea\u0219i pozi\u021bie din cele dou\u0103 numere.", " 7.", " R\u0103spuns corect: d) 3     Indica\u021bii: Num\u0103rul minim de compara\u021bii se ob\u021bine folosind algoritmul de c\u0103utare binar\u0103.", " Compara\u021bia 1: elementul din mijloc: 73; Compara\u021bia 2: elementul din mijloc: 95;  Compara\u021bia 3: elementul din mijloc: 82;"], "page_sentence_count_spacy": 16}, {"page_number": 304, "page_char_count": 2224, "page_word_count": 453, "page_sentence_count_raw": 34, "page_token_count": 556.0, "text": "304    8.  R\u0103spuns corect: e) nedefinit\u0103  Indica\u021bii: Este o variabil\u0103 local\u0103 neini\u0163ializat\u0103.  9.  R\u0103spuns corect: b) 190    Indica\u021bii: \u00cen total sunt 400 de elemente, 20 sunt pe diagonala secundar\u0103.   10. R\u0103spuns corect: d) 1023      EXEMPLU: Fie cele 3 tije a, b \u0219i c. Se mut\u0103 discurile de pe tija a pe tija b, utiliz\u00e2nd ca  tij\u0103 intermediar\u0103 tija c. Pentru k=3 discuri se fac 7 mut\u0103ri: a\uf0e0b, a\uf0e0c, b\uf0e0c, a\uf0e0b,  c\uf0e0a, c\uf0e0b, a\uf0e0b.   Indica\u021bii: Pentru k discuri este necesar un num\u0103r de 2k-1 mut\u0103ri.  11. R\u0103spuns corect: c) 8     Indica\u021bii: Graful nu con\u021bine bucle. Fiecare v\u00e2rf este adiacent cu toate celelalte v\u00e2rfuri.  Dac\u0103 graful are n v\u00e2rfuri exist\u0103 n(n-1) arce. 56=n(n-1), n=8.   12. R\u0103spuns corect: f) Doi dintre algoritmi nu difer\u0103 ca eficien\u021b\u0103 din punctul de vedere al  timpului de executare.      Indica\u021bii:   a) Algoritmii A1 \u0219i A2 rezolv\u0103 problema pentru orice date de intrare cu valorile din  interval.   b) Algoritmul A2 este cel mai eficient din punctul de vedere al timpului de executare. Are  complexitatea O(n) pentru parcurgerea \u0219irului \u0219i determinarea sumei.  c) Algoritmul A4 are complexitate dat\u0103 de o sortare rapid\u0103, O(n log n).  d) Algoritmul A4 rezolv\u0103 problema.  e) Algoritmii rezolv\u0103 problema pentru orice date de intrare cu valorile din interval.  f) A3 \u0219i A4 au aceea\u0219i eficien\u021b\u0103, complexitate dat\u0103 de o sortare rapid\u0103, O(n log n).  Observa\u021bie: Exist\u0103 algoritmi care rezolv\u0103 aceast\u0103 problem\u0103 \u00eentr-un timp mai scurt  (folosind opera\u021bii pe bi\u021bi).  13. R\u0103spuns corect: f) E1, E2 \u0219i E3      14. R\u0103spuns corect: c)  5040      EXEMPLU: Anagramele (nu neap\u0103rat \u00een aceast\u0103 ordine) sunt: aaccerrt, aaccertr,  aaccetrr, ..., rtreccaa, trreccaa. \u00cen total 5040.   Indica\u021bii: Litera a apare de dou\u0103 ori, litera c apare de dou\u0103 ori, litera e apare o dat\u0103, litera  r apare de dou\u0103 ori, litera t apare o dat\u0103; permut\u0103rile sunt cu repeti\u021bie.  Num\u0103rul permut\u0103rilor este: 8!/(2!\u00b72!\u00b71!\u00b72!\u00b71!)  15. R\u0103spuns corect: b) doar formula 1     Indica\u021bii:   Formula 1 poate fi ob\u021binut\u0103 din ecua\u021bia  (1 1 1 0) \ud835\udc5b = (\ud835\udc39 \ud835\udc5b+1 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b\u22121)  Clacul\u0103m determinantul: (\u22121)\ud835\udc5b= \ud835\udc39 \ud835\udc5b+1 \u2217\ud835\udc39 \ud835\udc5b\u22121 \u2212\ud835\udc39 \ud835\udc5b 2.  \u0218tim c\u0103 \ud835\udc40\ud835\udc5a\u2217\ud835\udc40\ud835\udc5b= \ud835\udc40\ud835\udc5a+\ud835\udc5b, pentru orice matrice \ud835\udc40 p\u0103tratic\u0103.  A\u0219adar (\u22121)\ud835\udc5a= \ud835\udc39 \ud835\udc5a+1 \u2217\ud835\udc39 \ud835\udc5a\u22121 \u2212\ud835\udc39 \ud835\udc5a 2.  \ud835\udc40\ud835\udc5a= (\ud835\udc39 \ud835\udc5a+1 \ud835\udc39 \ud835\udc5a \ud835\udc39 \ud835\udc5a \ud835\udc39 \ud835\udc5a\u22121)  \ud835\udc40\ud835\udc5b= (\ud835\udc39 \ud835\udc5b+1 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b\u22121)", "sentences": ["304    8.", " R\u0103spuns corect: e) nedefinit\u0103  Indica\u021bii: Este o variabil\u0103 local\u0103 neini\u0163ializat\u0103.", " 9.", " R\u0103spuns corect: b) 190    Indica\u021bii: \u00cen total sunt 400 de elemente, 20 sunt pe diagonala secundar\u0103.", "  10.", "R\u0103spuns corect: d) 1023      EXEMPLU: Fie cele 3 tije a, b \u0219i c. Se mut\u0103 discurile de pe tija a pe tija b, utiliz\u00e2nd ca  tij\u0103 intermediar\u0103 tija c. Pentru k=3 discuri se fac 7 mut\u0103ri: a\uf0e0b, a\uf0e0c, b\uf0e0c, a\uf0e0b,  c\uf0e0a, c\uf0e0b, a\uf0e0b.", "  Indica\u021bii: Pentru k discuri este necesar un num\u0103r de 2k-1 mut\u0103ri.", " 11.", "R\u0103spuns corect: c) 8     Indica\u021bii: Graful nu con\u021bine bucle.", "Fiecare v\u00e2rf este adiacent cu toate celelalte v\u00e2rfuri.", " Dac\u0103 graful are n v\u00e2rfuri exist\u0103 n(n-1) arce.", "56=n(n-1), n=8.", "  12.", "R\u0103spuns corect: f) Doi dintre algoritmi nu difer\u0103 ca eficien\u021b\u0103 din punctul de vedere al  timpului de executare.", "     Indica\u021bii:   a) Algoritmii A1 \u0219i A2 rezolv\u0103 problema pentru orice date de intrare cu valorile din  interval.", "  b) Algoritmul A2 este cel mai eficient din punctul de vedere al timpului de executare.", "Are  complexitatea O(n) pentru parcurgerea \u0219irului \u0219i determinarea sumei.", " c) Algoritmul A4 are complexitate dat\u0103 de o sortare rapid\u0103, O(n log n).", " d) Algoritmul A4 rezolv\u0103 problema.", " e) Algoritmii rezolv\u0103 problema pentru orice date de intrare cu valorile din interval.", " f) A3 \u0219i A4 au aceea\u0219i eficien\u021b\u0103, complexitate dat\u0103 de o sortare rapid\u0103, O(n log n).", " Observa\u021bie: Exist\u0103 algoritmi care rezolv\u0103 aceast\u0103 problem\u0103 \u00eentr-un timp mai scurt  (folosind opera\u021bii pe bi\u021bi).", " 13.", "R\u0103spuns corect: f) E1, E2 \u0219i E3      14.", "R\u0103spuns corect: c)  5040      EXEMPLU: Anagramele (nu neap\u0103rat \u00een aceast\u0103 ordine) sunt: aaccerrt, aaccertr,  aaccetrr, ..., rtreccaa, trreccaa.", "\u00cen total 5040.", "  Indica\u021bii: Litera a apare de dou\u0103 ori, litera c apare de dou\u0103 ori, litera e apare o dat\u0103, litera  r apare de dou\u0103 ori, litera t apare o dat\u0103; permut\u0103rile sunt cu repeti\u021bie.", " Num\u0103rul permut\u0103rilor este: 8!/(2!\u00b72!\u00b71!\u00b72!\u00b71!)", " 15.", "R\u0103spuns corect: b) doar formula 1     Indica\u021bii:   Formula 1 poate fi ob\u021binut\u0103 din ecua\u021bia  (1 1 1 0) \ud835\udc5b = (\ud835\udc39 \ud835\udc5b+1 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b\u22121)  Clacul\u0103m determinantul: (\u22121)\ud835\udc5b= \ud835\udc39 \ud835\udc5b+1 \u2217\ud835\udc39 \ud835\udc5b\u22121 \u2212\ud835\udc39 \ud835\udc5b 2.", " \u0218tim c\u0103 \ud835\udc40\ud835\udc5a\u2217\ud835\udc40\ud835\udc5b= \ud835\udc40\ud835\udc5a+\ud835\udc5b, pentru orice matrice \ud835\udc40 p\u0103tratic\u0103.", " A\u0219adar (\u22121)\ud835\udc5a= \ud835\udc39 \ud835\udc5a+1 \u2217\ud835\udc39 \ud835\udc5a\u22121 \u2212\ud835\udc39 \ud835\udc5a 2.", " \ud835\udc40\ud835\udc5a= (\ud835\udc39 \ud835\udc5a+1 \ud835\udc39 \ud835\udc5a \ud835\udc39 \ud835\udc5a \ud835\udc39 \ud835\udc5a\u22121)  \ud835\udc40\ud835\udc5b= (\ud835\udc39 \ud835\udc5b+1 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b\u22121)"], "page_sentence_count_spacy": 33}, {"page_number": 305, "page_char_count": 885, "page_word_count": 306, "page_sentence_count_raw": 5, "page_token_count": 221.25, "text": "305    \ud835\udc40\ud835\udc5a+\ud835\udc5b= (\ud835\udc39 \ud835\udc5a+\ud835\udc5b+1 \ud835\udc39 \ud835\udc5a+\ud835\udc5b \ud835\udc39 \ud835\udc5a+\ud835\udc5b \ud835\udc39 \ud835\udc5a+\ud835\udc5b\u22121)    \ud835\udc40\ud835\udc5a\u00b7 \ud835\udc40\ud835\udc5a= (\ud835\udc39 \ud835\udc5a+1 \ud835\udc39 \ud835\udc5a \ud835\udc39 \ud835\udc5a \ud835\udc39 \ud835\udc5a\u22121) \u00b7 (\ud835\udc39 \ud835\udc5b+1 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b\u22121) = = (\ud835\udc39 \ud835\udc5a+1 \u00b7 \ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5a+1 \u00b7 \ud835\udc39 \ud835\udc5b+ \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b\u22121 \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5a\u22121 \u00b7 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b+ \ud835\udc39 \ud835\udc5a\u22121 \u00b7 \ud835\udc39 \ud835\udc5b\u22121) = \ud835\udc40\ud835\udc5a+\ud835\udc5b= = (\ud835\udc39 \ud835\udc5a+\ud835\udc5b+1 \ud835\udc39 \ud835\udc5a+\ud835\udc5b \ud835\udc39 \ud835\udc5a+\ud835\udc5b \ud835\udc39 \ud835\udc5a+\ud835\udc5b\u22121)  Identific\u0103m:  \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5a\u22121 \u00b7 \ud835\udc39 \ud835\udc5b= \ud835\udc39 \ud835\udc5a+\ud835\udc5b       (\ud835\udc4e)  \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b+ \ud835\udc39 \ud835\udc5a\u22121 \u00b7 \ud835\udc39 \ud835\udc5b\u22121 = \ud835\udc39 \ud835\udc5a+\ud835\udc5b\u22121   (\ud835\udc4f)  Punem \ud835\udc5a= \ud835\udc5b  \ud835\udc39 \ud835\udc5b\u00b7 \ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5b\u22121 \u00b7 \ud835\udc39 \ud835\udc5b= \ud835\udc39 2\ud835\udc5b       (\ud835\udc4e)  \ud835\udc39 \ud835\udc5b 2 + \ud835\udc39 \ud835\udc5b\u22121 2 = \ud835\udc39 2\ud835\udc5b\u22121                      (\ud835\udc4f)  Din rela\u021bia (\ud835\udc4e) rezult\u0103  \ud835\udc39 2\ud835\udc5b= \ud835\udc39 \ud835\udc5b\u00b7 (\ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5b\u22121) = \ud835\udc39 \ud835\udc5b\u00b7 (\ud835\udc39 \ud835\udc5b\u22121 + \ud835\udc39 \ud835\udc5b+ \ud835\udc39 \ud835\udc5b\u22121) = \ud835\udc39 \ud835\udc5b\u00b7 (2 \u00b7 \ud835\udc39 \ud835\udc5b\u22121 + \ud835\udc39 \ud835\udc5b).  A\u0219adar:  Dac\u0103 n este par, \u00eenjum\u0103t\u0103\u021bindu-l, rezult\u0103:  \ud835\udc39(\ud835\udc5b) = \ud835\udc39(\ud835\udc5b 2) \u00b7 [2 \u00b7 \ud835\udc39(\ud835\udc5b 2 \u22121) + \ud835\udc39(\ud835\udc5b 2)].  Dac\u0103 n este impar, din (\ud835\udc4f) , rezult\u0103:  \ud835\udc39(\ud835\udc5b) = [\ud835\udc39( \ud835\udc5b+ 1 2 )] 2 + [\ud835\udc39( \ud835\udc5b\u22121 2 )] 2 .  Termeni, conform formulelor, sunt:  1, 1, 2, 3, 5, 8, ...  Referitor la formulele 2 \u0219i 3, corect este:  \ud835\udc39(\ud835\udc5b) = 1 \u221a5 \u00b7 ( 1+\u221a5 2 ) \ud835\udc5b \u2212 1 \u221a5 \u00b7 ( 1\u2212\u221a5 2 ) \ud835\udc5b", "sentences": ["305    \ud835\udc40\ud835\udc5a+\ud835\udc5b= (\ud835\udc39 \ud835\udc5a+\ud835\udc5b+1 \ud835\udc39 \ud835\udc5a+\ud835\udc5b \ud835\udc39 \ud835\udc5a+\ud835\udc5b \ud835\udc39 \ud835\udc5a+\ud835\udc5b\u22121)    \ud835\udc40\ud835\udc5a\u00b7 \ud835\udc40\ud835\udc5a= (\ud835\udc39 \ud835\udc5a+1 \ud835\udc39 \ud835\udc5a \ud835\udc39 \ud835\udc5a \ud835\udc39 \ud835\udc5a\u22121) \u00b7 (\ud835\udc39 \ud835\udc5b+1 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5b\u22121) = = (\ud835\udc39 \ud835\udc5a+1 \u00b7 \ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5a+1 \u00b7 \ud835\udc39 \ud835\udc5b+ \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b\u22121 \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5a\u22121 \u00b7 \ud835\udc39 \ud835\udc5b \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b+ \ud835\udc39 \ud835\udc5a\u22121 \u00b7 \ud835\udc39 \ud835\udc5b\u22121) = \ud835\udc40\ud835\udc5a+\ud835\udc5b= = (\ud835\udc39 \ud835\udc5a+\ud835\udc5b+1 \ud835\udc39 \ud835\udc5a+\ud835\udc5b \ud835\udc39 \ud835\udc5a+\ud835\udc5b \ud835\udc39 \ud835\udc5a+\ud835\udc5b\u22121)  Identific\u0103m:  \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5a\u22121 \u00b7 \ud835\udc39 \ud835\udc5b= \ud835\udc39 \ud835\udc5a+\ud835\udc5b       (\ud835\udc4e)  \ud835\udc39 \ud835\udc5a\u00b7 \ud835\udc39 \ud835\udc5b+ \ud835\udc39 \ud835\udc5a\u22121 \u00b7 \ud835\udc39 \ud835\udc5b\u22121 = \ud835\udc39 \ud835\udc5a+\ud835\udc5b\u22121   (\ud835\udc4f)  Punem \ud835\udc5a= \ud835\udc5b  \ud835\udc39 \ud835\udc5b\u00b7 \ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5b\u22121 \u00b7 \ud835\udc39 \ud835\udc5b= \ud835\udc39 2\ud835\udc5b       (\ud835\udc4e)  \ud835\udc39 \ud835\udc5b 2 + \ud835\udc39 \ud835\udc5b\u22121 2 = \ud835\udc39 2\ud835\udc5b\u22121                      (\ud835\udc4f)  Din rela\u021bia (\ud835\udc4e) rezult\u0103  \ud835\udc39 2\ud835\udc5b= \ud835\udc39 \ud835\udc5b\u00b7 (\ud835\udc39 \ud835\udc5b+1 + \ud835\udc39 \ud835\udc5b\u22121) = \ud835\udc39 \ud835\udc5b\u00b7 (\ud835\udc39 \ud835\udc5b\u22121 + \ud835\udc39 \ud835\udc5b+ \ud835\udc39 \ud835\udc5b\u22121) = \ud835\udc39 \ud835\udc5b\u00b7 (2 \u00b7 \ud835\udc39 \ud835\udc5b\u22121 + \ud835\udc39 \ud835\udc5b).", " A\u0219adar:  Dac\u0103 n este par, \u00eenjum\u0103t\u0103\u021bindu-l, rezult\u0103:  \ud835\udc39(\ud835\udc5b) = \ud835\udc39(\ud835\udc5b 2) \u00b7 [2 \u00b7 \ud835\udc39(\ud835\udc5b 2 \u22121) + \ud835\udc39(\ud835\udc5b 2)].", " Dac\u0103 n este impar, din (\ud835\udc4f) , rezult\u0103:  \ud835\udc39(\ud835\udc5b) = [\ud835\udc39( \ud835\udc5b+ 1 2 )] 2 + [\ud835\udc39( \ud835\udc5b\u22121 2 )] 2 .", " Termeni, conform formulelor, sunt:  1, 1, 2, 3, 5, 8, ...  Referitor la formulele 2 \u0219i 3, corect este:  \ud835\udc39(\ud835\udc5b) = 1 \u221a5 \u00b7 ( 1+\u221a5 2 ) \ud835\udc5b \u2212 1 \u221a5 \u00b7 ( 1\u2212\u221a5 2 ) \ud835\udc5b"], "page_sentence_count_spacy": 4}, {"page_number": 306, "page_char_count": 2301, "page_word_count": 453, "page_sentence_count_raw": 31, "page_token_count": 575.25, "text": "306    Varianta 30  Indica\u021bii \u0219i r\u0103spunsuri    1.  R\u0103spuns corect: c) n/2     EXEMPLU: Pentru n=8 \u0219i tabloul unidimensional (4 2 3 1 9 6 8 5) se ob\u021bine  tabloul (5 8 6 9 1 3 2 4).  Indica\u021bii: Se interschimb\u0103 4 cu 5, 2 cu 8, 3 cu 6 \u0219i 1 cu 9, 4 interschimb\u0103ri, adic\u0103 se fac   n/2 interschimb\u0103ri.  2.  R\u0103spuns corect: d) 0 elemente     Indica\u021bii: Nu este nevoie de spa\u021biu de memorie suplimentar.  3.  R\u0103spuns corect: f) 0   Indica\u021bii: Nu exist\u0103 nicio solu\u021bie pentru 3 dame.  4.  R\u0103spuns corect: b) 3 5     Indica\u021bii: Matricea de adiacen\u021b\u0103 are num\u0103rul de linii egal cu num\u0103rul de coloane.  5.  R\u0103spuns corect: e) dc(x,y)=dc(y,x mod y)     EXEMPLU: pentru x=6 \u0219i y=8   a) dc(6,8)\u2260dc(48,8)  b) dc(6,8)\u2260dc(6,6)  c) dc(6,8)=dc(8,48)=dc(48,384)=...  d) dc(6,8)\u2260dc(6,6)  f) dc(6,8)\u2260dc(0,0)  Indica\u021bii: Formula pentru a calcula cel mai mare divizor comun folosind algoritmul lui  Euclid este dc(x,y)=dc(y,x mod y). Se folose\u0219te recursiv p\u00e2n\u0103 se ob\u021bine restul 0.  6.  R\u0103spuns corect: b) 2 subtablouri, nu \u00eentotdeauna cu acela\u0219i num\u0103r de elemente. \u00cen partea  st\u00e2ng\u0103 se vor g\u0103si elementele mai mici dec\u00e2t pivotul, \u00een partea dreapt\u0103 se vor g\u0103si  elementele mai mari dec\u00e2t pivotul, elementele egale cu pivotul pot r\u0103m\u00e2ne \u00een oricare parte  a pivotului. Rezult\u0103 c\u0103 cele dou\u0103 p\u0103r\u021bi nu au \u00eentotdeauna acela\u0219i num\u0103r de elemente.  7.  R\u0103spuns corect: e) stiv\u0103     EXEMPLU: Se creeaz\u0103 o stiv\u0103, opera\u021bia de ad\u0103ugare numit\u0103 push(), memor\u00e2nd \u0219irul de la  primul caracter p\u00e2n\u0103 la ultimul. Astfel fiecare caracter al \u0219irului va fi, pe r\u00e2nd, \u00een v\u00e2rful  stivei. Extragerea se face din v\u00e2rful stivei, elimin\u00e2nd, pe r\u00e2nd, primul element, folosind  opera\u021bia numit\u0103 pop().  Indica\u021bii: Stiva corespunde principiului LIFO (Last In First Out).  8.  R\u0103spuns corect: d) f(n/2);(respectiv f(n div 2))  Indica\u021bii:   a) f(n-2) subprogramul nu se \u00eencheie pentru valori impare ale lui n.   b) f(n-1) subprogramul nu se \u00eencheie pentru valori negative ale lui n.  c) f(n%2) (respectiv f(n mod 2) ) subprogramul nu se \u00eencheie pentru valori impare  ale lui n.  e) f(n+2) subprogramul nu se \u00eencheie pentru valori ale lui n diferite de -2 \u0219i 0.  f) f(n*2) subprogramul nu se \u00eencheie pentru valori nenule ale lui n.  9.  R\u0103spuns corect: e) 4     Indica\u021bii: Un apel f(1) are rezultatul 2, cel\u0103lalt apel f(1) are rezultatul 2  10.  R\u0103spuns corect: d) 28", "sentences": ["306    Varianta 30  Indica\u021bii \u0219i r\u0103spunsuri    1.", " R\u0103spuns corect: c) n/2     EXEMPLU: Pentru n=8 \u0219i tabloul unidimensional (4 2 3 1 9 6 8 5) se ob\u021bine  tabloul (5 8 6 9 1 3 2 4).", " Indica\u021bii: Se interschimb\u0103 4 cu 5, 2 cu 8, 3 cu 6 \u0219i 1 cu 9, 4 interschimb\u0103ri, adic\u0103 se fac   n/2 interschimb\u0103ri.", " 2.", " R\u0103spuns corect: d) 0 elemente     Indica\u021bii: Nu este nevoie de spa\u021biu de memorie suplimentar.", " 3.", " R\u0103spuns corect: f) 0   Indica\u021bii: Nu exist\u0103 nicio solu\u021bie pentru 3 dame.", " 4.", " R\u0103spuns corect: b) 3 5     Indica\u021bii: Matricea de adiacen\u021b\u0103 are num\u0103rul de linii egal cu num\u0103rul de coloane.", " 5.", " R\u0103spuns corect: e) dc(x,y)=dc(y,x mod y)     EXEMPLU: pentru x=6 \u0219i y=8   a) dc(6,8)\u2260dc(48,8)  b) dc(6,8)\u2260dc(6,6)  c) dc(6,8)=dc(8,48)=dc(48,384)=...  d) dc(6,8)\u2260dc(6,6)  f) dc(6,8)\u2260dc(0,0)  Indica\u021bii: Formula pentru a calcula cel mai mare divizor comun folosind algoritmul lui  Euclid este dc(x,y)=dc(y,x mod y).", "Se folose\u0219te recursiv p\u00e2n\u0103 se ob\u021bine restul 0.", " 6.", " R\u0103spuns corect: b) 2 subtablouri, nu \u00eentotdeauna cu acela\u0219i num\u0103r de elemente.", "\u00cen partea  st\u00e2ng\u0103 se vor g\u0103si elementele mai mici dec\u00e2t pivotul, \u00een partea dreapt\u0103 se vor g\u0103si  elementele mai mari dec\u00e2t pivotul, elementele egale cu pivotul pot r\u0103m\u00e2ne \u00een oricare parte  a pivotului.", "Rezult\u0103 c\u0103 cele dou\u0103 p\u0103r\u021bi nu au \u00eentotdeauna acela\u0219i num\u0103r de elemente.", " 7.", " R\u0103spuns corect: e) stiv\u0103     EXEMPLU: Se creeaz\u0103 o stiv\u0103, opera\u021bia de ad\u0103ugare numit\u0103 push(), memor\u00e2nd \u0219irul de la  primul caracter p\u00e2n\u0103 la ultimul.", "Astfel fiecare caracter al \u0219irului va fi, pe r\u00e2nd, \u00een v\u00e2rful  stivei.", "Extragerea se face din v\u00e2rful stivei, elimin\u00e2nd, pe r\u00e2nd, primul element, folosind  opera\u021bia numit\u0103 pop().", " Indica\u021bii: Stiva corespunde principiului LIFO (Last In First Out).", " 8.", " R\u0103spuns corect: d) f(n/2);(respectiv f(n div 2))  Indica\u021bii:   a) f(n-2) subprogramul nu se \u00eencheie pentru valori impare ale lui n.   b) f(n-1) subprogramul nu se \u00eencheie pentru valori negative ale lui n.  c) f(n%2) (respectiv f(n mod 2) ) subprogramul nu se \u00eencheie pentru valori impare  ale lui n.  e) f(n+2) subprogramul nu se \u00eencheie pentru valori ale lui n diferite de -2 \u0219i 0.", " f) f(n*2) subprogramul nu se \u00eencheie pentru valori nenule ale lui n.  9.", " R\u0103spuns corect: e) 4     Indica\u021bii: Un apel f(1) are rezultatul 2, cel\u0103lalt apel f(1) are rezultatul 2  10.", " R\u0103spuns corect: d) 28"], "page_sentence_count_spacy": 26}, {"page_number": 307, "page_char_count": 2392, "page_word_count": 557, "page_sentence_count_raw": 35, "page_token_count": 598.0, "text": "307    Indica\u021bii: Folosim principiul includerii-excluderii. Consider\u0103m mul\u021bimea M={101, 102,  \u2026, 200}. Lu\u0103m alte trei submul\u021bimi A, B, C care au ca elemente cele aflate \u00een M divizibile  cu 2, 3, respectiv 5. Determin\u0103m elementele comune mul\u021bimilor A \u0219i B, A \u0219i C, B \u0219i C, apoi  comune mul\u021bimilor A, B \u0219i C.  EXEMPLU: Pentru valorile date avem: cardM=100. cardA=50. cardB=33. cardC=20.  card(AB)=17. card(AC)=10. card(BC)=7. card(ABC)=3.   cardM-cardA-cardB-cardC+card(AB)+card(AC)+card(BC)-card(ABC)  =  100-50-33- 20+17+10+7-3 = 28.  11.  R\u0103spuns corect: a) xx     Indica\u021bii: Dac\u0103 programul genereaz\u0103 permut\u0103ri de elemente care se repet\u0103 atunci cele dou\u0103  caractere x nu sunt diferite; se formeaz\u0103 o singur\u0103 permutare.  12.  R\u0103spuns corect: d) 3     Indica\u021bii: sunt adev\u0103rate enun\u021burile 2, 3 \u0219i 5.   Enun\u021bul 1: se genereaz\u0103 28 de numere cu prima cifr\u0103 2.  Enun\u021bul 2:  12457, 12459, 12479, 12679, 14679, 34679.  Enun\u021bul 3: 13679 sau 24568.  Enun\u021bul 4, un num\u0103r corect este 12789.   Enun\u021bul 5: cifra 1 apare de 50 de ori pe prima pozi\u021bie, cifra 9 apare de 50 de ori pe ultima  pozi\u021bie.  13.  R\u0103spuns corect: d) (n-1)!/2     Indica\u021bii: \u00cen graful neorientat complet orice permutare a celor n noduri este un ciclu  hamiltonian. Un acela\u0219i ciclu, ca permutare circular\u0103, se parcurge \u00een 2\u00b7n moduri. Se  porne\u0219te de la un nod \u00een sensul acelor de ceasornic, dar \u0219i \u00een sens trigonometric.  Exemplu: pentru n=4,   Cicluri identice:   (1 2 3 4 1), (1 4 3 2 1), (2 3 4 1 2), (2 1 4 3 2), (3 4 1 2 3), (3 2 1  4 3), (4 1 2 3 4), (4 3 2 1 4);   (1 3 4 2 1),( 1 2 4 3 1), (2 4 3 1 2), (2 1 3 4 2), (3 4 2 1 3), (3 1 2  4 3), (4 2 1 3 4), (4 3 1 2 4);  (1 4 2 3 1), (1 3 2 4 1), (2 4 1 3 2), (2 3 1 4 2), (3 1 4 2 3), (3 2 4  1 3), (4 1 3 2 4), (4 2 3 1 4).  \u00cen total avem 3 cicluri distincte hamiltoniene.   \u00cen general exist\u0103 n!/(2\u00b7n)=(n-1)!/2 cicluri hamiltoniene distincte.   14.  R\u0103spuns corect: b) 5    Indica\u021bii:  Num\u0103rul  de  grafuri  orientate  complete  cu n noduri  este   \ud835\udfd1\ud835\udc02\ud835\udc27 \ud835\udfd0, adic\u0103 3n(n-1)/2.  3n(n-1)/2=59049, 3n(n-1)/2=310, n=5.  15.  R\u0103spuns corect: c) doar  rela\u021biile \ud835\udc381 \u0219i \ud835\udc382    Indica\u021bii:   \ud835\udc381: Se poate observa c\u0103 fiecare al treilea termen din \u0219irul lui Fibonacci este par.  \ud835\udc382: \ud835\udc39 \ud835\udc5b= \ud835\udc39 \ud835\udc5b\u22121 + \ud835\udc39 \ud835\udc5b\u22122 = (\ud835\udc39 \ud835\udc5b\u22122 + \ud835\udc39 \ud835\udc5b\u22123) + (\ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22124) = \ud835\udc39 \ud835\udc5b\u22122 + 2 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + +\ud835\udc39 \ud835\udc5b\u22124 = (\ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22124) + 2 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22124 = 3 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22124 + (\ud835\udc39 \ud835\udc5b\u22125 + \ud835\udc39 \ud835\udc5b\u22126) = 3 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22126 = 4 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22126.", "sentences": ["307    Indica\u021bii: Folosim principiul includerii-excluderii.", "Consider\u0103m mul\u021bimea M={101, 102,  \u2026, 200}.", "Lu\u0103m alte trei submul\u021bimi A, B, C care au ca elemente cele aflate \u00een M divizibile  cu 2, 3, respectiv 5.", "Determin\u0103m elementele comune mul\u021bimilor A \u0219i B, A \u0219i C, B \u0219i C, apoi  comune mul\u021bimilor A, B \u0219i C.  EXEMPLU: Pentru valorile date avem: cardM=100.", "cardA=50.", "cardB=33.", "cardC=20.", " card(AB)=17.", "card(AC)=10.", "card(BC)=7.", "card(ABC)=3.", "  cardM-cardA-cardB-cardC+card(AB)+card(AC)+card(BC)-card(ABC)  =  100-50-33- 20+17+10+7-3 = 28.", " 11.", " R\u0103spuns corect: a) xx     Indica\u021bii: Dac\u0103 programul genereaz\u0103 permut\u0103ri de elemente care se repet\u0103 atunci cele dou\u0103  caractere x nu sunt diferite; se formeaz\u0103 o singur\u0103 permutare.", " 12.", " R\u0103spuns corect: d) 3     Indica\u021bii: sunt adev\u0103rate enun\u021burile 2, 3 \u0219i 5.", "  Enun\u021bul 1: se genereaz\u0103 28 de numere cu prima cifr\u0103 2.", " Enun\u021bul 2:  12457, 12459, 12479, 12679, 14679, 34679.", " Enun\u021bul 3: 13679 sau 24568.", " Enun\u021bul 4, un num\u0103r corect este 12789.", "  Enun\u021bul 5: cifra 1 apare de 50 de ori pe prima pozi\u021bie, cifra 9 apare de 50 de ori pe ultima  pozi\u021bie.", " 13.", " R\u0103spuns corect: d) (n-1)!/2     Indica\u021bii: \u00cen graful neorientat complet orice permutare a celor n noduri este un ciclu  hamiltonian.", "Un acela\u0219i ciclu, ca permutare circular\u0103, se parcurge \u00een 2\u00b7n moduri.", "Se  porne\u0219te de la un nod \u00een sensul acelor de ceasornic, dar \u0219i \u00een sens trigonometric.", " Exemplu: pentru n=4,   Cicluri identice:   (1 2 3 4 1), (1 4 3 2 1), (2 3 4 1 2), (2 1 4 3 2), (3 4 1 2 3), (3 2 1  4 3), (4 1 2 3 4), (4 3 2 1 4);   (1 3 4 2 1),( 1 2 4 3 1), (2 4 3 1 2), (2 1 3 4 2), (3 4 2 1 3), (3 1 2  4 3), (4 2 1 3 4), (4 3 1 2 4);  (1 4 2 3 1), (1 3 2 4 1), (2 4 1 3 2), (2 3 1 4 2), (3 1 4 2 3), (3 2 4  1 3), (4 1 3 2 4), (4 2 3 1 4).", " \u00cen total avem 3 cicluri distincte hamiltoniene.", "  \u00cen general exist\u0103 n!/(2\u00b7n)=(n-1)!/2 cicluri hamiltoniene distincte.", "  14.", " R\u0103spuns corect: b) 5    Indica\u021bii:  Num\u0103rul  de  grafuri  orientate  complete  cu n noduri  este   \ud835\udfd1\ud835\udc02\ud835\udc27 \ud835\udfd0, adic\u0103 3n(n-1)/2.", " 3n(n-1)/2=59049, 3n(n-1)/2=310, n=5.", " 15.", " R\u0103spuns corect: c) doar  rela\u021biile \ud835\udc381 \u0219i \ud835\udc382    Indica\u021bii:   \ud835\udc381: Se poate observa c\u0103 fiecare al treilea termen din \u0219irul lui Fibonacci este par.", " \ud835\udc382: \ud835\udc39 \ud835\udc5b= \ud835\udc39 \ud835\udc5b\u22121 + \ud835\udc39 \ud835\udc5b\u22122 = (\ud835\udc39 \ud835\udc5b\u22122 + \ud835\udc39 \ud835\udc5b\u22123) + (\ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22124) = \ud835\udc39 \ud835\udc5b\u22122 + 2 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + +\ud835\udc39 \ud835\udc5b\u22124 = (\ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22124) + 2 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22124 = 3 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22124 + (\ud835\udc39 \ud835\udc5b\u22125 + \ud835\udc39 \ud835\udc5b\u22126) = 3 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22126 = 4 \u00b7 \ud835\udc39 \ud835\udc5b\u22123 + \ud835\udc39 \ud835\udc5b\u22126."], "page_sentence_count_spacy": 34}, {"page_number": 308, "page_char_count": 306, "page_word_count": 74, "page_sentence_count_raw": 3, "page_token_count": 76.5, "text": "308    A\u0219adar, cum fiecare al treilea termen din \u0219irul lui Fibonacci este par, atunci \ud835\udc39 \ud835\udc5b\u22123 \u0219i \ud835\udc39 \ud835\udc5b\u22126  sunt ambii pari. Not\u0103m \ud835\udc39 \ud835\udc5b cu \ud835\udc39 \ud835\udc5d(\ud835\udc5b), rezult\u0103 c\u0103 \ud835\udc39 \ud835\udc5b\u22123 este termenul par precedent, adic\u0103  \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22121), iar \ud835\udc39 \ud835\udc5b\u22126 este \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22122).   \u00censeamn\u0103 c\u0103 \ud835\udc39 \ud835\udc5d(\ud835\udc5b) = 4 \u00b7 \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22121) + \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22122), \ud835\udc5b\u22652, \ud835\udc39 \ud835\udc5d(0) = 0 \u0219i \ud835\udc39 \ud835\udc5d(1) = 2.", "sentences": ["308    A\u0219adar, cum fiecare al treilea termen din \u0219irul lui Fibonacci este par, atunci \ud835\udc39 \ud835\udc5b\u22123 \u0219i \ud835\udc39 \ud835\udc5b\u22126  sunt ambii pari.", "Not\u0103m \ud835\udc39 \ud835\udc5b cu \ud835\udc39 \ud835\udc5d(\ud835\udc5b), rezult\u0103 c\u0103 \ud835\udc39 \ud835\udc5b\u22123 este termenul par precedent, adic\u0103  \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22121), iar \ud835\udc39 \ud835\udc5b\u22126 este \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22122).", "  \u00censeamn\u0103 c\u0103 \ud835\udc39 \ud835\udc5d(\ud835\udc5b) = 4 \u00b7 \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22121) + \ud835\udc39 \ud835\udc5d(\ud835\udc5b\u22122), \ud835\udc5b\u22652, \ud835\udc39 \ud835\udc5d(0) = 0 \u0219i \ud835\udc39 \ud835\udc5d(1) = 2."], "page_sentence_count_spacy": 3}, {"page_number": 309, "page_char_count": 2603, "page_word_count": 526, "page_sentence_count_raw": 34, "page_token_count": 650.75, "text": "309    Varianta 31  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: d) 2024  Indica\u021bii: Expresia are valoare maxim\u0103 dac\u0103 n=8080 deoarece 8080 este cel mai mare  num\u0103r natural de patru cifre multiplu de 2020.  2020 \u2013 n%2020 + n/2020= 2020-0+4=2024  2.  R\u0103spuns corect: a) 234    Indica\u021bii: Nu c\u0103ut\u0103m dec\u00e2t cazurile c\u00e2nd y=2. Pentru x=0 \u0219i y=2 se afi\u0219eaz\u0103 2; pentru  x=1 \u0219i y=2 se afi\u0219eaz\u0103 3; pentru x=2 \u0219i y=2 se afi\u0219eaz\u0103 4.  3.  R\u0103spuns corect: f) 42  Indica\u021bii: Se observ\u0103 c\u0103 toate elementele situate pe linia 2 sunt egale cu 1 \u0219i toate  elementele situate pe linia 4 sunt egale cu 3.  Suma elementelor situate pe linia 3 este 6  \u0219i suma elementelor situate pe linia 5 este 12. \u00cen rest, elementele din tabloul  bidimensional au valoarea 0.  1*6 + 3*6 + 2*3 + 4*3 = 42  4.  R\u0103spuns corect: a)  AUTONATICA  Indica\u021bii: Se elimin\u0103 a doua liter\u0103 O din BUTONOMATICA,  apoi se \u00eenlocuie\u0219te litera B  cu litera A, apoi se elimin\u0103 litera M.   5.  R\u0103spuns corect: b)  Limbajul C++/C (I.b<=J.a) || (J.b<=I.a)                Limbajul Pascal (I.b<=J.a) or (J.b<=I.a)  Indica\u021bii: Sunt dou\u0103 cazuri c\u00e2nd  I \u0219i J nu se intersecteaz\u0103: fie c\u00e2nd extremitatea dreapt\u0103  a lui I este mai mic\u0103 sau egal\u0103 cu extremitatea st\u00e2ng\u0103 a lui J, fie c\u00e2nd extremitatea  dreapt\u0103 a lui J este mai mic\u0103 sau egal\u0103 cu extremitatea st\u00e2ng\u0103 a lui  I.  6.  R\u0103spuns corect: b) 12  Indica\u021bii: Numerele c\u0103utate sunt pare deci au pe ultimele dou\u0103 pozi\u021bii 00, 02, 10,  12, 20, 22. Cifra sutelor poate s\u0103 fie 1 sau 2 pentru c\u0103 numerele sunt naturale \u0219i au  exact 3 cifre. Deci sunt 2*6=12 numere.  7.  R\u0103spuns corect: c) 3080  Indica\u021bii: Pentru rapiditate se poate utiliza formula n(n+1)(n+2)/3, unde n=20.  Deci 20*21*22/3=3080.  8.  R\u0103spuns corect: b) (16,9,7,5,4,3,2,1,0)  Indica\u021bii:  Primele 5 numere naturale p\u0103trate perfecte: 0, 1, 4, 9, 16. Sortate descresc\u0103tor  ajung: 16, 9, 4, 1, 0.  Primele 4 numere naturale prime:  2, 3, 5, 7. Sortate descresc\u0103tor ajung: 7, 5, 3, 2.  Dup\u0103 interclasare, C are 9 elemente \u0219i urm\u0103torul con\u021binut: (16, 9, 7, 5, 4, 3, 2, 1, 0).  9.  R\u0103spuns corect: a) 19 20 20  Indica\u021bii: Numai c \u00ee\u0219i schimb\u0103 valoarea.   10.  R\u0103spuns corect: c) 514  Indica\u021bii: Toate nodurile de la 1 \u0219i p\u00e2n\u0103 la 512 au c\u00e2te doi descenden\u021bi direc\u021bi(fii). Nodul  513 are un singur fiu: 1026; toate nodurile de la 514 \u0219i p\u00e2n\u0103 la 1026 sunt frunze.  1026-512=514  11.  R\u0103spuns corect: c) 9  Indica\u021bii: O solu\u021bie mai rapid\u0103 se bazeaz\u0103 pe calculul invers: se scad cele \u0219ase subgrafuri  care au mul\u021bimea muchiilor nevid\u0103 din 15 (num\u0103rul total de subgrafuri ale grafului  neorientat cu 4 noduri,  24-1=15). Subgrafurile cu dou\u0103 muchii au mul\u021bimea nodurilor", "sentences": ["309    Varianta 31  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: d) 2024  Indica\u021bii: Expresia are valoare maxim\u0103 dac\u0103 n=8080 deoarece 8080 este cel mai mare  num\u0103r natural de patru cifre multiplu de 2020.", " 2020 \u2013 n%2020 + n/2020= 2020-0+4=2024  2.", " R\u0103spuns corect: a) 234    Indica\u021bii: Nu c\u0103ut\u0103m dec\u00e2t cazurile c\u00e2nd y=2.", "Pentru x=0 \u0219i y=2 se afi\u0219eaz\u0103 2; pentru  x=1 \u0219i y=2 se afi\u0219eaz\u0103 3; pentru x=2 \u0219i y=2 se afi\u0219eaz\u0103 4.", " 3.", " R\u0103spuns corect: f) 42  Indica\u021bii: Se observ\u0103 c\u0103 toate elementele situate pe linia 2 sunt egale cu 1 \u0219i toate  elementele situate pe linia 4 sunt egale cu 3.", " Suma elementelor situate pe linia 3 este 6  \u0219i suma elementelor situate pe linia 5 este 12.", "\u00cen rest, elementele din tabloul  bidimensional au valoarea 0.", " 1*6 + 3*6 + 2*3 + 4*3 = 42  4.", " R\u0103spuns corect: a)  AUTONATICA  Indica\u021bii: Se elimin\u0103 a doua liter\u0103 O din BUTONOMATICA,  apoi se \u00eenlocuie\u0219te litera B  cu litera A, apoi se elimin\u0103 litera M.   5.", " R\u0103spuns corect: b)  Limbajul C++/C (I.b<=J.a) || (J.b<=I.a)                Limbajul Pascal (I.b<=J.a) or (J.b<=I.a)  Indica\u021bii: Sunt dou\u0103 cazuri c\u00e2nd  I \u0219i J nu se intersecteaz\u0103: fie c\u00e2nd extremitatea dreapt\u0103  a lui I este mai mic\u0103 sau egal\u0103 cu extremitatea st\u00e2ng\u0103 a lui J, fie c\u00e2nd extremitatea  dreapt\u0103 a lui J este mai mic\u0103 sau egal\u0103 cu extremitatea st\u00e2ng\u0103 a lui  I.  6.", " R\u0103spuns corect: b) 12  Indica\u021bii: Numerele c\u0103utate sunt pare deci au pe ultimele dou\u0103 pozi\u021bii 00, 02, 10,  12, 20, 22.", "Cifra sutelor poate s\u0103 fie 1 sau 2 pentru c\u0103 numerele sunt naturale \u0219i au  exact 3 cifre.", "Deci sunt 2*6=12 numere.", " 7.", " R\u0103spuns corect: c) 3080  Indica\u021bii: Pentru rapiditate se poate utiliza formula n(n+1)(n+2)/3, unde n=20.", " Deci 20*21*22/3=3080.", " 8.", " R\u0103spuns corect: b) (16,9,7,5,4,3,2,1,0)  Indica\u021bii:  Primele 5 numere naturale p\u0103trate perfecte: 0, 1, 4, 9, 16.", "Sortate descresc\u0103tor  ajung: 16, 9, 4, 1, 0.", " Primele 4 numere naturale prime:  2, 3, 5, 7.", "Sortate descresc\u0103tor ajung: 7, 5, 3, 2.", " Dup\u0103 interclasare, C are 9 elemente \u0219i urm\u0103torul con\u021binut: (16, 9, 7, 5, 4, 3, 2, 1, 0).", " 9.", " R\u0103spuns corect: a) 19 20 20  Indica\u021bii: Numai c \u00ee\u0219i schimb\u0103 valoarea.", "  10.", " R\u0103spuns corect: c) 514  Indica\u021bii: Toate nodurile de la 1 \u0219i p\u00e2n\u0103 la 512 au c\u00e2te doi descenden\u021bi direc\u021bi(fii).", "Nodul  513 are un singur fiu: 1026; toate nodurile de la 514 \u0219i p\u00e2n\u0103 la 1026 sunt frunze.", " 1026-512=514  11.", " R\u0103spuns corect: c) 9  Indica\u021bii: O solu\u021bie mai rapid\u0103 se bazeaz\u0103 pe calculul invers: se scad cele \u0219ase subgrafuri  care au mul\u021bimea muchiilor nevid\u0103 din 15 (num\u0103rul total de subgrafuri ale grafului  neorientat cu 4 noduri,  24-1=15).", "Subgrafurile cu dou\u0103 muchii au mul\u021bimea nodurilor"], "page_sentence_count_spacy": 32}, {"page_number": 310, "page_char_count": 1395, "page_word_count": 242, "page_sentence_count_raw": 15, "page_token_count": 348.75, "text": "310    {1,2,3,4}, respectiv {1,2,3} (dou\u0103 cazuri). Subgrafurile cu o muchie au mul\u021bimea  nodurilor {1,2,4}, {1,2}, {2,3,4}, respectiv {2,3} (patru cazuri).  24-1-2-4=9  12.  R\u0103spuns corect: b) O(logn), algoritm logaritmic  Indica\u021bii: Se utilizeaz\u0103 un algoritm logaritmic bazat pe calculul sumei   [n/5] + [n/(5*5)] + [n/(5*5*5)] + \u2026   13.  R\u0103spuns corect: e) 1  Indica\u021bii: Arcul pe care este suficient  s\u0103  \u00eel  ad\u0103ug\u0103m  este (2,4).  14.  R\u0103spuns corect: c)  49  Indica\u021bii: Num\u0103rul total de grafuri neorientate cu 8 noduri este 28*(8-1)/2  Num\u0103r\u0103m ce nu variaz\u0103 deasupra diagonalei principale din matricea de adiacen\u021b\u0103  asociat\u0103 grafului deoarece graful este neorientat.  Num\u0103r\u0103m perechile de noduri adiacente. Sunt  4  cazuri:  [2,8],[3,8],[5,8],[7,8]   Num\u0103r\u0103m perechile de noduri neadiacente. Sunt  6  cazuri:  [1,3],[1,5],[1,7],[3,5],[3,7],[5,7].  Deci num\u0103rul c\u0103utat este 28*(8-1)/2 \u2013 4 - 6 = 228-10 = 218 = 49  15.  R\u0103spuns corect: e) 8  Indica\u021bii: Tabloul unidimensional memoreaz\u0103 r\u0103sturnatele primelor 33 de numere  naturale p\u0103trate perfecte. Deoarece c\u0103ut\u0103m c\u00e2te numere din tablou se termin\u0103 cu cifra 1,  problema se rezum\u0103 la identificarea acelor p\u0103trate perfecte care \u00eencep cu cifra 1. Nu ne  intereseaz\u0103 numerele p\u0103trate perfecte mai mari dec\u00e2t 200 \u0219i mai mici dec\u00e2t 999 pentru  c\u0103 nu \u00eencep cu cifra 1.   P\u0103tratele perfecte c\u0103utate: 1,16,100,121,144,169,196,1024, deci sunt 8  numere.", "sentences": ["310    {1,2,3,4}, respectiv {1,2,3} (dou\u0103 cazuri).", "Subgrafurile cu o muchie au mul\u021bimea  nodurilor {1,2,4}, {1,2}, {2,3,4}, respectiv {2,3} (patru cazuri).", " 24-1-2-4=9  12.", " R\u0103spuns corect: b) O(logn), algoritm logaritmic  Indica\u021bii: Se utilizeaz\u0103 un algoritm logaritmic bazat pe calculul sumei   [n/5] + [n/(5*5)] + [n/(5*5*5)] + \u2026   13.", " R\u0103spuns corect: e) 1  Indica\u021bii: Arcul pe care este suficient  s\u0103  \u00eel  ad\u0103ug\u0103m  este (2,4).", " 14.", " R\u0103spuns corect: c)  49  Indica\u021bii: Num\u0103rul total de grafuri neorientate cu 8 noduri este 28*(8-1)/2  Num\u0103r\u0103m ce nu variaz\u0103 deasupra diagonalei principale din matricea de adiacen\u021b\u0103  asociat\u0103 grafului deoarece graful este neorientat.", " Num\u0103r\u0103m perechile de noduri adiacente.", "Sunt  4  cazuri:  [2,8],[3,8],[5,8],[7,8]   Num\u0103r\u0103m perechile de noduri neadiacente.", "Sunt  6  cazuri:  [1,3],[1,5],[1,7],[3,5],[3,7],[5,7].", " Deci num\u0103rul c\u0103utat este 28*(8-1)/2 \u2013 4 - 6 = 228-10 = 218 = 49  15.", " R\u0103spuns corect: e) 8  Indica\u021bii: Tabloul unidimensional memoreaz\u0103 r\u0103sturnatele primelor 33 de numere  naturale p\u0103trate perfecte.", "Deoarece c\u0103ut\u0103m c\u00e2te numere din tablou se termin\u0103 cu cifra 1,  problema se rezum\u0103 la identificarea acelor p\u0103trate perfecte care \u00eencep cu cifra 1.", "Nu ne  intereseaz\u0103 numerele p\u0103trate perfecte mai mari dec\u00e2t 200 \u0219i mai mici dec\u00e2t 999 pentru  c\u0103 nu \u00eencep cu cifra 1.", "  P\u0103tratele perfecte c\u0103utate: 1,16,100,121,144,169,196,1024, deci sunt 8  numere."], "page_sentence_count_spacy": 15}, {"page_number": 311, "page_char_count": 1484, "page_word_count": 283, "page_sentence_count_raw": 27, "page_token_count": 371.0, "text": "311    Varianta 32  1. R\u0103spuns corect: c)  2. R\u0103spuns corect: a)  Indica\u021bii: Variabila i re\u0163ine, \u00een ordine descresc\u0103toare, multiplii comuni ai variabilelor  a \u015fi b. La final variabila i re\u0163ine cel mai mic multiplu comun al acesora.  3. R\u0103spuns corect: a)  Indica\u021bii: Pentru x=9 se afi\u015feaz\u0103: 18 27 36 45 54 63 72 81 90.  4. R\u0103spuns corect: d)   5. R\u0103spuns corect: c)  Indica\u021bii: se formeaz\u0103 trei componente conexe, dou\u0103 cu c\u00e2te trei noduri \u0219i una cu patru  noduri.  6. R\u0103spuns corect: b)  Indica\u021bii: Algoritmul lui Euclid reprezint\u0103 o metod\u0103 eficient\u0103 de calculare a celui mai  mare divizor comun a dou\u0103 numere \u00eentregi.  7. R\u0103spuns corect: d)  Indica\u021bii: Graful este conex \u0219i toate gradele sunt pare.  8. R\u0103spuns corect: c)  9. R\u0103spuns corect: b)  Indica\u021bii: Submul\u021bimile generate sunt: {2} {1,2} {2,5} {2,9} {1,2,5}  {1,2,9} {2,5,9} {1,2,5,9}.  10. R\u0103spuns corect: c)  11. R\u0103spuns corect: c)  Indica\u021bii: Pe nivelul 1 este un nod care are doi fii; pe nivelul 2 sunt 2 noduri care au,  fiecare c\u00e2te 3 fii; pe nivelul 3 sunt 6 noduri care au, fiecare c\u00e2te 4 fii.  Deci, num\u0103rul de frunze este 24.  12. R\u0103spuns corect: e)  Indica\u021bii: \u00cen antetul subprogramului f, y este parametru formal transmis prin referin\u0163\u0103.  13. R\u0103spuns corect: f)  Indica\u021bii: Se calculeaz\u0103 cmmdc al numerelor x \u0219i y \u0219i apoi cmmdc pentru num\u0103rul  rezultat \u0219i z.  14. R\u0103spuns corect: a)  15. R\u0103spuns corect: b)  Indica\u021bii: Ciclurile care sunt acelea\u0219i cu excep\u021bia punctului de plecare nu sunt luate \u00een  calcul separat.", "sentences": ["311    Varianta 32  1.", "R\u0103spuns corect: c)  2.", "R\u0103spuns corect: a)  Indica\u021bii: Variabila i re\u0163ine, \u00een ordine descresc\u0103toare, multiplii comuni ai variabilelor  a \u015fi b. La final variabila i re\u0163ine cel mai mic multiplu comun al acesora.", " 3.", "R\u0103spuns corect: a)  Indica\u021bii: Pentru x=9 se afi\u015feaz\u0103: 18 27 36 45 54 63 72 81 90.", " 4.", "R\u0103spuns corect: d)   5.", "R\u0103spuns corect: c)  Indica\u021bii: se formeaz\u0103 trei componente conexe, dou\u0103 cu c\u00e2te trei noduri \u0219i una cu patru  noduri.", " 6.", "R\u0103spuns corect: b)  Indica\u021bii: Algoritmul lui Euclid reprezint\u0103 o metod\u0103 eficient\u0103 de calculare a celui mai  mare divizor comun a dou\u0103 numere \u00eentregi.", " 7.", "R\u0103spuns corect: d)  Indica\u021bii: Graful este conex \u0219i toate gradele sunt pare.", " 8.", "R\u0103spuns corect: c)  9.", "R\u0103spuns corect: b)  Indica\u021bii: Submul\u021bimile generate sunt: {2} {1,2} {2,5} {2,9} {1,2,5}  {1,2,9} {2,5,9} {1,2,5,9}.", " 10.", "R\u0103spuns corect: c)  11.", "R\u0103spuns corect: c)  Indica\u021bii: Pe nivelul 1 este un nod care are doi fii; pe nivelul 2 sunt 2 noduri care au,  fiecare c\u00e2te 3 fii; pe nivelul 3 sunt 6 noduri care au, fiecare c\u00e2te 4 fii.", " Deci, num\u0103rul de frunze este 24.", " 12.", "R\u0103spuns corect: e)  Indica\u021bii: \u00cen antetul subprogramului f, y este parametru formal transmis prin referin\u0163\u0103.", " 13.", "R\u0103spuns corect: f)  Indica\u021bii: Se calculeaz\u0103 cmmdc al numerelor x \u0219i y \u0219i apoi cmmdc pentru num\u0103rul  rezultat \u0219i z.  14.", "R\u0103spuns corect: a)  15.", "R\u0103spuns corect: b)  Indica\u021bii: Ciclurile care sunt acelea\u0219i cu excep\u021bia punctului de plecare nu sunt luate \u00een  calcul separat."], "page_sentence_count_spacy": 25}, {"page_number": 312, "page_char_count": 964, "page_word_count": 189, "page_sentence_count_raw": 24, "page_token_count": 241.0, "text": "312    Varianta 33  1. R\u0103spuns corect: a)  2. R\u0103spuns corect: f)  3. R\u0103spuns corect: d)  4. R\u0103spuns corect: d)  5. R\u0103spuns corect: c)  Indica\u021bii:    6. R\u0103spuns corect: b)  Indica\u021bii:    7. R\u0103spuns corect: b)  Indica\u021bii:  \ud835\udfcf\ud835\udfce\ud835\udfce(\ud835\udfcf\ud835\udfce\ud835\udfce\u2212\ud835\udfcf) \ud835\udfd0 = \ud835\udfd2\ud835\udfd7\ud835\udfd3\ud835\udfce.  8. R\u0103spuns corect: e)  Indica\u021bii:  \ud835\udc83+\ud835\udc84 \ud835\udfd0+ \ud835\udc84+\ud835\udc85 \ud835\udfd0= \ud835\udc83+\ud835\udc85 \ud835\udfd0+ \ud835\udc84.  9. R\u0103spuns corect: c)  Indica\u021bii: Graful este conex \u0219i toate gradele sunt pare; nu exist\u0103 lan\u021b hamiltonian.  10. R\u0103spuns corect: c)  Indica\u021bii: Solu\u0163iile sunt: 3+4+5 \u0219i 3+9.  11. R\u0103spuns corect: a)  Indica\u021bii: Arborele are n-1 muchii \u0219i suma gradelor unui graf este dublul num\u0103rului de  muchii.  12. R\u0103spuns corect: b)  13. R\u0103spuns corect: c)  Indica\u021bii: La fiecare pas se adaug\u0103 3k \u0219i se scot k+2, adic\u0103 ram\u00e2n \u00een coad\u0103 2k+2  elemente. Dup\u0103 9 pa\u0219i num\u0103rul de elemente este 2(1+2+..+9)+2*9=90-18=72.  14. R\u0103spuns corect: a)  15. R\u0103spuns corect: f)  Indica\u021bii: Arborele are n-1 muchii. Num\u0103rul de elemente nule din matricea de  adiacen\u0163\u0103 este: n2-2(n-1)= n2-2n+2.", "sentences": ["312    Varianta 33  1.", "R\u0103spuns corect: a)  2.", "R\u0103spuns corect: f)  3.", "R\u0103spuns corect: d)  4.", "R\u0103spuns corect: d)  5.", "R\u0103spuns corect: c)  Indica\u021bii:    6.", "R\u0103spuns corect: b)  Indica\u021bii:    7.", "R\u0103spuns corect: b)  Indica\u021bii:  \ud835\udfcf\ud835\udfce\ud835\udfce(\ud835\udfcf\ud835\udfce\ud835\udfce\u2212\ud835\udfcf) \ud835\udfd0 = \ud835\udfd2\ud835\udfd7\ud835\udfd3\ud835\udfce.  8.", "R\u0103spuns corect: e)  Indica\u021bii:  \ud835\udc83+\ud835\udc84 \ud835\udfd0+ \ud835\udc84+\ud835\udc85 \ud835\udfd0= \ud835\udc83+\ud835\udc85 \ud835\udfd0+ \ud835\udc84.  9.", "R\u0103spuns corect: c)  Indica\u021bii: Graful este conex \u0219i toate gradele sunt pare; nu exist\u0103 lan\u021b hamiltonian.", " 10.", "R\u0103spuns corect: c)  Indica\u021bii: Solu\u0163iile sunt: 3+4+5 \u0219i 3+9.", " 11.", "R\u0103spuns corect: a)  Indica\u021bii: Arborele are n-1 muchii \u0219i suma gradelor unui graf este dublul num\u0103rului de  muchii.", " 12.", "R\u0103spuns corect: b)  13.", "R\u0103spuns corect: c)  Indica\u021bii: La fiecare pas se adaug\u0103 3k \u0219i se scot k+2, adic\u0103 ram\u00e2n \u00een coad\u0103 2k+2  elemente.", "Dup\u0103 9 pa\u0219i num\u0103rul de elemente este 2(1+2+..+9)+2*9=90-18=72.", " 14.", "R\u0103spuns corect: a)  15.", "R\u0103spuns corect: f)  Indica\u021bii: Arborele are n-1 muchii.", "Num\u0103rul de elemente nule din matricea de  adiacen\u0163\u0103 este: n2-2(n-1)= n2-2n+2."], "page_sentence_count_spacy": 22}, {"page_number": 313, "page_char_count": 661, "page_word_count": 139, "page_sentence_count_raw": 20, "page_token_count": 165.25, "text": "313    Varianta 34  1. R\u0103spuns corect: a)  2. R\u0103spuns corect: c)  3. R\u0103spuns corect: c)  Indica\u021bii: \u00cen timpul rul\u0103rii, variabilei b are urm\u0103toarele valori:   0 1 2 4 7 8 915 22 23 24.  4. R\u0103spuns corect: a)  5. R\u0103spuns corect: c)  Indica\u021bii:    6. R\u0103spuns corect: a)  7. R\u0103spuns corect: c)  8. R\u0103spuns corect: d)  9. R\u0103spuns corect: d)  10. R\u0103spuns corect: c)  11. R\u0103spuns corect: a)  Indica\u021bii: \u00cen antetul subprogramului f, b este parametru formal transmis prin referin\u0163\u0103.  12. R\u0103spuns corect: b)  Indica\u021bii: Graful complet cu n noduri are  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0  muchii.  13. R\u0103spuns corect: c)  14. R\u0103spuns corect: c)  Indica\u021bii: S1=S2= \ud835\udc8f(\ud835\udc8f\u2212\ud835\udfcf) \ud835\udfd0 .  15. R\u0103spuns corect: c)", "sentences": ["313    Varianta 34  1.", "R\u0103spuns corect: a)  2.", "R\u0103spuns corect: c)  3.", "R\u0103spuns corect: c)  Indica\u021bii: \u00cen timpul rul\u0103rii, variabilei b are urm\u0103toarele valori:   0 1 2 4 7 8 915 22 23 24.", " 4.", "R\u0103spuns corect: a)  5.", "R\u0103spuns corect: c)  Indica\u021bii:    6.", "R\u0103spuns corect: a)  7.", "R\u0103spuns corect: c)  8.", "R\u0103spuns corect: d)  9.", "R\u0103spuns corect: d)  10.", "R\u0103spuns corect: c)  11.", "R\u0103spuns corect: a)  Indica\u021bii: \u00cen antetul subprogramului f, b este parametru formal transmis prin referin\u0163\u0103.", " 12.", "R\u0103spuns corect: b)  Indica\u021bii: Graful complet cu n noduri are  \ud835\udc27(\ud835\udc27\u2212\ud835\udfcf) \ud835\udfd0  muchii.", " 13.", "R\u0103spuns corect: c)  14.", "R\u0103spuns corect: c)  Indica\u021bii: S1=S2= \ud835\udc8f(\ud835\udc8f\u2212\ud835\udfcf) \ud835\udfd0 .", " 15.", "R\u0103spuns corect: c)"], "page_sentence_count_spacy": 20}, {"page_number": 314, "page_char_count": 786, "page_word_count": 161, "page_sentence_count_raw": 19, "page_token_count": 196.5, "text": "314    Varianta 35  1. R\u0103spuns corect: b)  2. R\u0103spuns corect: d)  3. R\u0103spuns corect: b)  Indica\u021bii: Pentru fiecare \ud835\udc56\u2208{1,2,3, \u2026 ,10}, se realizeaz\u0103 10 execu\u0163ii ale instruc\u0163iunii  care afi\u015feaz\u0103 valoarea variabilei k. Num\u0103rul final de execu\u0163ii este: 10\u22199=90.   4. R\u0103spuns corect: c)  5. R\u0103spuns corect: c)  6. R\u0103spuns corect: d)  7. R\u0103spuns corect: e)  Indica\u021bii:  sunt  necesare  11(11-1)/2=55  compar\u0103ri  \u015fi  11(11-1)/2=55  interschimb\u0103ri.  8. R\u0103spuns corect: b)  9. R\u0103spuns corect: f)  Indica\u021bii: (1 2 3 4) (1 4 3 2) (3 2 1 4) (3 4 1 2)  10. R\u0103spuns corect: c)  11. R\u0103spuns corect: e)   Indica\u021bii: \u00cen antetul subprogramului f, y este parametru formal transmis prin referin\u0163\u0103  12. R\u0103spuns corect: b)  Indica\u021bii:    13. R\u0103spuns corect: a)   14. R\u0103spuns corect: d)   15. R\u0103spuns corect: b)", "sentences": ["314    Varianta 35  1.", "R\u0103spuns corect: b)  2.", "R\u0103spuns corect: d)  3.", "R\u0103spuns corect: b)  Indica\u021bii: Pentru fiecare \ud835\udc56\u2208{1,2,3, \u2026 ,10}, se realizeaz\u0103 10 execu\u0163ii ale instruc\u0163iunii  care afi\u015feaz\u0103 valoarea variabilei k. Num\u0103rul final de execu\u0163ii este: 10\u22199=90.", "  4.", "R\u0103spuns corect: c)  5.", "R\u0103spuns corect: c)  6.", "R\u0103spuns corect: d)  7.", "R\u0103spuns corect: e)  Indica\u021bii:  sunt  necesare  11(11-1)/2=55  compar\u0103ri  \u015fi  11(11-1)/2=55  interschimb\u0103ri.", " 8.", "R\u0103spuns corect: b)  9.", "R\u0103spuns corect: f)  Indica\u021bii: (1 2 3 4) (1 4 3 2) (3 2 1 4) (3 4 1 2)  10.", "R\u0103spuns corect: c)  11.", "R\u0103spuns corect: e)   Indica\u021bii: \u00cen antetul subprogramului f, y este parametru formal transmis prin referin\u0163\u0103  12.", "R\u0103spuns corect: b)  Indica\u021bii:    13.", "R\u0103spuns corect: a)   14.", "R\u0103spuns corect: d)   15.", "R\u0103spuns corect: b)"], "page_sentence_count_spacy": 18}, {"page_number": 315, "page_char_count": 2115, "page_word_count": 364, "page_sentence_count_raw": 32, "page_token_count": 528.75, "text": "315    Varianta 36    1. R\u0103spuns corect: f) 288 1  Indica\u021bii:   Operatori aritmetici binari  multiplicativi  Limbajul Pascal  Limbajul C|C++  \u00cenmul\u021birea  *  *  C\u00e2tul \u00eemp\u0103r\u021birii \u00eentregi  div  /  Restul \u00eemp\u0103r\u021birii \u00eentregi  mod  %  Cei trei operatori au aceea\u0219i prioritate \u0219i se evalueaz\u0103 de la st\u00e2nga la dreapta.  x=288, y=1.  2. R\u0103spuns corect: c) (x=y \u015fi y\u2260z) sau (x\u2260y \u015fi y=z)  Indica\u021bii: Cele trei variabile trebuie s\u0103 fie ini\u021bializate. Expresia este 1/True dac\u0103 cele  trei variabile sunt egale sau diferite dou\u0103 c\u00e2te dou\u0103. Expresia este 0/False dac\u0103 oricare  dou\u0103 variabile sunt egale \u0219i oricare dou\u0103 diferite.  3. R\u0103spuns corect: e) 100  Indica\u021bii: x=y=100. Deoarece condi\u021bia x>y este fals\u0103 se execut\u0103 y\uf0df10*x\u20138*y.  Valoarea lui y se modific\u0103, y=200. Diferen\u021ba absolut\u0103 |x-y|=|y-x|=100.  4. R\u0103spuns corect: c) a>=1  Indica\u021bii: Limbajul C++/C: Secven\u021bele date sunt echivalente atunci c\u00e2nd <condi\u021bia>  din instruc\u021biunea while este la fel cu <condi\u021bia> din instuc\u021biunea do\u2026 while.   Limbajul Pascal: Secven\u021bele date sunt echivalente atunci c\u00e2nd <condi\u021bia> din  instruc\u021biunea while\u2026 do devine <nega\u021bie condi\u021bie> \u00een instruc\u021biunea repeat\u2026  until.  5. R\u0103spuns corect: d) 96  Indica\u021bii: f(5)=2*f(4)=2*(2*f(3))= 2*2*(2*f(2))=2*2*2*(2*f(1))  =2*2*2*2*(2*f(0))=2*2*2*2*(2*3)=96  6. R\u0103spuns corect: d) strcat | concat  Indica\u021bii: Concatenarea a dou\u0103 \u0219iruri se poate realiza \u00een Limbajul C++/C cu  subprogramul predefinit strcat, iar \u00een Limbajul Pascal cu func\u021bia predefinit\u0103 concat.  7. R\u0103spuns corect: a) 3  Indica\u021bii: Exist\u0103 3 lan\u021buri distincte de lungime 3 de la nodul 1 la nodul 4:  L1=[1,2,3,4], L2=[1,2,5,4] \u0219i L3=[1,5,2,4].  8. R\u0103spuns corect: b) 1  Indica\u021bii: Primul nod este r\u0103d\u0103cina arborelui. Fiecare nod are un singur descendent.  Ultimul nod este frunz\u0103.   9. R\u0103spuns corect: d) 207  Indica\u021bii: Numerele generate sunt: 108,126,153,162,18,207 etc.   10. R\u0103spuns corect: f) 2043231   Indica\u021bii: Elementele tabloului sunt: a[0]=1, a[1]=2, a[2]=3 \u2026  a[2020]=2021.  Suma elementelor este \ud835\udc60= \ud835\udc5b(\ud835\udc5b+1) 2  . Pentru n=2021suma elementelor este  2021\u22172022 2 = 2043231.  11. R\u0103spuns corect: e) 5  5 6 10 20  1  tabloul ini\u021bial", "sentences": ["315    Varianta 36    1.", "R\u0103spuns corect: f) 288 1  Indica\u021bii:   Operatori aritmetici binari  multiplicativi  Limbajul Pascal  Limbajul C|C++  \u00cenmul\u021birea  *  *  C\u00e2tul \u00eemp\u0103r\u021birii \u00eentregi  div  /  Restul \u00eemp\u0103r\u021birii \u00eentregi  mod  %  Cei trei operatori au aceea\u0219i prioritate \u0219i se evalueaz\u0103 de la st\u00e2nga la dreapta.", " x=288, y=1.", " 2.", "R\u0103spuns corect: c) (x=y \u015fi y\u2260z) sau (x\u2260y \u015fi y=z)  Indica\u021bii: Cele trei variabile trebuie s\u0103 fie ini\u021bializate.", "Expresia este 1/True dac\u0103 cele  trei variabile sunt egale sau diferite dou\u0103 c\u00e2te dou\u0103.", "Expresia este 0/False dac\u0103 oricare  dou\u0103 variabile sunt egale \u0219i oricare dou\u0103 diferite.", " 3.", "R\u0103spuns corect: e) 100  Indica\u021bii: x=y=100.", "Deoarece condi\u021bia x>y este fals\u0103 se execut\u0103 y\uf0df10*x\u20138*y.", " Valoarea lui y se modific\u0103, y=200.", "Diferen\u021ba absolut\u0103 |x-y|=|y-x|=100.", " 4.", "R\u0103spuns corect: c) a>=1  Indica\u021bii: Limbajul C++/C: Secven\u021bele date sunt echivalente atunci c\u00e2nd <condi\u021bia>  din instruc\u021biunea while este la fel cu <condi\u021bia> din instuc\u021biunea do\u2026 while.", "  Limbajul Pascal: Secven\u021bele date sunt echivalente atunci c\u00e2nd <condi\u021bia> din  instruc\u021biunea while\u2026 do devine <nega\u021bie condi\u021bie> \u00een instruc\u021biunea repeat\u2026  until.", " 5.", "R\u0103spuns corect: d) 96  Indica\u021bii: f(5)=2*f(4)=2*(2*f(3))= 2*2*(2*f(2))=2*2*2*(2*f(1))  =2*2*2*2*(2*f(0))=2*2*2*2*(2*3)=96  6.", "R\u0103spuns corect: d) strcat | concat  Indica\u021bii: Concatenarea a dou\u0103 \u0219iruri se poate realiza \u00een Limbajul C++/C cu  subprogramul predefinit strcat, iar \u00een Limbajul Pascal cu func\u021bia predefinit\u0103 concat.", " 7.", "R\u0103spuns corect: a) 3  Indica\u021bii: Exist\u0103 3 lan\u021buri distincte de lungime 3 de la nodul 1 la nodul 4:  L1=[1,2,3,4], L2=[1,2,5,4] \u0219i L3=[1,5,2,4].", " 8.", "R\u0103spuns corect: b) 1  Indica\u021bii: Primul nod este r\u0103d\u0103cina arborelui.", "Fiecare nod are un singur descendent.", " Ultimul nod este frunz\u0103.", "  9.", "R\u0103spuns corect: d) 207  Indica\u021bii: Numerele generate sunt: 108,126,153,162,18,207 etc.   10.", "R\u0103spuns corect: f) 2043231   Indica\u021bii: Elementele tabloului sunt: a[0]=1, a[1]=2, a[2]=3 \u2026  a[2020]=2021.", " Suma elementelor este \ud835\udc60= \ud835\udc5b(\ud835\udc5b+1) 2  .", "Pentru n=2021suma elementelor este  2021\u22172022 2 = 2043231.", " 11.", "R\u0103spuns corect: e) 5  5 6 10 20  1  tabloul ini\u021bial"], "page_sentence_count_spacy": 31}, {"page_number": 316, "page_char_count": 2268, "page_word_count": 838, "page_sentence_count_raw": 17, "page_token_count": 567.0, "text": "316    Indica\u021bii: La fiecare parcurgere se  compar\u0103 elementele \u00eenvecinate \u0219i se  realizeaz\u0103 interschimbul doar \u00eentre  elementele care nu respect\u0103 rela\u021bia  de ordine. Configura\u021bia este final\u0103  atunci c\u00e2nd nu se mai realizeaz\u0103  niciun interschimb.  5 6 10  1  20 prima parcurgere  5 6  1  10 20 a 2-a parcurgere  5 1  6  10 20 a 3-a parcurgere  1 5  6  10 20 a 4-a parcurgere  1 5  6  10 20 a 5-a parcurgere    12. R\u0103spuns corect: b) 29  Indica\u021bii: Numere excep\u021bionale:  110,111,112,113,114,115,116,117,118,19,210, 310,  410,510,610,710,810,910,221,331,242,441,551,661,771,283,881,392,  991.  13. R\u0103spuns corect: f) 3  Indica\u021bii: \u00cen schema apelurilor  recursive, pentru n=3, valorile  afi\u0219ate sunt \u00eencercuite: 1 1 1  2 1 3. Numerele asociate  s\u0103ge\u021bilor indic\u0103 ordinea de  executare a apelurilor recursive  \u0219i, implicit, ordinea de afi\u0219are a  valorilor.                14. R\u0103spuns corect: c)   Indica\u021bii: Secven\u0163a interschimb\u0103 elementele triunghiurilor unu \u015fi doi inclusiv  elementele de pe diagonale, celelalte elemente p\u0103str\u00e2ndu-\u0219i pozi\u021bia ini\u021bial\u0103.                                              Matricea ini\u021bial\u0103       Matricea final\u0103                                                    1  2  3  4  5                  5  2  3  4  1                                                    1  2  3  4  5                  5  4  3  2  1                                                    1  2  3  4  5                  5  4  3  2  1                                                    1  2  3  4  5                  5  4  3  2  1                                                     1  2  3  4  5                  5  2  3  4  1    15. R\u0103spuns corect: d) 252  Indica\u021bii: Pentru n num\u0103r natural format din 3 cifre, subprogramul va returna un num\u0103r  natural format din acelea\u0219i 3 cifre. Dac\u0103 n con\u021bine cel pu\u021bin o cifr\u0103 de 9, atunci num\u0103rul  returnat va avea cifra sutelor egal\u0103 cu 9.  \u00cen intervalul [100,199] exist\u0103 19 numere naturale care au cel pu\u021bin o cifr\u0103 de 9. \u00cen  intervalul [100,899] exist\u0103 8*19=152 numere naturale care au cel pu\u021bin o cifr\u0103 de 9.  \u00cen intervalul [900,999] exist\u0103 100 de numere care au cel pu\u021bin o cifr\u0103 de 9.  A\u0219adar, pentru n\u2208[100,999] subprogramul poate returna 252 numere naturale cu cifra  sutelor 9.        2  1  1  3  6  5  4  2  f(3)  2  3  1  1  1  1", "sentences": ["316    Indica\u021bii: La fiecare parcurgere se  compar\u0103 elementele \u00eenvecinate \u0219i se  realizeaz\u0103 interschimbul doar \u00eentre  elementele care nu respect\u0103 rela\u021bia  de ordine.", "Configura\u021bia este final\u0103  atunci c\u00e2nd nu se mai realizeaz\u0103  niciun interschimb.", " 5 6 10  1  20 prima parcurgere  5 6  1  10 20 a 2-a parcurgere  5 1  6  10 20 a 3-a parcurgere  1 5  6  10 20 a 4-a parcurgere  1 5  6  10 20 a 5-a parcurgere    12.", "R\u0103spuns corect: b) 29  Indica\u021bii: Numere excep\u021bionale:  110,111,112,113,114,115,116,117,118,19,210, 310,  410,510,610,710,810,910,221,331,242,441,551,661,771,283,881,392,  991.", " 13.", "R\u0103spuns corect: f) 3  Indica\u021bii: \u00cen schema apelurilor  recursive, pentru n=3, valorile  afi\u0219ate sunt \u00eencercuite: 1 1 1  2 1 3.", "Numerele asociate  s\u0103ge\u021bilor indic\u0103 ordinea de  executare a apelurilor recursive  \u0219i, implicit, ordinea de afi\u0219are a  valorilor.", "               14.", "R\u0103spuns corect: c)   Indica\u021bii: Secven\u0163a interschimb\u0103 elementele triunghiurilor unu \u015fi doi inclusiv  elementele de pe diagonale, celelalte elemente p\u0103str\u00e2ndu-\u0219i pozi\u021bia ini\u021bial\u0103.", "                                             Matricea ini\u021bial\u0103       Matricea final\u0103                                                    1  2  3  4  5                  5  2  3  4  1                                                    1  2  3  4  5                  5  4  3  2  1                                                    1  2  3  4  5                  5  4  3  2  1                                                    1  2  3  4  5                  5  4  3  2  1                                                     1  2  3  4  5                  5  2  3  4  1    15.", "R\u0103spuns corect: d) 252  Indica\u021bii: Pentru n num\u0103r natural format din 3 cifre, subprogramul va returna un num\u0103r  natural format din acelea\u0219i 3 cifre.", "Dac\u0103 n con\u021bine cel pu\u021bin o cifr\u0103 de 9, atunci num\u0103rul  returnat va avea cifra sutelor egal\u0103 cu 9.", " \u00cen intervalul [100,199] exist\u0103 19 numere naturale care au cel pu\u021bin o cifr\u0103 de 9.", "\u00cen  intervalul [100,899] exist\u0103 8*19=152 numere naturale care au cel pu\u021bin o cifr\u0103 de 9.", " \u00cen intervalul [900,999] exist\u0103 100 de numere care au cel pu\u021bin o cifr\u0103 de 9.", " A\u0219adar, pentru n\u2208[100,999] subprogramul poate returna 252 numere naturale cu cifra  sutelor 9.", "       2  1  1  3  6  5  4  2  f(3)  2  3  1  1  1  1"], "page_sentence_count_spacy": 17}, {"page_number": 317, "page_char_count": 1902, "page_word_count": 378, "page_sentence_count_raw": 22, "page_token_count": 475.5, "text": "317    Varianta 37  1. R\u0103spuns corect: b)  Indica\u021bii: Se face diferen\u0163a la nivel de cod ASCII (97- 99= -2).  2. R\u0103spuns corect: c)   Indica\u021bii: Reprezentarea grafic\u0103 a respectivului arbore este:      3. R\u0103spuns corect: f)  Indica\u021bii: Matricea de adiacen\u0163\u0103 este simetric\u0103 fa\u0163\u0103 de diagonala principal\u0103 prin  urmare num\u0103rul total de cifre 1 este n(n-1)=n2-n. Cum pe diagonala principal\u0103  avem un num\u0103r de n cifre de 0, iar num\u0103rul total de elemente din matrice este n2,  matricea desemneaz\u0103 \u00eenc\u0103 de la bun \u00eenceput un graf norientat complet.  4. R\u0103spuns corect: c)  Indica\u021bii: Pentru a ob\u0163ine un num\u0103r maxim de noduri izolate, vom asigura totalul de  10589 de muchii cu un num\u0103r minim de noduri (147). Cum restul nodurilor sunt  izolate, gradul maxim pe care \u00eel poate avea un nod din cele 147 este egal cu 146.  5. R\u0103spuns corect: f)  Indica\u021bii: Pentru a ajunge la cuv\u00e2ntul din mijloc, se elimin\u0103 primul cuv\u00e2nt din \u015firul  de caractere, iar apoi \u00een cadrul structurii repetitive urm\u0103toarele patru cuvinte. Ultimul  cuv\u00e2nt copiat \u00een variabila c desemneaz\u0103 cuv\u00e2ntul c\u0103utat.  6. R\u0103spuns corect: b)  Indica\u021bii: Variabila k va desemna num\u0103rul seriei de termeni \u00een care se g\u0103se\u015fte cel de  pe pozi\u0163ia n, iar s va re\u0163ine pozi\u0163ia ultimului termen din acea serie.  7. R\u0103spuns corect: c)  Indica\u021bii: Ex: pentru n=5, se va construi \u00een memorie un tablou simetric fa\u0163\u0103 de  ambele diagonale de forma:  2 3 4 5 6   3 4 5 6 5   4 5 6 5 4   5 6 5 4 3   6 5 4 3 2  8. R\u0103spuns corect: c)  Indica\u021bii: Se re\u0163in \u00een ordine descresc\u0103toare multiplii comuni ai celor dou\u0103 variabile.  La final variabila d va p\u0103stra valoarea celui mai mic multiplu comun al acestora.  9. R\u0103spuns corect: d)  Indica\u021bii: Variabila c re\u0163ine puterea lui 5 din factorialul lui a, dar cum exist\u0103 \u00een  acela\u015fi timp \u015fi un num\u0103r de elemente pare mai mare decat c, valoarea sa va desemna  \u015fi num\u0103rul de 0 ob\u0163inut din \u00eenmul\u0163iri de forma 2*5.  10. R\u0103spuns corect: c)", "sentences": ["317    Varianta 37  1.", "R\u0103spuns corect: b)  Indica\u021bii: Se face diferen\u0163a la nivel de cod ASCII (97- 99= -2).", " 2.", "R\u0103spuns corect: c)   Indica\u021bii: Reprezentarea grafic\u0103 a respectivului arbore este:      3.", "R\u0103spuns corect: f)  Indica\u021bii: Matricea de adiacen\u0163\u0103 este simetric\u0103 fa\u0163\u0103 de diagonala principal\u0103 prin  urmare num\u0103rul total de cifre 1 este n(n-1)=n2-n.", "Cum pe diagonala principal\u0103  avem un num\u0103r de n cifre de 0, iar num\u0103rul total de elemente din matrice este n2,  matricea desemneaz\u0103 \u00eenc\u0103 de la bun \u00eenceput un graf norientat complet.", " 4.", "R\u0103spuns corect: c)  Indica\u021bii: Pentru a ob\u0163ine un num\u0103r maxim de noduri izolate, vom asigura totalul de  10589 de muchii cu un num\u0103r minim de noduri (147).", "Cum restul nodurilor sunt  izolate, gradul maxim pe care \u00eel poate avea un nod din cele 147 este egal cu 146.", " 5.", "R\u0103spuns corect: f)  Indica\u021bii: Pentru a ajunge la cuv\u00e2ntul din mijloc, se elimin\u0103 primul cuv\u00e2nt din \u015firul  de caractere, iar apoi \u00een cadrul structurii repetitive urm\u0103toarele patru cuvinte.", "Ultimul  cuv\u00e2nt copiat \u00een variabila c desemneaz\u0103 cuv\u00e2ntul c\u0103utat.", " 6.", "R\u0103spuns corect: b)  Indica\u021bii: Variabila k va desemna num\u0103rul seriei de termeni \u00een care se g\u0103se\u015fte cel de  pe pozi\u0163ia n, iar s va re\u0163ine pozi\u0163ia ultimului termen din acea serie.", " 7.", "R\u0103spuns corect: c)  Indica\u021bii: Ex: pentru n=5, se va construi \u00een memorie un tablou simetric fa\u0163\u0103 de  ambele diagonale de forma:  2 3 4 5 6   3 4 5 6 5   4 5 6 5 4   5 6 5 4 3   6 5 4 3 2  8.", "R\u0103spuns corect: c)  Indica\u021bii: Se re\u0163in \u00een ordine descresc\u0103toare multiplii comuni ai celor dou\u0103 variabile.", " La final variabila d va p\u0103stra valoarea celui mai mic multiplu comun al acestora.", " 9.", "R\u0103spuns corect: d)  Indica\u021bii: Variabila c re\u0163ine puterea lui 5 din factorialul lui a, dar cum exist\u0103 \u00een  acela\u015fi timp \u015fi un num\u0103r de elemente pare mai mare decat c, valoarea sa va desemna  \u015fi num\u0103rul de 0 ob\u0163inut din \u00eenmul\u0163iri de forma 2*5.", " 10.", "R\u0103spuns corect: c)"], "page_sentence_count_spacy": 22}, {"page_number": 318, "page_char_count": 994, "page_word_count": 181, "page_sentence_count_raw": 11, "page_token_count": 248.5, "text": "318    Indica\u021bii: Pentru a ajunge la o anumit\u0103 liter\u0103 din \u015firul de caractere strada, va  trebui mai \u00eent\u00e2i accesat un element din tablou (v[5]), iar apoi c\u00e2mpul adresa.  11. R\u0103spuns corect: c)  Indica\u021bii: La prima deschidere a fi\u015fierului se vor citi toate valorile existente \u00een acesta,  iar la cea de-a doua se vor citi doar primele n-1 valori care includ \u015fi valoarea citit\u0103  initial \u00een n.   12. R\u0103spuns corect: a)  Indica\u021bii: Se caut\u0103 valoarea raportului dintre suma cifrelor (ob\u0163inut\u0103 prin apelul  f(n)) \u015fi num\u0103rul de cifre calculat \u00een variabila c.  13. R\u0103spuns corect: e)  Indica\u021bii: Se lipesc primele dou\u0103 caractere din \u015firul p la ceea ce a r\u0103mas \u00een s dup\u0103  eliminarea de caractere.  14. R\u0103spuns corect: b)   Indica\u021bii: Secven\u0163a parcurge \u00een spiral\u0103 \u00een sensul acelor de ceasornic elementele  tabloului respectiv.  15. R\u0103spuns corect: e)  Indica\u021bii: Pentru a ob\u0163ine media dorit\u0103, variabila ev nu este validat\u0103 dac\u0103 apelul  func\u0163iei medie nu se reg\u0103se\u015fte \u00een intervalul de valori [x-0.5; x+0.5).", "sentences": ["318    Indica\u021bii: Pentru a ajunge la o anumit\u0103 liter\u0103 din \u015firul de caractere strada, va  trebui mai \u00eent\u00e2i accesat un element din tablou (v[5]), iar apoi c\u00e2mpul adresa.", " 11.", "R\u0103spuns corect: c)  Indica\u021bii: La prima deschidere a fi\u015fierului se vor citi toate valorile existente \u00een acesta,  iar la cea de-a doua se vor citi doar primele n-1 valori care includ \u015fi valoarea citit\u0103  initial \u00een n.   12.", "R\u0103spuns corect: a)  Indica\u021bii: Se caut\u0103 valoarea raportului dintre suma cifrelor (ob\u0163inut\u0103 prin apelul  f(n)) \u015fi num\u0103rul de cifre calculat \u00een variabila c.  13.", "R\u0103spuns corect: e)  Indica\u021bii: Se lipesc primele dou\u0103 caractere din \u015firul p la ceea ce a r\u0103mas \u00een s dup\u0103  eliminarea de caractere.", " 14.", "R\u0103spuns corect: b)   Indica\u021bii: Secven\u0163a parcurge \u00een spiral\u0103 \u00een sensul acelor de ceasornic elementele  tabloului respectiv.", " 15.", "R\u0103spuns corect: e)  Indica\u021bii: Pentru a ob\u0163ine media dorit\u0103, variabila ev nu este validat\u0103 dac\u0103 apelul  func\u0163iei medie nu se reg\u0103se\u015fte \u00een intervalul de valori [x-0.5; x+0.5)."], "page_sentence_count_spacy": 9}, {"page_number": 319, "page_char_count": 1677, "page_word_count": 307, "page_sentence_count_raw": 20, "page_token_count": 419.25, "text": "319    Varianta 38    1. R\u0103spuns corect: f)  Indica\u021bii: Termenii \u015firului lui Fibonacci: 1,1,2,3,5,8,13,21,34,55, \u2026  Primii cinci termeni impari diferi\u0163i duc la suma: 1+3+5+13+21= 43  2. R\u0103spuns corect: b)   Indica\u021bii: Reprezentarea grafic\u0103 a respectivului arbore este:      3. R\u0103spuns corect: d)  Indica\u021bii: Num\u0103rul minim de \u00eencerc\u0103ri este ob\u0163inut la depistarea parolei \u00eenc\u0103 de la  prima testare, iar num\u0103rul maxim este dat de formula num\u0103r total caractere   (52+10= 62)num\u0103r caractere parol\u0103  4. R\u0103spuns corect: b)  Indica\u021bii: Muchia [1, 6] va deveni muchia [3,6].  5. R\u0103spuns corect: f)  Indica\u021bii: Calculul valorii variabilei d se va opri \u00een momentul \u00een care variabila i va  ajunge la valoarea 0.  6. R\u0103spuns corect: f)  Indica\u021bii: Elementele de pe pozi\u0163ii pare nu vor primi valori din fi\u015fier \u015fi prin urmare  elementul v[8] are valoarea 0 ob\u0163inut\u0103 din declararea vectorului ca parametru  global.  7. R\u0103spuns corect: d)  Indica\u021bii: Se vor afi\u015fa elementele tabloului pe 4 linii \u015fi 3 coloane respect\u00e2nd formula  de calcul i+j.  8. R\u0103spuns corect: e)  Indica\u021bii: Variabila k va trece prin to\u0163i termenii de la 0 la 10, iar variabila p va  dezvolta pentru fiecare termen k \u00eenmul\u0163irile cu 0,1,\u2026 10.  9. R\u0103spuns corect: a)  Indica\u021bii: Secven\u0163a va \u015fterge pe r\u00e2nd fiecare apari\u0163ie a sub\u015firului test \u00een ordinea  apari\u0163iei acestora \u00een \u015firul ini\u0163ial  10. R\u0103spuns corect: c)   Indica\u021bii: Secven\u0163a folose\u015fte formula de calcul matematic al produsului dintre dou\u0103  matrice.   11. R\u0103spuns corect: e)  Indica\u021bii: Variabila c va parcurge toate caracterele aflate \u00eentre literele mici m \u015fi r,  dar la afi\u015fare se vor trece cele ce ocupa 5 pozi\u0163ii \u00een urm\u0103, respectiv hijklm.  12. R\u0103spuns corect: a)", "sentences": ["319    Varianta 38    1.", "R\u0103spuns corect: f)  Indica\u021bii: Termenii \u015firului lui Fibonacci: 1,1,2,3,5,8,13,21,34,55, \u2026  Primii cinci termeni impari diferi\u0163i duc la suma: 1+3+5+13+21= 43  2.", "R\u0103spuns corect: b)   Indica\u021bii: Reprezentarea grafic\u0103 a respectivului arbore este:      3.", "R\u0103spuns corect: d)  Indica\u021bii: Num\u0103rul minim de \u00eencerc\u0103ri este ob\u0163inut la depistarea parolei \u00eenc\u0103 de la  prima testare, iar num\u0103rul maxim este dat de formula num\u0103r total caractere   (52+10= 62)num\u0103r caractere parol\u0103  4.", "R\u0103spuns corect: b)  Indica\u021bii: Muchia [1, 6] va deveni muchia [3,6].", " 5.", "R\u0103spuns corect: f)  Indica\u021bii: Calculul valorii variabilei d se va opri \u00een momentul \u00een care variabila i va  ajunge la valoarea 0.", " 6.", "R\u0103spuns corect: f)  Indica\u021bii: Elementele de pe pozi\u0163ii pare nu vor primi valori din fi\u015fier \u015fi prin urmare  elementul v[8] are valoarea 0 ob\u0163inut\u0103 din declararea vectorului ca parametru  global.", " 7.", "R\u0103spuns corect: d)  Indica\u021bii: Se vor afi\u015fa elementele tabloului pe 4 linii \u015fi 3 coloane respect\u00e2nd formula  de calcul i+j.", " 8.", "R\u0103spuns corect: e)  Indica\u021bii: Variabila k va trece prin to\u0163i termenii de la 0 la 10, iar variabila p va  dezvolta pentru fiecare termen k \u00eenmul\u0163irile cu 0,1,\u2026 10.", " 9.", "R\u0103spuns corect: a)  Indica\u021bii: Secven\u0163a va \u015fterge pe r\u00e2nd fiecare apari\u0163ie a sub\u015firului test \u00een ordinea  apari\u0163iei acestora \u00een \u015firul ini\u0163ial  10.", "R\u0103spuns corect: c)   Indica\u021bii: Secven\u0163a folose\u015fte formula de calcul matematic al produsului dintre dou\u0103  matrice.", "  11.", "R\u0103spuns corect: e)  Indica\u021bii: Variabila c va parcurge toate caracterele aflate \u00eentre literele mici m \u015fi r,  dar la afi\u015fare se vor trece cele ce ocupa 5 pozi\u0163ii \u00een urm\u0103, respectiv hijklm.", " 12.", "R\u0103spuns corect: a)"], "page_sentence_count_spacy": 20}, {"page_number": 320, "page_char_count": 950, "page_word_count": 165, "page_sentence_count_raw": 8, "page_token_count": 237.5, "text": "320    Indica\u021bii: Secven\u0163a duce \u00een prima parte la r\u0103sturnarea caracterelor din cadrul \u015firului  de caractere, dar acestea vor fi repozi\u0163ionate \u00een formatul ini\u0163ial \u00een a doua jum\u0103tate a  instruc\u0163iunii repetitive.  13. R\u0103spuns corect: d)  Indica\u021bii: Se citesc pe r\u00e2nd datele corespunz\u0103toare celor trei elevi, iar \u00een paralel \u00een s  se calculeaz\u0103 suma tuturor notelor din fi\u015fierul de intrare. Dac\u0103 din variabila s se scade  valoarea 71, se va ob\u0163ine suma notelor lui Sebby, prin urmare expresia afi\u015fat\u0103  reprezint\u0103 media acestuia.  14. R\u0103spuns corect: a)  Indica\u021bii: Dac\u0103 diferen\u0163a dintre componenta de pe pozi\u0163ia curent\u0103 si cea anterioar\u0103  nu respect\u0103 ra\u0163ia dintre primele dou\u0103 componente, variabila ev va primi valoarea 0  ce indic\u0103 o valoare invalid\u0103.   15. R\u0103spuns corect: c)  Indica\u021bii: Se parcurg \u00een paralel cele dou\u0103 diagonale \u015fi se interschimb\u0103 fiecare  element de pe diagonala principal\u0103(ai, i) cu fiecare element de pe cea secundar\u0103   (ai, n-i+1).", "sentences": ["320    Indica\u021bii: Secven\u0163a duce \u00een prima parte la r\u0103sturnarea caracterelor din cadrul \u015firului  de caractere, dar acestea vor fi repozi\u0163ionate \u00een formatul ini\u0163ial \u00een a doua jum\u0103tate a  instruc\u0163iunii repetitive.", " 13.", "R\u0103spuns corect: d)  Indica\u021bii: Se citesc pe r\u00e2nd datele corespunz\u0103toare celor trei elevi, iar \u00een paralel \u00een s  se calculeaz\u0103 suma tuturor notelor din fi\u015fierul de intrare.", "Dac\u0103 din variabila s se scade  valoarea 71, se va ob\u0163ine suma notelor lui Sebby, prin urmare expresia afi\u015fat\u0103  reprezint\u0103 media acestuia.", " 14.", "R\u0103spuns corect: a)  Indica\u021bii: Dac\u0103 diferen\u0163a dintre componenta de pe pozi\u0163ia curent\u0103 si cea anterioar\u0103  nu respect\u0103 ra\u0163ia dintre primele dou\u0103 componente, variabila ev va primi valoarea 0  ce indic\u0103 o valoare invalid\u0103.", "  15.", "R\u0103spuns corect: c)  Indica\u021bii: Se parcurg \u00een paralel cele dou\u0103 diagonale \u015fi se interschimb\u0103 fiecare  element de pe diagonala principal\u0103(ai, i) cu fiecare element de pe cea secundar\u0103   (ai, n-i+1)."], "page_sentence_count_spacy": 8}, {"page_number": 321, "page_char_count": 1935, "page_word_count": 388, "page_sentence_count_raw": 18, "page_token_count": 483.75, "text": "321    Varianta 39  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: c) a \u0219i -1  Indica\u021bii: Din num\u0103rul total de valori din \u0219ir, 100,  elimin\u0103 num\u0103rul cifrelor din \u0219ir  2.  R\u0103spuns corect: e) VBPRE  3.  R\u0103spuns corect: e) patru  Indica\u021bii: Primele patru elemente din tablou primesc valoarea 9  4.  R\u0103spuns corect: c) 2  Indica\u021bii: dup\u0103 prima parcurgere 51 ajunge pe pozi\u021bia final\u0103, dup\u0103 cea de-a doua  parcurgere 40 ajunge pe pozi\u021bia final\u0103  5.  R\u0103spuns corect:      Limbajul C++/C   b) (i<j)&&(i+j<n+1)  Limbajul Pascal    b) (i<j)AND(i+j<n+1)  Indica\u021bii: Condi\u021bia stabile\u0219te o intersec\u021bie pe cele dou\u0103 zone: zona aflat\u0103 deasupra  diagonalei principale (i<j) \u0219i zona aflat\u0103 deasupra diagonalei secundare (i+j<n+1)  6.  R\u0103spuns corect: e) 12  Indica\u021bii: Graful neorientat cu 8 noduri \u015fi 28 de muchii este un graf complet. Pentru un  num\u0103r minim de muchii eliminate se aleg 2 componente conexe astfel: o component  conex\u0103 cu 2 noduri \u0219i o component\u0103 conex\u0103 cu 6 noduri, se vor elimina 6+6=12 muchii.   7.  R\u0103spuns corect:    Limbajul C++/C  a) x*y>y*z && x*z>y*z  Limbajul Pascal   a) (x*y>y*z) AND(x*z>y*z)  8.  R\u0103spuns corect:   Limbajul C++/C   b) (x>1000) && ((x*x*x) % 1000 == 0)  Limbajul Pascal    b) (x>1000) AND ((x*x*x) MOD 1000 = 0)  Indica\u021bii: x=36*35=1260  9.  R\u0103spuns corect: f) [log 2 n]+1  10.  R\u0103spuns corect: d) 45  11.  R\u0103spuns corect: c)  este conex \u0219i suma elementelor de pe fiecare coloan\u0103 a matricei de  adiacen\u021b\u0103 este num\u0103r par  12.  R\u0103spuns corect: a) 8  7  20  12  13.  R\u0103spuns corect: e) 12600  Indica\u021bii: \ud835\udc3610 1 \u2217\ud835\udc369 2 \u2217\ud835\udc367 3*\ud835\udc364 4=10*36*35*1=12600 \u0219iruri distincte  14.  R\u0103spuns corect: b) 8  Indica\u021bii: Pentru fiecare nod ales drept nod r\u0103d\u0103cin\u0103, exist\u0103 un singur vector de ta\u021bi  15.  R\u0103spuns corect: b) verific\u0103 dac\u0103 num\u0103rul x este divizibil cu b-1  Indica\u021bii: Se aplic\u0103 criteriul de divizibilitate: un num\u0103r natural scris \u00een baz\u0103 b se divide  cu b-1 dac\u0103 \u0219i numai dac\u0103 suma cifrelor sale este un multiplu de b-1.", "sentences": ["321    Varianta 39  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: c) a \u0219i -1  Indica\u021bii: Din num\u0103rul total de valori din \u0219ir, 100,  elimin\u0103 num\u0103rul cifrelor din \u0219ir  2.", " R\u0103spuns corect: e) VBPRE  3.", " R\u0103spuns corect: e) patru  Indica\u021bii: Primele patru elemente din tablou primesc valoarea 9  4.", " R\u0103spuns corect: c) 2  Indica\u021bii: dup\u0103 prima parcurgere 51 ajunge pe pozi\u021bia final\u0103, dup\u0103 cea de-a doua  parcurgere 40 ajunge pe pozi\u021bia final\u0103  5.", " R\u0103spuns corect:      Limbajul C++/C   b) (i<j)&&(i+j<n+1)  Limbajul Pascal    b) (i<j)AND(i+j<n+1)  Indica\u021bii: Condi\u021bia stabile\u0219te o intersec\u021bie pe cele dou\u0103 zone: zona aflat\u0103 deasupra  diagonalei principale (i<j) \u0219i zona aflat\u0103 deasupra diagonalei secundare (i+j<n+1)  6.", " R\u0103spuns corect: e) 12  Indica\u021bii: Graful neorientat cu 8 noduri \u015fi 28 de muchii este un graf complet.", "Pentru un  num\u0103r minim de muchii eliminate se aleg 2 componente conexe astfel: o component  conex\u0103 cu 2 noduri \u0219i o component\u0103 conex\u0103 cu 6 noduri, se vor elimina 6+6=12 muchii.", "  7.", " R\u0103spuns corect:    Limbajul C++/C  a) x*y>y*z && x*z>y*z  Limbajul Pascal   a) (x*y>y*z) AND(x*z>y*z)  8.", " R\u0103spuns corect:   Limbajul C++/C   b) (x>1000) && ((x*x*x) % 1000 == 0)  Limbajul Pascal    b) (x>1000) AND ((x*x*x) MOD 1000 = 0)  Indica\u021bii: x=36*35=1260  9.", " R\u0103spuns corect: f) [log 2 n]+1  10.", " R\u0103spuns corect: d) 45  11.", " R\u0103spuns corect: c)  este conex \u0219i suma elementelor de pe fiecare coloan\u0103 a matricei de  adiacen\u021b\u0103 este num\u0103r par  12.", " R\u0103spuns corect: a) 8  7  20  12  13.", " R\u0103spuns corect: e) 12600  Indica\u021bii: \ud835\udc3610 1 \u2217\ud835\udc369 2 \u2217\ud835\udc367 3*\ud835\udc364 4=10*36*35*1=12600 \u0219iruri distincte  14.", " R\u0103spuns corect: b) 8  Indica\u021bii: Pentru fiecare nod ales drept nod r\u0103d\u0103cin\u0103, exist\u0103 un singur vector de ta\u021bi  15.", " R\u0103spuns corect: b) verific\u0103 dac\u0103 num\u0103rul x este divizibil cu b-1  Indica\u021bii: Se aplic\u0103 criteriul de divizibilitate: un num\u0103r natural scris \u00een baz\u0103 b se divide  cu b-1 dac\u0103 \u0219i numai dac\u0103 suma cifrelor sale este un multiplu de b-1."], "page_sentence_count_spacy": 18}, {"page_number": 322, "page_char_count": 2011, "page_word_count": 372, "page_sentence_count_raw": 25, "page_token_count": 502.75, "text": "322    Varianta 40  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: d) 63  Indica\u021bii: f(63)=f(62)+63=\u2026=f(4)+5+6+\u2026+63=8+(5+6+\u2026+63)=2014  2.  R\u0103spuns corect: e) 50  3.  R\u0103spuns corect: c) studentarterou  Indica\u021bii: La primul \u0219ir se concateneaz\u0103 cel de-al doilea \u0219ir, mai pu\u021bin primul caracter,  apoi se concateneaz\u0103 cel de-al treilea \u0219ir, mai pu\u021bin primele dou\u0103 caractere.  4.  R\u0103spuns corect: d) oricare ar fi x,y,z, p egal cu q  Indica\u021bii: cele dou\u0103 expresii sunt echivalente  5.  R\u0103spuns corect: c) 130  6.  R\u0103spuns corect: a) [-2n-1, 2n-1 -1]  Indica\u021bii: primul bit, din reprezentare, este cel de semn (0- pentru numere \u00eentregi  pozitive \u0219i 1- pentru numere \u00eentregi negative), ceilal\u021bi n-1 bi\u021bi sunt folosi\u021bi pentru  reprezentarea valorii absolute a num\u0103rului.  7.  R\u0103spuns corect: b) 16  Indica\u021bii: se intr\u0103 o singur\u0103 dat\u0103 \u00een instruc\u021biunea while, variabila p nu se modific\u0103  8.  R\u0103spuns corect: b) 7,16,10  Indica\u021bii: se \u00eenjum\u0103t\u0103\u021be\u0219te secven\u021ba curent\u0103 \u00een care se face c\u0103utarea  9.  R\u0103spuns corect: e) 777  Indica\u021bii: Num\u0103rul valorilor de 1 din tabloul bidimensional, pe linii, este 1 + 2 + 4 + 8 +  16 + 32 + 64 + 128 = 255. Tabloul are 8 linii \u0219i 129 coloane. De unde, num\u0103rul de valori  0 este: (129-1) + (129-2) + \u2026 + (129-128) = 777  10.  R\u0103spuns corect: a) 377  Indica\u021bii: se pot folosi termenii din \u0219irul lui Fibonacci  11.  R\u0103spuns corect: c) 11  Indica\u021bii: Graful neorientat are 20 de muchii care formeaz\u0103 o component\u0103 conex\u0103  folosind 7 noduri. R\u0103m\u00e2n 10 noduri izolate.  12.  R\u0103spuns corect: b) 13  Indica\u021bii: 2 \u0219i toate numerele impare cuprinse \u00eentre 3 \u0219i [sqrt(681)]  13.  R\u0103spuns corect: d) 101  Indica\u021bii: Num\u0103rul total de permut\u0103ri cu 5 elemente este 5!=120. Dup\u0103 permutarea  51423 se mai genereaz\u0103 \u00eenc\u0103 19 termeni.  14.  R\u0103spuns corect: b) A,B  Indica\u021bii: c.m.m.m.c(m,n)=m*n/c.m.m.d.c(m,n)  15.  R\u0103spuns corect: f) 413  Indica\u021bii: Num\u0103rul grafurilor neorientate cu 8 noduri este 228. Num\u0103rul grafurilor  neorientate cu 8 noduri, \u00een care nodurile 2 \u0219i 3 sunt neadiacente, este 228/2=227 , s.a.m.d.", "sentences": ["322    Varianta 40  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: d) 63  Indica\u021bii: f(63)=f(62)+63=\u2026=f(4)+5+6+\u2026+63=8+(5+6+\u2026+63)=2014  2.", " R\u0103spuns corect: e) 50  3.", " R\u0103spuns corect: c) studentarterou  Indica\u021bii: La primul \u0219ir se concateneaz\u0103 cel de-al doilea \u0219ir, mai pu\u021bin primul caracter,  apoi se concateneaz\u0103 cel de-al treilea \u0219ir, mai pu\u021bin primele dou\u0103 caractere.", " 4.", " R\u0103spuns corect: d) oricare ar fi x,y,z, p egal cu q  Indica\u021bii: cele dou\u0103 expresii sunt echivalente  5.", " R\u0103spuns corect: c) 130  6.", " R\u0103spuns corect: a) [-2n-1, 2n-1 -1]  Indica\u021bii: primul bit, din reprezentare, este cel de semn (0- pentru numere \u00eentregi  pozitive \u0219i 1- pentru numere \u00eentregi negative), ceilal\u021bi n-1 bi\u021bi sunt folosi\u021bi pentru  reprezentarea valorii absolute a num\u0103rului.", " 7.", " R\u0103spuns corect: b) 16  Indica\u021bii: se intr\u0103 o singur\u0103 dat\u0103 \u00een instruc\u021biunea while, variabila p nu se modific\u0103  8.", " R\u0103spuns corect: b) 7,16,10  Indica\u021bii: se \u00eenjum\u0103t\u0103\u021be\u0219te secven\u021ba curent\u0103 \u00een care se face c\u0103utarea  9.", " R\u0103spuns corect: e) 777  Indica\u021bii: Num\u0103rul valorilor de 1 din tabloul bidimensional, pe linii, este 1 + 2 + 4 + 8 +  16 + 32 + 64 + 128 = 255.", "Tabloul are 8 linii \u0219i 129 coloane.", "De unde, num\u0103rul de valori  0 este: (129-1) + (129-2) + \u2026 + (129-128) = 777  10.", " R\u0103spuns corect: a) 377  Indica\u021bii: se pot folosi termenii din \u0219irul lui Fibonacci  11.", " R\u0103spuns corect: c) 11  Indica\u021bii: Graful neorientat are 20 de muchii care formeaz\u0103 o component\u0103 conex\u0103  folosind 7 noduri.", "R\u0103m\u00e2n 10 noduri izolate.", " 12.", " R\u0103spuns corect: b) 13  Indica\u021bii: 2 \u0219i toate numerele impare cuprinse \u00eentre 3 \u0219i [sqrt(681)]  13.", " R\u0103spuns corect: d) 101  Indica\u021bii: Num\u0103rul total de permut\u0103ri cu 5 elemente este 5!=120.", "Dup\u0103 permutarea  51423 se mai genereaz\u0103 \u00eenc\u0103 19 termeni.", " 14.", " R\u0103spuns corect: b) A,B  Indica\u021bii: c.m.m.m.c(m,n)=m*n/c.m.m.d.c(m,n)  15.", " R\u0103spuns corect: f) 413  Indica\u021bii: Num\u0103rul grafurilor neorientate cu 8 noduri este 228.", "Num\u0103rul grafurilor  neorientate cu 8 noduri, \u00een care nodurile 2 \u0219i 3 sunt neadiacente, este 228/2=227 , s.a.m.d."], "page_sentence_count_spacy": 25}, {"page_number": 323, "page_char_count": 2327, "page_word_count": 537, "page_sentence_count_raw": 24, "page_token_count": 581.75, "text": "323    Varianta 41  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect:a) exact n(n-1)/2 \u2013m   Indica\u021bii: Graful G1 va con\u0163ine muchiile  grafului complementar al lui G (dac\u0103 \u00een G  exist\u0103 o muchie \u00een G1 nu va exista). Din graful complet cu n noduri \u015fi n(n-1)/2 muchhi  se scad muchiile grafului G, m  2.  R\u0103spuns corect: f) x<=d  Indica\u021bii: Func\u0163ia descompune \u00een factori primi un num\u0103r. C\u00e2nd num\u0103rul x devinde egal  cu divizorul atunci num\u0103rul x este un factor prim la puterea 1  3.  R\u0103spuns corect: d) 4  Indica\u021bii: Se parcurge vectorul pentru c\u0103utarea valorii x, repeti\u0163ia oprindu-se la prima  apari\u0163ie a valorii x \u00een vector sau dup\u0103 ce toate elementele au fost parcurse dac\u0103 x nu  apare \u00een vector.    4.  R\u0103spuns corect: d) 128  Indica\u021bii: Exist\u0103 \u015firul de apeluri: F(7), F(6)\u2026 F(0) care duce la valorile returnate de la  st\u00e2nga la dreapta 1, 2*1, 2*2, 2*4, 2*8, 2*16, 2*32, 2*64=128  5.  R\u0103spuns corect:   c) CDEFGEFG   Indica\u021bii. Se memoreaz\u0103 \u015firul de caractere \u00eencep\u00e2nd de la pozi\u0163ia 4 (C) \u2502 5 (Pascal)  apoi \u015firul \u00eencep\u00e2nd de la pozi\u0163ia 2 (C) \u2502 3 (Pascal) \u015fi apoi se concateneaz\u0103 aceste dou\u0103  \u015firuri.  6.  R\u0103spuns corect: d) B,C  Indica\u021bii: La evaluare se \u0163ine cont de prioritatea operatorilor    7.  R\u0103spuns corect:  b) BEC BED CAB   Indica\u021bii: Se pleac\u0103 de la variantele propuse \u015fi aplic\u00e2nd metoda backtracking se  genereaz\u0103 urm\u0103toarele solu\u0163ii.  8.  R\u0103spuns corect: a) de 5 ori     9.  R\u0103spuns corect: f) 0   Indica\u021bii: Fiecare nod n are ca fii nodurile 2n \u015fi 2n+1. Fiind num\u0103r impar nu r\u0103m\u00e2ne nici  un nod cu un fiu.  10.  R\u0103spuns corect: e) n(n-1)/2  Indica\u021bii: Ini\u0163ial vectorul este ordonat cresc\u0103tor, deci se face num\u0103rul maxim de  interschimb\u0103ri.  11.  R\u0103spuns corect: c) n=5, U={[1,3], [1,4], [3,4], [2,4], [4,5], [2,5]}  Indica\u021bii: Se deseneaz\u0103 fiecare graf. Ca s\u0103 fie eulerian trebuie ca s\u0103 existe un ciclu care  s\u0103 con\u0163in\u0103 toate muchiile grafului o singur\u0103 dat\u0103 iar ca s\u0103 nu fie hamiltonian trebuie s\u0103 nu  existe niciun ciclu care s\u0103 con\u0163in\u0103 toate nodurile grafului o singur\u0103 dat\u0103.  12.  R\u0103spuns corect:   Limbajul C++/C   b) if(x>y && y>z)                                                  p=x*y*z;    Limbajul Pascal    b) if (x>y) AND (y>z)                                                then p:=x*y*z;  Indica\u021bii: Din proprietatea de tranzitivitate se observ\u0103 c\u0103 expresia logic\u0103 z>x are  \u00eentotdeauna valoare 1\u2502true.", "sentences": ["323    Varianta 41  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect:a) exact n(n-1)/2 \u2013m   Indica\u021bii: Graful G1 va con\u0163ine muchiile  grafului complementar al lui G (dac\u0103 \u00een G  exist\u0103 o muchie \u00een G1 nu va exista).", "Din graful complet cu n noduri \u015fi n(n-1)/2 muchhi  se scad muchiile grafului G, m  2.", " R\u0103spuns corect: f) x<=d  Indica\u021bii: Func\u0163ia descompune \u00een factori primi un num\u0103r.", "C\u00e2nd num\u0103rul x devinde egal  cu divizorul atunci num\u0103rul x este un factor prim la puterea 1  3.", " R\u0103spuns corect: d) 4  Indica\u021bii: Se parcurge vectorul pentru c\u0103utarea valorii x, repeti\u0163ia oprindu-se la prima  apari\u0163ie a valorii x \u00een vector sau dup\u0103 ce toate elementele au fost parcurse dac\u0103 x nu  apare \u00een vector.", "   4.", " R\u0103spuns corect: d) 128  Indica\u021bii: Exist\u0103 \u015firul de apeluri: F(7), F(6)\u2026 F(0) care duce la valorile returnate de la  st\u00e2nga la dreapta 1, 2*1, 2*2, 2*4, 2*8, 2*16, 2*32, 2*64=128  5.", " R\u0103spuns corect:   c) CDEFGEFG   Indica\u021bii.", "Se memoreaz\u0103 \u015firul de caractere \u00eencep\u00e2nd de la pozi\u0163ia 4 (C) \u2502 5 (Pascal)  apoi \u015firul \u00eencep\u00e2nd de la pozi\u0163ia 2 (C) \u2502 3 (Pascal) \u015fi apoi se concateneaz\u0103 aceste dou\u0103  \u015firuri.", " 6.", " R\u0103spuns corect: d) B,C  Indica\u021bii: La evaluare se \u0163ine cont de prioritatea operatorilor    7.", " R\u0103spuns corect:  b) BEC BED CAB   Indica\u021bii: Se pleac\u0103 de la variantele propuse \u015fi aplic\u00e2nd metoda backtracking se  genereaz\u0103 urm\u0103toarele solu\u0163ii.", " 8.", " R\u0103spuns corect: a) de 5 ori     9.", " R\u0103spuns corect: f) 0   Indica\u021bii: Fiecare nod n are ca fii nodurile 2n \u015fi 2n+1.", "Fiind num\u0103r impar nu r\u0103m\u00e2ne nici  un nod cu un fiu.", " 10.", " R\u0103spuns corect: e) n(n-1)/2  Indica\u021bii: Ini\u0163ial vectorul este ordonat cresc\u0103tor, deci se face num\u0103rul maxim de  interschimb\u0103ri.", " 11.", " R\u0103spuns corect: c) n=5, U={[1,3], [1,4], [3,4], [2,4], [4,5], [2,5]}  Indica\u021bii: Se deseneaz\u0103 fiecare graf.", "Ca s\u0103 fie eulerian trebuie ca s\u0103 existe un ciclu care  s\u0103 con\u0163in\u0103 toate muchiile grafului o singur\u0103 dat\u0103 iar ca s\u0103 nu fie hamiltonian trebuie s\u0103 nu  existe niciun ciclu care s\u0103 con\u0163in\u0103 toate nodurile grafului o singur\u0103 dat\u0103.", " 12.", " R\u0103spuns corect:   Limbajul C++/C   b) if(x>y && y>z)                                                  p=x*y*z;    Limbajul Pascal    b) if (x>y) AND (y>z)                                                then p:=x*y*z;  Indica\u021bii: Din proprietatea de tranzitivitate se observ\u0103 c\u0103 expresia logic\u0103 z>x are  \u00eentotdeauna valoare 1\u2502true."], "page_sentence_count_spacy": 24}, {"page_number": 324, "page_char_count": 365, "page_word_count": 70, "page_sentence_count_raw": 5, "page_token_count": 91.25, "text": "324    13.  R\u0103spuns corect:  b) cuprins \u00eentre 7 \u0219i 12  Indica\u021bii: Num\u0103rul de \u00eenjum\u0103t\u0103\u0163iri este log1000  14.  R\u0103spuns corect: a) A  Indica\u021bii: Se folose\u015fte algoritmul care modific\u0103 num\u0103rul prin adunarea ultimei cifre la  c\u00e2tul \u00eemp\u0103r\u0163irii la 10 p\u00e2n\u0103 c\u00e2nd se ob\u0163ine un num\u0103r care are o singur\u0103 cifr\u0103.   15.  R\u0103spuns corect: c) 94  Indica\u021bii: 1+3+3x2+3x22+3x23+3x24= 94", "sentences": ["324    13.", " R\u0103spuns corect:  b) cuprins \u00eentre 7 \u0219i 12  Indica\u021bii: Num\u0103rul de \u00eenjum\u0103t\u0103\u0163iri este log1000  14.", " R\u0103spuns corect: a) A  Indica\u021bii: Se folose\u015fte algoritmul care modific\u0103 num\u0103rul prin adunarea ultimei cifre la  c\u00e2tul \u00eemp\u0103r\u0163irii la 10 p\u00e2n\u0103 c\u00e2nd se ob\u0163ine un num\u0103r care are o singur\u0103 cifr\u0103.", "  15.", " R\u0103spuns corect: c) 94  Indica\u021bii: 1+3+3x2+3x22+3x23+3x24= 94"], "page_sentence_count_spacy": 5}, {"page_number": 325, "page_char_count": 2459, "page_word_count": 479, "page_sentence_count_raw": 33, "page_token_count": 614.75, "text": "325    Varianta 42  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: d) 6  Indica\u021bii: Subprogramul se apeleaz\u0103 pe prima jum\u0103tate (de la n la (n+m)/2) \u015fi pe a doua  ((n+m)/2 +1 p\u00e2n\u0103 la m) adun\u00e2nd restul fiec\u0103rui element la imparitrea cu 2.  2.  R\u0103spuns corect: a) Numai S1  Indica\u021bii:  S1 func\u0163ioneaz\u0103 c\u00e2t timp exist\u0103 litera \u00een \u015fir \u015fi c\u00e2t timp caracterele sunt diferite  de litere mari. Asemeni cel de-al doilea. C\u00e2nd se opresc afi\u015feaz\u0103 caracterul la care s-au  oprit.  3.  R\u0103spuns corect: d) 1+2=3       Indica\u021bii:  Se trece peste primele dou\u0103 litere , c\u00e2nd se ajunge la primul 1 se schimb\u0103  urm\u0103torul cu caracterul  +. Se trece la primul  caracter de 2, urm\u0103torul dup\u0103 acesta fiind  schimbat \u00een caracterul  =, urm\u00e2nd ca mai apoi s\u0103 r\u0103m\u00e2n\u0103 la final doar caracterul  3.  4.  R\u0103spuns corect: d) trei  Indica\u021bii: Se parcurg elementele p\u00e2n\u0103 la \u00eent\u00e2lnirea lui 0, pentru i>0.  5.  R\u0103spuns corect:   f) Cea mai lung\u0103 secven\u021b\u0103 de valori de parit\u0103\u021bi diferite   Indica\u021bii: Se parcurge vectorul num\u0103r\u00e2nd elementele consecutive de pafit\u0103\u021bi diferite.  Dac\u0103 se ajunge la un element de aceea\u0219i paritate cu cel de dinainte se reseteaz\u0103 lungimea  secven\u021bei \u0219i se analizeaz\u0103 lungimea maxim\u0103.  6.  R\u0103spuns corect: f) 62    7.  R\u0103spuns corect:  e) C2n-p+1    8.  R\u0103spuns corect: c)  j*j+suma(j*j-1)    9.  R\u0103spuns corect: b)  1  Indica\u021bii: Se repet\u0103 o singur\u0103 dat\u0103 pentru c\u0103 se evalueaz\u0103 v[0], care este 0, deci  repeti\u021biea se opre\u0219te, \u0219i apoi se incrementeaz\u0103 i.   10.  R\u0103spuns corect: d) 25  Indica\u021bii: Pe nivelul 0, se g\u0103se\u0219te un nod (r\u0103d\u0103cina), pe nivelul 1, 2 noduri, pe nivelul 2,  4 noduri, pe nivelul 3, 8 noduri, pe nivelul 4, 16 noduri iar nivelul 5 32 noduri.  11.  R\u0103spuns corect: d) 1023; 1032; 105; 1203;  Indica\u021bii: Se porne\u0219te de la o solu\u021bie propus\u0103 \u0219i se genereaz\u0103 cu algoritmul backtracking  celelalte solu\u021bii.   12.  R\u0103spuns corect: a) metoda c\u0103ut\u0103rii binare  Indica\u021bii: Sunt 2 metode de c\u0103utare: secven\u021bial\u0103 \u0219i binar\u0103. Eficient\u0103 este metoda c\u0103ut\u0103rii  binare pentru care se efectueaz\u0103 log(n) opera\u021bii.  13.  R\u0103spuns corect:  d) permut\u0103rilor  Indica\u021bii: Se folose\u0219te metoda backtracking. Coloanele din matrice vor reprezenta  elementele care se genereaz\u0103.  14.  R\u0103spuns corect: f ) 20  Indica\u021bii: Vor exista doar muchii \u00een care extremitatea ini\u021bial\u0103 este mai mic\u0103 dec\u00e2t  extremitatea final\u0103. Deci, dac\u0103 exist\u0103 drumul de la i la j, \u00een care nodurile sunt \u00een ordine  cresc\u0103toare, nu va exista drumul de la j la i. Deci, fiecare nod formeaz\u0103 o component\u0103  tare conex\u0103.", "sentences": ["325    Varianta 42  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: d) 6  Indica\u021bii: Subprogramul se apeleaz\u0103 pe prima jum\u0103tate (de la n la (n+m)/2) \u015fi pe a doua  ((n+m)/2 +1 p\u00e2n\u0103 la m) adun\u00e2nd restul fiec\u0103rui element la imparitrea cu 2.", " 2.", " R\u0103spuns corect: a) Numai S1  Indica\u021bii:  S1 func\u0163ioneaz\u0103 c\u00e2t timp exist\u0103 litera \u00een \u015fir \u015fi c\u00e2t timp caracterele sunt diferite  de litere mari.", "Asemeni cel de-al doilea.", "C\u00e2nd se opresc afi\u015feaz\u0103 caracterul la care s-au  oprit.", " 3.", " R\u0103spuns corect: d) 1+2=3       Indica\u021bii:  Se trece peste primele dou\u0103 litere , c\u00e2nd se ajunge la primul 1 se schimb\u0103  urm\u0103torul cu caracterul  +.", "Se trece la primul  caracter de 2, urm\u0103torul dup\u0103 acesta fiind  schimbat \u00een caracterul  =, urm\u00e2nd ca mai apoi s\u0103 r\u0103m\u00e2n\u0103 la final doar caracterul  3.", " 4.", " R\u0103spuns corect: d) trei  Indica\u021bii: Se parcurg elementele p\u00e2n\u0103 la \u00eent\u00e2lnirea lui 0, pentru i>0.", " 5.", " R\u0103spuns corect:   f) Cea mai lung\u0103 secven\u021b\u0103 de valori de parit\u0103\u021bi diferite   Indica\u021bii: Se parcurge vectorul num\u0103r\u00e2nd elementele consecutive de pafit\u0103\u021bi diferite.", " Dac\u0103 se ajunge la un element de aceea\u0219i paritate cu cel de dinainte se reseteaz\u0103 lungimea  secven\u021bei \u0219i se analizeaz\u0103 lungimea maxim\u0103.", " 6.", " R\u0103spuns corect: f) 62    7.", " R\u0103spuns corect:  e) C2n-p+1    8.", " R\u0103spuns corect: c)  j*j+suma(j*j-1)    9.", " R\u0103spuns corect: b)  1  Indica\u021bii: Se repet\u0103 o singur\u0103 dat\u0103 pentru c\u0103 se evalueaz\u0103 v[0], care este 0, deci  repeti\u021biea se opre\u0219te, \u0219i apoi se incrementeaz\u0103 i.   10.", " R\u0103spuns corect: d) 25  Indica\u021bii: Pe nivelul 0, se g\u0103se\u0219te un nod (r\u0103d\u0103cina), pe nivelul 1, 2 noduri, pe nivelul 2,  4 noduri, pe nivelul 3, 8 noduri, pe nivelul 4, 16 noduri iar nivelul 5 32 noduri.", " 11.", " R\u0103spuns corect: d) 1023; 1032; 105; 1203;  Indica\u021bii: Se porne\u0219te de la o solu\u021bie propus\u0103 \u0219i se genereaz\u0103 cu algoritmul backtracking  celelalte solu\u021bii.", "  12.", " R\u0103spuns corect: a) metoda c\u0103ut\u0103rii binare  Indica\u021bii: Sunt 2 metode de c\u0103utare: secven\u021bial\u0103 \u0219i binar\u0103.", "Eficient\u0103 este metoda c\u0103ut\u0103rii  binare pentru care se efectueaz\u0103 log(n) opera\u021bii.", " 13.", " R\u0103spuns corect:  d) permut\u0103rilor  Indica\u021bii: Se folose\u0219te metoda backtracking.", "Coloanele din matrice vor reprezenta  elementele care se genereaz\u0103.", " 14.", " R\u0103spuns corect: f ) 20  Indica\u021bii: Vor exista doar muchii \u00een care extremitatea ini\u021bial\u0103 este mai mic\u0103 dec\u00e2t  extremitatea final\u0103.", "Deci, dac\u0103 exist\u0103 drumul de la i la j, \u00een care nodurile sunt \u00een ordine  cresc\u0103toare, nu va exista drumul de la j la i. Deci, fiecare nod formeaz\u0103 o component\u0103  tare conex\u0103."], "page_sentence_count_spacy": 31}, {"page_number": 326, "page_char_count": 113, "page_word_count": 25, "page_sentence_count_raw": 2, "page_token_count": 28.25, "text": "326    15.  R\u0103spuns corect: c) 13  Indica\u021bii: Se num\u0103r\u0103 num\u0103rul de \u00eenjum\u0103t\u0103\u021biri care se fac pentru a ajunge la 1.", "sentences": ["326    15.", " R\u0103spuns corect: c) 13  Indica\u021bii: Se num\u0103r\u0103 num\u0103rul de \u00eenjum\u0103t\u0103\u021biri care se fac pentru a ajunge la 1."], "page_sentence_count_spacy": 2}, {"page_number": 327, "page_char_count": 1691, "page_word_count": 343, "page_sentence_count_raw": 25, "page_token_count": 422.75, "text": "327    Varianta 43  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: b) 1  Indica\u021bii: Se execut\u0103 opera\u021biile matematice \u00een ordinea priorit\u0103\u021bii operatorilor.  2.  R\u0103spuns corect: e) 3.15  Indica\u021bii: Variabilelor i \u0219i j, fiind de tip \u00eentreg, li se atribuie [x] \u0219i, respectiv,  [y].    3.  R\u0103spuns corect: d) 0  Indica\u021bii: Se evalueaz\u0103 j\u22600 (F) \u0219i apoi operatorul de incrementare =>i=1. Pentru c\u0103 i\u22600 se  decrementeaz\u0103 =>i=0 \u0219i apoi se evalueaz\u0103 suma.   4.  R\u0103spuns corect: e) 51970  Indica\u021bii: Se introduc \u00een x cifrele impare din n, \u00een aceea\u0219i ordine, doar c\u0103 se \u00eencepe de la  cifra zecilor.  5.  R\u0103spuns corect: f) 8  Indica\u021bii: Se calculeaz\u0103 ultima cifr\u0103 nenul\u0103 a num\u0103rului n!.  6.  R\u0103spuns corect: d) 28 56 4 13 6 18 26 90 25  Indica\u021bii: Se \u0219terg elementele nule din tabloul unidimensional.  7.  R\u0103spuns corect: b) Informatica-poli  Indica\u021bii: Se determin\u0103 adresa de memorie a caracterului '-', \u00eemp\u0103r\u021bindu-se astfel \u0219irul  ini\u021bial \u00een dou\u0103 \u0219iruri de caractere. Apoi se concateneaz\u0103 al doilea \u0219ir cu primul, dup\u0103 ce  prima liter\u0103 a fiec\u0103rui \u0219ir se transform\u0103.  8.  R\u0103spuns corect: b) b  Indica\u021bii: Se declar\u0103 un tablou unidimensional cu 2 elemente de tip structur\u0103, fiecare  element con\u021bin\u00e2nd un pointer c\u0103tre un \u0219ir de caractere. C\u00e2mpului din a doua structur\u0103 i se  atribuie \u0219irul definit de la pozi\u021bia 1.  9.  R\u0103spuns corect: c) A \u0219i D  Indica\u021bii: Pentru a afla num\u0103rul de drumuri de lungime k dintre dou\u0103 noduri i \u0219i j \u00eentr-un  graf orientat, se calculeaz\u0103 matricea X=Ak, unde A este matricea de adiacen\u021b\u0103. Xi,j  reprezint\u0103 num\u0103rul de drumuri. Deci A=( 0 1 1 0 0 0 1 1 0 0 0 1 1 1 0 0 )\u0219i A3=( 2 2 0 1 1 1 0 1 0 1 2 1 1 1 1 3 ) Se  observ\u0103 c\u0103 \u00eentre A3[1,3]=A3[3][1]=0.  10.  R\u0103spuns corect: d) 4", "sentences": ["327    Varianta 43  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: b) 1  Indica\u021bii: Se execut\u0103 opera\u021biile matematice \u00een ordinea priorit\u0103\u021bii operatorilor.", " 2.", " R\u0103spuns corect: e) 3.15  Indica\u021bii: Variabilelor i \u0219i j, fiind de tip \u00eentreg, li se atribuie [x] \u0219i, respectiv,  [y].", "   3.", " R\u0103spuns corect: d) 0  Indica\u021bii: Se evalueaz\u0103 j\u22600 (F) \u0219i apoi operatorul de incrementare =>i=1.", "Pentru c\u0103 i\u22600 se  decrementeaz\u0103 =>i=0 \u0219i apoi se evalueaz\u0103 suma.", "  4.", " R\u0103spuns corect: e) 51970  Indica\u021bii: Se introduc \u00een x cifrele impare din n, \u00een aceea\u0219i ordine, doar c\u0103 se \u00eencepe de la  cifra zecilor.", " 5.", " R\u0103spuns corect: f) 8  Indica\u021bii: Se calculeaz\u0103 ultima cifr\u0103 nenul\u0103 a num\u0103rului n!.", " 6.", " R\u0103spuns corect: d) 28 56 4 13 6 18 26 90 25  Indica\u021bii: Se \u0219terg elementele nule din tabloul unidimensional.", " 7.", " R\u0103spuns corect: b) Informatica-poli  Indica\u021bii: Se determin\u0103 adresa de memorie a caracterului '-', \u00eemp\u0103r\u021bindu-se astfel \u0219irul  ini\u021bial \u00een dou\u0103 \u0219iruri de caractere.", "Apoi se concateneaz\u0103 al doilea \u0219ir cu primul, dup\u0103 ce  prima liter\u0103 a fiec\u0103rui \u0219ir se transform\u0103.", " 8.", " R\u0103spuns corect: b) b  Indica\u021bii: Se declar\u0103 un tablou unidimensional cu 2 elemente de tip structur\u0103, fiecare  element con\u021bin\u00e2nd un pointer c\u0103tre un \u0219ir de caractere.", "C\u00e2mpului din a doua structur\u0103 i se  atribuie \u0219irul definit de la pozi\u021bia 1.", " 9.", " R\u0103spuns corect: c) A \u0219i D  Indica\u021bii: Pentru a afla num\u0103rul de drumuri de lungime k dintre dou\u0103 noduri i \u0219i j \u00eentr-un  graf orientat, se calculeaz\u0103 matricea X=Ak, unde A este matricea de adiacen\u021b\u0103.", "Xi,j  reprezint\u0103 num\u0103rul de drumuri.", "Deci A=( 0 1 1 0 0 0 1 1 0 0 0 1 1 1 0 0 )\u0219i A3=( 2 2 0 1 1 1 0 1 0 1 2 1 1 1 1 3 ) Se  observ\u0103 c\u0103 \u00eentre A3[1,3]=A3[3][1]=0.", " 10.", " R\u0103spuns corect: d) 4"], "page_sentence_count_spacy": 25}, {"page_number": 328, "page_char_count": 1703, "page_word_count": 493, "page_sentence_count_raw": 15, "page_token_count": 425.75, "text": "328    Indica\u021bii: \u0218irul apelurilor este:f(0)  0<7 \u21d2    f(2)  2<7 \u21d2     f(4)  4<7 \u21d2     f(6)  6<7 \u21d2     f(8)  8>7 \u21d2    8-3 raspuns care  se returneaz\u0103 la apelul anterior, adun\u00e2ndu-se de fiecare dat\u0103 1. f(0)=7. Apoi se calculeaz\u0103  f(7)=2; f(2)=6 \u0219i f(6)=4.  11.  R\u0103spuns corect: c) 2 4 1 5 3                               5 1 4 2 3                               1 2 3 4 5                               5 4 3 2 1                                  4 1 5 3 2  Indica\u021bii: Se fac 3 permut\u0103ri circulare ale ultimelor 3 linii astfel \u00eenc\u00e2t matricea la final  revine la configura\u021bia ini\u021bial\u0103.  12.  R\u0103spuns corect: c) 7196                                       7198   Indica\u021bii: Dac\u0103 se porne\u0219te de la 7196  se continu\u0103 cu 7197 (incorect\u0103, se repet\u0103 cifra 7),  7 1 9 8, se revine la a doua cifr\u0103\u0219i se alege 2, dar fiind prim nu e permis, la fel 3 \u0219i se  ajunge la 4, apoi se continu\u0103 cu 0 \u0219i cu 1, adic\u0103 7401.   13.  R\u0103spuns corect: c) II \u0219i IV  Indica\u021bii: \u00censecven\u021ba IV, exist\u0103 un nod cu gradul 8, ceeace nu este posibil \u00eentr-un graf cu  8 noduri. \u00censecven\u021ba II, gradul 6 al celor 4 v\u00e2rfuri \u00eenseamn\u0103 18 muchii (nodul 1 incident  cu 6 muchii, nodul 2 incident cu 5 muchii (a \u0219asea fiind (1,2), deja num\u0103rat\u0103)) etc. Adic\u0103  6+5+4+3=18 muchii. Un exemplu posibil de graf ar fi:  Din secven\u021ba  dat\u0103: 6+6+6+6+3+3+2+2=34 => 17 (muchii contradic\u021bie).  14.  R\u0103spuns corect: b) O(n) pentru f1 \u0219i O(2n) pentru f2  Indica\u021bii: Am puteascriepentrufiecarefunc\u021bie, complexitatea timp, recurent, astfel:  T1(n)=T1(n-1)+C care este O(n)  T2(n)=2\u2219T2(n-1)+C care este O(2n)  15.  R\u0103spuns corect: a) O(log2k)  Indica\u021bii: Se calculeaz\u0103 nk \u00een timp logaritmic dup\u0103 urm\u0103toarea metod\u0103:  \ud835\udc5b\ud835\udc58= {\ud835\udc5b\u2219(\ud835\udc5b2) \ud835\udc58\u22121 2 , \ud835\udc51\ud835\udc4e\ud835\udc50\ud835\udc4e \ud835\udc58 \ud835\udc56\ud835\udc5a\ud835\udc5d\ud835\udc4e\ud835\udc5f (\ud835\udc5b2) \ud835\udc58 2, \ud835\udc51\ud835\udc4e\ud835\udc50\ud835\udc4e \ud835\udc58 \ud835\udc5d\ud835\udc4e\ud835\udc5f", "sentences": ["328    Indica\u021bii: \u0218irul apelurilor este:f(0)  0<7 \u21d2    f(2)  2<7 \u21d2     f(4)  4<7 \u21d2     f(6)  6<7 \u21d2     f(8)  8>7 \u21d2    8-3 raspuns care  se returneaz\u0103 la apelul anterior, adun\u00e2ndu-se de fiecare dat\u0103 1.", "f(0)=7.", "Apoi se calculeaz\u0103  f(7)=2; f(2)=6 \u0219i f(6)=4.", " 11.", " R\u0103spuns corect: c) 2 4 1 5 3                               5 1 4 2 3                               1 2 3 4 5                               5 4 3 2 1                                  4 1 5 3 2  Indica\u021bii: Se fac 3 permut\u0103ri circulare ale ultimelor 3 linii astfel \u00eenc\u00e2t matricea la final  revine la configura\u021bia ini\u021bial\u0103.", " 12.", " R\u0103spuns corect: c) 7196                                       7198   Indica\u021bii: Dac\u0103 se porne\u0219te de la 7196  se continu\u0103 cu 7197 (incorect\u0103, se repet\u0103 cifra 7),  7 1 9 8, se revine la a doua cifr\u0103\u0219i se alege 2, dar fiind prim nu e permis, la fel 3 \u0219i se  ajunge la 4, apoi se continu\u0103 cu 0 \u0219i cu 1, adic\u0103 7401.", "  13.", " R\u0103spuns corect: c) II \u0219i IV  Indica\u021bii: \u00censecven\u021ba IV, exist\u0103 un nod cu gradul 8, ceeace nu este posibil \u00eentr-un graf cu  8 noduri.", "\u00censecven\u021ba II, gradul 6 al celor 4 v\u00e2rfuri \u00eenseamn\u0103 18 muchii (nodul 1 incident  cu 6 muchii, nodul 2 incident cu 5 muchii (a \u0219asea fiind (1,2), deja num\u0103rat\u0103)) etc. Adic\u0103  6+5+4+3=18 muchii.", "Un exemplu posibil de graf ar fi:  Din secven\u021ba  dat\u0103: 6+6+6+6+3+3+2+2=34 => 17 (muchii contradic\u021bie).", " 14.", " R\u0103spuns corect: b) O(n) pentru f1 \u0219i O(2n) pentru f2  Indica\u021bii: Am puteascriepentrufiecarefunc\u021bie, complexitatea timp, recurent, astfel:  T1(n)=T1(n-1)+C care este O(n)  T2(n)=2\u2219T2(n-1)+C care este O(2n)  15.", " R\u0103spuns corect: a) O(log2k)  Indica\u021bii: Se calculeaz\u0103 nk \u00een timp logaritmic dup\u0103 urm\u0103toarea metod\u0103:  \ud835\udc5b\ud835\udc58= {\ud835\udc5b\u2219(\ud835\udc5b2) \ud835\udc58\u22121 2 , \ud835\udc51\ud835\udc4e\ud835\udc50\ud835\udc4e \ud835\udc58 \ud835\udc56\ud835\udc5a\ud835\udc5d\ud835\udc4e\ud835\udc5f (\ud835\udc5b2) \ud835\udc58 2, \ud835\udc51\ud835\udc4e\ud835\udc50\ud835\udc4e \ud835\udc58 \ud835\udc5d\ud835\udc4e\ud835\udc5f"], "page_sentence_count_spacy": 14}, {"page_number": 329, "page_char_count": 1979, "page_word_count": 385, "page_sentence_count_raw": 28, "page_token_count": 494.75, "text": "329    Varianta 44  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: c) 10  Indica\u021bii: Se fac opera\u021biile matematice \u00een ordinea priorit\u0103\u021bii operatorilor.  2.  R\u0103spuns corect: e) 3.5  Indica\u021bii: Se folose\u0219te operatorul cast, astfel \u00eenc\u00e2t rezultatul \u00eemp\u0103r\u021birii i/j s\u0103 fie real.   3.  R\u0103spuns corect: f) 5  Indica\u021bii: Se evalueaz\u0103 j\u22600 (A)\u0219i apoi operatorul de decrementare =>j=2. Pentru c\u0103 !j=0  atunci se evalueaz\u0103 i\u22600 (A) \u0219i se incrementeaz\u0103 j=> j=3.   4.  R\u0103spuns corect: d) 3  Indica\u021bii: Se concateneaz\u0103 la sf\u00e2r\u0219itul \u0219irului s \u0219irul ABCDE \u0219i se ob\u021bine ABCDEABCDE,  apoi se \u0219terg primele 3 caractere. Deci \u0219irul s este DEABCDE.  5.  R\u0103spuns corect: b) 1  Indica\u021bii: Apelul func\u021biei implic\u0103 decrementarea valorii parametrului \u0219i returnarea acestui  rezultat.  6.  R\u0103spuns corect: a) p*=2\u2502p:=p*2  Indica\u021bii: Fie n=\ud835\udc511 \ud835\udc521 \u2219\ud835\udc512 \ud835\udc522 \u2219\u2026 \u2219\ud835\udc51\ud835\udc5f \ud835\udc52\ud835\udc5f, descompus \u00een factori primi. \u0218tim c\u0103 num\u0103rul de  divizori ai lui n este(\ud835\udc521 + 1) \u2219(\ud835\udc522 + 1) \u2219\u2026 \u2219(\ud835\udc52\ud835\udc5f+ 1). Folosindu-se acest rezultat, se  determin\u0103 factorii primi p\u00e2n\u0103 la \u221a\ud835\udc5b. Dac\u0103 n\u22601 atunci n este un num\u0103r prim, deci la  produsul anterior mai trebuie \u00eenmul\u021bit 2.  7.  R\u0103spuns corect: e) x[k/2]*(x[k/2]-1)/2 \u2502 x[k div 2]*(x[k div 2]-1) div 2   Indica\u021bii: Se folose\u0219te vectorul de frecven\u021b\u0103 x astfel \u00eenc\u00e2t, x[i] s\u0103 exprime num\u0103rul de  elemente din v care au restul i la \u00eemp\u0103r\u021birea cu k. Se observ\u0103 c\u0103 algoritmul nu adaug\u0103  num\u0103rul de perechi ob\u021binute \u00eentre elemente cu acela\u0219i rest [k:2], \u00een cazul \u00een care k este par.  Acest num\u0103r reprezint\u0103 num\u0103rul de combin\u0103ri ale valorilor de rest [k:2].   8.  R\u0103spuns corect: c) a[n-j-1][n-i-1]=2; \u2502 a[n-j-1,n-i-1]:=2;  Indica\u021bii: Se parcurg elementele din cadranul 1 \u0219i apoi prin simetrie fa\u021b\u0103 de diagonala  secundar\u0103 se vor completa \u0219i elementele din cadranul II.  9.  R\u0103spuns corect: c) -1  Indica\u021bii: \u0218irul apelurilor este:f(16)  16>8 \u21d2      f(13)  13>8 \u21d2       f(10)  10>8 \u21d2       f(7)  7<8 \u21d2    7-5=2. Se calculeaz\u0103  f(2)=-3, apoi se  revine cu -3+4, se calculeaz\u0103 f(1)=-4 \u0219.a.m.d.  10.  R\u0103spuns corect: c) 8", "sentences": ["329    Varianta 44  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: c) 10  Indica\u021bii: Se fac opera\u021biile matematice \u00een ordinea priorit\u0103\u021bii operatorilor.", " 2.", " R\u0103spuns corect: e) 3.5  Indica\u021bii: Se folose\u0219te operatorul cast, astfel \u00eenc\u00e2t rezultatul \u00eemp\u0103r\u021birii i/j s\u0103 fie real.", "  3.", " R\u0103spuns corect: f) 5  Indica\u021bii: Se evalueaz\u0103 j\u22600 (A)\u0219i apoi operatorul de decrementare =>j=2.", "Pentru c\u0103 !", "j=0  atunci se evalueaz\u0103 i\u22600 (A) \u0219i se incrementeaz\u0103 j=> j=3.", "  4.", " R\u0103spuns corect: d) 3  Indica\u021bii: Se concateneaz\u0103 la sf\u00e2r\u0219itul \u0219irului s \u0219irul ABCDE \u0219i se ob\u021bine ABCDEABCDE,  apoi se \u0219terg primele 3 caractere.", "Deci \u0219irul s este DEABCDE.", " 5.", " R\u0103spuns corect: b) 1  Indica\u021bii: Apelul func\u021biei implic\u0103 decrementarea valorii parametrului \u0219i returnarea acestui  rezultat.", " 6.", " R\u0103spuns corect: a) p*=2\u2502p:=p*2  Indica\u021bii: Fie n=\ud835\udc511 \ud835\udc521 \u2219\ud835\udc512 \ud835\udc522 \u2219\u2026 \u2219\ud835\udc51\ud835\udc5f \ud835\udc52\ud835\udc5f, descompus \u00een factori primi.", "\u0218tim c\u0103 num\u0103rul de  divizori ai lui n este(\ud835\udc521 + 1) \u2219(\ud835\udc522 + 1) \u2219\u2026 \u2219(\ud835\udc52\ud835\udc5f+ 1).", "Folosindu-se acest rezultat, se  determin\u0103 factorii primi p\u00e2n\u0103 la \u221a\ud835\udc5b. Dac\u0103 n\u22601 atunci n este un num\u0103r prim, deci la  produsul anterior mai trebuie \u00eenmul\u021bit 2.", " 7.", " R\u0103spuns corect: e) x[k/2]*(x[k/2]-1)/2 \u2502 x[k div 2]*(x[k div 2]-1) div 2   Indica\u021bii: Se folose\u0219te vectorul de frecven\u021b\u0103 x astfel \u00eenc\u00e2t, x[i] s\u0103 exprime num\u0103rul de  elemente din v care au restul i la \u00eemp\u0103r\u021birea cu k. Se observ\u0103 c\u0103 algoritmul nu adaug\u0103  num\u0103rul de perechi ob\u021binute \u00eentre elemente cu acela\u0219i rest [k:2], \u00een cazul \u00een care k este par.", " Acest num\u0103r reprezint\u0103 num\u0103rul de combin\u0103ri ale valorilor de rest [k:2].", "  8.", " R\u0103spuns corect: c) a[n-j-1][n-i-1]=2; \u2502 a[n-j-1,n-i-1]:=2;  Indica\u021bii: Se parcurg elementele din cadranul 1 \u0219i apoi prin simetrie fa\u021b\u0103 de diagonala  secundar\u0103 se vor completa \u0219i elementele din cadranul II.", " 9.", " R\u0103spuns corect: c) -1  Indica\u021bii: \u0218irul apelurilor este:f(16)  16>8 \u21d2      f(13)  13>8 \u21d2       f(10)  10>8 \u21d2       f(7)  7<8 \u21d2    7-5=2.", "Se calculeaz\u0103  f(2)=-3, apoi se  revine cu -3+4, se calculeaz\u0103 f(1)=-4 \u0219.a.m.d.  10.", " R\u0103spuns corect: c) 8"], "page_sentence_count_spacy": 26}, {"page_number": 330, "page_char_count": 1683, "page_word_count": 297, "page_sentence_count_raw": 18, "page_token_count": 420.75, "text": "330    Indica\u021bii: Se observ\u0103 c\u0103 \u00eentre nodurile 1, 2, 6 exist\u0103 drum \u00eentre oricare dou\u0103 noduri, deci  ele formeaz\u0103 o component\u0103 tare conex\u0103. \u00centre celelalte 7 noduri nu exist\u0103 drum de la i la j  \u0219i de la j la i, deci fiecare nod formeaz\u0103 separat, c\u00e2te o component\u0103 tare conex\u0103.   11.  R\u0103spuns corect: e) apnmdc  Indica\u021bii: Plec\u00e2nd de la solu\u021bia apnmdc se genereaz\u0103 urm\u0103toarele \u00eencerc\u0103ri: apnmdd,  apnmdm, apnmdn, apnmdp... \u0219i se revine la primul caracter \u0219i se genereaz\u0103 ebacid  12.  R\u0103spuns corect: b) se elimin\u0103 o muchie \u0219i se adaug\u0103 dou\u0103  Indica\u021bii: Se observ\u0103 c\u0103 graful are dou\u0103 componente conexe. Fiecare component\u0103 conex\u0103  are 501 noduri, fiind subgrafuri complete. De\u0219i gradul fiec\u0103rui nod este par, graful nu este  eulerian pentru c\u0103 nu este conex. Dac\u0103, de exemplu, se elimin\u0103 muchia [2,4] din subgraful  cu noduri pare, atunci gradele celor dou\u0103 noduri devin impare, deci trebuie ref\u0103cut\u0103  paritatea, a\u0219a c\u0103 putem ad\u0103uga, de exemplu, muchia [2,1], dar \u0219i [4,1]. \u00cen felul acesta,  graful devine conex \u0219i se p\u0103streaz\u0103 paritatea gradelor nodurilor.  13.  R\u0103spuns corect: d) 7  Indica\u021bii: Pentru ca \u00een\u0103l\u021bimea arborelui s\u0103 fie minim\u0103, num\u0103rul de fii ai fiec\u0103rui nod  trebuie s\u0103 fie maxim, adic\u0103 4. Deci pe nivelul 0 se g\u0103se\u0219te r\u0103d\u0103cina, pe nivelul 1 vor fi 41  noduri, pe nivelul 2, 42=16 noduri, pe nivelul 3, 43=64 noduri, apoi 44=256, 45=1024, pe  nivelul 6, restul nodurilor. Deci, \u00een total, 7 nivele.   14.  R\u0103spuns corect: d) O(nlogn)  Indica\u021bii: Pentru prima repeti\u021bie timpul este O(n), dar pentru a doua, timpul este  logaritmic.  15.  R\u0103spuns corect: b) n  Indica\u021bii: Expresia se poatere scrie astfel:  a0+a1*x+a2*x2+a3*x3+...+an*xn=a0+x*(a1+x*(a2+.....+x*(an-1+x*an))..)", "sentences": ["330    Indica\u021bii: Se observ\u0103 c\u0103 \u00eentre nodurile 1, 2, 6 exist\u0103 drum \u00eentre oricare dou\u0103 noduri, deci  ele formeaz\u0103 o component\u0103 tare conex\u0103.", "\u00centre celelalte 7 noduri nu exist\u0103 drum de la i la j  \u0219i de la j la i, deci fiecare nod formeaz\u0103 separat, c\u00e2te o component\u0103 tare conex\u0103.", "  11.", " R\u0103spuns corect: e) apnmdc  Indica\u021bii: Plec\u00e2nd de la solu\u021bia apnmdc se genereaz\u0103 urm\u0103toarele \u00eencerc\u0103ri: apnmdd,  apnmdm, apnmdn, apnmdp... \u0219i se revine la primul caracter \u0219i se genereaz\u0103 ebacid  12.", " R\u0103spuns corect: b) se elimin\u0103 o muchie \u0219i se adaug\u0103 dou\u0103  Indica\u021bii: Se observ\u0103 c\u0103 graful are dou\u0103 componente conexe.", "Fiecare component\u0103 conex\u0103  are 501 noduri, fiind subgrafuri complete.", "De\u0219i gradul fiec\u0103rui nod este par, graful nu este  eulerian pentru c\u0103 nu este conex.", "Dac\u0103, de exemplu, se elimin\u0103 muchia [2,4] din subgraful  cu noduri pare, atunci gradele celor dou\u0103 noduri devin impare, deci trebuie ref\u0103cut\u0103  paritatea, a\u0219a c\u0103 putem ad\u0103uga, de exemplu, muchia [2,1], dar \u0219i [4,1].", "\u00cen felul acesta,  graful devine conex \u0219i se p\u0103streaz\u0103 paritatea gradelor nodurilor.", " 13.", " R\u0103spuns corect: d) 7  Indica\u021bii: Pentru ca \u00een\u0103l\u021bimea arborelui s\u0103 fie minim\u0103, num\u0103rul de fii ai fiec\u0103rui nod  trebuie s\u0103 fie maxim, adic\u0103 4.", "Deci pe nivelul 0 se g\u0103se\u0219te r\u0103d\u0103cina, pe nivelul 1 vor fi 41  noduri, pe nivelul 2, 42=16 noduri, pe nivelul 3, 43=64 noduri, apoi 44=256, 45=1024, pe  nivelul 6, restul nodurilor.", "Deci, \u00een total, 7 nivele.", "  14.", " R\u0103spuns corect: d) O(nlogn)  Indica\u021bii: Pentru prima repeti\u021bie timpul este O(n), dar pentru a doua, timpul este  logaritmic.", " 15.", " R\u0103spuns corect: b) n  Indica\u021bii: Expresia se poatere scrie astfel:  a0+a1*x+a2*x2+a3*x3+...+an*xn=a0+x*(a1+x*(a2+.....+x*(an-1+x*an))..)"], "page_sentence_count_spacy": 17}, {"page_number": 331, "page_char_count": 1885, "page_word_count": 346, "page_sentence_count_raw": 23, "page_token_count": 471.25, "text": "331    Varianta 45  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: d) 15  Indica\u021bii: \u00cent\u00e2i se evalueaz\u0103 operatorul de decrementare, deci valoarea variabilei i  devine 3, se face produsul i*j \u0219i apoi se evalueaz\u0103 operatorul de incrementare.   2.  R\u0103spuns corect: c) -4  Indica\u021bii: \u00cent\u00e2i se face produsul, deci k=-9,  apoi la k se adun\u0103 j => k=-12 \u0219i se  determin\u0103 c\u00e2tul \u00eemp\u0103rtirii lui k la i.  3.  R\u0103spuns corect: b) -1  Indica\u021bii: Se evalueaz\u0103 j\u22600 \u0219i apoi operatorul de decrementare =>i=1. Pentru c\u0103 i\u22600  se m\u0103re\u0219te j cu 1 => j=-1 \u0219i apoi se evalueaz\u0103 produsul.   4.  R\u0103spuns corect: d) 2 1  Indica\u021bii: Se returneaz\u0103 valoarea ini\u021bial\u0103 a parametrului \u0219i apoi se incrementeaz\u0103  parametrul, pentru c\u0103 operatorul de incrementare este \u00een form\u0103 postfixat\u0103. Deci se  returneaz\u0103 1 iar parametrul va avea valoarea 2.  5.  R\u0103spuns corect: e) 4  Indica\u021bii: Este declarat un vector cu 2 elemente de tip structur\u0103, fiecare element  con\u021bin\u00e2nd un alt vector cu dou\u0103 numere \u00eentregi. Se atribuie valoare doar elementelor  S[0].a[1] \u0219i S[1].a[0].  6.  R\u0103spuns corect: f) 30  Indica\u021bii: Algoritmul determin\u0103 toate numerele din intervalul [1, 10000] care sunt  formate doar din cifrele 4 \u0219i/sau 6. Exemple 4, 6, 44, 46, 64, 66 etc.   7.  R\u0103spuns corect: c) II  Indica\u021bii: Se parcurg elementele din zona I, dar se folosesc elementele simetrice cu  acestea fa\u021b\u0103 de diagonala secundar\u0103, deci elemente din zona II   8.  R\u0103spuns corect: b) Automatica-UPB  Indica\u021bii: Se determin\u0103 adresa de memorie\u2502pozi\u021bia caracterului '-', \u00eemp\u0103r\u021bindu-se astfel  \u0219irul ini\u021bial \u00een dou\u0103 \u0219iruri de caractere. Apoi se concateneaz\u0103 al doilea \u0219ir cu primul, dup\u0103  ce prima liter\u0103 a celui de al doilea \u0219ir se transform\u0103 \u00een liter\u0103 mare.   9.  R\u0103spuns corect: f) a[i]>a[j]  Indica\u021bii: Se folose\u0219te algoritmul de ordonare prin num\u0103rare. Fiecare element b[i]  memoreaz\u0103 num\u0103rul de elemente din tabloul unidimensional a, mai mari dec\u00e2t a[i].", "sentences": ["331    Varianta 45  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: d) 15  Indica\u021bii: \u00cent\u00e2i se evalueaz\u0103 operatorul de decrementare, deci valoarea variabilei i  devine 3, se face produsul i*j \u0219i apoi se evalueaz\u0103 operatorul de incrementare.", "  2.", " R\u0103spuns corect: c) -4  Indica\u021bii: \u00cent\u00e2i se face produsul, deci k=-9,  apoi la k se adun\u0103 j => k=-12 \u0219i se  determin\u0103 c\u00e2tul \u00eemp\u0103rtirii lui k la i.  3.", " R\u0103spuns corect: b) -1  Indica\u021bii: Se evalueaz\u0103 j\u22600 \u0219i apoi operatorul de decrementare =>i=1.", "Pentru c\u0103 i\u22600  se m\u0103re\u0219te j cu 1 => j=-1 \u0219i apoi se evalueaz\u0103 produsul.", "  4.", " R\u0103spuns corect: d) 2 1  Indica\u021bii: Se returneaz\u0103 valoarea ini\u021bial\u0103 a parametrului \u0219i apoi se incrementeaz\u0103  parametrul, pentru c\u0103 operatorul de incrementare este \u00een form\u0103 postfixat\u0103.", "Deci se  returneaz\u0103 1 iar parametrul va avea valoarea 2.", " 5.", " R\u0103spuns corect: e) 4  Indica\u021bii: Este declarat un vector cu 2 elemente de tip structur\u0103, fiecare element  con\u021bin\u00e2nd un alt vector cu dou\u0103 numere \u00eentregi.", "Se atribuie valoare doar elementelor  S[0].a[1] \u0219i S[1].a[0].", " 6.", " R\u0103spuns corect: f) 30  Indica\u021bii: Algoritmul determin\u0103 toate numerele din intervalul [1, 10000] care sunt  formate doar din cifrele 4 \u0219i/sau 6.", "Exemple 4, 6, 44, 46, 64, 66 etc.   7.", " R\u0103spuns corect: c) II  Indica\u021bii: Se parcurg elementele din zona I, dar se folosesc elementele simetrice cu  acestea fa\u021b\u0103 de diagonala secundar\u0103, deci elemente din zona II   8.", " R\u0103spuns corect: b) Automatica-UPB  Indica\u021bii: Se determin\u0103 adresa de memorie\u2502pozi\u021bia caracterului '-', \u00eemp\u0103r\u021bindu-se astfel  \u0219irul ini\u021bial \u00een dou\u0103 \u0219iruri de caractere.", "Apoi se concateneaz\u0103 al doilea \u0219ir cu primul, dup\u0103  ce prima liter\u0103 a celui de al doilea \u0219ir se transform\u0103 \u00een liter\u0103 mare.", "  9.", " R\u0103spuns corect: f) a[i]>a[j]  Indica\u021bii: Se folose\u0219te algoritmul de ordonare prin num\u0103rare.", "Fiecare element b[i]  memoreaz\u0103 num\u0103rul de elemente din tabloul unidimensional a, mai mari dec\u00e2t a[i]."], "page_sentence_count_spacy": 21}, {"page_number": 332, "page_char_count": 2066, "page_word_count": 473, "page_sentence_count_raw": 22, "page_token_count": 516.5, "text": "332    10.  R\u0103spuns corect: a) -6  Indica\u021bii: \u0218irul apelurilor este: f(19,7)  19>7 \u21d2      f(16, 8)  16>8 \u21d2       f(13, 9)  13>9 \u21d2       f(10,10)  10=10 \u21d2         f(11,  10)  11>10 \u21d2         f(8,11)  8<11 \u21d2      3*8-2*11 raspuns care se returneaz\u0103 la apelul anterior \u0219amd,  sc\u0103z\u00e2ndu-se 2, unde e cazul.   11.  R\u0103spuns corect: c) 4316  3618  3418  Indica\u021bii: O abordare ar putea s\u0103 plece de la o variant\u0103 dat\u0103.  Folosind metoda  backtracking, \u021bin\u00e2nd cont de condi\u021biile impuse de problem\u0103, se pleac\u0103 de la primul  num\u0103r propus \u0219i se genereaz\u0103 urm\u0103toarele trei solu\u021bii.  12.  R\u0103spuns corect: a) 2i-1 \u2013 1  Indica\u021bii: Pentru ca pe niveluri, s\u0103 avem num\u0103r maxim de noduri, trebuie ca toate  nodurile de pe nivelurile anterioare sa aib\u0103 c\u00e2te 2 fii. Deci, pe nivelul 1, avem 20 noduri,  pe nivelul 2 sunt 21 noduri, pe nivelul 3 sunt 22 noduri \u0219.a.m.d. Deci, pe nivelul i vor fi  2i-1 noduri. Cum num\u0103rul total de noduri este par, iar pe nivelul 1 este un nod, atunci pe  nivelul i vor fi 2i-1-1 noduri.  13.  R\u0103spuns corect: c) 25  Indica\u021bii: Parti\u021biile mul\u021bimii nodurilor pot avea:  prima mul\u021bime \u2013 1 nod; a doua - 9 noduri => nr de muchii 1*9  prima mul\u021bime \u2013 2 noduri; a doua - 8 noduri => nr de muchii 2*8  \u2026.  prima mul\u021bime \u2013 5 noduri; a doua - 5 noduri => nr de muchii 5*5 (maxim)  14.  R\u0103spuns corect: b) O(n)  Indica\u021bii: Complexitatea algoritmului pare a fi O(n2). Pentru c\u0103 a doua repeti\u021bie nu  reseteaz\u0103 valoarea lui j la 0, atunci vor fi valori ale lui i pentru care a doua repeti\u021bie nu  se mai execut\u0103 . Deci, vom avea maxim 2 treceri prin vector, deci O(n).  15.  R\u0103spuns corect: e) 30  Indica\u021bii: Pentru a afla num\u0103rul de drumuri de lungime k dintre dou\u0103 noduri i \u0219i j \u00eentr- un graf orientat, se calculeaz\u0103 matricea X=Ak, unde A este matricea de adiacen\u021b\u0103. Xi,j  reprezint\u0103 num\u0103rul de drumuri dintre nodurile i \u0219i j de lungime k. Pentru a calcula  num\u0103rul total de drumuri din digraf, atunci se adun\u0103 toate valorile matricei X. Deci  A=( 0 1 1 0 1 0 1 1 1 0 0 1 1 0 0 0 ), .., A3=( 3 2 2 1 3 2 3 2 2 1 2 2 2 0 1 2 ) . Se adun\u0103 toate elementele \u0219i se ob\u021bine 30.", "sentences": ["332    10.", " R\u0103spuns corect: a) -6  Indica\u021bii: \u0218irul apelurilor este: f(19,7)  19>7 \u21d2      f(16, 8)  16>8 \u21d2       f(13, 9)  13>9 \u21d2       f(10,10)  10=10 \u21d2         f(11,  10)  11>10 \u21d2         f(8,11)  8<11 \u21d2      3*8-2*11 raspuns care se returneaz\u0103 la apelul anterior \u0219amd,  sc\u0103z\u00e2ndu-se 2, unde e cazul.", "  11.", " R\u0103spuns corect: c) 4316  3618  3418  Indica\u021bii: O abordare ar putea s\u0103 plece de la o variant\u0103 dat\u0103.", " Folosind metoda  backtracking, \u021bin\u00e2nd cont de condi\u021biile impuse de problem\u0103, se pleac\u0103 de la primul  num\u0103r propus \u0219i se genereaz\u0103 urm\u0103toarele trei solu\u021bii.", " 12.", " R\u0103spuns corect: a) 2i-1 \u2013 1  Indica\u021bii: Pentru ca pe niveluri, s\u0103 avem num\u0103r maxim de noduri, trebuie ca toate  nodurile de pe nivelurile anterioare sa aib\u0103 c\u00e2te 2 fii.", "Deci, pe nivelul 1, avem 20 noduri,  pe nivelul 2 sunt 21 noduri, pe nivelul 3 sunt 22 noduri \u0219.a.m.d. Deci, pe nivelul i vor fi  2i-1 noduri.", "Cum num\u0103rul total de noduri este par, iar pe nivelul 1 este un nod, atunci pe  nivelul i vor fi 2i-1-1 noduri.", " 13.", " R\u0103spuns corect: c) 25  Indica\u021bii: Parti\u021biile mul\u021bimii nodurilor pot avea:  prima mul\u021bime \u2013 1 nod; a doua - 9 noduri => nr de muchii 1*9  prima mul\u021bime \u2013 2 noduri; a doua - 8 noduri => nr de muchii 2*8  \u2026.", " prima mul\u021bime \u2013 5 noduri; a doua - 5 noduri => nr de muchii 5*5 (maxim)  14.", " R\u0103spuns corect: b) O(n)  Indica\u021bii: Complexitatea algoritmului pare a fi O(n2).", "Pentru c\u0103 a doua repeti\u021bie nu  reseteaz\u0103 valoarea lui j la 0, atunci vor fi valori ale lui i pentru care a doua repeti\u021bie nu  se mai execut\u0103 .", "Deci, vom avea maxim 2 treceri prin vector, deci O(n).", " 15.", " R\u0103spuns corect: e) 30  Indica\u021bii: Pentru a afla num\u0103rul de drumuri de lungime k dintre dou\u0103 noduri i \u0219i j \u00eentr- un graf orientat, se calculeaz\u0103 matricea X=Ak, unde A este matricea de adiacen\u021b\u0103.", "Xi,j  reprezint\u0103 num\u0103rul de drumuri dintre nodurile i \u0219i j de lungime k. Pentru a calcula  num\u0103rul total de drumuri din digraf, atunci se adun\u0103 toate valorile matricei X. Deci  A=( 0 1 1 0 1 0 1 1 1 0 0 1 1 0 0 0 ), .., A3=( 3 2 2 1 3 2 3 2 2 1 2 2 2 0 1 2 ) .", "Se adun\u0103 toate elementele \u0219i se ob\u021bine 30."], "page_sentence_count_spacy": 19}, {"page_number": 333, "page_char_count": 1708, "page_word_count": 346, "page_sentence_count_raw": 20, "page_token_count": 427.0, "text": "333    Varianta 46  Indica\u021bii \u0219i r\u0103spunsuri  1.  R\u0103spuns corect: c) 6  Indica\u021bii: Se fac opera\u021biile \u00een ordinea priorit\u0103\u021bii operatorilor  2.  R\u0103spuns corect: e) 32  Indica\u021bii: Sunt generate toate numerele care con\u021bin doar cifrele 5 \u0219i/sau 7.   3.  R\u0103spuns corect: d) 48 52 26 11 41 65  Indica\u021bii: Se rearanjeaz\u0103 elementele vectorului, astfel \u00eenc\u00e2t cele pare s\u0103 fie la \u00eenceputul  \u0219irului, iar cele impare la sf\u00e2r\u0219it.  4.  R\u0103spuns corect: d) informaticatest  Indica\u021bii: Func\u021bia strtok (C) separ\u0103 \u0219irul ini\u021bial \u00een dou\u0103 \u0219iruri. Se concateneaz\u0103 al  doilea \u0219ir cu primul \u0219i se modific\u0103 \u0219irul ini\u021bial. Nu se mai adaug\u0103 spa\u021biu \u00eentre cele dou\u0103  \u0219iruri.  5.  R\u0103spuns corect: f) r>t  Indica\u021bii: Pentru intersec\u021bia a n intervale se determin\u0103 maximul dintre capetele din  st\u00e2nga ale intervalelor (notat cu r \u00een secven\u021ba dat\u0103) \u0219i minimul dintre capetele din  dreapta ale intervalelor (notat cu t \u00een secven\u021ba dat\u0103). Intervalele se intersecteaz\u0103 dac\u0103  r\u2264t.  6.  R\u0103spuns corect: f) a[n+1-j][n+1-i] \u2502a[n+1-j,n+1-i]  Indica\u021bii: Algoritmul parcurge elementele din zona I \u0219i, prin simetrie fa\u021b\u0103 de diagonala  secundar\u0103, acceseaz\u0103 elementele din zona II.  7.  R\u0103spuns corect: a) p/=2\u2502p div 2  Indica\u021bii: Este folosit algoritmul c\u0103ut\u0103rii binare.   8.  R\u0103spuns corect: c) 3  Indica\u021bii: Variabila S de tip \u00eenregistrare, dup\u0103 toate atribuirile f\u0103cute, va avea valoarea  {4, 5, 6, {3, 2, 1}}. Se afi\u0219eaz\u0103 rezultatul expresiei: 5-2  9.  R\u0103spuns corect: a) 0  Indica\u021bii: \u0218irul apelurilor este: f(6,2)  6>2 \u21d2    f(2, 6)  2<6 \u21d2     4, apoi se revine la apelul anterior \u0219i  se evalueaz\u0103 f(4, 3)  4>3 \u21d2     f(3,4)  3<4 \u21d2     1; se continu\u0103 cu f(1, 1)  1=1 \u21d2    f(2,1)  2>1 \u21d2     f(1,2)  1<2 \u21d2    1 \u0219i se  revine adun\u00e2nd pe 2 sau sc\u0103z\u00e2nd pe 1.", "sentences": ["333    Varianta 46  Indica\u021bii \u0219i r\u0103spunsuri  1.", " R\u0103spuns corect: c) 6  Indica\u021bii: Se fac opera\u021biile \u00een ordinea priorit\u0103\u021bii operatorilor  2.", " R\u0103spuns corect: e) 32  Indica\u021bii: Sunt generate toate numerele care con\u021bin doar cifrele 5 \u0219i/sau 7.", "  3.", " R\u0103spuns corect: d) 48 52 26 11 41 65  Indica\u021bii: Se rearanjeaz\u0103 elementele vectorului, astfel \u00eenc\u00e2t cele pare s\u0103 fie la \u00eenceputul  \u0219irului, iar cele impare la sf\u00e2r\u0219it.", " 4.", " R\u0103spuns corect: d) informaticatest  Indica\u021bii: Func\u021bia strtok (C) separ\u0103 \u0219irul ini\u021bial \u00een dou\u0103 \u0219iruri.", "Se concateneaz\u0103 al  doilea \u0219ir cu primul \u0219i se modific\u0103 \u0219irul ini\u021bial.", "Nu se mai adaug\u0103 spa\u021biu \u00eentre cele dou\u0103  \u0219iruri.", " 5.", " R\u0103spuns corect: f) r>t  Indica\u021bii: Pentru intersec\u021bia a n intervale se determin\u0103 maximul dintre capetele din  st\u00e2nga ale intervalelor (notat cu r \u00een secven\u021ba dat\u0103) \u0219i minimul dintre capetele din  dreapta ale intervalelor (notat cu t \u00een secven\u021ba dat\u0103).", "Intervalele se intersecteaz\u0103 dac\u0103  r\u2264t.", " 6.", " R\u0103spuns corect: f) a[n+1-j][n+1-i] \u2502a[n+1-j,n+1-i]  Indica\u021bii: Algoritmul parcurge elementele din zona I \u0219i, prin simetrie fa\u021b\u0103 de diagonala  secundar\u0103, acceseaz\u0103 elementele din zona II.", " 7.", " R\u0103spuns corect: a) p/=2\u2502p div 2  Indica\u021bii: Este folosit algoritmul c\u0103ut\u0103rii binare.", "  8.", " R\u0103spuns corect: c) 3  Indica\u021bii: Variabila S de tip \u00eenregistrare, dup\u0103 toate atribuirile f\u0103cute, va avea valoarea  {4, 5, 6, {3, 2, 1}}.", "Se afi\u0219eaz\u0103 rezultatul expresiei: 5-2  9.", " R\u0103spuns corect: a) 0  Indica\u021bii: \u0218irul apelurilor este: f(6,2)  6>2 \u21d2    f(2, 6)  2<6 \u21d2     4, apoi se revine la apelul anterior \u0219i  se evalueaz\u0103 f(4, 3)  4>3 \u21d2     f(3,4)  3<4 \u21d2     1; se continu\u0103 cu f(1, 1)  1=1 \u21d2    f(2,1)  2>1 \u21d2     f(1,2)  1<2 \u21d2    1 \u0219i se  revine adun\u00e2nd pe 2 sau sc\u0103z\u00e2nd pe 1."], "page_sentence_count_spacy": 20}, {"page_number": 334, "page_char_count": 1977, "page_word_count": 384, "page_sentence_count_raw": 19, "page_token_count": 494.25, "text": "334    10.  R\u0103spuns corect: e) 8  Indica\u021bii: Circuitele elementare sunt: ABA, ACBA, ACDBA, ADBA, ADCBA,  AEA, AEDBA, AEDCBA  11.  R\u0103spuns corect: b) egrl egrm  Indica\u021bii: O abordare ar putea s\u0103 plece de la o variant\u0103 dat\u0103.  Folosind metoda  backtracking, \u021bin\u00e2nd cont de condi\u021biile impuse de problem\u0103, se pleac\u0103 de la primul  cuv\u00e2nt propus \u0219i se genereaz\u0103 urm\u0103toarele dou\u0103 solu\u021bii.  12.  R\u0103spuns corect: c) x=t[x]; \u2502 x:=t[x];  Indica\u021bii: Se merge pe drumul de la nodul x c\u0103tre r\u0103d\u0103cin\u0103, adic\u0103, de fiecare dat\u0103, se  trece de la x la tat\u0103l lui.  13.  R\u0103spuns corect: a) 1100  Indica\u021bii: Algoritmul determin\u0103 cifra de control a num\u0103rului n. Deci, se cere s\u0103 se  determine c\u00e2te numere din intervalul [100, 10000] au cifra de control 5. Cum  numerele cu aceea\u0219i cifr\u0103 de control reprezint\u0103 o progresie aritmetic\u0103 cu ra\u021bia 9, atunci  raspunsul este (10000-100)/9=1100.   14.  R\u0103spuns corect: e) 148  Indica\u021bii: Grup\u0103m elementele c\u00e2te dou\u0103 (primul cu al doilea, al treilea cu al patrulea  etc). Pentru prima pereche de elemente se face o comparare, presupun\u00e2ndu-se c\u0103  minimul perechii este minimul global, respectiv maximul perechii este maximul global.  Pentru fiecare dintre celelalte perechi, se face o comparare ca s\u0103 se determine cel mai  mic \u0219i cel mai mare num\u0103r din pereche \u0219i apoi minimul perechii cu minimul global \u0219i  maximul perechii cu maximul global. Deci, pentru fiecare pereche de elemente, se fac 3  compara\u021bii. Deci 3 \u2219 100 2 \u22122 = 148  15.  R\u0103spuns corect: d) 4  Indica\u021bii: Dac\u0103 aranj\u0103m nodurile astfel:  , se observ\u0103 c\u0103 o  component\u0103 conex\u0103 con\u021bine nodurile de pe dou\u0103 coloane. Adic\u0103, prima component\u0103  con\u021bine nodurile de pe coloanele 1 \u0219i 5, a doua component\u0103 con\u021bine nodurile de pe  coloanele 2 \u0219i 6, a treia de pe coloanele 3 \u0219i 7 iar a patra de pe coloanele 4 \u0219i 8.  Deci componentele conexe sunt:  {100, 96, 92, 88, 84, 80, \u2026\u2026, 12, 8, 4}  {99, 95, 91, 87, 83, 79, \u2026\u2026.., 11, 7, 3}  {98, 94, 90, 86, 82, 78, \u2026., 10, 6, 2}  {97, 93, 89, 85, 81, 77, \u2026.., 9, 5, 1}", "sentences": ["334    10.", " R\u0103spuns corect: e) 8  Indica\u021bii: Circuitele elementare sunt: ABA, ACBA, ACDBA, ADBA, ADCBA,  AEA, AEDBA, AEDCBA  11.", " R\u0103spuns corect: b) egrl egrm  Indica\u021bii: O abordare ar putea s\u0103 plece de la o variant\u0103 dat\u0103.", " Folosind metoda  backtracking, \u021bin\u00e2nd cont de condi\u021biile impuse de problem\u0103, se pleac\u0103 de la primul  cuv\u00e2nt propus \u0219i se genereaz\u0103 urm\u0103toarele dou\u0103 solu\u021bii.", " 12.", " R\u0103spuns corect: c) x=t[x]; \u2502 x:=t[x];  Indica\u021bii: Se merge pe drumul de la nodul x c\u0103tre r\u0103d\u0103cin\u0103, adic\u0103, de fiecare dat\u0103, se  trece de la x la tat\u0103l lui.", " 13.", " R\u0103spuns corect: a) 1100  Indica\u021bii: Algoritmul determin\u0103 cifra de control a num\u0103rului n. Deci, se cere s\u0103 se  determine c\u00e2te numere din intervalul [100, 10000] au cifra de control 5.", "Cum  numerele cu aceea\u0219i cifr\u0103 de control reprezint\u0103 o progresie aritmetic\u0103 cu ra\u021bia 9, atunci  raspunsul este (10000-100)/9=1100.", "  14.", " R\u0103spuns corect: e) 148  Indica\u021bii: Grup\u0103m elementele c\u00e2te dou\u0103 (primul cu al doilea, al treilea cu al patrulea  etc).", "Pentru prima pereche de elemente se face o comparare, presupun\u00e2ndu-se c\u0103  minimul perechii este minimul global, respectiv maximul perechii este maximul global.", " Pentru fiecare dintre celelalte perechi, se face o comparare ca s\u0103 se determine cel mai  mic \u0219i cel mai mare num\u0103r din pereche \u0219i apoi minimul perechii cu minimul global \u0219i  maximul perechii cu maximul global.", "Deci, pentru fiecare pereche de elemente, se fac 3  compara\u021bii.", "Deci 3 \u2219 100 2 \u22122 = 148  15.", " R\u0103spuns corect: d) 4  Indica\u021bii: Dac\u0103 aranj\u0103m nodurile astfel:  , se observ\u0103 c\u0103 o  component\u0103 conex\u0103 con\u021bine nodurile de pe dou\u0103 coloane.", "Adic\u0103, prima component\u0103  con\u021bine nodurile de pe coloanele 1 \u0219i 5, a doua component\u0103 con\u021bine nodurile de pe  coloanele 2 \u0219i 6, a treia de pe coloanele 3 \u0219i 7 iar a patra de pe coloanele 4 \u0219i 8.", " Deci componentele conexe sunt:  {100, 96, 92, 88, 84, 80, \u2026\u2026, 12, 8, 4}  {99, 95, 91, 87, 83, 79, \u2026\u2026.., 11, 7, 3}  {98, 94, 90, 86, 82, 78, \u2026.,", "10, 6, 2}  {97, 93, 89, 85, 81, 77, \u2026.., 9, 5, 1}"], "page_sentence_count_spacy": 19}, {"page_number": 335, "page_char_count": 3, "page_word_count": 1, "page_sentence_count_raw": 1, "page_token_count": 0.75, "text": "335", "sentences": ["335"], "page_sentence_count_spacy": 1}]